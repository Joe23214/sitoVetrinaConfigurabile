import { c as css, a as addLumoGlobalStyles, r as registerStyles$1, n as notEqual, T as ThemableMixin, L as LitElement, h as html$1, d as defineCustomElement, t as themeRegistry, u as unsafeCSS, b as ThemePropertyMixin, e as nothing, f as render, D as Directive, P as PartType, g as directive, i as noChange, s as svg, j as color, k as typography, l as reactExports, m as clientExports, o as jsxDEV, O as Outlet, _ as __vitePreload } from "./indexhtml-yMQsl7Ls.js";
function _mergeNamespaces(n, m3) {
  for (var i2 = 0; i2 < m3.length; i2++) {
    const e2 = m3[i2];
    if (typeof e2 !== "string" && !Array.isArray(e2)) {
      for (const k2 in e2) {
        if (k2 !== "default" && !(k2 in n)) {
          const d3 = Object.getOwnPropertyDescriptor(e2, k2);
          if (d3) {
            Object.defineProperty(n, k2, d3.get ? d3 : {
              enumerable: true,
              get: () => e2[k2]
            });
          }
        }
      }
    }
  }
  return Object.freeze(Object.defineProperty(n, Symbol.toStringTag, { value: "Module" }));
}
var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
function getDefaultExportFromCjs(x2) {
  return x2 && x2.__esModule && Object.prototype.hasOwnProperty.call(x2, "default") ? x2["default"] : x2;
}
/**
 * @license
 * Copyright (c) 2017 - 2025 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const userColors = css`
  :host {
    --vaadin-user-color-0: #df0b92;
    --vaadin-user-color-1: #650acc;
    --vaadin-user-color-2: #097faa;
    --vaadin-user-color-3: #ad6200;
    --vaadin-user-color-4: #bf16f3;
    --vaadin-user-color-5: #084391;
    --vaadin-user-color-6: #078836;
  }

  [theme~='dark'] {
    --vaadin-user-color-0: #ff66c7;
    --vaadin-user-color-1: #9d8aff;
    --vaadin-user-color-2: #8aff66;
    --vaadin-user-color-3: #ffbd66;
    --vaadin-user-color-4: #dc6bff;
    --vaadin-user-color-5: #66fffa;
    --vaadin-user-color-6: #e6ff66;
  }
`;
addLumoGlobalStyles("user-color-props", userColors);
/**
 * @license
 * Copyright (c) 2021 - 2025 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
registerStyles$1(
  "vaadin-field-outline",
  css`
    :host {
      transition: opacity 0.3s;
      -webkit-mask-image: none !important;
      mask-image: none !important;
    }

    :host::before {
      content: '';
      position: absolute;
      inset: 0;
      box-shadow: 0 0 0 2px var(--_active-user-color);
      border-radius: var(--lumo-border-radius-s);
      transition: box-shadow 0.3s;
    }

    :host([context$='checkbox'])::before {
      box-shadow:
        0 0 0 2px var(--lumo-base-color),
        0 0 0 4px var(--_active-user-color);
    }

    :host([context$='radio-button'])::before {
      border-radius: 50%;
      box-shadow:
        0 0 0 3px var(--lumo-base-color),
        0 0 0 5px var(--_active-user-color);
    }

    :host([context$='item'])::before {
      box-shadow: inset 0 0 0 2px var(--_active-user-color);
    }
  `,
  { moduleId: "lumo-field-outline" }
);
/**
 * @license
 * Copyright (c) 2017 - 2025 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const overlay = css`
  :host {
    top: var(--lumo-space-m);
    right: var(--lumo-space-m);
    bottom: var(--lumo-space-m);
    left: var(--lumo-space-m);
    /* Workaround for Edge issue (only on Surface), where an overflowing vaadin-list-box inside vaadin-select-overlay makes the overlay transparent */
    /* stylelint-disable-next-line */
    outline: 0px solid transparent;
  }

  [part='overlay'] {
    background-color: var(--lumo-base-color);
    background-image: linear-gradient(var(--lumo-tint-5pct), var(--lumo-tint-5pct));
    border-radius: var(--lumo-border-radius-m);
    box-shadow:
      0 0 0 1px var(--lumo-shade-5pct),
      var(--lumo-box-shadow-m);
    color: var(--lumo-body-text-color);
    font-family: var(--lumo-font-family);
    font-size: var(--lumo-font-size-m);
    font-weight: 400;
    line-height: var(--lumo-line-height-m);
    letter-spacing: 0;
    text-transform: none;
    -webkit-text-size-adjust: 100%;
    -webkit-font-smoothing: antialiased;
    -moz-osx-font-smoothing: grayscale;
  }

  [part='content'] {
    padding: var(--lumo-space-xs);
  }

  [part='backdrop'] {
    background-color: var(--lumo-shade-20pct);
    animation: 0.2s lumo-overlay-backdrop-enter both;
    will-change: opacity;
  }

  @keyframes lumo-overlay-backdrop-enter {
    0% {
      opacity: 0;
    }
  }

  :host([closing]) [part='backdrop'] {
    animation: 0.2s lumo-overlay-backdrop-exit both;
  }

  @keyframes lumo-overlay-backdrop-exit {
    100% {
      opacity: 0;
    }
  }

  @keyframes lumo-overlay-dummy-animation {
    0% {
      opacity: 1;
    }

    100% {
      opacity: 1;
    }
  }
`;
registerStyles$1("", overlay, { moduleId: "lumo-overlay" });
/**
 * @license
 * Copyright (c) 2021 - 2025 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
registerStyles$1(
  "vaadin-user-tags-overlay",
  [
    overlay,
    css`
      [part='overlay'] {
        box-shadow: none;
        background: transparent;
        will-change: opacity, transform;
      }

      [part='content'] {
        padding: 0;
      }

      :host([opening]) [part='overlay'] {
        animation: 0.1s lumo-user-tags-enter ease-out both;
      }

      @keyframes lumo-user-tags-enter {
        0% {
          opacity: 0;
        }
      }

      :host([closing]) [part='overlay'] {
        animation: 0.1s lumo-user-tags-exit both;
      }

      @keyframes lumo-user-tags-exit {
        100% {
          opacity: 0;
        }
      }
    `
  ],
  {
    moduleId: "lumo-user-tags-overlay"
  }
);
registerStyles$1(
  "vaadin-user-tag",
  css`
    :host {
      font-family: var(--lumo-font-family);
      font-size: var(--lumo-font-size-xxs);
      border-radius: var(--lumo-border-radius-s);
      box-shadow: var(--lumo-box-shadow-xs);
      --vaadin-user-tag-offset: var(--lumo-space-xs);
    }

    [part='name'] {
      color: var(--lumo-primary-contrast-color);
      padding: 0.3em calc(0.3em + var(--lumo-border-radius-s) / 4);
      line-height: 1;
      font-weight: 500;
      min-width: calc(var(--lumo-line-height-xs) * 1em + 0.45em);
    }
  `,
  { moduleId: "lumo-user-tag" }
);
/**
 * @license
 * Copyright (c) 2021 - 2025 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const directionSubscribers = [];
function alignDirs(element, documentDir, elementDir = element.getAttribute("dir")) {
  if (documentDir) {
    element.setAttribute("dir", documentDir);
  } else if (elementDir != null) {
    element.removeAttribute("dir");
  }
}
function getDocumentDir() {
  return document.documentElement.getAttribute("dir");
}
function directionUpdater() {
  const documentDir = getDocumentDir();
  directionSubscribers.forEach((element) => {
    alignDirs(element, documentDir);
  });
}
const directionObserver = new MutationObserver(directionUpdater);
directionObserver.observe(document.documentElement, { attributes: true, attributeFilter: ["dir"] });
const DirMixin = (superClass) => class VaadinDirMixin extends superClass {
  static get properties() {
    return {
      /**
       * @protected
       */
      dir: {
        type: String,
        value: "",
        reflectToAttribute: true,
        converter: {
          fromAttribute: (attr) => {
            return !attr ? "" : attr;
          },
          toAttribute: (prop) => {
            return prop === "" ? null : prop;
          }
        }
      }
    };
  }
  /**
   * @return {boolean}
   * @protected
   */
  get __isRTL() {
    return this.getAttribute("dir") === "rtl";
  }
  /** @protected */
  connectedCallback() {
    super.connectedCallback();
    if (!this.hasAttribute("dir") || this.__restoreSubscription) {
      this.__subscribe();
      alignDirs(this, getDocumentDir(), null);
    }
  }
  /** @protected */
  attributeChangedCallback(name, oldValue, newValue) {
    super.attributeChangedCallback(name, oldValue, newValue);
    if (name !== "dir") {
      return;
    }
    const documentDir = getDocumentDir();
    const newValueEqlDocDir = newValue === documentDir && directionSubscribers.indexOf(this) === -1;
    const newValueEmptied = !newValue && oldValue && directionSubscribers.indexOf(this) === -1;
    const newDiffValue = newValue !== documentDir && oldValue === documentDir;
    if (newValueEqlDocDir || newValueEmptied) {
      this.__subscribe();
      alignDirs(this, documentDir, newValue);
    } else if (newDiffValue) {
      this.__unsubscribe();
    }
  }
  /** @protected */
  disconnectedCallback() {
    super.disconnectedCallback();
    this.__restoreSubscription = directionSubscribers.includes(this);
    this.__unsubscribe();
  }
  /** @protected */
  _valueToNodeAttribute(node, value, attribute) {
    if (attribute === "dir" && value === "" && !node.hasAttribute("dir")) {
      return;
    }
    super._valueToNodeAttribute(node, value, attribute);
  }
  /** @protected */
  _attributeToProperty(attribute, value, type) {
    if (attribute === "dir" && !value) {
      this.dir = "";
    } else {
      super._attributeToProperty(attribute, value, type);
    }
  }
  /** @private */
  __subscribe() {
    if (!directionSubscribers.includes(this)) {
      directionSubscribers.push(this);
    }
  }
  /** @private */
  __unsubscribe() {
    if (directionSubscribers.includes(this)) {
      directionSubscribers.splice(directionSubscribers.indexOf(this), 1);
    }
  }
};
const appliedClassMixins = /* @__PURE__ */ new WeakMap();
function wasMixinPreviouslyApplied(mixin, superClass) {
  let klass = superClass;
  while (klass) {
    if (appliedClassMixins.get(klass) === mixin) {
      return true;
    }
    klass = Object.getPrototypeOf(klass);
  }
  return false;
}
function dedupeMixin(mixin) {
  return (superClass) => {
    if (wasMixinPreviouslyApplied(mixin, superClass)) {
      return superClass;
    }
    const mixedClass = mixin(superClass);
    appliedClassMixins.set(mixedClass, mixin);
    return mixedClass;
  };
}
/**
 * @license
 * Copyright (c) 2023 - 2025 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
function get$2(path, object) {
  return path.split(".").reduce((obj, property) => obj ? obj[property] : void 0, object);
}
function set$1(path, value, object) {
  const pathParts = path.split(".");
  const lastPart = pathParts.pop();
  const target = pathParts.reduce((target2, part) => target2[part], object);
  target[lastPart] = value;
}
/**
 * @license
 * Copyright (c) 2021 - 2025 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const caseMap$1 = {};
const CAMEL_TO_DASH$1 = /([A-Z])/gu;
function camelToDash(camel) {
  if (!caseMap$1[camel]) {
    caseMap$1[camel] = camel.replace(CAMEL_TO_DASH$1, "-$1").toLowerCase();
  }
  return caseMap$1[camel];
}
function upper$1(name) {
  return name[0].toUpperCase() + name.substring(1);
}
function parseObserver(observerString) {
  const [method, rest] = observerString.split("(");
  const observerProps = rest.replace(")", "").split(",").map((prop) => prop.trim());
  return {
    method,
    observerProps
  };
}
function getOrCreateMap(obj, name) {
  if (!Object.prototype.hasOwnProperty.call(obj, name)) {
    obj[name] = new Map(obj[name]);
  }
  return obj[name];
}
const PolylitMixinImplementation = (superclass) => {
  class PolylitMixinClass extends superclass {
    static createProperty(name, options) {
      if ([String, Boolean, Number, Array].includes(options)) {
        options = {
          type: options
        };
      }
      if (options && options.reflectToAttribute) {
        options.reflect = true;
      }
      super.createProperty(name, options);
    }
    static getOrCreateMap(name) {
      return getOrCreateMap(this, name);
    }
    /**
     * @protected
     * @override
     */
    static finalize() {
      super.finalize();
      if (Array.isArray(this.observers)) {
        const complexObservers = this.getOrCreateMap("__complexObservers");
        this.observers.forEach((observer2) => {
          const { method, observerProps } = parseObserver(observer2);
          complexObservers.set(method, observerProps);
        });
      }
    }
    static addCheckedInitializer(initializer) {
      super.addInitializer((instance) => {
        if (instance instanceof this) {
          initializer(instance);
        }
      });
    }
    static getPropertyDescriptor(name, key, options) {
      const defaultDescriptor = super.getPropertyDescriptor(name, key, options);
      let result = defaultDescriptor;
      this.getOrCreateMap("__propKeys").set(name, key);
      if (options.sync) {
        result = {
          get: defaultDescriptor.get,
          set(value) {
            const oldValue = this[name];
            if (notEqual(value, oldValue)) {
              this[key] = value;
              this.requestUpdate(name, oldValue, options);
              if (this.hasUpdated) {
                this.performUpdate();
              }
            }
          },
          configurable: true,
          enumerable: true
        };
      }
      if (options.readOnly) {
        const setter = result.set;
        this.addCheckedInitializer((instance) => {
          instance[`_set${upper$1(name)}`] = function(value) {
            setter.call(instance, value);
          };
        });
        result = {
          get: result.get,
          set() {
          },
          configurable: true,
          enumerable: true
        };
      }
      if ("value" in options) {
        this.addCheckedInitializer((instance) => {
          const value = typeof options.value === "function" ? options.value.call(instance) : options.value;
          if (options.readOnly) {
            instance[`_set${upper$1(name)}`](value);
          } else {
            instance[name] = value;
          }
        });
      }
      if (options.observer) {
        const method = options.observer;
        this.getOrCreateMap("__observers").set(name, method);
        this.addCheckedInitializer((instance) => {
          if (!instance[method]) {
            console.warn(`observer method ${method} not defined`);
          }
        });
      }
      if (options.notify) {
        if (!this.__notifyProps) {
          this.__notifyProps = /* @__PURE__ */ new Set();
        } else if (!this.hasOwnProperty("__notifyProps")) {
          const notifyProps = this.__notifyProps;
          this.__notifyProps = new Set(notifyProps);
        }
        this.__notifyProps.add(name);
      }
      if (options.computed) {
        const assignComputedMethod = `__assignComputed${name}`;
        const observer2 = parseObserver(options.computed);
        this.prototype[assignComputedMethod] = function(...props) {
          this[name] = this[observer2.method](...props);
        };
        this.getOrCreateMap("__computedObservers").set(assignComputedMethod, observer2.observerProps);
      }
      if (!options.attribute) {
        options.attribute = camelToDash(name);
      }
      return result;
    }
    static get polylitConfig() {
      return {
        asyncFirstRender: false
      };
    }
    constructor() {
      super();
      this.__hasPolylitMixin = true;
    }
    /** @protected */
    connectedCallback() {
      super.connectedCallback();
      const parentHost = this.getRootNode().host;
      if (parentHost && parentHost.__hasPolylitMixin && this.id) {
        parentHost.$ ||= {};
        parentHost.$[this.id] = this;
      }
      const { polylitConfig } = this.constructor;
      if (!this.hasUpdated && !polylitConfig.asyncFirstRender) {
        this.performUpdate();
      }
    }
    /** @protected */
    firstUpdated() {
      super.firstUpdated();
      if (!this.$) {
        this.$ = {};
      }
      [...Object.values(this.$), this.renderRoot].forEach((node) => {
        node.querySelectorAll("[id]").forEach((node2) => {
          this.$[node2.id] = node2;
        });
      });
    }
    /** @protected */
    ready() {
    }
    /** @protected */
    willUpdate(props) {
      if (this.constructor.__computedObservers) {
        this.__runComplexObservers(props, this.constructor.__computedObservers);
      }
    }
    /** @protected */
    updated(props) {
      const wasReadyInvoked = this.__isReadyInvoked;
      this.__isReadyInvoked = true;
      if (this.constructor.__observers) {
        this.__runObservers(props, this.constructor.__observers);
      }
      if (this.constructor.__complexObservers) {
        this.__runComplexObservers(props, this.constructor.__complexObservers);
      }
      if (this.__dynamicPropertyObservers) {
        this.__runDynamicObservers(props, this.__dynamicPropertyObservers);
      }
      if (this.__dynamicMethodObservers) {
        this.__runComplexObservers(props, this.__dynamicMethodObservers);
      }
      if (this.constructor.__notifyProps) {
        this.__runNotifyProps(props, this.constructor.__notifyProps);
      }
      if (!wasReadyInvoked) {
        this.ready();
      }
    }
    /**
     * Set several properties at once and perform synchronous update.
     * @protected
     */
    setProperties(props) {
      Object.entries(props).forEach(([name, value]) => {
        const key = this.constructor.__propKeys.get(name);
        const oldValue = this[key];
        this[key] = value;
        this.requestUpdate(name, oldValue);
      });
      if (this.hasUpdated) {
        this.performUpdate();
      }
    }
    /** @protected */
    _createMethodObserver(observer2) {
      const dynamicObservers = getOrCreateMap(this, "__dynamicMethodObservers");
      const { method, observerProps } = parseObserver(observer2);
      dynamicObservers.set(method, observerProps);
    }
    /** @protected */
    _createPropertyObserver(property, method) {
      const dynamicObservers = getOrCreateMap(this, "__dynamicPropertyObservers");
      dynamicObservers.set(method, property);
    }
    /** @private */
    __runComplexObservers(props, observers) {
      observers.forEach((observerProps, method) => {
        if (observerProps.some((prop) => props.has(prop))) {
          if (!this[method]) {
            console.warn(`observer method ${method} not defined`);
          } else {
            this[method](...observerProps.map((prop) => this[prop]));
          }
        }
      });
    }
    /** @private */
    __runDynamicObservers(props, observers) {
      observers.forEach((prop, method) => {
        if (props.has(prop) && this[method]) {
          this[method](this[prop], props.get(prop));
        }
      });
    }
    /** @private */
    __runObservers(props, observers) {
      props.forEach((v, k2) => {
        const observer2 = observers.get(k2);
        if (observer2 !== void 0 && this[observer2]) {
          this[observer2](this[k2], v);
        }
      });
    }
    /** @private */
    __runNotifyProps(props, notifyProps) {
      props.forEach((_, k2) => {
        if (notifyProps.has(k2)) {
          this.dispatchEvent(
            new CustomEvent(`${camelToDash(k2)}-changed`, {
              detail: {
                value: this[k2]
              }
            })
          );
        }
      });
    }
    /** @protected */
    _get(path, object) {
      return get$2(path, object);
    }
    /** @protected */
    _set(path, value, object) {
      set$1(path, value, object);
    }
  }
  return PolylitMixinClass;
};
const PolylitMixin = dedupeMixin(PolylitMixinImplementation);
/**
 * @license
 * Copyright (c) 2021 - 2025 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const fieldOutlineStyles = css`
  :host {
    display: block;
    box-sizing: border-box;
    position: absolute;
    inset: 0;
    width: 100%;
    height: 100%;
    pointer-events: none;
    user-select: none;
    opacity: 0;
    --_active-user-color: transparent;
  }

  :host([has-active-user]) {
    opacity: 1;
  }
`;
const userTagStyles = css`
  :host {
    display: block;
    box-sizing: border-box;
    margin: 0 0 var(--vaadin-user-tag-offset);
    opacity: 0;
    height: 1.3rem;
    transition: opacity 0.2s ease-in-out;
    background-color: var(--vaadin-user-tag-color);
    color: #fff;
    cursor: default;
    -webkit-user-select: none;
    user-select: none;
    --vaadin-user-tag-offset: 4px;
  }

  :host(.show) {
    opacity: 1;
  }

  :host(:last-of-type) {
    margin-bottom: 0;
  }

  [part='name'] {
    overflow: hidden;
    white-space: nowrap;
    text-overflow: ellipsis;
    box-sizing: border-box;
    padding: 2px 4px;
    height: 1.3rem;
    font-size: 13px;
  }
`;
const userTagsOverlayStyles = css`
  [part='overlay'] {
    position: relative;
    left: -4px;
    padding: 4px;
    outline: none;
    overflow: visible;
  }

  ::slotted([part='tags']) {
    display: flex;
    flex-direction: column;
    align-items: flex-start;
  }

  :host([dir='rtl']) [part='overlay'] {
    left: auto;
    right: -4px;
  }

  :host([opening]),
  :host([closing]) {
    animation: 0.14s user-tags-overlay-dummy-animation;
  }

  @keyframes user-tags-overlay-dummy-animation {
    0% {
      opacity: 1;
    }

    100% {
      opacity: 1;
    }
  }
`;
/**
 * @license
 * Copyright (c) 2021 - 2025 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
class UserTag extends ThemableMixin(DirMixin(PolylitMixin(LitElement))) {
  static get is() {
    return "vaadin-user-tag";
  }
  static get styles() {
    return userTagStyles;
  }
  /** @protected */
  render() {
    return html$1`<div part="name">${this.name}</div>`;
  }
  static get properties() {
    return {
      /**
       * Name of the user.
       */
      name: {
        type: String
      },
      /**
       * Id of the user.
       */
      uid: {
        type: String
      },
      /**
       * Color index of the user.
       */
      colorIndex: {
        type: Number,
        observer: "_colorIndexChanged"
      }
    };
  }
  /** @protected */
  ready() {
    super.ready();
    this.addEventListener("mousedown", this._onClick.bind(this), true);
  }
  /** @private */
  _colorIndexChanged(index) {
    if (index != null) {
      this.style.setProperty("--vaadin-user-tag-color", `var(--vaadin-user-color-${index})`);
    }
  }
  /**
   * @param {Event} e
   * @private
   */
  _onClick(e2) {
    e2.preventDefault();
    this.dispatchEvent(
      new CustomEvent("user-tag-click", {
        bubbles: true,
        composed: true,
        detail: {
          name: this.name
        }
      })
    );
  }
}
defineCustomElement(UserTag);
/**
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/
window.JSCompiler_renameProperty = function(prop, obj) {
  return prop;
};
/**
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/
let scheduled = false;
let beforeRenderQueue = [];
let afterRenderQueue = [];
function schedule() {
  scheduled = true;
  requestAnimationFrame(function() {
    scheduled = false;
    flushQueue(beforeRenderQueue);
    setTimeout(function() {
      runQueue(afterRenderQueue);
    });
  });
}
function flushQueue(queue) {
  while (queue.length) {
    callMethod(queue.shift());
  }
}
function runQueue(queue) {
  for (let i2 = 0, l = queue.length; i2 < l; i2++) {
    callMethod(queue.shift());
  }
}
function callMethod(info) {
  const context = info[0];
  const callback = info[1];
  const args = info[2];
  try {
    callback.apply(context, args);
  } catch (e2) {
    setTimeout(() => {
      throw e2;
    });
  }
}
function beforeNextRender(context, callback, args) {
  if (!scheduled) {
    schedule();
  }
  beforeRenderQueue.push([context, callback, args]);
}
function afterNextRender(context, callback, args) {
  if (!scheduled) {
    schedule();
  }
  afterRenderQueue.push([context, callback, args]);
}
/**
 * @license
 * Copyright (c) 2021 - 2025 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const testUserAgent = (regexp) => regexp.test(navigator.userAgent);
const testPlatform = (regexp) => regexp.test(navigator.platform);
const testVendor = (regexp) => regexp.test(navigator.vendor);
const isAndroid = testUserAgent(/Android/u);
const isChrome = testUserAgent(/Chrome/u) && testVendor(/Google Inc/u);
const isFirefox = testUserAgent(/Firefox/u);
const isIPad = testPlatform(/^iPad/u) || testPlatform(/^Mac/u) && navigator.maxTouchPoints > 1;
const isIPhone = testPlatform(/^iPhone/u);
const isIOS = isIPhone || isIPad;
const isSafari = testUserAgent(/^((?!chrome|android).)*safari/iu);
const isTouch = (() => {
  try {
    document.createEvent("TouchEvent");
    return true;
  } catch (_) {
    return false;
  }
})();
const supportsAdoptingStyleSheets$1 = window.ShadowRoot && "adoptedStyleSheets" in Document.prototype && "replace" in CSSStyleSheet.prototype;
/**
 * @license
 * Copyright (c) 2017 Anton Korzunov
 * SPDX-License-Identifier: MIT
 */
let counterMap = /* @__PURE__ */ new WeakMap();
let uncontrolledNodes = /* @__PURE__ */ new WeakMap();
let markerMap = {};
let lockCount = 0;
const isElement = (node) => node && node.nodeType === Node.ELEMENT_NODE;
const logError = (...args) => {
  console.error(`Error: ${args.join(" ")}. Skip setting aria-hidden.`);
};
const correctTargets = (parent, targets) => {
  if (!isElement(parent)) {
    logError(parent, "is not a valid element");
    return [];
  }
  return targets.map((target) => {
    if (!isElement(target)) {
      logError(target, "is not a valid element");
      return null;
    }
    let node = target;
    while (node && node !== parent) {
      if (parent.contains(node)) {
        return target;
      }
      node = node.getRootNode().host;
    }
    logError(target, "is not contained inside", parent);
    return null;
  }).filter((x2) => Boolean(x2));
};
const applyAttributeToOthers = (originalTarget, parentNode, markerName, controlAttribute) => {
  const targets = correctTargets(parentNode, Array.isArray(originalTarget) ? originalTarget : [originalTarget]);
  if (!markerMap[markerName]) {
    markerMap[markerName] = /* @__PURE__ */ new WeakMap();
  }
  const markerCounter = markerMap[markerName];
  const hiddenNodes = [];
  const elementsToKeep = /* @__PURE__ */ new Set();
  const elementsToStop = new Set(targets);
  const keep = (el) => {
    if (!el || elementsToKeep.has(el)) {
      return;
    }
    elementsToKeep.add(el);
    const slot = el.assignedSlot;
    if (slot) {
      keep(slot);
    }
    keep(el.parentNode || el.host);
  };
  targets.forEach(keep);
  const deep = (parent) => {
    if (!parent || elementsToStop.has(parent)) {
      return;
    }
    const root2 = parent.shadowRoot;
    const children = root2 ? [...parent.children, ...root2.children] : [...parent.children];
    children.forEach((node) => {
      if (["template", "script", "style"].includes(node.localName)) {
        return;
      }
      if (elementsToKeep.has(node)) {
        deep(node);
      } else {
        const attr = node.getAttribute(controlAttribute);
        const alreadyHidden = attr !== null && attr !== "false";
        const counterValue = (counterMap.get(node) || 0) + 1;
        const markerValue = (markerCounter.get(node) || 0) + 1;
        counterMap.set(node, counterValue);
        markerCounter.set(node, markerValue);
        hiddenNodes.push(node);
        if (counterValue === 1 && alreadyHidden) {
          uncontrolledNodes.set(node, true);
        }
        if (markerValue === 1) {
          node.setAttribute(markerName, "true");
        }
        if (!alreadyHidden) {
          node.setAttribute(controlAttribute, "true");
        }
      }
    });
  };
  deep(parentNode);
  elementsToKeep.clear();
  lockCount += 1;
  return () => {
    hiddenNodes.forEach((node) => {
      const counterValue = counterMap.get(node) - 1;
      const markerValue = markerCounter.get(node) - 1;
      counterMap.set(node, counterValue);
      markerCounter.set(node, markerValue);
      if (!counterValue) {
        if (uncontrolledNodes.has(node)) {
          uncontrolledNodes.delete(node);
        } else {
          node.removeAttribute(controlAttribute);
        }
      }
      if (!markerValue) {
        node.removeAttribute(markerName);
      }
    });
    lockCount -= 1;
    if (!lockCount) {
      counterMap = /* @__PURE__ */ new WeakMap();
      counterMap = /* @__PURE__ */ new WeakMap();
      uncontrolledNodes = /* @__PURE__ */ new WeakMap();
      markerMap = {};
    }
  };
};
const hideOthers = (originalTarget, parentNode = document.body, markerName = "data-aria-hidden") => {
  const targets = Array.from(Array.isArray(originalTarget) ? originalTarget : [originalTarget]);
  if (parentNode) {
    targets.push(...Array.from(parentNode.querySelectorAll("[aria-live]")));
  }
  return applyAttributeToOthers(targets, parentNode, markerName, "aria-hidden");
};
/**
 * @license
 * Copyright (c) 2021 - 2025 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
class AriaModalController {
  /**
   * @param {HTMLElement} host
   */
  constructor(host, callback) {
    this.host = host;
    this.callback = typeof callback === "function" ? callback : () => host;
  }
  /**
   * Make the controller host modal by hiding other elements from screen readers
   * using `aria-hidden` attribute (can be replaced with `inert` in the future).
   *
   * The method name is chosen to align with the one provided by native `<dialog>`:
   * https://developer.mozilla.org/en-US/docs/Web/API/HTMLDialogElement/showModal
   */
  showModal() {
    const targets = this.callback();
    this.__showOthers = hideOthers(targets);
  }
  /**
   * Remove `aria-hidden` from other elements unless there are any other
   * controller hosts on the page activated by using `showModal()` call.
   */
  close() {
    if (this.__showOthers) {
      this.__showOthers();
      this.__showOthers = null;
    }
  }
}
/**
 * @license
 * Copyright (c) 2021 - 2025 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
let keyboardActive = false;
window.addEventListener(
  "keydown",
  () => {
    keyboardActive = true;
  },
  { capture: true }
);
window.addEventListener(
  "mousedown",
  () => {
    keyboardActive = false;
  },
  { capture: true }
);
function getDeepActiveElement() {
  let host = document.activeElement || document.body;
  while (host.shadowRoot && host.shadowRoot.activeElement) {
    host = host.shadowRoot.activeElement;
  }
  return host;
}
function isKeyboardActive() {
  return keyboardActive;
}
function isElementHiddenDirectly(element) {
  const style = element.style;
  if (style.visibility === "hidden" || style.display === "none") {
    return true;
  }
  const computedStyle = window.getComputedStyle(element);
  if (computedStyle.visibility === "hidden" || computedStyle.display === "none") {
    return true;
  }
  return false;
}
function hasLowerTabOrder(a3, b2) {
  const ati = Math.max(a3.tabIndex, 0);
  const bti = Math.max(b2.tabIndex, 0);
  return ati === 0 || bti === 0 ? bti > ati : ati > bti;
}
function mergeSortByTabIndex(left, right) {
  const result = [];
  while (left.length > 0 && right.length > 0) {
    if (hasLowerTabOrder(left[0], right[0])) {
      result.push(right.shift());
    } else {
      result.push(left.shift());
    }
  }
  return result.concat(left, right);
}
function sortElementsByTabIndex(elements) {
  const len = elements.length;
  if (len < 2) {
    return elements;
  }
  const pivot = Math.ceil(len / 2);
  const left = sortElementsByTabIndex(elements.slice(0, pivot));
  const right = sortElementsByTabIndex(elements.slice(pivot));
  return mergeSortByTabIndex(left, right);
}
function isElementHidden(element) {
  if (element.checkVisibility) {
    return !element.checkVisibility({ visibilityProperty: true });
  }
  if (element.offsetParent === null && element.clientWidth === 0 && element.clientHeight === 0) {
    return true;
  }
  return isElementHiddenDirectly(element);
}
function isElementFocusable(element) {
  if (element.matches('[tabindex="-1"]')) {
    return false;
  }
  if (element.matches("input, select, textarea, button, object")) {
    return element.matches(":not([disabled])");
  }
  return element.matches("a[href], area[href], iframe, [tabindex], [contentEditable]");
}
function isElementFocused(element) {
  return element.getRootNode().activeElement === element;
}
function normalizeTabIndex(element) {
  if (!isElementFocusable(element)) {
    return -1;
  }
  const tabIndex = element.getAttribute("tabindex") || 0;
  return Number(tabIndex);
}
function collectFocusableNodes(node, result) {
  if (node.nodeType !== Node.ELEMENT_NODE || isElementHiddenDirectly(node)) {
    return false;
  }
  const element = (
    /** @type {HTMLElement} */
    node
  );
  const tabIndex = normalizeTabIndex(element);
  let needsSort = tabIndex > 0;
  if (tabIndex >= 0) {
    result.push(element);
  }
  let children = [];
  if (element.localName === "slot") {
    children = element.assignedNodes({ flatten: true });
  } else {
    children = (element.shadowRoot || element).children;
  }
  [...children].forEach((child) => {
    needsSort = collectFocusableNodes(child, result) || needsSort;
  });
  return needsSort;
}
function getFocusableElements(element) {
  const focusableElements = [];
  const needsSortByTabIndex = collectFocusableNodes(element, focusableElements);
  if (needsSortByTabIndex) {
    return sortElementsByTabIndex(focusableElements);
  }
  return focusableElements;
}
/**
 * @license
 * Copyright (c) 2021 - 2025 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
class FocusRestorationController {
  /**
   * Saves the given node as a target for restoring focus to
   * when `restoreFocus()` is called. If no node is provided,
   * the currently focused node in the DOM is saved as a target.
   *
   * @param {Node | null | undefined} focusNode
   */
  saveFocus(focusNode) {
    this.focusNode = focusNode || getDeepActiveElement();
  }
  /**
   * Restores focus to the target node that was saved previously with `saveFocus()`.
   */
  restoreFocus(options) {
    const focusNode = this.focusNode;
    if (!focusNode) {
      return;
    }
    const preventScroll = options ? options.preventScroll : false;
    if (getDeepActiveElement() === document.body) {
      setTimeout(() => focusNode.focus({ preventScroll }));
    } else {
      focusNode.focus({ preventScroll });
    }
    this.focusNode = null;
  }
}
/**
 * @license
 * Copyright (c) 2021 - 2025 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const instances = [];
class FocusTrapController {
  /**
   * @param {HTMLElement} host
   */
  constructor(host) {
    this.host = host;
    this.__trapNode = null;
    this.__onKeyDown = this.__onKeyDown.bind(this);
  }
  /**
   * An array of tab-ordered focusable elements inside the trap node.
   *
   * @return {HTMLElement[]}
   * @private
   */
  get __focusableElements() {
    return getFocusableElements(this.__trapNode);
  }
  /**
   * The index of the element inside the trap node that currently has focus.
   *
   * @return {HTMLElement | undefined}
   * @private
   */
  get __focusedElementIndex() {
    const focusableElements = this.__focusableElements;
    return focusableElements.indexOf(focusableElements.filter(isElementFocused).pop());
  }
  hostConnected() {
    document.addEventListener("keydown", this.__onKeyDown);
  }
  hostDisconnected() {
    document.removeEventListener("keydown", this.__onKeyDown);
  }
  /**
   * Activates a focus trap for a DOM node that will prevent focus from escaping the node.
   * The trap can be deactivated with the `.releaseFocus()` method.
   *
   * If focus is initially outside the trap, the method will move focus inside,
   * on the first focusable element of the trap in the tab order.
   * The first focusable element can be the trap node itself if it is focusable
   * and comes first in the tab order.
   *
   * If there are no focusable elements, the method will throw an exception
   * and the trap will not be set.
   *
   * @param {HTMLElement} trapNode
   */
  trapFocus(trapNode) {
    this.__trapNode = trapNode;
    if (this.__focusableElements.length === 0) {
      this.__trapNode = null;
      throw new Error("The trap node should have at least one focusable descendant or be focusable itself.");
    }
    instances.push(this);
    if (this.__focusedElementIndex === -1) {
      this.__focusableElements[0].focus();
    }
  }
  /**
   * Deactivates the focus trap set with the `.trapFocus()` method
   * so that it becomes possible to tab outside the trap node.
   */
  releaseFocus() {
    this.__trapNode = null;
    instances.pop();
  }
  /**
   * A `keydown` event handler that manages tabbing navigation when the trap is enabled.
   *
   * - Moves focus to the next focusable element of the trap on `Tab` press.
   * When no next element to focus, the method moves focus to the first focusable element.
   * - Moves focus to the prev focusable element of the trap on `Shift+Tab` press.
   * When no prev element to focus, the method moves focus to the last focusable element.
   *
   * @param {KeyboardEvent} event
   * @private
   */
  __onKeyDown(event) {
    if (!this.__trapNode) {
      return;
    }
    if (this !== Array.from(instances).pop()) {
      return;
    }
    if (event.key === "Tab") {
      event.preventDefault();
      const backward = event.shiftKey;
      this.__focusNextElement(backward);
    }
  }
  /**
   * - Moves focus to the next focusable element if `backward === false`.
   * When no next element to focus, the method moves focus to the first focusable element.
   * - Moves focus to the prev focusable element if `backward === true`.
   * When no prev element to focus the method moves focus to the last focusable element.
   *
   * If no focusable elements, the method returns immediately.
   *
   * @param {boolean} backward
   * @private
   */
  __focusNextElement(backward = false) {
    const focusableElements = this.__focusableElements;
    const step = backward ? -1 : 1;
    const currentIndex = this.__focusedElementIndex;
    const nextIndex = (focusableElements.length + currentIndex + step) % focusableElements.length;
    const element = focusableElements[nextIndex];
    element.focus();
    if (element.localName === "input") {
      element.select();
    }
  }
}
/**
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/
let dedupeId$1 = 0;
const dedupingMixin = function(mixin) {
  let mixinApplications = (
    /** @type {!MixinFunction} */
    mixin.__mixinApplications
  );
  if (!mixinApplications) {
    mixinApplications = /* @__PURE__ */ new WeakMap();
    mixin.__mixinApplications = mixinApplications;
  }
  let mixinDedupeId = dedupeId$1++;
  function dedupingMixin2(base) {
    let baseSet = (
      /** @type {!MixinFunction} */
      base.__mixinSet
    );
    if (baseSet && baseSet[mixinDedupeId]) {
      return base;
    }
    let map = mixinApplications;
    let extended = map.get(base);
    if (!extended) {
      extended = /** @type {!Function} */
      mixin(base);
      map.set(base, extended);
      let mixinSet = Object.create(
        /** @type {!MixinFunction} */
        extended.__mixinSet || baseSet || null
      );
      mixinSet[mixinDedupeId] = true;
      extended.__mixinSet = mixinSet;
    }
    return extended;
  }
  return dedupingMixin2;
};
/**
 * @license
 * Copyright (c) 2021 - 2025 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const ControllerMixin = dedupingMixin((superClass) => {
  if (typeof superClass.prototype.addController === "function") {
    return superClass;
  }
  return class ControllerMixinClass extends superClass {
    constructor() {
      super();
      this.__controllers = /* @__PURE__ */ new Set();
    }
    /** @protected */
    connectedCallback() {
      super.connectedCallback();
      this.__controllers.forEach((c2) => {
        if (c2.hostConnected) {
          c2.hostConnected();
        }
      });
    }
    /** @protected */
    disconnectedCallback() {
      super.disconnectedCallback();
      this.__controllers.forEach((c2) => {
        if (c2.hostDisconnected) {
          c2.hostDisconnected();
        }
      });
    }
    /**
     * Registers a controller to participate in the element update cycle.
     *
     * @param {ReactiveController} controller
     * @protected
     */
    addController(controller) {
      this.__controllers.add(controller);
      if (this.$ !== void 0 && this.isConnected && controller.hostConnected) {
        controller.hostConnected();
      }
    }
    /**
     * Removes a controller from the element.
     *
     * @param {ReactiveController} controller
     * @protected
     */
    removeController(controller) {
      this.__controllers.delete(controller);
    }
  };
});
/**
 * @license
 * Copyright (c) 2017 - 2025 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const OverlayFocusMixin = (superClass) => class OverlayFocusMixin extends ControllerMixin(superClass) {
  static get properties() {
    return {
      /**
       * When true, opening the overlay moves focus to the first focusable child,
       * or to the overlay part with tabindex if there are no focusable children.
       * @attr {boolean} focus-trap
       */
      focusTrap: {
        type: Boolean,
        value: false
      },
      /**
       * Set to true to enable restoring of focus when overlay is closed.
       * @attr {boolean} restore-focus-on-close
       */
      restoreFocusOnClose: {
        type: Boolean,
        value: false
      },
      /**
       * Set to specify the element which should be focused on overlay close,
       * if `restoreFocusOnClose` is set to true.
       * @type {HTMLElement}
       */
      restoreFocusNode: {
        type: HTMLElement
      }
    };
  }
  constructor() {
    super();
    this.__ariaModalController = new AriaModalController(this);
    this.__focusTrapController = new FocusTrapController(this);
    this.__focusRestorationController = new FocusRestorationController();
  }
  /** @protected */
  ready() {
    super.ready();
    this.addController(this.__ariaModalController);
    this.addController(this.__focusTrapController);
    this.addController(this.__focusRestorationController);
  }
  /**
   * Release focus and restore focus after the overlay is closed.
   *
   * @protected
   */
  _resetFocus() {
    if (this.focusTrap) {
      this.__ariaModalController.close();
      this.__focusTrapController.releaseFocus();
    }
    if (this.restoreFocusOnClose && this._shouldRestoreFocus()) {
      const preventScroll = !isKeyboardActive();
      this.__focusRestorationController.restoreFocus({ preventScroll });
    }
  }
  /**
   * Save the previously focused node when the overlay starts to open.
   *
   * @protected
   */
  _saveFocus() {
    if (this.restoreFocusOnClose) {
      this.__focusRestorationController.saveFocus(this.restoreFocusNode);
    }
  }
  /**
   * Trap focus within the overlay after opening has completed.
   *
   * @protected
   */
  _trapFocus() {
    if (this.focusTrap) {
      this.__ariaModalController.showModal();
      this.__focusTrapController.trapFocus(this.$.overlay);
    }
  }
  /**
   * Returns true if focus is still inside the overlay or on the body element,
   * otherwise false.
   *
   * Focus shouldn't be restored if it's been moved elsewhere by another
   * component or as a result of a user interaction e.g. the user clicked
   * on a button outside the overlay while the overlay was open.
   *
   * @protected
   * @return {boolean}
   */
  _shouldRestoreFocus() {
    const activeElement = getDeepActiveElement();
    return activeElement === document.body || this._deepContains(activeElement);
  }
  /**
   * Returns true if the overlay contains the given node,
   * including those within shadow DOM trees.
   *
   * @param {Node} node
   * @return {boolean}
   * @protected
   */
  _deepContains(node) {
    if (this.contains(node)) {
      return true;
    }
    let n = node;
    const doc = node.ownerDocument;
    while (n && n !== doc && n !== this) {
      n = n.parentNode || n.host;
    }
    return n === this;
  }
};
/**
 * @license
 * Copyright (c) 2017 - 2025 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const getAttachedInstances = () => Array.from(document.body.children).filter((el) => el instanceof HTMLElement && el._hasOverlayStackMixin && !el.hasAttribute("closing")).sort((a3, b2) => a3.__zIndex - b2.__zIndex || 0);
const getOverlayInstances = () => getAttachedInstances().filter((el) => el.$.overlay);
const isLastOverlay$1 = (overlay2, filter2 = (_overlay) => true) => {
  const filteredOverlays = getOverlayInstances().filter(filter2);
  return overlay2 === filteredOverlays.pop();
};
const overlayMap = /* @__PURE__ */ new WeakMap();
const setNestedOverlay = (parent, nested) => {
  if (nested != null) {
    overlayMap.set(parent, nested);
  } else {
    overlayMap.delete(parent);
  }
};
const OverlayStackMixin = (superClass) => class OverlayStackMixin extends superClass {
  constructor() {
    super();
    this._hasOverlayStackMixin = true;
  }
  /**
   * Returns true if this is the last one in the opened overlays stack.
   *
   * @return {boolean}
   * @protected
   */
  get _last() {
    return isLastOverlay$1(this);
  }
  /**
   * Brings the overlay as visually the frontmost one.
   */
  bringToFront() {
    let zIndex = "";
    const frontmost = getAttachedInstances().filter((o) => o !== this).pop();
    if (frontmost) {
      const frontmostZIndex = frontmost.__zIndex;
      zIndex = frontmostZIndex + 1;
    }
    this.style.zIndex = zIndex;
    this.__zIndex = zIndex || parseFloat(getComputedStyle(this).zIndex);
    if (overlayMap.has(this)) {
      overlayMap.get(this).bringToFront();
    }
  }
  /** @protected */
  _enterModalState() {
    if (document.body.style.pointerEvents !== "none") {
      this._previousDocumentPointerEvents = document.body.style.pointerEvents;
      document.body.style.pointerEvents = "none";
    }
    getOverlayInstances().forEach((el) => {
      if (el !== this) {
        el.$.overlay.style.pointerEvents = "none";
      }
    });
  }
  /** @protected */
  _exitModalState() {
    if (this._previousDocumentPointerEvents !== void 0) {
      document.body.style.pointerEvents = this._previousDocumentPointerEvents;
      delete this._previousDocumentPointerEvents;
    }
    const instances2 = getOverlayInstances();
    let el;
    while (el = instances2.pop()) {
      if (el === this) {
        continue;
      }
      el.$.overlay.style.removeProperty("pointer-events");
      if (!el.modeless) {
        break;
      }
    }
  }
};
/**
 * @license
 * Copyright (c) 2017 - 2025 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const OverlayMixin = (superClass) => class OverlayMixin extends OverlayFocusMixin(OverlayStackMixin(superClass)) {
  static get properties() {
    return {
      /**
       * When true, the overlay is visible and attached to body.
       */
      opened: {
        type: Boolean,
        notify: true,
        observer: "_openedChanged",
        reflectToAttribute: true,
        sync: true
      },
      /**
       * Owner element passed with renderer function
       * @type {HTMLElement}
       */
      owner: {
        type: Object,
        sync: true
      },
      /**
       * Object with properties that is passed to `renderer` function
       */
      model: {
        type: Object,
        sync: true
      },
      /**
       * Custom function for rendering the content of the overlay.
       * Receives three arguments:
       *
       * - `root` The root container DOM element. Append your content to it.
       * - `owner` The host element of the renderer function.
       * - `model` The object with the properties related with rendering.
       * @type {OverlayRenderer | null | undefined}
       */
      renderer: {
        type: Object,
        sync: true
      },
      /**
       * When true the overlay won't disable the main content, showing
       * it doesn't change the functionality of the user interface.
       * @type {boolean}
       */
      modeless: {
        type: Boolean,
        value: false,
        reflectToAttribute: true,
        observer: "_modelessChanged",
        sync: true
      },
      /**
       * When set to true, the overlay is hidden. This also closes the overlay
       * immediately in case there is a closing animation in progress.
       * @type {boolean}
       */
      hidden: {
        type: Boolean,
        reflectToAttribute: true,
        observer: "_hiddenChanged",
        sync: true
      },
      /**
       * When true the overlay has backdrop on top of content when opened.
       * @type {boolean}
       */
      withBackdrop: {
        type: Boolean,
        value: false,
        reflectToAttribute: true,
        sync: true
      }
    };
  }
  static get observers() {
    return ["_rendererOrDataChanged(renderer, owner, model, opened)"];
  }
  constructor() {
    super();
    this._boundMouseDownListener = this._mouseDownListener.bind(this);
    this._boundMouseUpListener = this._mouseUpListener.bind(this);
    this._boundOutsideClickListener = this._outsideClickListener.bind(this);
    this._boundKeydownListener = this._keydownListener.bind(this);
    if (isIOS) {
      this._boundIosResizeListener = () => this._detectIosNavbar();
    }
  }
  /** @protected */
  ready() {
    super.ready();
    this.addEventListener("click", () => {
    });
    this.$.backdrop.addEventListener("click", () => {
    });
    this.addEventListener("mouseup", () => {
      if (document.activeElement === document.body && this.$.overlay.getAttribute("tabindex") === "0") {
        this.$.overlay.focus();
      }
    });
  }
  /** @protected */
  connectedCallback() {
    super.connectedCallback();
    if (this._boundIosResizeListener) {
      this._detectIosNavbar();
      window.addEventListener("resize", this._boundIosResizeListener);
    }
  }
  /** @protected */
  disconnectedCallback() {
    super.disconnectedCallback();
    if (this._boundIosResizeListener) {
      window.removeEventListener("resize", this._boundIosResizeListener);
    }
  }
  /**
   * Requests an update for the content of the overlay.
   * While performing the update, it invokes the renderer passed in the `renderer` property.
   *
   * It is not guaranteed that the update happens immediately (synchronously) after it is requested.
   */
  requestContentUpdate() {
    if (this.renderer) {
      this.renderer.call(this.owner, this, this.owner, this.model);
    }
  }
  /**
   * @param {Event=} sourceEvent
   */
  close(sourceEvent) {
    const evt = new CustomEvent("vaadin-overlay-close", {
      bubbles: true,
      cancelable: true,
      detail: { sourceEvent }
    });
    this.dispatchEvent(evt);
    if (!evt.defaultPrevented) {
      this.opened = false;
    }
  }
  /** @private */
  _detectIosNavbar() {
    if (!this.opened) {
      return;
    }
    const innerHeight = window.innerHeight;
    const innerWidth = window.innerWidth;
    const landscape = innerWidth > innerHeight;
    const clientHeight = document.documentElement.clientHeight;
    if (landscape && clientHeight > innerHeight) {
      this.style.setProperty("--vaadin-overlay-viewport-bottom", `${clientHeight - innerHeight}px`);
    } else {
      this.style.setProperty("--vaadin-overlay-viewport-bottom", "0");
    }
  }
  /** @private */
  _addGlobalListeners() {
    document.addEventListener("mousedown", this._boundMouseDownListener);
    document.addEventListener("mouseup", this._boundMouseUpListener);
    document.documentElement.addEventListener("click", this._boundOutsideClickListener, true);
  }
  /** @private */
  _removeGlobalListeners() {
    document.removeEventListener("mousedown", this._boundMouseDownListener);
    document.removeEventListener("mouseup", this._boundMouseUpListener);
    document.documentElement.removeEventListener("click", this._boundOutsideClickListener, true);
  }
  /** @private */
  _rendererOrDataChanged(renderer, owner, model, opened) {
    const ownerOrModelChanged = this._oldOwner !== owner || this._oldModel !== model;
    this._oldModel = model;
    this._oldOwner = owner;
    const rendererChanged = this._oldRenderer !== renderer;
    const hasOldRenderer = this._oldRenderer !== void 0;
    this._oldRenderer = renderer;
    const openedChanged = this._oldOpened !== opened;
    this._oldOpened = opened;
    if (rendererChanged && hasOldRenderer) {
      this.innerHTML = "";
      delete this._$litPart$;
    }
    if (opened && renderer && (rendererChanged || openedChanged || ownerOrModelChanged)) {
      this.requestContentUpdate();
    }
  }
  /** @private */
  _modelessChanged(modeless) {
    if (!modeless) {
      if (this.opened) {
        this._addGlobalListeners();
        this._enterModalState();
      }
    } else {
      this._removeGlobalListeners();
      this._exitModalState();
    }
  }
  /** @private */
  _openedChanged(opened, wasOpened) {
    if (opened) {
      this._saveFocus();
      this._animatedOpening();
      afterNextRender(this, () => {
        this._trapFocus();
        const evt = new CustomEvent("vaadin-overlay-open", { bubbles: true });
        this.dispatchEvent(evt);
      });
      document.addEventListener("keydown", this._boundKeydownListener);
      if (!this.modeless) {
        this._addGlobalListeners();
      }
    } else if (wasOpened) {
      this._resetFocus();
      this._animatedClosing();
      document.removeEventListener("keydown", this._boundKeydownListener);
      if (!this.modeless) {
        this._removeGlobalListeners();
      }
    }
  }
  /** @private */
  _hiddenChanged(hidden) {
    if (hidden && this.hasAttribute("closing")) {
      this._flushAnimation("closing");
    }
  }
  /**
   * @return {boolean}
   * @private
   */
  _shouldAnimate() {
    const style = getComputedStyle(this);
    const name = style.getPropertyValue("animation-name");
    const hidden = style.getPropertyValue("display") === "none";
    return !hidden && name && name !== "none";
  }
  /**
   * @param {string} type
   * @param {Function} callback
   * @private
   */
  _enqueueAnimation(type, callback) {
    const handler = `__${type}Handler`;
    const listener = (event) => {
      if (event && event.target !== this) {
        return;
      }
      callback();
      this.removeEventListener("animationend", listener);
      delete this[handler];
    };
    this[handler] = listener;
    this.addEventListener("animationend", listener);
  }
  /**
   * @param {string} type
   * @protected
   */
  _flushAnimation(type) {
    const handler = `__${type}Handler`;
    if (typeof this[handler] === "function") {
      this[handler]();
    }
  }
  /** @private */
  _animatedOpening() {
    if (this.parentNode === document.body && this.hasAttribute("closing")) {
      this._flushAnimation("closing");
    }
    this._attachOverlay();
    if (!this.modeless) {
      this._enterModalState();
    }
    this.setAttribute("opening", "");
    if (this._shouldAnimate()) {
      this._enqueueAnimation("opening", () => {
        this._finishOpening();
      });
    } else {
      this._finishOpening();
    }
  }
  /** @private */
  _attachOverlay() {
    this._placeholder = document.createComment("vaadin-overlay-placeholder");
    this.parentNode.insertBefore(this._placeholder, this);
    document.body.appendChild(this);
    this.bringToFront();
  }
  /** @private */
  _finishOpening() {
    this.removeAttribute("opening");
  }
  /** @private */
  _finishClosing() {
    this._detachOverlay();
    this.$.overlay.style.removeProperty("pointer-events");
    this.removeAttribute("closing");
    this.dispatchEvent(new CustomEvent("vaadin-overlay-closed"));
  }
  /** @private */
  _animatedClosing() {
    if (this.hasAttribute("opening")) {
      this._flushAnimation("opening");
    }
    if (this._placeholder) {
      this._exitModalState();
      this.setAttribute("closing", "");
      this.dispatchEvent(new CustomEvent("vaadin-overlay-closing"));
      if (this._shouldAnimate()) {
        this._enqueueAnimation("closing", () => {
          this._finishClosing();
        });
      } else {
        this._finishClosing();
      }
    }
  }
  /** @private */
  _detachOverlay() {
    this._placeholder.parentNode.insertBefore(this, this._placeholder);
    this._placeholder.parentNode.removeChild(this._placeholder);
  }
  /** @private */
  _mouseDownListener(event) {
    this._mouseDownInside = event.composedPath().indexOf(this.$.overlay) >= 0;
  }
  /** @private */
  _mouseUpListener(event) {
    this._mouseUpInside = event.composedPath().indexOf(this.$.overlay) >= 0;
  }
  /**
   * Whether to close the overlay on outside click or not.
   * Override this method to customize the closing logic.
   *
   * @param {Event} _event
   * @return {boolean}
   * @protected
   */
  _shouldCloseOnOutsideClick(_event) {
    return this._last;
  }
  /**
   * Outside click listener used in capture phase to close the overlay before
   * propagating the event to the listener on the element that triggered it.
   * Otherwise, calling `open()` would result in closing and re-opening.
   *
   * @private
   */
  _outsideClickListener(event) {
    if (event.composedPath().includes(this.$.overlay) || this._mouseDownInside || this._mouseUpInside) {
      this._mouseDownInside = false;
      this._mouseUpInside = false;
      return;
    }
    if (!this._shouldCloseOnOutsideClick(event)) {
      return;
    }
    const evt = new CustomEvent("vaadin-overlay-outside-click", {
      bubbles: true,
      cancelable: true,
      detail: { sourceEvent: event }
    });
    this.dispatchEvent(evt);
    if (this.opened && !evt.defaultPrevented) {
      this.close(event);
    }
  }
  /**
   * Listener used to close whe overlay on Escape press, if it is the last one.
   * @private
   */
  _keydownListener(event) {
    if (!this._last) {
      return;
    }
    if (this.modeless && !event.composedPath().includes(this.$.overlay)) {
      return;
    }
    if (event.key === "Escape") {
      const evt = new CustomEvent("vaadin-overlay-escape-press", {
        bubbles: true,
        cancelable: true,
        detail: { sourceEvent: event }
      });
      this.dispatchEvent(evt);
      if (this.opened && !evt.defaultPrevented) {
        this.close(event);
      }
    }
  }
};
/**
 * @license
 * Copyright (c) 2021 - 2025 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
function getAncestorRootNodes(node) {
  const result = [];
  while (node) {
    if (node.nodeType === Node.DOCUMENT_NODE) {
      result.push(node);
      break;
    }
    if (node.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {
      result.push(node);
      node = node.host;
      continue;
    }
    if (node.assignedSlot) {
      node = node.assignedSlot;
      continue;
    }
    node = node.parentNode;
  }
  return result;
}
function getFlattenedElements(node) {
  const result = [];
  let elements;
  if (node.localName === "slot") {
    elements = node.assignedElements();
  } else {
    result.push(node);
    elements = [...node.children];
  }
  elements.forEach((elem) => result.push(...getFlattenedElements(elem)));
  return result;
}
function getClosestElement(selector, node) {
  if (!node) {
    return null;
  }
  return node.closest(selector) || getClosestElement(selector, node.getRootNode().host);
}
function deserializeAttributeValue(value) {
  if (!value) {
    return /* @__PURE__ */ new Set();
  }
  return new Set(value.split(" "));
}
function serializeAttributeValue(values) {
  return values ? [...values].join(" ") : "";
}
function addValueToAttribute(element, attr, value) {
  const values = deserializeAttributeValue(element.getAttribute(attr));
  values.add(value);
  element.setAttribute(attr, serializeAttributeValue(values));
}
function removeValueFromAttribute(element, attr, value) {
  const values = deserializeAttributeValue(element.getAttribute(attr));
  values.delete(value);
  if (values.size === 0) {
    element.removeAttribute(attr);
    return;
  }
  element.setAttribute(attr, serializeAttributeValue(values));
}
function isEmptyTextNode(node) {
  return node.nodeType === Node.TEXT_NODE && node.textContent.trim() === "";
}
/**
 * @license
 * Copyright (c) 2024 - 2025 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
function observeMove(element, callback) {
  let io = null;
  const root2 = document.documentElement;
  function cleanup() {
    io && io.disconnect();
    io = null;
  }
  function refresh(skip = false, threshold = 1) {
    cleanup();
    const { left, top, width, height } = element.getBoundingClientRect();
    if (!skip) {
      callback();
    }
    if (!width || !height) {
      return;
    }
    const insetTop = Math.floor(top);
    const insetRight = Math.floor(root2.clientWidth - (left + width));
    const insetBottom = Math.floor(root2.clientHeight - (top + height));
    const insetLeft = Math.floor(left);
    const rootMargin = `${-insetTop}px ${-insetRight}px ${-insetBottom}px ${-insetLeft}px`;
    const options = {
      rootMargin,
      threshold: Math.max(0, Math.min(1, threshold)) || 1
    };
    let isFirstUpdate = true;
    function handleObserve(entries) {
      let ratio = entries[0].intersectionRatio;
      if (ratio !== threshold) {
        if (!isFirstUpdate) {
          return refresh();
        }
        if (ratio === 0) {
          ratio = 1e-7;
        }
        refresh(false, ratio);
      }
      isFirstUpdate = false;
    }
    io = new IntersectionObserver(handleObserve, options);
    io.observe(element);
  }
  refresh(true);
  return cleanup;
}
/**
 * @license
 * Copyright (c) 2017 - 2025 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const PROP_NAMES_VERTICAL = {
  start: "top",
  end: "bottom"
};
const PROP_NAMES_HORIZONTAL = {
  start: "left",
  end: "right"
};
const targetResizeObserver = new ResizeObserver((entries) => {
  setTimeout(() => {
    entries.forEach((entry) => {
      if (entry.target.__overlay) {
        entry.target.__overlay._updatePosition();
      }
    });
  });
});
const PositionMixin = (superClass) => class PositionMixin extends superClass {
  static get properties() {
    return {
      /**
       * The element next to which this overlay should be aligned.
       * The position of the overlay relative to the positionTarget can be adjusted
       * with properties `horizontalAlign`, `verticalAlign`, `noHorizontalOverlap`
       * and `noVerticalOverlap`.
       */
      positionTarget: {
        type: Object,
        value: null,
        sync: true
      },
      /**
       * When `positionTarget` is set, this property defines whether to align the overlay's
       * left or right side to the target element by default.
       * Possible values are `start` and `end`.
       * RTL is taken into account when interpreting the value.
       * The overlay is automatically flipped to the opposite side when it doesn't fit into
       * the default side defined by this property.
       *
       * @attr {start|end} horizontal-align
       */
      horizontalAlign: {
        type: String,
        value: "start",
        sync: true
      },
      /**
       * When `positionTarget` is set, this property defines whether to align the overlay's
       * top or bottom side to the target element by default.
       * Possible values are `top` and `bottom`.
       * The overlay is automatically flipped to the opposite side when it doesn't fit into
       * the default side defined by this property.
       *
       * @attr {top|bottom} vertical-align
       */
      verticalAlign: {
        type: String,
        value: "top",
        sync: true
      },
      /**
       * When `positionTarget` is set, this property defines whether the overlay should overlap
       * the target element in the x-axis, or be positioned right next to it.
       *
       * @attr {boolean} no-horizontal-overlap
       */
      noHorizontalOverlap: {
        type: Boolean,
        value: false,
        sync: true
      },
      /**
       * When `positionTarget` is set, this property defines whether the overlay should overlap
       * the target element in the y-axis, or be positioned right above/below it.
       *
       * @attr {boolean} no-vertical-overlap
       */
      noVerticalOverlap: {
        type: Boolean,
        value: false,
        sync: true
      },
      /**
       * If the overlay content has no intrinsic height, this property can be used to set
       * the minimum vertical space (in pixels) required by the overlay. Setting a value to
       * the property effectively disables the content measurement in favor of using this
       * fixed value for determining the open direction.
       *
       * @attr {number} required-vertical-space
       */
      requiredVerticalSpace: {
        type: Number,
        value: 0,
        sync: true
      }
    };
  }
  static get observers() {
    return [
      "__positionSettingsChanged(horizontalAlign, verticalAlign, noHorizontalOverlap, noVerticalOverlap, requiredVerticalSpace)",
      "__overlayOpenedChanged(opened, positionTarget)"
    ];
  }
  constructor() {
    super();
    this.__onScroll = this.__onScroll.bind(this);
    this._updatePosition = this._updatePosition.bind(this);
  }
  /** @protected */
  connectedCallback() {
    super.connectedCallback();
    if (this.opened) {
      this.__addUpdatePositionEventListeners();
    }
  }
  /** @protected */
  disconnectedCallback() {
    super.disconnectedCallback();
    this.__removeUpdatePositionEventListeners();
  }
  /** @private */
  __addUpdatePositionEventListeners() {
    window.visualViewport.addEventListener("resize", this._updatePosition);
    window.visualViewport.addEventListener("scroll", this.__onScroll, true);
    this.__positionTargetAncestorRootNodes = getAncestorRootNodes(this.positionTarget);
    this.__positionTargetAncestorRootNodes.forEach((node) => {
      node.addEventListener("scroll", this.__onScroll, true);
    });
    if (this.positionTarget) {
      this.__observePositionTargetMove = observeMove(this.positionTarget, () => {
        this._updatePosition();
      });
    }
  }
  /** @private */
  __removeUpdatePositionEventListeners() {
    window.visualViewport.removeEventListener("resize", this._updatePosition);
    window.visualViewport.removeEventListener("scroll", this.__onScroll, true);
    if (this.__positionTargetAncestorRootNodes) {
      this.__positionTargetAncestorRootNodes.forEach((node) => {
        node.removeEventListener("scroll", this.__onScroll, true);
      });
      this.__positionTargetAncestorRootNodes = null;
    }
    if (this.__observePositionTargetMove) {
      this.__observePositionTargetMove();
      this.__observePositionTargetMove = null;
    }
  }
  /** @private */
  __overlayOpenedChanged(opened, positionTarget) {
    this.__removeUpdatePositionEventListeners();
    if (positionTarget) {
      positionTarget.__overlay = null;
      targetResizeObserver.unobserve(positionTarget);
      if (opened) {
        this.__addUpdatePositionEventListeners();
        positionTarget.__overlay = this;
        targetResizeObserver.observe(positionTarget);
      }
    }
    if (opened) {
      const computedStyle = getComputedStyle(this);
      if (!this.__margins) {
        this.__margins = {};
        ["top", "bottom", "left", "right"].forEach((propName) => {
          this.__margins[propName] = parseInt(computedStyle[propName], 10);
        });
      }
      this._updatePosition();
      requestAnimationFrame(() => this._updatePosition());
    }
  }
  __positionSettingsChanged() {
    this._updatePosition();
  }
  /** @private */
  __onScroll(e2) {
    if (e2.target instanceof Node && this.contains(e2.target)) {
      return;
    }
    this._updatePosition();
  }
  _updatePosition() {
    if (!this.positionTarget || !this.opened || !this.__margins) {
      return;
    }
    const targetRect = this.positionTarget.getBoundingClientRect();
    if (targetRect.width === 0 && targetRect.height === 0 && this.opened) {
      this.opened = false;
      return;
    }
    const shouldAlignStartVertically = this.__shouldAlignStartVertically(targetRect);
    this.style.justifyContent = shouldAlignStartVertically ? "flex-start" : "flex-end";
    const isRTL = this.__isRTL;
    const shouldAlignStartHorizontally = this.__shouldAlignStartHorizontally(targetRect, isRTL);
    const flexStart = !isRTL && shouldAlignStartHorizontally || isRTL && !shouldAlignStartHorizontally;
    this.style.alignItems = flexStart ? "flex-start" : "flex-end";
    const overlayRect = this.getBoundingClientRect();
    const verticalProps = this.__calculatePositionInOneDimension(
      targetRect,
      overlayRect,
      this.noVerticalOverlap,
      PROP_NAMES_VERTICAL,
      this,
      shouldAlignStartVertically
    );
    const horizontalProps = this.__calculatePositionInOneDimension(
      targetRect,
      overlayRect,
      this.noHorizontalOverlap,
      PROP_NAMES_HORIZONTAL,
      this,
      shouldAlignStartHorizontally
    );
    Object.assign(this.style, verticalProps, horizontalProps);
    this.toggleAttribute("bottom-aligned", !shouldAlignStartVertically);
    this.toggleAttribute("top-aligned", shouldAlignStartVertically);
    this.toggleAttribute("end-aligned", !flexStart);
    this.toggleAttribute("start-aligned", flexStart);
  }
  __shouldAlignStartHorizontally(targetRect, rtl) {
    const contentWidth = Math.max(this.__oldContentWidth || 0, this.$.overlay.offsetWidth);
    this.__oldContentWidth = this.$.overlay.offsetWidth;
    const viewportWidth = Math.min(window.innerWidth, document.documentElement.clientWidth);
    const defaultAlignLeft = !rtl && this.horizontalAlign === "start" || rtl && this.horizontalAlign === "end";
    return this.__shouldAlignStart(
      targetRect,
      contentWidth,
      viewportWidth,
      this.__margins,
      defaultAlignLeft,
      this.noHorizontalOverlap,
      PROP_NAMES_HORIZONTAL
    );
  }
  __shouldAlignStartVertically(targetRect) {
    const contentHeight = this.requiredVerticalSpace || Math.max(this.__oldContentHeight || 0, this.$.overlay.offsetHeight);
    this.__oldContentHeight = this.$.overlay.offsetHeight;
    const viewportHeight = Math.min(window.innerHeight, document.documentElement.clientHeight);
    const defaultAlignTop = this.verticalAlign === "top";
    return this.__shouldAlignStart(
      targetRect,
      contentHeight,
      viewportHeight,
      this.__margins,
      defaultAlignTop,
      this.noVerticalOverlap,
      PROP_NAMES_VERTICAL
    );
  }
  // eslint-disable-next-line @typescript-eslint/max-params
  __shouldAlignStart(targetRect, contentSize, viewportSize, margins, defaultAlignStart, noOverlap, propNames) {
    const spaceForStartAlignment = viewportSize - targetRect[noOverlap ? propNames.end : propNames.start] - margins[propNames.end];
    const spaceForEndAlignment = targetRect[noOverlap ? propNames.start : propNames.end] - margins[propNames.start];
    const spaceForDefaultAlignment = defaultAlignStart ? spaceForStartAlignment : spaceForEndAlignment;
    const spaceForOtherAlignment = defaultAlignStart ? spaceForEndAlignment : spaceForStartAlignment;
    const shouldGoToDefaultSide = spaceForDefaultAlignment > spaceForOtherAlignment || spaceForDefaultAlignment > contentSize;
    return defaultAlignStart === shouldGoToDefaultSide;
  }
  /**
   * Returns an adjusted value after resizing the browser window,
   * to avoid wrong calculations when e.g. previously set `bottom`
   * CSS property value is larger than the updated viewport height.
   * See https://github.com/vaadin/web-components/issues/4604
   */
  __adjustBottomProperty(cssPropNameToSet, propNames, currentValue) {
    let adjustedProp;
    if (cssPropNameToSet === propNames.end) {
      if (propNames.end === PROP_NAMES_VERTICAL.end) {
        const viewportHeight = Math.min(window.innerHeight, document.documentElement.clientHeight);
        if (currentValue > viewportHeight && this.__oldViewportHeight) {
          const heightDiff = this.__oldViewportHeight - viewportHeight;
          adjustedProp = currentValue - heightDiff;
        }
        this.__oldViewportHeight = viewportHeight;
      }
      if (propNames.end === PROP_NAMES_HORIZONTAL.end) {
        const viewportWidth = Math.min(window.innerWidth, document.documentElement.clientWidth);
        if (currentValue > viewportWidth && this.__oldViewportWidth) {
          const widthDiff = this.__oldViewportWidth - viewportWidth;
          adjustedProp = currentValue - widthDiff;
        }
        this.__oldViewportWidth = viewportWidth;
      }
    }
    return adjustedProp;
  }
  /**
   * Returns an object with CSS position properties to set,
   * e.g. { top: "100px" }
   */
  // eslint-disable-next-line @typescript-eslint/max-params
  __calculatePositionInOneDimension(targetRect, overlayRect, noOverlap, propNames, overlay2, shouldAlignStart) {
    const cssPropNameToSet = shouldAlignStart ? propNames.start : propNames.end;
    const cssPropNameToClear = shouldAlignStart ? propNames.end : propNames.start;
    const currentValue = parseFloat(overlay2.style[cssPropNameToSet] || getComputedStyle(overlay2)[cssPropNameToSet]);
    const adjustedValue = this.__adjustBottomProperty(cssPropNameToSet, propNames, currentValue);
    const diff = overlayRect[shouldAlignStart ? propNames.start : propNames.end] - targetRect[noOverlap === shouldAlignStart ? propNames.end : propNames.start];
    const valueToSet = adjustedValue ? `${adjustedValue}px` : `${currentValue + diff * (shouldAlignStart ? -1 : 1)}px`;
    return {
      [cssPropNameToSet]: valueToSet,
      [cssPropNameToClear]: ""
    };
  }
};
/**
 * @license
 * Copyright (c) 2017 - 2025 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const overlayStyles = css`
  :host {
    z-index: 200;
    position: fixed;

    /* Despite of what the names say, <vaadin-overlay> is just a container
          for position/sizing/alignment. The actual overlay is the overlay part. */

    /* Default position constraints: the entire viewport. Note: themes can
          override this to introduce gaps between the overlay and the viewport. */
    inset: 0;
    bottom: var(--vaadin-overlay-viewport-bottom);

    /* Use flexbox alignment for the overlay part. */
    display: flex;
    flex-direction: column; /* makes dropdowns sizing easier */
    /* Align to center by default. */
    align-items: center;
    justify-content: center;

    /* Allow centering when max-width/max-height applies. */
    margin: auto;

    /* The host is not clickable, only the overlay part is. */
    pointer-events: none;

    /* Remove tap highlight on touch devices. */
    -webkit-tap-highlight-color: transparent;

    /* CSS API for host */
    --vaadin-overlay-viewport-bottom: 0;
  }

  :host([hidden]),
  :host(:not([opened]):not([closing])),
  :host(:not([opened]):not([closing])) [part='overlay'] {
    display: none !important;
  }

  [part='overlay'] {
    -webkit-overflow-scrolling: touch;
    overflow: auto;
    pointer-events: auto;

    /* Prevent overflowing the host */
    max-width: 100%;
    box-sizing: border-box;

    -webkit-tap-highlight-color: initial; /* reenable tap highlight inside */
  }

  [part='backdrop'] {
    z-index: -1;
    content: '';
    background: rgba(0, 0, 0, 0.5);
    position: fixed;
    inset: 0;
    pointer-events: auto;
  }
`;
/**
 * @license
 * Copyright (c) 2021 - 2025 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
class UserTagsOverlay extends PositionMixin(OverlayMixin(DirMixin(ThemableMixin(PolylitMixin(LitElement))))) {
  static get is() {
    return "vaadin-user-tags-overlay";
  }
  static get styles() {
    return [overlayStyles, userTagsOverlayStyles];
  }
  /** @protected */
  render() {
    return html$1`
      <div id="backdrop" part="backdrop" ?hidden="${!this.withBackdrop}"></div>
      <div part="overlay" id="overlay">
        <div part="content" id="content">
          <slot></slot>
        </div>
      </div>
    `;
  }
}
defineCustomElement(UserTagsOverlay);
/**
 * @license
 * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
 * This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
 * The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
 * The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
 * Code distributed by Google as part of the polymer project is also
 * subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
 */
let microtaskCurrHandle$1 = 0;
let microtaskLastHandle$1 = 0;
const microtaskCallbacks$1 = [];
let microtaskScheduled$1 = false;
function microtaskFlush$1() {
  microtaskScheduled$1 = false;
  const len = microtaskCallbacks$1.length;
  for (let i2 = 0; i2 < len; i2++) {
    const cb = microtaskCallbacks$1[i2];
    if (cb) {
      try {
        cb();
      } catch (e2) {
        setTimeout(() => {
          throw e2;
        });
      }
    }
  }
  microtaskCallbacks$1.splice(0, len);
  microtaskLastHandle$1 += len;
}
const timeOut$1 = {
  /**
   * Returns a sub-module with the async interface providing the provided
   * delay.
   *
   * @memberof timeOut
   * @param {number=} delay Time to wait before calling callbacks in ms
   * @return {!AsyncInterface} An async timeout interface
   */
  after(delay) {
    return {
      run(fn) {
        return window.setTimeout(fn, delay);
      },
      cancel(handle) {
        window.clearTimeout(handle);
      }
    };
  },
  /**
   * Enqueues a function called in the next task.
   *
   * @memberof timeOut
   * @param {!Function} fn Callback to run
   * @param {number=} delay Delay in milliseconds
   * @return {number} Handle used for canceling task
   */
  run(fn, delay) {
    return window.setTimeout(fn, delay);
  },
  /**
   * Cancels a previously enqueued `timeOut` callback.
   *
   * @memberof timeOut
   * @param {number} handle Handle returned from `run` of callback to cancel
   * @return {void}
   */
  cancel(handle) {
    window.clearTimeout(handle);
  }
};
const animationFrame$1 = {
  /**
   * Enqueues a function called at `requestAnimationFrame` timing.
   *
   * @memberof animationFrame
   * @param {function(number):void} fn Callback to run
   * @return {number} Handle used for canceling task
   */
  run(fn) {
    return window.requestAnimationFrame(fn);
  },
  /**
   * Cancels a previously enqueued `animationFrame` callback.
   *
   * @memberof animationFrame
   * @param {number} handle Handle returned from `run` of callback to cancel
   * @return {void}
   */
  cancel(handle) {
    window.cancelAnimationFrame(handle);
  }
};
const idlePeriod$1 = {
  /**
   * Enqueues a function called at `requestIdleCallback` timing.
   *
   * @memberof idlePeriod
   * @param {function(!IdleDeadline):void} fn Callback to run
   * @return {number} Handle used for canceling task
   */
  run(fn) {
    return window.requestIdleCallback ? window.requestIdleCallback(fn) : window.setTimeout(fn, 16);
  },
  /**
   * Cancels a previously enqueued `idlePeriod` callback.
   *
   * @memberof idlePeriod
   * @param {number} handle Handle returned from `run` of callback to cancel
   * @return {void}
   */
  cancel(handle) {
    if (window.cancelIdleCallback) {
      window.cancelIdleCallback(handle);
    } else {
      window.clearTimeout(handle);
    }
  }
};
const microTask$1 = {
  /**
   * Enqueues a function called at microtask timing.
   *
   * @memberof microTask
   * @param {!Function=} callback Callback to run
   * @return {number} Handle used for canceling task
   */
  run(callback) {
    if (!microtaskScheduled$1) {
      microtaskScheduled$1 = true;
      queueMicrotask(() => microtaskFlush$1());
    }
    microtaskCallbacks$1.push(callback);
    const result = microtaskCurrHandle$1;
    microtaskCurrHandle$1 += 1;
    return result;
  },
  /**
   * Cancels a previously enqueued `microTask` callback.
   *
   * @memberof microTask
   * @param {number} handle Handle returned from `run` of callback to cancel
   * @return {void}
   */
  cancel(handle) {
    const idx = handle - microtaskLastHandle$1;
    if (idx >= 0) {
      if (!microtaskCallbacks$1[idx]) {
        throw new Error(`invalid async handle: ${handle}`);
      }
      microtaskCallbacks$1[idx] = null;
    }
  }
};
/**
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/
const debouncerQueue$1 = /* @__PURE__ */ new Set();
let Debouncer$1 = class Debouncer {
  /**
   * Creates a debouncer if no debouncer is passed as a parameter
   * or it cancels an active debouncer otherwise. The following
   * example shows how a debouncer can be called multiple times within a
   * microtask and "debounced" such that the provided callback function is
   * called once. Add this method to a custom element:
   *
   * ```js
   * import {microTask} from '@vaadin/component-base/src/async.js';
   * import {Debouncer} from '@vaadin/component-base/src/debounce.js';
   * // ...
   *
   * _debounceWork() {
   *   this._debounceJob = Debouncer.debounce(this._debounceJob,
   *       microTask, () => this._doWork());
   * }
   * ```
   *
   * If the `_debounceWork` method is called multiple times within the same
   * microtask, the `_doWork` function will be called only once at the next
   * microtask checkpoint.
   *
   * Note: In testing it is often convenient to avoid asynchrony. To accomplish
   * this with a debouncer, you can use `enqueueDebouncer` and
   * `flush`. For example, extend the above example by adding
   * `enqueueDebouncer(this._debounceJob)` at the end of the
   * `_debounceWork` method. Then in a test, call `flush` to ensure
   * the debouncer has completed.
   *
   * @param {Debouncer?} debouncer Debouncer object.
   * @param {!AsyncInterface} asyncModule Object with Async interface
   * @param {function()} callback Callback to run.
   * @return {!Debouncer} Returns a debouncer object.
   */
  static debounce(debouncer, asyncModule, callback) {
    if (debouncer instanceof Debouncer) {
      debouncer._cancelAsync();
    } else {
      debouncer = new Debouncer();
    }
    debouncer.setConfig(asyncModule, callback);
    return debouncer;
  }
  constructor() {
    this._asyncModule = null;
    this._callback = null;
    this._timer = null;
  }
  /**
   * Sets the scheduler; that is, a module with the Async interface,
   * a callback and optional arguments to be passed to the run function
   * from the async module.
   *
   * @param {!AsyncInterface} asyncModule Object with Async interface.
   * @param {function()} callback Callback to run.
   * @return {void}
   */
  setConfig(asyncModule, callback) {
    this._asyncModule = asyncModule;
    this._callback = callback;
    this._timer = this._asyncModule.run(() => {
      this._timer = null;
      debouncerQueue$1.delete(this);
      this._callback();
    });
  }
  /**
   * Cancels an active debouncer and returns a reference to itself.
   *
   * @return {void}
   */
  cancel() {
    if (this.isActive()) {
      this._cancelAsync();
      debouncerQueue$1.delete(this);
    }
  }
  /**
   * Cancels a debouncer's async callback.
   *
   * @return {void}
   */
  _cancelAsync() {
    if (this.isActive()) {
      this._asyncModule.cancel(
        /** @type {number} */
        this._timer
      );
      this._timer = null;
    }
  }
  /**
   * Flushes an active debouncer and returns a reference to itself.
   *
   * @return {void}
   */
  flush() {
    if (this.isActive()) {
      this.cancel();
      this._callback();
    }
  }
  /**
   * Returns true if the debouncer is active.
   *
   * @return {boolean} True if active.
   */
  isActive() {
    return this._timer != null;
  }
};
function enqueueDebouncer$1(debouncer) {
  debouncerQueue$1.add(debouncer);
}
function flushDebouncers$1() {
  const didFlush = Boolean(debouncerQueue$1.size);
  debouncerQueue$1.forEach((debouncer) => {
    try {
      debouncer.flush();
    } catch (e2) {
      setTimeout(() => {
        throw e2;
      });
    }
  });
  return didFlush;
}
const flush$1 = () => {
  let debouncers;
  do {
    debouncers = flushDebouncers$1();
  } while (debouncers);
};
/**
 * @license
 * Copyright (c) 2021 - 2025 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const listenOnce = (elem, type) => {
  return new Promise((resolve) => {
    const listener = () => {
      elem.removeEventListener(type, listener);
      resolve();
    };
    elem.addEventListener(type, listener);
  });
};
class UserTags extends PolylitMixin(LitElement) {
  static get is() {
    return "vaadin-user-tags";
  }
  static get styles() {
    return css`
      :host {
        position: absolute;
      }
    `;
  }
  /** @protected */
  render() {
    return html$1`
      <vaadin-user-tags-overlay
        id="overlay"
        modeless
        .opened="${this.opened}"
        no-vertical-overlap
        @vaadin-overlay-open="${this._onOverlayOpen}"
      ></vaadin-user-tags-overlay>
    `;
  }
  static get properties() {
    return {
      /**
       * True when the field has focus. In this case, the overlay
       * with a list of the user tags needs to be always visible.
       */
      hasFocus: {
        type: Boolean,
        value: false,
        observer: "_hasFocusChanged"
      },
      /**
       * True when the overlay is opened.
       */
      opened: {
        type: Boolean,
        value: false,
        sync: true
      },
      /**
       * True when the overlay is flashing: quickly shown and then hidden
       * once a different user starts to interact with the field.
       */
      flashing: {
        type: Boolean,
        value: false
      },
      /**
       * A target element that the overlay is positioned to.
       */
      target: {
        type: Object,
        observer: "__targetChanged"
      },
      /**
       * A list of users who focused the field.
       */
      users: {
        type: Array,
        value: () => []
      },
      duration: {
        type: Number,
        value: 200
      },
      delay: {
        type: Number,
        value: 2e3
      },
      /** @private */
      __flashQueue: {
        type: Array,
        value: () => []
      },
      /** @private */
      __isTargetVisible: {
        type: Boolean,
        value: false
      }
    };
  }
  constructor() {
    super();
    this.__targetVisibilityObserver = new IntersectionObserver(
      ([entry]) => {
        this.__onTargetVisibilityChange(entry.isIntersecting);
      },
      { threshold: 1 }
    );
  }
  /** @protected */
  get wrapper() {
    return this.$.overlay.querySelector('[part="tags"]');
  }
  /** @protected */
  connectedCallback() {
    super.connectedCallback();
    if (this.target) {
      this.__targetVisibilityObserver.observe(this.target);
    }
  }
  /** @protected */
  disconnectedCallback() {
    super.disconnectedCallback();
    this.opened = false;
    if (this.target) {
      this.__targetVisibilityObserver.unobserve(this.target);
    }
  }
  /** @protected */
  ready() {
    super.ready();
    this.$.overlay.renderer = (root2) => {
      if (!root2.firstChild) {
        const tags = document.createElement("div");
        tags.setAttribute("part", "tags");
        root2.appendChild(tags);
      }
    };
    this.$.overlay.requestContentUpdate();
  }
  /** @private */
  __onTargetVisibilityChange(isVisible) {
    this.__isTargetVisible = isVisible;
    if (isVisible && this.__flashQueue.length > 0 && !this.flashing) {
      this.flashTags(this.__flashQueue.shift());
      return;
    }
    if (isVisible && this.hasFocus) {
      this.opened = true;
      return;
    }
    if (!isVisible && this.opened) {
      this.opened = false;
    }
  }
  /** @private */
  __targetChanged(newTarget, oldTarget) {
    this.$.overlay.positionTarget = newTarget;
    if (oldTarget) {
      this.__targetVisibilityObserver.unobserve(oldTarget);
    }
    if (newTarget) {
      this.__targetVisibilityObserver.observe(newTarget);
    }
  }
  /** @private */
  _hasFocusChanged(hasFocus) {
    if (hasFocus && this.flashing) {
      this.stopFlash();
    }
  }
  createUserTag(user) {
    const tag = document.createElement("vaadin-user-tag");
    tag.name = user.name;
    tag.uid = user.id;
    tag.colorIndex = user.colorIndex;
    return tag;
  }
  getTagForUser(user) {
    return Array.from(this.wrapper.children).find((tag) => tag.uid === user.id);
  }
  getChangedTags(addedUsers, removedUsers) {
    const removed = removedUsers.map((user) => this.getTagForUser(user));
    const added = addedUsers.map((user) => this.getTagForUser(user) || this.createUserTag(user));
    return { added, removed };
  }
  applyTagsStart({ added, removed }) {
    const wrapper = this.wrapper;
    removed.forEach((tag) => {
      if (tag) {
        tag.classList.add("removing");
        tag.classList.remove("show");
      }
    });
    added.forEach((tag) => wrapper.insertBefore(tag, wrapper.firstChild));
  }
  applyTagsEnd({ added, removed }) {
    const wrapper = this.wrapper;
    removed.forEach((tag) => {
      if (tag && tag.parentNode === wrapper) {
        wrapper.removeChild(tag);
      }
    });
    added.forEach((tag) => tag && tag.classList.add("show"));
  }
  setUsers(users) {
    this.requestContentUpdate();
    let addedUsers = [];
    let removedUsers = [];
    const hasNewUsers = Array.isArray(users);
    const hasOldUsers = Array.isArray(this.users);
    if (hasOldUsers) {
      const newUserIds = (users || []).map((user) => user.id);
      removedUsers = this.users.filter((item2) => !newUserIds.includes(item2.id));
    }
    if (hasNewUsers) {
      const oldUserIds = (this.users || []).map((user) => user.id);
      addedUsers = users.filter((item2) => !oldUserIds.includes(item2.id)).reverse();
    }
    if (addedUsers.length === 0 && removedUsers.length === 0) {
      return;
    }
    const changedTags = this.getChangedTags(addedUsers, removedUsers);
    if (this.__flashQueue.length > 0) {
      removedUsers.forEach((user, i2) => {
        if (changedTags.removed[i2] === null) {
          return;
        }
        this.__flashQueue.forEach((tags) => {
          if (tags.some((tag) => tag.uid === user.id)) {
            this.__flashQueue = this.__flashQueue.filter((_, index) => index !== i2);
          }
        });
      });
    }
    if (this.opened && this.hasFocus) {
      this.updateTags(users, changedTags);
    } else if (addedUsers.length > 0 && document.visibilityState !== "hidden") {
      const addedTags = changedTags.added;
      const removedTags = changedTags.removed;
      this.updateTagsSync(users, {
        added: [],
        removed: removedTags
      });
      if (this.flashing || !this.__isTargetVisible) {
        this.__flashQueue = [...this.__flashQueue, addedTags];
      } else {
        this.flashTags(addedTags);
      }
    } else {
      this.updateTagsSync(users, changedTags);
    }
  }
  /** @private */
  _onOverlayOpen() {
    Array.from(this.wrapper.children).forEach((tag) => {
      if (!tag.classList.contains("removing")) {
        tag.classList.add("show");
      }
    });
  }
  flashTags(added) {
    this.flashing = true;
    const wrapper = this.wrapper;
    const hidden = Array.from(wrapper.children);
    hidden.forEach((tag) => {
      tag.style.display = "none";
    });
    added.forEach((tag) => {
      wrapper.insertBefore(tag, wrapper.firstChild);
    });
    this.flashPromise = new Promise((resolve) => {
      listenOnce(this.$.overlay, "vaadin-overlay-open").then(() => {
        this._debounceFlashStart = Debouncer$1.debounce(
          this._debounceFlashStart,
          timeOut$1.after(this.duration + this.delay),
          () => {
            if (!this.hasFocus) {
              added.forEach((tag) => tag.classList.remove("show"));
            }
            this._debounceFlashEnd = Debouncer$1.debounce(this._debounceFlashEnd, timeOut$1.after(this.duration), () => {
              const finishFlash = () => {
                hidden.forEach((tag) => {
                  tag.style.display = "block";
                });
                this.flashing = false;
                resolve();
              };
              if (this.hasFocus) {
                finishFlash();
              } else {
                listenOnce(this.$.overlay, "animationend").then(() => {
                  finishFlash();
                });
                this.opened = false;
              }
            });
          }
        );
      });
    }).then(() => {
      if (this.__flashQueue.length > 0) {
        const tags = this.__flashQueue[0];
        this.__flashQueue = [...this.__flashQueue].slice(1);
        this.flashTags(tags);
      }
    });
    this.opened = true;
  }
  stopFlash() {
    if (this._debounceFlashStart) {
      this._debounceFlashStart.flush();
    }
    if (this._debounceFlashEnd) {
      this._debounceFlashEnd.flush();
    }
    this.$.overlay._flushAnimation("closing");
  }
  updateTags(users, changed) {
    this.applyTagsStart(changed);
    this._debounceRender = Debouncer$1.debounce(this._debounceRender, timeOut$1.after(this.duration), () => {
      this.users = users;
      this.applyTagsEnd(changed);
      if (users.length === 0 && this.opened) {
        this.opened = false;
      }
    });
  }
  updateTagsSync(users, changed) {
    this.applyTagsStart(changed);
    this.users = users;
    this.applyTagsEnd(changed);
  }
  show() {
    this.hasFocus = true;
    if (this.__isTargetVisible) {
      this.opened = true;
    }
  }
  hide() {
    this.hasFocus = false;
    this.opened = false;
  }
  requestContentUpdate() {
    if (this._debounceRender && this._debounceRender.isActive()) {
      this._debounceRender.flush();
    }
  }
}
defineCustomElement(UserTags);
/**
 * @license
 * Copyright (c) 2021 - 2025 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
registerStyles$1("vaadin-field-outline", fieldOutlineStyles, { moduleId: "vaadin-field-outline-styles" });
class FieldOutline extends ThemableMixin(DirMixin(PolylitMixin(LitElement))) {
  static get is() {
    return "vaadin-field-outline";
  }
  static get properties() {
    return {
      /**
       * A user who last interacted with the field.
       */
      user: {
        type: Object,
        value: null,
        observer: "_userChanged",
        sync: true
      }
    };
  }
  /** @protected */
  render() {
    return html$1``;
  }
  /** @protected */
  ready() {
    super.ready();
    this.setAttribute("part", "outline");
    this._field = this.getRootNode().host;
  }
  /** @private */
  _userChanged(user) {
    this.toggleAttribute("has-active-user", Boolean(user));
    const value = user ? `var(--vaadin-user-color-${user.colorIndex})` : "transparent";
    const prop = "--_active-user-color";
    this.style.setProperty(prop, value);
    if (this._field) {
      this._field.style.setProperty(prop, value);
    }
  }
}
defineCustomElement(FieldOutline);
/**
 * @license
 * Copyright (c) 2022 - 2025 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const region = document.createElement("div");
region.style.position = "fixed";
region.style.clip = "rect(0px, 0px, 0px, 0px)";
region.setAttribute("aria-live", "polite");
document.body.appendChild(region);
let alertDebouncer;
function announce(text, options = {}) {
  const mode = options.mode || "polite";
  const timeout = options.timeout === void 0 ? 150 : options.timeout;
  if (mode === "alert") {
    region.removeAttribute("aria-live");
    region.removeAttribute("role");
    alertDebouncer = Debouncer$1.debounce(alertDebouncer, animationFrame$1, () => {
      region.setAttribute("role", "alert");
    });
  } else {
    if (alertDebouncer) {
      alertDebouncer.cancel();
    }
    region.removeAttribute("role");
    region.setAttribute("aria-live", mode);
  }
  region.textContent = "";
  setTimeout(() => {
    region.textContent = text;
  }, timeout);
}
/**
 * @license
 * Copyright (c) 2021 - 2025 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const getOutlineTarget = (element, tagName) => {
  switch (tagName) {
    /* c8 ignore next */
    case "vaadin-big-decimal-field":
    case "vaadin-combo-box":
    case "vaadin-date-picker":
    case "vaadin-email-field":
    case "vaadin-integer-field":
    case "vaadin-number-field":
    case "vaadin-password-field":
    case "vaadin-select":
    case "vaadin-text-area":
    case "vaadin-text-field":
    case "vaadin-time-picker":
      return element.shadowRoot.querySelector('[part="input-field"]');
    /* c8 ignore next */
    case "vaadin-checkbox":
      return element.shadowRoot.querySelector('[part="checkbox"]');
    /* c8 ignore next */
    case "vaadin-radio-button":
      return element.shadowRoot.querySelector('[part="radio"]');
    /* c8 ignore next */
    default:
      return element;
  }
};
const fields = /* @__PURE__ */ new WeakMap();
const initOutline = (field) => {
  if (!fields.has(field)) {
    const tagName = field.tagName.toLowerCase();
    const target = getOutlineTarget(field, tagName);
    target.style.position = "relative";
    if (tagName.endsWith("text-area")) {
      target.style.overflow = "visible";
    }
    const style = document.createElement("style");
    style.textContent = `
      :host([focused]) [part="outline"] {
        opacity: calc(1 - var(--lumo-input-field-pointer-focus-visible, 0));
      }

      :host([active]) [part="outline"],
      :host([focus-ring]) [part="outline"] {
        display: none;
      }
    `;
    field.shadowRoot.appendChild(style);
    const outline = document.createElement("vaadin-field-outline");
    (target === field ? field.shadowRoot : target).appendChild(outline);
    outline.setAttribute("context", tagName);
    fields.set(field, { root: field, target, outline });
  }
  return fields.get(field);
};
/**
 * @license
 * Copyright (c) 2021 - 2025 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
class ComponentObserver {
  constructor(component) {
    this.component = component;
    this.initTags(component);
  }
  getFields() {
    return [this.component];
  }
  getFieldIndex(field) {
    return this.getFields().indexOf(field);
  }
  getFocusTarget(_event) {
    return this.component;
  }
  initTags(component) {
    const tags = document.createElement("vaadin-user-tags");
    component.shadowRoot.appendChild(tags);
    tags.target = component;
    this._tags = tags;
    component.addEventListener("mouseenter", (event) => {
      if (event.relatedTarget === this._tags.$.overlay) {
        return;
      }
      this._mouse = true;
      this._mouseDebouncer = Debouncer$1.debounce(this._mouseDebouncer, timeOut$1.after(200), () => {
        if (this._mouse) {
          this._tags.show();
        }
      });
    });
    component.addEventListener("mouseleave", (event) => {
      if (event.relatedTarget === this._tags.$.overlay) {
        return;
      }
      this._mouse = false;
      if (!this._hasFocus) {
        this._tags.hide();
      }
    });
    component.addEventListener("vaadin-highlight-show", (_event) => {
      this._hasFocus = true;
      if (this._debouncer && this._debouncer.isActive()) {
        this._debouncer.cancel();
      } else {
        this._tags.show();
      }
    });
    component.addEventListener("vaadin-highlight-hide", (_event) => {
      this._hasFocus = false;
      if (!this._mouse) {
        this._debouncer = Debouncer$1.debounce(this._debouncer, timeOut$1.after(1), () => {
          this._tags.hide();
        });
      }
    });
    this._tags.$.overlay.addEventListener("mouseleave", (event) => {
      if (event.relatedTarget === component) {
        return;
      }
      this._mouse = false;
      if (!component.hasAttribute("focused")) {
        this._tags.hide();
      }
    });
  }
  setOutlines(users) {
    const fields2 = this.getFields();
    fields2.forEach((field, idx) => {
      const { outline } = initOutline(field);
      const index = fields2.length === 1 ? 0 : users.map((user) => user.fieldIndex).indexOf(idx);
      outline.user = users[index];
    });
  }
  showOutline(field) {
    this.fire("show", field);
  }
  hideOutline(field) {
    this.fire("hide", field);
  }
  fire(action, field) {
    this.component.dispatchEvent(
      new CustomEvent(`vaadin-highlight-${action}`, {
        bubbles: true,
        composed: true,
        detail: { fieldIndex: this.getFieldIndex(field) }
      })
    );
  }
  redraw(users) {
    this._tags.setUsers(users);
    this.setOutlines(users);
  }
}
/**
 * @license
 * Copyright (c) 2021 - 2025 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
class FieldObserver extends ComponentObserver {
  constructor(field) {
    super(field);
    this.addListeners(field);
  }
  addListeners(field) {
    field.addEventListener("focusin", (event) => this.onFocusIn(event));
    field.addEventListener("focusout", (event) => this.onFocusOut(event));
  }
  onFocusIn(event) {
    const target = this.getFocusTarget(event);
    this.showOutline(target);
  }
  onFocusOut(event) {
    const target = this.getFocusTarget(event);
    this.hideOutline(target);
  }
}
/**
 * @license
 * Copyright (c) 2021 - 2025 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
class CheckboxGroupObserver extends FieldObserver {
  getFields() {
    return this.component.__checkboxes;
  }
  getFocusTarget(event) {
    const fields2 = this.getFields();
    return Array.from(event.composedPath()).find((node) => fields2.includes(node));
  }
}
/**
 * @license
 * Copyright (c) 2021 - 2025 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
class DatePickerObserver extends ComponentObserver {
  constructor(datePicker2) {
    super(datePicker2);
    this.datePicker = datePicker2;
    this.blurWhileOpened = false;
    this.addListeners(datePicker2);
  }
  addListeners(datePicker2) {
    this.overlay = datePicker2.$.overlay;
    datePicker2.addEventListener("opened-changed", (event) => this.onOpenedChanged(event));
    this.overlay.addEventListener("focusout", (event) => this.onOverlayFocusOut(event));
    datePicker2.addEventListener("focusin", (event) => this.onFocusIn(event));
    datePicker2.addEventListener("focusout", (event) => this.onFocusOut(event));
  }
  isEventInOverlay(node) {
    return this.datePicker._overlayContent && this.datePicker._overlayContent.contains(node);
  }
  isFullscreen() {
    const datePicker2 = this.datePicker;
    return datePicker2._noInput && !isKeyboardActive();
  }
  onFocusIn(event) {
    if (this.isEventInOverlay(event.relatedTarget)) {
      return;
    }
    if (this.blurWhileOpened) {
      this.blurWhileOpened = false;
      return;
    }
    this.showOutline(this.datePicker);
  }
  onFocusOut(event) {
    if (this.isEventInOverlay(event.relatedTarget)) ;
    else if (!this.datePicker.opened) {
      this.hideOutline(this.datePicker);
    } else {
      this.blurWhileOpened = true;
    }
  }
  onOverlayFocusOut(event) {
    if (!this.datePicker.contains(event.relatedTarget)) {
      this.blurWhileOpened = true;
    }
  }
  onOpenedChanged(event) {
    if (event.detail.value === true && this.isFullscreen()) {
      this.showOutline(this.datePicker);
    }
    if (event.detail.value === false && this.blurWhileOpened) {
      this.blurWhileOpened = false;
      this.hideOutline(this.datePicker);
    }
  }
}
/**
 * @license
 * Copyright (c) 2021 - 2025 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
class DateObserver extends DatePickerObserver {
  constructor(datePicker2, host) {
    super(datePicker2);
    this.component = host;
  }
  getFieldIndex() {
    return 0;
  }
}
class TimeObserver extends FieldObserver {
  constructor(timePicker2, host) {
    super(timePicker2);
    this.component = host;
    this.timePicker = timePicker2;
  }
  getFocusTarget(_event) {
    return this.timePicker;
  }
  getFieldIndex() {
    return 1;
  }
}
class DateTimePickerObserver extends ComponentObserver {
  constructor(picker) {
    super(picker);
    const [datePicker2, timePicker2] = this.getFields();
    this.dateObserver = new DateObserver(datePicker2, picker);
    this.timeObserver = new TimeObserver(timePicker2, picker);
  }
  getFields() {
    return [this.component.querySelector("[slot=date-picker]"), this.component.querySelector("[slot=time-picker]")];
  }
}
/**
 * @license
 * Copyright (c) 2021 - 2025 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
class ListBoxObserver extends FieldObserver {
  getFields() {
    return this.component.items || [];
  }
  getFocusTarget(event) {
    const fields2 = this.getFields();
    return Array.from(event.composedPath()).find((node) => fields2.includes(node));
  }
}
/**
 * @license
 * Copyright (c) 2021 - 2025 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
class RadioGroupObserver extends FieldObserver {
  getFields() {
    return this.component.__radioButtons;
  }
  getFocusTarget(event) {
    const fields2 = this.getFields();
    return Array.from(event.composedPath()).find((node) => fields2.includes(node));
  }
}
/**
 * @license
 * Copyright (c) 2021 - 2025 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
class SelectObserver extends FieldObserver {
  constructor(select2) {
    super(select2);
    this.blurWhileOpened = false;
    this.overlay = select2._overlayElement;
  }
  addListeners(select2) {
    super.addListeners(select2);
    select2.addEventListener("opened-changed", (event) => {
      if (select2._phone && event.detail.value === false) {
        this.hideOutline(select2);
      }
    });
  }
  onFocusIn(event) {
    if (this.overlay.contains(event.relatedTarget)) {
      return;
    }
    if (!this.component._phone && this.overlay.hasAttribute("closing")) {
      return;
    }
    super.onFocusIn(event);
  }
  onFocusOut(event) {
    if (this.overlay.contains(event.relatedTarget)) {
      return;
    }
    super.onFocusOut(event);
  }
}
/**
 * @license
 * Copyright (c) 2021 - 2025 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const initFieldObserver = (field) => {
  let result;
  switch (field.tagName.toLowerCase()) {
    /* c8 ignore next */
    case "vaadin-date-picker":
      result = new DatePickerObserver(field);
      break;
    /* c8 ignore next */
    case "vaadin-date-time-picker":
      result = new DateTimePickerObserver(field);
      break;
    /* c8 ignore next */
    case "vaadin-select":
      result = new SelectObserver(field);
      break;
    /* c8 ignore next 2 */
    case "vaadin-checkbox-group":
      result = new CheckboxGroupObserver(field);
      break;
    case "vaadin-radio-group":
      result = new RadioGroupObserver(field);
      break;
    case "vaadin-list-box":
      result = new ListBoxObserver(field);
      break;
    default:
      result = new FieldObserver(field);
  }
  return result;
};
class FieldHighlighterController {
  constructor(host) {
    this.host = host;
    this.user = null;
    this.users = [];
  }
  get user() {
    return this._user;
  }
  set user(user) {
    this._user = user;
    if (user) {
      const msg = `${user.name} started editing`;
      const { label } = this.host;
      announce(label ? `${msg} ${label}` : msg);
    }
  }
  hostConnected() {
    this.redraw();
  }
  addUser(user) {
    if (user) {
      this.users.push(user);
      this.redraw();
      this.user = user;
    }
  }
  setUsers(users) {
    if (Array.isArray(users)) {
      this.users = users;
      this.redraw();
      this.user = users[users.length - 1] || null;
    }
  }
  removeUser(user) {
    if (user && user.id !== void 0) {
      let index;
      for (let i2 = 0; i2 < this.users.length; i2++) {
        if (this.users[i2].id === user.id) {
          index = i2;
          break;
        }
      }
      if (index !== void 0) {
        this.users.splice(index, 1);
        this.redraw();
        if (this.users.length > 0) {
          this.user = this.users[this.users.length - 1];
        } else {
          this.user = null;
        }
      }
    }
  }
  redraw() {
    this.observer.redraw([...this.users].reverse());
  }
}
class FieldHighlighter extends HTMLElement {
  static get is() {
    return "vaadin-field-highlighter";
  }
  static init(field) {
    if (!field._highlighterController) {
      const instance = new FieldHighlighterController(field);
      field.setAttribute("has-highlighter", "");
      instance.observer = initFieldObserver(field);
      field.addController(instance);
      field._highlighterController = instance;
    }
    return field._highlighterController;
  }
  static addUser(field, user) {
    this.init(field).addUser(user);
  }
  static removeUser(field, user) {
    this.init(field).removeUser(user);
  }
  static setUsers(field, users) {
    this.init(field).setUsers(users);
  }
}
defineCustomElement(FieldHighlighter);
/**
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/
let CSS_URL_RX = /(url\()([^)]*)(\))/g;
let ABS_URL = /(^\/[^\/])|(^#)|(^[\w-\d]*:)/;
let workingURL;
let resolveDoc;
function resolveUrl(url, baseURI) {
  if (url && ABS_URL.test(url)) {
    return url;
  }
  if (url === "//") {
    return url;
  }
  if (workingURL === void 0) {
    workingURL = false;
    try {
      const u2 = new URL("b", "http://a");
      u2.pathname = "c%20d";
      workingURL = u2.href === "http://a/c%20d";
    } catch (e2) {
    }
  }
  if (!baseURI) {
    baseURI = document.baseURI || window.location.href;
  }
  if (workingURL) {
    try {
      return new URL(url, baseURI).href;
    } catch (e2) {
      return url;
    }
  }
  if (!resolveDoc) {
    resolveDoc = document.implementation.createHTMLDocument("temp");
    resolveDoc.base = resolveDoc.createElement("base");
    resolveDoc.head.appendChild(resolveDoc.base);
    resolveDoc.anchor = resolveDoc.createElement("a");
    resolveDoc.body.appendChild(resolveDoc.anchor);
  }
  resolveDoc.base.href = baseURI;
  resolveDoc.anchor.href = url;
  return resolveDoc.anchor.href || url;
}
function resolveCss(cssText, baseURI) {
  return cssText.replace(CSS_URL_RX, function(m3, pre, url, post) {
    return pre + "'" + resolveUrl(url.replace(/["']/g, ""), baseURI) + "'" + post;
  });
}
function pathFromUrl(url) {
  return url.substring(0, url.lastIndexOf("/") + 1);
}
/**
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/
const useShadow = !window.ShadyDOM || !window.ShadyDOM.inUse;
Boolean(!window.ShadyCSS || window.ShadyCSS.nativeCss);
const supportsAdoptingStyleSheets = useShadow && "adoptedStyleSheets" in Document.prototype && "replaceSync" in CSSStyleSheet.prototype && // Since spec may change, feature detect exact API we need
(() => {
  try {
    const sheet = new CSSStyleSheet();
    sheet.replaceSync("");
    const host = document.createElement("div");
    host.attachShadow({ mode: "open" });
    host.shadowRoot.adoptedStyleSheets = [sheet];
    return host.shadowRoot.adoptedStyleSheets[0] === sheet;
  } catch (e2) {
    return false;
  }
})();
let rootPath = window.Polymer && window.Polymer.rootPath || pathFromUrl(document.baseURI || window.location.href);
let sanitizeDOMValue = window.Polymer && window.Polymer.sanitizeDOMValue || void 0;
window.Polymer && window.Polymer.setPassiveTouchGestures || false;
let strictTemplatePolicy = window.Polymer && window.Polymer.strictTemplatePolicy || false;
let allowTemplateFromDomModule = window.Polymer && window.Polymer.allowTemplateFromDomModule || false;
let legacyOptimizations = window.Polymer && window.Polymer.legacyOptimizations || false;
let legacyWarnings = window.Polymer && window.Polymer.legacyWarnings || false;
let syncInitialRender = window.Polymer && window.Polymer.syncInitialRender || false;
let legacyUndefined = window.Polymer && window.Polymer.legacyUndefined || false;
let orderedComputed = window.Polymer && window.Polymer.orderedComputed || false;
let removeNestedTemplates = window.Polymer && window.Polymer.removeNestedTemplates || false;
let fastDomIf = window.Polymer && window.Polymer.fastDomIf || false;
let suppressTemplateNotifications = window.Polymer && window.Polymer.suppressTemplateNotifications || false;
window.Polymer && window.Polymer.legacyNoObservedAttributes || false;
let useAdoptedStyleSheetsWithBuiltCSS = window.Polymer && window.Polymer.useAdoptedStyleSheetsWithBuiltCSS || false;
/**
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/
let modules = {};
let lcModules = {};
function setModule(id, module2) {
  modules[id] = lcModules[id.toLowerCase()] = module2;
}
function findModule(id) {
  return modules[id] || lcModules[id.toLowerCase()];
}
function styleOutsideTemplateCheck(inst) {
  if (inst.querySelector("style")) {
    console.warn("dom-module %s has style outside template", inst.id);
  }
}
class DomModule extends HTMLElement {
  /** @override */
  static get observedAttributes() {
    return ["id"];
  }
  /**
   * Retrieves the element specified by the css `selector` in the module
   * registered by `id`. For example, this.import('foo', 'img');
   * @param {string} id The id of the dom-module in which to search.
   * @param {string=} selector The css selector by which to find the element.
   * @return {Element} Returns the element which matches `selector` in the
   * module registered at the specified `id`.
   *
   * @export
   * @nocollapse Referred to indirectly in style-gather.js
   */
  static import(id, selector) {
    if (id) {
      let m3 = findModule(id);
      if (m3 && selector) {
        return m3.querySelector(selector);
      }
      return m3;
    }
    return null;
  }
  /* eslint-disable no-unused-vars */
  /**
   * @param {string} name Name of attribute.
   * @param {?string} old Old value of attribute.
   * @param {?string} value Current value of attribute.
   * @param {?string} namespace Attribute namespace.
   * @return {void}
   * @override
   */
  attributeChangedCallback(name, old, value, namespace) {
    if (old !== value) {
      this.register();
    }
  }
  /* eslint-enable no-unused-args */
  /**
   * The absolute URL of the original location of this `dom-module`.
   *
   * This value will differ from this element's `ownerDocument` in the
   * following ways:
   * - Takes into account any `assetpath` attribute added during bundling
   *   to indicate the original location relative to the bundled location
   * - Uses the HTMLImports polyfill's `importForElement` API to ensure
   *   the path is relative to the import document's location since
   *   `ownerDocument` is not currently polyfilled
   */
  get assetpath() {
    if (!this.__assetpath) {
      const owner = window.HTMLImports && HTMLImports.importForElement ? HTMLImports.importForElement(this) || document : this.ownerDocument;
      const url = resolveUrl(
        this.getAttribute("assetpath") || "",
        owner.baseURI
      );
      this.__assetpath = pathFromUrl(url);
    }
    return this.__assetpath;
  }
  /**
   * Registers the dom-module at a given id. This method should only be called
   * when a dom-module is imperatively created. For
   * example, `document.createElement('dom-module').register('foo')`.
   * @param {string=} id The id at which to register the dom-module.
   * @return {void}
   */
  register(id) {
    id = id || this.id;
    if (id) {
      if (strictTemplatePolicy && findModule(id) !== void 0) {
        setModule(id, null);
        throw new Error(`strictTemplatePolicy: dom-module ${id} re-registered`);
      }
      this.id = id;
      setModule(id, this);
      styleOutsideTemplateCheck(this);
    }
  }
}
DomModule.prototype["modules"] = modules;
customElements.define("dom-module", DomModule);
/**
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/
const MODULE_STYLE_LINK_SELECTOR = "link[rel=import][type~=css]";
const INCLUDE_ATTR = "include";
const SHADY_UNSCOPED_ATTR = "shady-unscoped";
function importModule(moduleId) {
  return (
    /** @type {?DomModule} */
    DomModule.import(moduleId)
  );
}
function styleForImport(importDoc) {
  let container = importDoc.body ? importDoc.body : importDoc;
  const importCss = resolveCss(
    container.textContent,
    importDoc.baseURI
  );
  const style = document.createElement("style");
  style.textContent = importCss;
  return style;
}
function stylesFromModules(moduleIds) {
  const modules2 = moduleIds.trim().split(/\s+/);
  const styles2 = [];
  for (let i2 = 0; i2 < modules2.length; i2++) {
    styles2.push(...stylesFromModule(modules2[i2]));
  }
  return styles2;
}
function stylesFromModule(moduleId) {
  const m3 = importModule(moduleId);
  if (!m3) {
    console.warn("Could not find style data in module named", moduleId);
    return [];
  }
  if (m3._styles === void 0) {
    const styles2 = [];
    styles2.push(..._stylesFromModuleImports(m3));
    const template2 = (
      /** @type {?HTMLTemplateElement} */
      m3.querySelector("template")
    );
    if (template2) {
      styles2.push(...stylesFromTemplate(
        template2,
        /** @type {templateWithAssetPath} */
        m3.assetpath
      ));
    }
    m3._styles = styles2;
  }
  return m3._styles;
}
function stylesFromTemplate(template2, baseURI) {
  if (!template2._styles) {
    const styles2 = [];
    const e$ = template2.content.querySelectorAll("style");
    for (let i2 = 0; i2 < e$.length; i2++) {
      let e2 = e$[i2];
      let include = e2.getAttribute(INCLUDE_ATTR);
      if (include) {
        styles2.push(...stylesFromModules(include).filter(function(item2, index, self2) {
          return self2.indexOf(item2) === index;
        }));
      }
      if (baseURI) {
        e2.textContent = resolveCss(
          e2.textContent,
          /** @type {string} */
          baseURI
        );
      }
      styles2.push(e2);
    }
    template2._styles = styles2;
  }
  return template2._styles;
}
function stylesFromModuleImports(moduleId) {
  let m3 = importModule(moduleId);
  return m3 ? _stylesFromModuleImports(m3) : [];
}
function _stylesFromModuleImports(module2) {
  const styles2 = [];
  const p$ = module2.querySelectorAll(MODULE_STYLE_LINK_SELECTOR);
  for (let i2 = 0; i2 < p$.length; i2++) {
    let p = p$[i2];
    if (p.import) {
      const importDoc = p.import;
      const unscoped = p.hasAttribute(SHADY_UNSCOPED_ATTR);
      if (unscoped && !importDoc._unscopedStyle) {
        const style = styleForImport(importDoc);
        style.setAttribute(SHADY_UNSCOPED_ATTR, "");
        importDoc._unscopedStyle = style;
      } else if (!importDoc._style) {
        importDoc._style = styleForImport(importDoc);
      }
      styles2.push(unscoped ? importDoc._unscopedStyle : importDoc._style);
    }
  }
  return styles2;
}
/**
 * @license
 * Copyright (c) 2021 - 2025 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
let moduleIdIndex = 0;
function registerStyles(themeFor, styles2 = [], options = {}) {
  const themeId = options.moduleId || `custom-style-module-${moduleIdIndex}`;
  moduleIdIndex += 1;
  const module2 = document.createElement("dom-module");
  if (themeFor) {
    module2.setAttribute("theme-for", themeFor);
  }
  const includeStylesToTemplate = !!(styles2.length && options.moduleId);
  const moduleIncludes = [].concat(options.include || []);
  if (moduleIncludes.length === 0) {
    module2.__allStyles = styles2;
  } else if (!includeStylesToTemplate) {
    module2.__partialStyles = styles2;
  }
  module2.innerHTML = `
    <template>
      ${moduleIncludes.map((include) => `<style include=${include}></style>`)}
      ${includeStylesToTemplate ? `<style>${styles2.map((style) => style.cssText).join("\n")}</style>` : ""}
    </template>
  `;
  module2.register(themeId);
}
function getModuleStyles(module2) {
  return stylesFromTemplate(module2.querySelector("template")).map((styleElement) => {
    return unsafeCSS(styleElement.textContent);
  });
}
function getAllThemes() {
  const domModule = DomModule;
  const modules2 = domModule.prototype.modules;
  return Object.keys(modules2).map((moduleId) => {
    const module2 = modules2[moduleId];
    const themeFor = module2.getAttribute("theme-for");
    if (!module2.__allStyles) {
      module2.__allStyles = getModuleStyles(module2).concat(module2.__partialStyles || []);
    }
    return {
      themeFor,
      moduleId,
      styles: module2.__allStyles
    };
  });
}
if (!window.Vaadin) {
  window.Vaadin = {};
}
window.Vaadin.styleModules = {
  getAllThemes,
  registerStyles
};
if (themeRegistry && themeRegistry.length > 0) {
  themeRegistry.forEach((theme) => {
    registerStyles(theme.themeFor, theme.styles, {
      moduleId: theme.moduleId,
      include: theme.include
    });
  });
  themeRegistry.length = 0;
}
/**
 * @license
 * Copyright (c) 2017 - 2025 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const fontIcons = css`
  @font-face {
    font-family: 'lumo-icons';
    src: url(data:application/font-woff;charset=utf-8;base64,d09GRgABAAAAABHAAAsAAAAAI6AAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAABHU1VCAAABCAAAADsAAABUIIslek9TLzIAAAFEAAAAQwAAAFZAIUuNY21hcAAAAYgAAAD+AAADymne8hxnbHlmAAACiAAAC+gAABioIzlOlWhlYWQAAA5wAAAAMAAAADZa/6SsaGhlYQAADqAAAAAdAAAAJAbpA4BobXR4AAAOwAAAABAAAAC0q+AAAGxvY2EAAA7QAAAAXAAAAFyF7o1GbWF4cAAADywAAAAfAAAAIAFMAXBuYW1lAAAPTAAAATEAAAIuUUJZCHBvc3QAABCAAAABPQAAAgfdkltveJxjYGRgYOBiMGCwY2BycfMJYeDLSSzJY5BiYGGAAJA8MpsxJzM9kYEDxgPKsYBpDiBmg4gCACY7BUgAeJxjYGS+xDiBgZWBgamKaQ8DA0MPhGZ8wGDIyAQUZWBlZsAKAtJcUxgcXjG+0mEO+p/FEMUcxDANKMwIkgMABvgMMAB4nO3SV26EMABF0UsZpjG9d6Y3FpgF5StLYxMTP16WEUvHV1gGIQzQAJKgDFKIfojQ+A6rUb2e0KnXU77qPanWq/LzCXOkOVyn9RyHvWl4YkaTFu1wX5ecHn0GDBkxZsKUGXMWLFmxZsOWHXsOFBw5cebClRt3Hjx58dZ7RRn/I9cUF39Xpb691acRG2piOtUqNZ1P1TCdeJUZatNQW4baNtSO6U+ouoaam96u6hlq31AHhjo01JGhjg11YqhTQ50Z6txQF4a6NNSVoa4NdWOoW0PdGereUA+GWhjq0VBPhno21IuhXg31Zqh3Q30Y6tNQX4b6NtTSKH8BOIRpQQAAeJy1WH1sW9UVv+fG9vPz+7Bf/N6zHcd2/J04jbP6s0lap4kDpB9JWzUUCqxNgaHxpTI6hNhUNLVr17HSISb2D2iAJrWb6FTWahNQdQxRvmHamAR0qibE1E18CG3QaVNFvJ17n+3YIf1AiMQ679x77j3v3HPPPed3H7ER/OsYpw8TmQRIiuQJ8RZK+WjO1B3xaCzla21orY10a+OQ6aHTHtP0zB31mBs1GZ6RNU2uXc7oPL+xdRS9R9X1oK4fVfijdsBqvqF6vd1eLzPrYrYZ57WteF7bPDIc5+ZcJnta+S9i2Vfhs4MaMwZNQmO0Vv7gF/MZcNsCcJp4sJFSwYyAmRuFCmTBDRBUkwGqnlViyjmVBpLqaXhNpt0J5V1JOqMkuqn8WkMHvZX+iOlImiqkBiFVYDrCqINulmkwKb8ry2fkZBBn7FcTlk4ZdfpRZ9MOesLSAakKt0N3g4p2jAL8eIEOOqom/U0lgQRXUl8LtXM7HFkojUIpF0ErVBhcZC1vtyjtpsqr83a8RVcSH+ool8LgcIMjNohmVCACuDs506BdO6WIQeXjUsh1XKZGRNpp9piv3+Givoh00OU6KEV81HUHTLtN093Q+YGlE3wLHWRtMNy9XWqdLm2HKbaNsGzhu+41eswFOjE6WKSk2/1Wpt+qHeM6phbohmVmj3GvpdcVkiy9zbXfzHVqKuDB0IR2P6ZpF+D7dy6YC/9svGmBE5hKB9+X2+hh4iYRMkhGyTqyFc9APmeGQHf043tWQKHkizmwaY5AroTNVJzJDc2SFzUu92kOLsdmKu77vByb8/IjtxmhkMFISRBFISO4XMLJlj4XgGuRXtaHw2FLyHifdSOpisIhJjgkiPBAyJh7lfXTkhEadwk1mUngrOC6MazX7mASeEAPV1FyjEumBOaEDu4DP/ogRDKkiLEV1woVyMeLLKJCEM+FwdCwL4XLcRgdbfkhbzS8BNvXDKzNQiAWgOzagTXF1Eyq+Ci6/TPm/JrNY/59p1epKN4jQFGe0fx+LTMwNVCrAU2VSqnaKYzIiGmWe2Rvp9KDJhncrjLaFce8VCUbyQ1kB9lNfkJ+To6R58mfyd/Ip9ABXohDHqqwEW7A2Mij1ehntLu+h8xMtocjUJcYwoLdtYafv/1Vjy8vjLaLtBfOt3/B931Rexa24e5zstgnyqvZHs69zuhq3vFgRpQVJyN7FuE++RLSeW4xMi+t6Zeo5sIK6S5dlGVRD2hWnGoB3j7OV3lesvNLic8tOnLRSRfRdOna63VJp/1WbYs5dFZjy1AqpGICQEWKmNI+CZNoVTJ7pNop+IZkRrBHgnEmqr3TrEsfw1Gi8LqE+S1aV0SNNwXVVVvuUoU3ld6TLwmditIpvKTU50zSzWwO1h0rL8awnulwTXMYrGDT4aQ1fb4GPkyv5vMEh5Vec6yw0AMXnfcx1l/rfVZaKLDi0W4j/HfeyGZuHOf1IUGW1udizU2leXY0OmLpVDpVKJfKpZzPRKHgEBzpXAUKWYipoIeBdl3JfLZVBizEqWun1i4ZGFiyduq3DebayXsmJ+95gBG4+Urm1a2SdpKV57lP2wZyZqI+FAlfUtO+NCmgdWhMOS1gDY+jHWnBhwjBQLMEXxmLbx6t9JXTWDLtsSxgisfErqvQMbbBoywZmeyLeWe8OWNydFDxzMx4lMGRtX0xN3YFJkeW+O0bascGNwwObtjCCOzrzAVWjSwN2K9cpyn9o5cZOXMmkAuM85EbNHnJyHhfLLCnPhxJYw9eoIMkyC3l+4ZuY5ig7lW2oYUynDgg+Xrk+++Xe3zSgRYetnyuy+KbfjiB+GAAtZ8HHXmtijZfFFgrujhmOs2qkXvuSV6WqA1WLYqhPHOfsa26rklKFqbAGL2dOIlGurB6LWFVFd/KoBBaYTFYVBs93hZRFlrG5Ex4NVFIJguJVvqnBW2kNNvFGx90YUcSEvyZSMDeZjc0xYlEYy8+hHcWx9YrZOaPPyCGepP5Q34aXnGBr8d1QhSf4yjtiebZqNJfEYl4SY6dDRb8WSguLZW9ZQtBpoW4hX0QMyB2KmsYcOh8HMQxBn288oZ6BXV0GOq/ClKsC6T8g9X3OFKZNkJrYkOx2lEk+KNDy953+wGHXuGGzhGZ+uLK8FVrQkbtKBv+9EztU2sgTCNpvXMdJjqJ4tkdw+x00dPKkZ1QR254x7GQoFmvfakSnL3gCc5nREly2mN2pyTLMacMipNT7YInGU7JzlN2p9N+yinXTirOKEvPUafSWMNDmCf9pIQYaG19DSxKGqvAQ+xg60iabEm5MheUU2n+HxO4TDDbjnw6xxK8QzfhbHXq8pWVqanKysun9s6ztdt7sivGqruqYyuyPS6Hw9XehGt6q+l0dT0jvaFMZjiTuTHo7+vdtHJTb58/2ML+IxHt9/n9vv5owiWKrrbWD+sakKxhKoYzxF5f7y9INxki42QNuYrVFDPfvqxyY83xWNMV+ZxPSMWb62W+wPSCJwkDDl1WZOGW84nAEo4A7HjB/uWmOdayRFnKjazi668u/ajJlUd87aPk048Crlu4j1Oh9gxdL3Z1inNPIt2xvKNlsU4hn54Z5Y6YbTDu9hHOvkcFAb35fU6hNovKOrtQmcvbNV9/Ntfv5xf4atDWOOTX6CSHZ08xujhPs51+f9zvf1YLIGoPPKvxVh0TSLAXzzUBFiXs7GJVB7vH5/PAXznd4+vx4a95h3qI/oYIpIdMkA1kC7kVLS3GhWI5bwj1fIaVKG/Ei5gXWOjhtcJbzFthaMQrwIcIRj0ppvO6yV95icu9j/YPDNySWp7w+kOr95R1RfGpfVlDVhS/2geJ5Umv2mn0rkxBvzvgdisndJXaVF1X5z5jdHGe2n/QnYo8+b2uaMivhowgjYcLnVqnrEpQezsieyVZ6ooETbdJO6ip+cORLpes6BL82/qg8VHbo45B/vch/YQeJX28QvEANR3sQhxh+TcMCEd4l8BKF7uID7KM05tRYlIHHXY63YIi2fXQyj5XSBbcMeewKLpttkJ2Syz33YJfDdJdSYkqHbYb3VHRJgTV8c0TAy67YHeK7htwOKWax5co7Do8Pfh1tKdx1g5j9o6TZeQyMo27FuW3vbYsbY/Op3AG06DMKionRlpgHzCEeMmLU5opRrCyS670RzppZeW5p/iT3jL3lB4O63QS6dzzh8SAtOqwGJK3bv+lGJTWbr++471wsVKMRJCEK5H+cLg/Qp+IDsdqs7HhKD7hMXyyrD/Li8RjRqimHhI7HP2vSDZn9brplySb0L9dgpURSwmSiBFhilrwB8OA9gZ29NkRO/669parW9e7XZDxwvgRu+SE7zgl+xG5p/HtRqJ3cdwSZwsbwTA1WT3jEdyPN0sWxvDGy+xovIzHosnwc9LePf9tywun0fMkWaFYZbB4oovRq8VyKYUBkMVXqVhBHSylQ0wanvla3+rQ1XbR8ZzstYOo2Mf7vjk8ftcGDWxdSdXx0cAVveHg1TZFtEOn8ntBBFs11V++vuLUQ5qz+U6d/oUjpGIdNjOQhJXNqn5YCS1Yy5PofLGEs6Js2yOKe2yyOLxtaGjbt7cNIURCEDdWfaQ6lurtRYbePCuItv1iUNxvE4Vdw2zQ0LZhdv2fxjHp5uAmdlBpopHXoJGU8e6BRc0yi+PztkaHTRRrW1m2hcfFLlEUzzD+DGczjEVCg9jEQZhFcdAL2DjD+DPiSWQzjM2I89g5RXdxfECS+CIWy1hTGmFs6EIbkv/pbtkfU3aPrZ+4c2Lizn07qufym/L5TTdtyuU2/We3HPeDsjtb3bGPSSfW31aX3LQpX/d9sL7fWYpRJPBbCJavYjrFjj0rT2GWCZjf6Ytffr8beXl/HYeyGwJiIK8FLDHbfo65xGz7YCSRqCQSkbbHI5eUU5X4sjj+zrU9aHnRlEnrd7YGptd0x2Jf/RbH9PAiovadckSnEsJ661OgPFuH9B4O6e202vIN0h9xHXSJh1wRP5Vqv1uI6Wn9Gxmrwzqrii1gqhEscJanuAlGas+s2/uzvetgS72NpHZ6aHbZstmh/wPq1seEeJxjYGRgYADi31ySEvH8Nl8ZuJlfAEUYalQ3NCLo/6+ZpzLdAnI5GJhAogAiBgraeJxjYGRgYA76nwUkXzAAAfNUBkYGVKALAFb4A3EAAAB4nGNgYGBgfjG0MAAMzihlAAAAAABOAJoA6AEKASwBTgFwAZoBxAHuAhoCnALoBJoEvATWBPIFDgUqBXoF0AX+BkQGlga4BwgHagfiCGoIpAi8CVAJmAoQCiwKVgqQCtYLGAtOC4gL6AwuDFR4nGNgZGBg0GVMYRBlAAEmIOYCQgaG/2A+AwAYygG+AHicbZE9TsMwGIbf9A/RSggEYmHxAgtq+jN2ZGj3Dt3T1GlTOXHkuBW9AyfgEByCgTNwCA7BW/NJlVBtyd/jx+8XKwmAa3whwnFE6Ib1OBq44O6Pm6Qb4Rb5QbiNHh6FO/RD4S6eMRHu4RaaT4halzR3eBVu4Apvwk36d+EW+UO4jXt8Cnfov4W7WOBHuIen6MXsCtvPU1vWc73emcSdxIkW2tW5LdUoHp7kTJfaJV6v1PKg6v167H2mMmcLNbWl18ZYVTm71amPN95Xk8EgEx+ntoDBDgUs+siRspaoMef7rukNEriziXNuwS7Hmoe9wggxv+e55IzJMqQTeNYV00scuNbY8+YxrUfGfcaMZb/CNPQe04bT0lThbEuT0sfYhK6K/23Amf3Lx+H24hcj4GScAAAAeJxtjuduwzAMhH2NnTqOk+6993TfSZFY24giGZTVon36eiRFf5SAiO/A05HBWtBXEvxfGdYwQIgIQ6wjxggJxkgxwRQb2MQWtrGDXexhHwc4xBGOcYJTnOEcF7jEFa5xg1vc4R4PeMQTnvGCV2R4C1Khy9xkkkxNnPRC03s97pHLvKgTYXJNmbKfZom9o8POEffsq0Qw28+ltcPe2uHS2rGvRjPBmSwE1+GMtI6l0GSU4JEsSM4XgudpQx9sTRf3K9rAyUr0962UryKprZwPpM0jyda5uP2qrVBjxSLPCmGUplixrdpBSKqsI2oO4gF9Udq8TJVOzDSpcEHGR4vSeJdaVsSkMl26OqoKa6jttQ0rLb6a5l3YjO2QqV01YXLlNy2XDR0JlkXojbJTb/5GDX3V+kPviIPgB9AUks0AAAA=)
      format('woff');
    font-weight: normal;
    font-style: normal;
  }

  html {
    --lumo-icons-align-center: '\\ea01';
    --lumo-icons-align-left: '\\ea02';
    --lumo-icons-align-right: '\\ea03';
    --lumo-icons-angle-down: '\\ea04';
    --lumo-icons-angle-left: '\\ea05';
    --lumo-icons-angle-right: '\\ea06';
    --lumo-icons-angle-up: '\\ea07';
    --lumo-icons-arrow-down: '\\ea08';
    --lumo-icons-arrow-left: '\\ea09';
    --lumo-icons-arrow-right: '\\ea0a';
    --lumo-icons-arrow-up: '\\ea0b';
    --lumo-icons-bar-chart: '\\ea0c';
    --lumo-icons-bell: '\\ea0d';
    --lumo-icons-calendar: '\\ea0e';
    --lumo-icons-checkmark: '\\ea0f';
    --lumo-icons-chevron-down: '\\ea10';
    --lumo-icons-chevron-left: '\\ea11';
    --lumo-icons-chevron-right: '\\ea12';
    --lumo-icons-chevron-up: '\\ea13';
    --lumo-icons-clock: '\\ea14';
    --lumo-icons-cog: '\\ea15';
    --lumo-icons-cross: '\\ea16';
    --lumo-icons-download: '\\ea17';
    --lumo-icons-drag-handle: '\\ea18';
    --lumo-icons-dropdown: '\\ea19';
    --lumo-icons-edit: '\\ea1a';
    --lumo-icons-error: '\\ea1b';
    --lumo-icons-eye: '\\ea1c';
    --lumo-icons-eye-disabled: '\\ea1d';
    --lumo-icons-menu: '\\ea1e';
    --lumo-icons-minus: '\\ea1f';
    --lumo-icons-ordered-list: '\\ea20';
    --lumo-icons-phone: '\\ea21';
    --lumo-icons-photo: '\\ea22';
    --lumo-icons-play: '\\ea23';
    --lumo-icons-plus: '\\ea24';
    --lumo-icons-redo: '\\ea25';
    --lumo-icons-reload: '\\ea26';
    --lumo-icons-resize-handle: '\\ea27';
    --lumo-icons-search: '\\ea28';
    --lumo-icons-undo: '\\ea29';
    --lumo-icons-unordered-list: '\\ea2a';
    --lumo-icons-upload: '\\ea2b';
    --lumo-icons-user: '\\ea2c';
  }
`;
addLumoGlobalStyles("font-icons", fontIcons);
/**
 * @license
 * Copyright (c) 2017 - 2025 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const sizing = css`
  :host {
    --lumo-size-xs: 1.625rem;
    --lumo-size-s: 1.875rem;
    --lumo-size-m: 2.25rem;
    --lumo-size-l: 2.75rem;
    --lumo-size-xl: 3.5rem;

    /* Icons */
    --lumo-icon-size-s: 1.25em;
    --lumo-icon-size-m: 1.5em;
    --lumo-icon-size-l: 2.25em;
    /* For backwards compatibility */
    --lumo-icon-size: var(--lumo-icon-size-m);
  }
`;
addLumoGlobalStyles("sizing-props", sizing);
const detailsSummary = css`
  :host {
    display: flex;
    align-items: center;
    width: 100%;
    outline: none;
    padding: var(--lumo-space-s) 0;
    box-sizing: border-box;
    font-family: var(--lumo-font-family);
    font-size: var(--lumo-font-size-m);
    font-weight: 500;
    line-height: var(--lumo-line-height-xs);
    color: var(--lumo-secondary-text-color);
    background-color: inherit;
    border-radius: var(--lumo-border-radius-m);
    cursor: var(--lumo-clickable-cursor);
    -webkit-tap-highlight-color: transparent;
    -webkit-font-smoothing: antialiased;
    -moz-osx-font-smoothing: grayscale;
  }

  :host([disabled]),
  :host([disabled]) [part='toggle'] {
    color: var(--lumo-disabled-text-color);
    cursor: default;
  }

  @media (hover: hover) {
    :host(:hover:not([disabled])),
    :host(:hover:not([disabled])) [part='toggle'] {
      color: var(--lumo-contrast-80pct);
    }
  }

  [part='toggle'] {
    display: block;
    width: 1em;
    height: 1em;
    margin-left: calc(var(--lumo-space-xs) * -1);
    margin-right: var(--lumo-space-xs);
    font-size: var(--lumo-icon-size-s);
    line-height: 1;
    color: var(--lumo-contrast-60pct);
    font-family: 'lumo-icons';
    cursor: var(--lumo-clickable-cursor);
  }

  [part='toggle']::before {
    content: var(--lumo-icons-angle-right);
  }

  :host([opened]) [part='toggle'] {
    transform: rotate(90deg);
  }

  [part='content'] {
    flex-grow: 1;
  }

  /* RTL styles */
  :host([dir='rtl']) [part='toggle'] {
    margin-left: var(--lumo-space-xs);
    margin-right: calc(var(--lumo-space-xs) * -1);
  }

  :host([dir='rtl']) [part='toggle']::before {
    content: var(--lumo-icons-angle-left);
  }

  :host([opened][dir='rtl']) [part='toggle'] {
    transform: rotate(-90deg);
  }

  /* Small */
  :host([theme~='small']) {
    padding-top: var(--lumo-space-xs);
    padding-bottom: var(--lumo-space-xs);
  }

  :host([theme~='small']) [part='toggle'] {
    margin-right: calc(var(--lumo-space-xs) / 2);
  }

  :host([theme~='small'][dir='rtl']) [part='toggle'] {
    margin-left: calc(var(--lumo-space-xs) / 2);
  }

  /* Filled */
  :host([theme~='filled']) {
    padding: var(--lumo-space-s) calc(var(--lumo-space-s) + var(--lumo-space-xs) / 2);
  }

  /* Reverse */
  :host([theme~='reverse']) {
    justify-content: space-between;
  }

  :host([theme~='reverse']) [part='toggle'] {
    order: 1;
    margin-right: 0;
  }

  :host([theme~='reverse'][dir='rtl']) [part='toggle'] {
    margin-left: 0;
  }

  /* Filled reverse */
  :host([theme~='reverse'][theme~='filled']) {
    padding-left: var(--lumo-space-m);
  }

  :host([theme~='reverse'][theme~='filled'][dir='rtl']) {
    padding-right: var(--lumo-space-m);
  }
`;
registerStyles$1("vaadin-details-summary", detailsSummary, { moduleId: "lumo-details-summary" });
const accordionHeading$1 = css`
  :host {
    padding: 0;
  }

  [part='content'] {
    padding: var(--lumo-space-s) 0;
  }

  :host([theme~='filled']) {
    padding-top: 0;
    padding-bottom: 0;
  }
`;
registerStyles$1("vaadin-accordion-heading", [detailsSummary, accordionHeading$1], { moduleId: "lumo-accordion-heading" });
/**
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/
const wrap$1 = window["ShadyDOM"] && window["ShadyDOM"]["noPatch"] && window["ShadyDOM"]["wrap"] ? window["ShadyDOM"]["wrap"] : window["ShadyDOM"] ? (n) => ShadyDOM["patch"](n) : (n) => n;
/**
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/
function isPath(path) {
  return path.indexOf(".") >= 0;
}
function root(path) {
  let dotIndex = path.indexOf(".");
  if (dotIndex === -1) {
    return path;
  }
  return path.slice(0, dotIndex);
}
function isAncestor(base, path) {
  return base.indexOf(path + ".") === 0;
}
function isDescendant(base, path) {
  return path.indexOf(base + ".") === 0;
}
function translate(base, newBase, path) {
  return newBase + path.slice(base.length);
}
function matches(base, path) {
  return base === path || isAncestor(base, path) || isDescendant(base, path);
}
function normalize(path) {
  if (Array.isArray(path)) {
    let parts = [];
    for (let i2 = 0; i2 < path.length; i2++) {
      let args = path[i2].toString().split(".");
      for (let j = 0; j < args.length; j++) {
        parts.push(args[j]);
      }
    }
    return parts.join(".");
  } else {
    return path;
  }
}
function split(path) {
  if (Array.isArray(path)) {
    return normalize(path).split(".");
  }
  return path.toString().split(".");
}
function get$1(root2, path, info) {
  let prop = root2;
  let parts = split(path);
  for (let i2 = 0; i2 < parts.length; i2++) {
    if (!prop) {
      return;
    }
    let part = parts[i2];
    prop = prop[part];
  }
  if (info) {
    info.path = parts.join(".");
  }
  return prop;
}
function set(root2, path, value) {
  let prop = root2;
  let parts = split(path);
  let last = parts[parts.length - 1];
  if (parts.length > 1) {
    for (let i2 = 0; i2 < parts.length - 1; i2++) {
      let part = parts[i2];
      prop = prop[part];
      if (!prop) {
        return;
      }
    }
    prop[last] = value;
  } else {
    prop[path] = value;
  }
  return parts.join(".");
}
/**
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/
const caseMap = {};
const DASH_TO_CAMEL = /-[a-z]/g;
const CAMEL_TO_DASH = /([A-Z])/g;
function dashToCamelCase(dash) {
  return caseMap[dash] || (caseMap[dash] = dash.indexOf("-") < 0 ? dash : dash.replace(
    DASH_TO_CAMEL,
    (m3) => m3[1].toUpperCase()
  ));
}
function camelToDashCase(camel) {
  return caseMap[camel] || (caseMap[camel] = camel.replace(CAMEL_TO_DASH, "-$1").toLowerCase());
}
/**
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/
let microtaskCurrHandle = 0;
let microtaskLastHandle = 0;
let microtaskCallbacks = [];
let microtaskNodeContent = 0;
let microtaskScheduled = false;
let microtaskNode = document.createTextNode("");
new window.MutationObserver(microtaskFlush).observe(microtaskNode, { characterData: true });
function microtaskFlush() {
  microtaskScheduled = false;
  const len = microtaskCallbacks.length;
  for (let i2 = 0; i2 < len; i2++) {
    let cb = microtaskCallbacks[i2];
    if (cb) {
      try {
        cb();
      } catch (e2) {
        setTimeout(() => {
          throw e2;
        });
      }
    }
  }
  microtaskCallbacks.splice(0, len);
  microtaskLastHandle += len;
}
const timeOut = {
  /**
   * Returns a sub-module with the async interface providing the provided
   * delay.
   *
   * @memberof timeOut
   * @param {number=} delay Time to wait before calling callbacks in ms
   * @return {!AsyncInterface} An async timeout interface
   */
  after(delay) {
    return {
      run(fn) {
        return window.setTimeout(fn, delay);
      },
      cancel(handle) {
        window.clearTimeout(handle);
      }
    };
  },
  /**
   * Enqueues a function called in the next task.
   *
   * @memberof timeOut
   * @param {!Function} fn Callback to run
   * @param {number=} delay Delay in milliseconds
   * @return {number} Handle used for canceling task
   */
  run(fn, delay) {
    return window.setTimeout(fn, delay);
  },
  /**
   * Cancels a previously enqueued `timeOut` callback.
   *
   * @memberof timeOut
   * @param {number} handle Handle returned from `run` of callback to cancel
   * @return {void}
   */
  cancel(handle) {
    window.clearTimeout(handle);
  }
};
const animationFrame = {
  /**
   * Enqueues a function called at `requestAnimationFrame` timing.
   *
   * @memberof animationFrame
   * @param {function(number):void} fn Callback to run
   * @return {number} Handle used for canceling task
   */
  run(fn) {
    return window.requestAnimationFrame(fn);
  },
  /**
   * Cancels a previously enqueued `animationFrame` callback.
   *
   * @memberof animationFrame
   * @param {number} handle Handle returned from `run` of callback to cancel
   * @return {void}
   */
  cancel(handle) {
    window.cancelAnimationFrame(handle);
  }
};
const idlePeriod = {
  /**
   * Enqueues a function called at `requestIdleCallback` timing.
   *
   * @memberof idlePeriod
   * @param {function(!IdleDeadline):void} fn Callback to run
   * @return {number} Handle used for canceling task
   */
  run(fn) {
    return window.requestIdleCallback ? window.requestIdleCallback(fn) : window.setTimeout(fn, 16);
  },
  /**
   * Cancels a previously enqueued `idlePeriod` callback.
   *
   * @memberof idlePeriod
   * @param {number} handle Handle returned from `run` of callback to cancel
   * @return {void}
   */
  cancel(handle) {
    window.cancelIdleCallback ? window.cancelIdleCallback(handle) : window.clearTimeout(handle);
  }
};
const microTask = {
  /**
   * Enqueues a function called at microtask timing.
   *
   * @memberof microTask
   * @param {!Function=} callback Callback to run
   * @return {number} Handle used for canceling task
   */
  run(callback) {
    if (!microtaskScheduled) {
      microtaskScheduled = true;
      microtaskNode.textContent = microtaskNodeContent++;
    }
    microtaskCallbacks.push(callback);
    return microtaskCurrHandle++;
  },
  /**
   * Cancels a previously enqueued `microTask` callback.
   *
   * @memberof microTask
   * @param {number} handle Handle returned from `run` of callback to cancel
   * @return {void}
   */
  cancel(handle) {
    const idx = handle - microtaskLastHandle;
    if (idx >= 0) {
      if (!microtaskCallbacks[idx]) {
        throw new Error("invalid async handle: " + handle);
      }
      microtaskCallbacks[idx] = null;
    }
  }
};
/**
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/
const microtask = microTask;
const PropertiesChanged = dedupingMixin(
  /**
   * @template T
   * @param {function(new:T)} superClass Class to apply mixin to.
   * @return {function(new:T)} superClass with mixin applied.
   */
  (superClass) => {
    class PropertiesChanged2 extends superClass {
      /**
       * Creates property accessors for the given property names.
       * @param {!Object} props Object whose keys are names of accessors.
       * @return {void}
       * @protected
       * @nocollapse
       */
      static createProperties(props) {
        const proto2 = this.prototype;
        for (let prop in props) {
          if (!(prop in proto2)) {
            proto2._createPropertyAccessor(prop);
          }
        }
      }
      /**
       * Returns an attribute name that corresponds to the given property.
       * The attribute name is the lowercased property name. Override to
       * customize this mapping.
       * @param {string} property Property to convert
       * @return {string} Attribute name corresponding to the given property.
       *
       * @protected
       * @nocollapse
       */
      static attributeNameForProperty(property) {
        return property.toLowerCase();
      }
      /**
       * Override point to provide a type to which to deserialize a value to
       * a given property.
       * @param {string} name Name of property
       *
       * @protected
       * @nocollapse
       */
      static typeForProperty(name) {
      }
      //eslint-disable-line no-unused-vars
      /**
       * Creates a setter/getter pair for the named property with its own
       * local storage.  The getter returns the value in the local storage,
       * and the setter calls `_setProperty`, which updates the local storage
       * for the property and enqueues a `_propertiesChanged` callback.
       *
       * This method may be called on a prototype or an instance.  Calling
       * this method may overwrite a property value that already exists on
       * the prototype/instance by creating the accessor.
       *
       * @param {string} property Name of the property
       * @param {boolean=} readOnly When true, no setter is created; the
       *   protected `_setProperty` function must be used to set the property
       * @return {void}
       * @protected
       * @override
       */
      _createPropertyAccessor(property, readOnly) {
        this._addPropertyToAttributeMap(property);
        if (!this.hasOwnProperty(JSCompiler_renameProperty("__dataHasAccessor", this))) {
          this.__dataHasAccessor = Object.assign({}, this.__dataHasAccessor);
        }
        if (!this.__dataHasAccessor[property]) {
          this.__dataHasAccessor[property] = true;
          this._definePropertyAccessor(property, readOnly);
        }
      }
      /**
       * Adds the given `property` to a map matching attribute names
       * to property names, using `attributeNameForProperty`. This map is
       * used when deserializing attribute values to properties.
       *
       * @param {string} property Name of the property
       * @override
       */
      _addPropertyToAttributeMap(property) {
        if (!this.hasOwnProperty(JSCompiler_renameProperty("__dataAttributes", this))) {
          this.__dataAttributes = Object.assign({}, this.__dataAttributes);
        }
        let attr = this.__dataAttributes[property];
        if (!attr) {
          attr = this.constructor.attributeNameForProperty(property);
          this.__dataAttributes[attr] = property;
        }
        return attr;
      }
      /**
       * Defines a property accessor for the given property.
       * @param {string} property Name of the property
       * @param {boolean=} readOnly When true, no setter is created
       * @return {void}
       * @override
       */
      _definePropertyAccessor(property, readOnly) {
        Object.defineProperty(this, property, {
          /* eslint-disable valid-jsdoc */
          /** @this {PropertiesChanged} */
          get() {
            return this.__data[property];
          },
          /** @this {PropertiesChanged} */
          set: readOnly ? function() {
          } : function(value) {
            if (this._setPendingProperty(property, value, true)) {
              this._invalidateProperties();
            }
          }
          /* eslint-enable */
        });
      }
      constructor() {
        super();
        this.__dataEnabled = false;
        this.__dataReady = false;
        this.__dataInvalid = false;
        this.__data = {};
        this.__dataPending = null;
        this.__dataOld = null;
        this.__dataInstanceProps = null;
        this.__dataCounter = 0;
        this.__serializing = false;
        this._initializeProperties();
      }
      /**
       * Lifecycle callback called when properties are enabled via
       * `_enableProperties`.
       *
       * Users may override this function to implement behavior that is
       * dependent on the element having its property data initialized, e.g.
       * from defaults (initialized from `constructor`, `_initializeProperties`),
       * `attributeChangedCallback`, or values propagated from host e.g. via
       * bindings.  `super.ready()` must be called to ensure the data system
       * becomes enabled.
       *
       * @return {void}
       * @public
       * @override
       */
      ready() {
        this.__dataReady = true;
        this._flushProperties();
      }
      /**
       * Initializes the local storage for property accessors.
       *
       * Provided as an override point for performing any setup work prior
       * to initializing the property accessor system.
       *
       * @return {void}
       * @protected
       * @override
       */
      _initializeProperties() {
        for (let p in this.__dataHasAccessor) {
          if (this.hasOwnProperty(p)) {
            this.__dataInstanceProps = this.__dataInstanceProps || {};
            this.__dataInstanceProps[p] = this[p];
            delete this[p];
          }
        }
      }
      /**
       * Called at ready time with bag of instance properties that overwrote
       * accessors when the element upgraded.
       *
       * The default implementation sets these properties back into the
       * setter at ready time.  This method is provided as an override
       * point for customizing or providing more efficient initialization.
       *
       * @param {Object} props Bag of property values that were overwritten
       *   when creating property accessors.
       * @return {void}
       * @protected
       * @override
       */
      _initializeInstanceProperties(props) {
        Object.assign(this, props);
      }
      /**
       * Updates the local storage for a property (via `_setPendingProperty`)
       * and enqueues a `_proeprtiesChanged` callback.
       *
       * @param {string} property Name of the property
       * @param {*} value Value to set
       * @return {void}
       * @protected
       * @override
       */
      _setProperty(property, value) {
        if (this._setPendingProperty(property, value)) {
          this._invalidateProperties();
        }
      }
      /**
       * Returns the value for the given property.
       * @param {string} property Name of property
       * @return {*} Value for the given property
       * @protected
       * @override
       */
      _getProperty(property) {
        return this.__data[property];
      }
      /* eslint-disable no-unused-vars */
      /**
       * Updates the local storage for a property, records the previous value,
       * and adds it to the set of "pending changes" that will be passed to the
       * `_propertiesChanged` callback.  This method does not enqueue the
       * `_propertiesChanged` callback.
       *
       * @param {string} property Name of the property
       * @param {*} value Value to set
       * @param {boolean=} ext Not used here; affordance for closure
       * @return {boolean} Returns true if the property changed
       * @protected
       * @override
       */
      _setPendingProperty(property, value, ext) {
        let old = this.__data[property];
        let changed = this._shouldPropertyChange(property, value, old);
        if (changed) {
          if (!this.__dataPending) {
            this.__dataPending = {};
            this.__dataOld = {};
          }
          if (this.__dataOld && !(property in this.__dataOld)) {
            this.__dataOld[property] = old;
          }
          this.__data[property] = value;
          this.__dataPending[property] = value;
        }
        return changed;
      }
      /* eslint-enable */
      /**
       * @param {string} property Name of the property
       * @return {boolean} Returns true if the property is pending.
       */
      _isPropertyPending(property) {
        return !!(this.__dataPending && this.__dataPending.hasOwnProperty(property));
      }
      /**
       * Marks the properties as invalid, and enqueues an async
       * `_propertiesChanged` callback.
       *
       * @return {void}
       * @protected
       * @override
       */
      _invalidateProperties() {
        if (!this.__dataInvalid && this.__dataReady) {
          this.__dataInvalid = true;
          microtask.run(() => {
            if (this.__dataInvalid) {
              this.__dataInvalid = false;
              this._flushProperties();
            }
          });
        }
      }
      /**
       * Call to enable property accessor processing. Before this method is
       * called accessor values will be set but side effects are
       * queued. When called, any pending side effects occur immediately.
       * For elements, generally `connectedCallback` is a normal spot to do so.
       * It is safe to call this method multiple times as it only turns on
       * property accessors once.
       *
       * @return {void}
       * @protected
       * @override
       */
      _enableProperties() {
        if (!this.__dataEnabled) {
          this.__dataEnabled = true;
          if (this.__dataInstanceProps) {
            this._initializeInstanceProperties(this.__dataInstanceProps);
            this.__dataInstanceProps = null;
          }
          this.ready();
        }
      }
      /**
       * Calls the `_propertiesChanged` callback with the current set of
       * pending changes (and old values recorded when pending changes were
       * set), and resets the pending set of changes. Generally, this method
       * should not be called in user code.
       *
       * @return {void}
       * @protected
       * @override
       */
      _flushProperties() {
        this.__dataCounter++;
        const props = this.__data;
        const changedProps = this.__dataPending;
        const old = this.__dataOld;
        if (this._shouldPropertiesChange(props, changedProps, old)) {
          this.__dataPending = null;
          this.__dataOld = null;
          this._propertiesChanged(props, changedProps, old);
        }
        this.__dataCounter--;
      }
      /**
       * Called in `_flushProperties` to determine if `_propertiesChanged`
       * should be called. The default implementation returns true if
       * properties are pending. Override to customize when
       * `_propertiesChanged` is called.
       * @param {!Object} currentProps Bag of all current accessor values
       * @param {?Object} changedProps Bag of properties changed since the last
       *   call to `_propertiesChanged`
       * @param {?Object} oldProps Bag of previous values for each property
       *   in `changedProps`
       * @return {boolean} true if changedProps is truthy
       * @override
       */
      _shouldPropertiesChange(currentProps, changedProps, oldProps) {
        return Boolean(changedProps);
      }
      /**
       * Callback called when any properties with accessors created via
       * `_createPropertyAccessor` have been set.
       *
       * @param {!Object} currentProps Bag of all current accessor values
       * @param {?Object} changedProps Bag of properties changed since the last
       *   call to `_propertiesChanged`
       * @param {?Object} oldProps Bag of previous values for each property
       *   in `changedProps`
       * @return {void}
       * @protected
       * @override
       */
      _propertiesChanged(currentProps, changedProps, oldProps) {
      }
      /**
       * Method called to determine whether a property value should be
       * considered as a change and cause the `_propertiesChanged` callback
       * to be enqueued.
       *
       * The default implementation returns `true` if a strict equality
       * check fails. The method always returns false for `NaN`.
       *
       * Override this method to e.g. provide stricter checking for
       * Objects/Arrays when using immutable patterns.
       *
       * @param {string} property Property name
       * @param {*} value New property value
       * @param {*} old Previous property value
       * @return {boolean} Whether the property should be considered a change
       *   and enqueue a `_proeprtiesChanged` callback
       * @protected
       * @override
       */
      _shouldPropertyChange(property, value, old) {
        return (
          // Strict equality check
          old !== value && // This ensures (old==NaN, value==NaN) always returns false
          (old === old || value === value)
        );
      }
      /**
       * Implements native Custom Elements `attributeChangedCallback` to
       * set an attribute value to a property via `_attributeToProperty`.
       *
       * @param {string} name Name of attribute that changed
       * @param {?string} old Old attribute value
       * @param {?string} value New attribute value
       * @param {?string} namespace Attribute namespace.
       * @return {void}
       * @suppress {missingProperties} Super may or may not implement the callback
       * @override
       */
      attributeChangedCallback(name, old, value, namespace) {
        if (old !== value) {
          this._attributeToProperty(name, value);
        }
        if (super.attributeChangedCallback) {
          super.attributeChangedCallback(name, old, value, namespace);
        }
      }
      /**
       * Deserializes an attribute to its associated property.
       *
       * This method calls the `_deserializeValue` method to convert the string to
       * a typed value.
       *
       * @param {string} attribute Name of attribute to deserialize.
       * @param {?string} value of the attribute.
       * @param {*=} type type to deserialize to, defaults to the value
       * returned from `typeForProperty`
       * @return {void}
       * @override
       */
      _attributeToProperty(attribute, value, type) {
        if (!this.__serializing) {
          const map = this.__dataAttributes;
          const property = map && map[attribute] || attribute;
          this[property] = this._deserializeValue(value, type || this.constructor.typeForProperty(property));
        }
      }
      /**
       * Serializes a property to its associated attribute.
       *
       * @suppress {invalidCasts} Closure can't figure out `this` is an element.
       *
       * @param {string} property Property name to reflect.
       * @param {string=} attribute Attribute name to reflect to.
       * @param {*=} value Property value to refect.
       * @return {void}
       * @override
       */
      _propertyToAttribute(property, attribute, value) {
        this.__serializing = true;
        value = arguments.length < 3 ? this[property] : value;
        this._valueToNodeAttribute(
          /** @type {!HTMLElement} */
          this,
          value,
          attribute || this.constructor.attributeNameForProperty(property)
        );
        this.__serializing = false;
      }
      /**
       * Sets a typed value to an HTML attribute on a node.
       *
       * This method calls the `_serializeValue` method to convert the typed
       * value to a string.  If the `_serializeValue` method returns `undefined`,
       * the attribute will be removed (this is the default for boolean
       * type `false`).
       *
       * @param {Element} node Element to set attribute to.
       * @param {*} value Value to serialize.
       * @param {string} attribute Attribute name to serialize to.
       * @return {void}
       * @override
       */
      _valueToNodeAttribute(node, value, attribute) {
        const str = this._serializeValue(value);
        if (attribute === "class" || attribute === "name" || attribute === "slot") {
          node = /** @type {?Element} */
          wrap$1(node);
        }
        if (str === void 0) {
          node.removeAttribute(attribute);
        } else {
          node.setAttribute(
            attribute,
            // Closure's type for `setAttribute`'s second parameter incorrectly
            // excludes `TrustedScript`.
            str === "" && window.trustedTypes ? (
              /** @type {?} */
              window.trustedTypes.emptyScript
            ) : str
          );
        }
      }
      /**
       * Converts a typed JavaScript value to a string.
       *
       * This method is called when setting JS property values to
       * HTML attributes.  Users may override this method to provide
       * serialization for custom types.
       *
       * @param {*} value Property value to serialize.
       * @return {string | undefined} String serialized from the provided
       * property  value.
       * @override
       */
      _serializeValue(value) {
        switch (typeof value) {
          case "boolean":
            return value ? "" : void 0;
          default:
            return value != null ? value.toString() : void 0;
        }
      }
      /**
       * Converts a string to a typed JavaScript value.
       *
       * This method is called when reading HTML attribute values to
       * JS properties.  Users may override this method to provide
       * deserialization for custom `type`s. Types for `Boolean`, `String`,
       * and `Number` convert attributes to the expected types.
       *
       * @param {?string} value Value to deserialize.
       * @param {*=} type Type to deserialize the string to.
       * @return {*} Typed value deserialized from the provided string.
       * @override
       */
      _deserializeValue(value, type) {
        switch (type) {
          case Boolean:
            return value !== null;
          case Number:
            return Number(value);
          default:
            return value;
        }
      }
    }
    return PropertiesChanged2;
  }
);
/**
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/
const nativeProperties = {};
let proto = HTMLElement.prototype;
while (proto) {
  let props = Object.getOwnPropertyNames(proto);
  for (let i2 = 0; i2 < props.length; i2++) {
    nativeProperties[props[i2]] = true;
  }
  proto = Object.getPrototypeOf(proto);
}
const isTrustedType = (() => {
  if (!window.trustedTypes) {
    return () => false;
  }
  return (val) => trustedTypes.isHTML(val) || trustedTypes.isScript(val) || trustedTypes.isScriptURL(val);
})();
function saveAccessorValue(model, property) {
  if (!nativeProperties[property]) {
    let value = model[property];
    if (value !== void 0) {
      if (model.__data) {
        model._setPendingProperty(property, value);
      } else {
        if (!model.__dataProto) {
          model.__dataProto = {};
        } else if (!model.hasOwnProperty(JSCompiler_renameProperty("__dataProto", model))) {
          model.__dataProto = Object.create(model.__dataProto);
        }
        model.__dataProto[property] = value;
      }
    }
  }
}
const PropertyAccessors = dedupingMixin((superClass) => {
  const base = PropertiesChanged(superClass);
  class PropertyAccessors2 extends base {
    /**
     * Generates property accessors for all attributes in the standard
     * static `observedAttributes` array.
     *
     * Attribute names are mapped to property names using the `dash-case` to
     * `camelCase` convention
     *
     * @return {void}
     * @nocollapse
     */
    static createPropertiesForAttributes() {
      let a$ = (
        /** @type {?} */
        this.observedAttributes
      );
      for (let i2 = 0; i2 < a$.length; i2++) {
        this.prototype._createPropertyAccessor(dashToCamelCase(a$[i2]));
      }
    }
    /**
     * Returns an attribute name that corresponds to the given property.
     * By default, converts camel to dash case, e.g. `fooBar` to `foo-bar`.
     * @param {string} property Property to convert
     * @return {string} Attribute name corresponding to the given property.
     *
     * @protected
     * @nocollapse
     */
    static attributeNameForProperty(property) {
      return camelToDashCase(property);
    }
    /**
     * Overrides PropertiesChanged implementation to initialize values for
     * accessors created for values that already existed on the element
     * prototype.
     *
     * @return {void}
     * @protected
     * @override
     */
    _initializeProperties() {
      if (this.__dataProto) {
        this._initializeProtoProperties(this.__dataProto);
        this.__dataProto = null;
      }
      super._initializeProperties();
    }
    /**
     * Called at instance time with bag of properties that were overwritten
     * by accessors on the prototype when accessors were created.
     *
     * The default implementation sets these properties back into the
     * setter at instance time.  This method is provided as an override
     * point for customizing or providing more efficient initialization.
     *
     * @param {Object} props Bag of property values that were overwritten
     *   when creating property accessors.
     * @return {void}
     * @protected
     * @override
     */
    _initializeProtoProperties(props) {
      for (let p in props) {
        this._setProperty(p, props[p]);
      }
    }
    /**
     * Ensures the element has the given attribute. If it does not,
     * assigns the given value to the attribute.
     *
     * @suppress {invalidCasts} Closure can't figure out `this` is infact an
     *     element
     *
     * @param {string} attribute Name of attribute to ensure is set.
     * @param {string} value of the attribute.
     * @return {void}
     * @override
     */
    _ensureAttribute(attribute, value) {
      const el = (
        /** @type {!HTMLElement} */
        this
      );
      if (!el.hasAttribute(attribute)) {
        this._valueToNodeAttribute(el, value, attribute);
      }
    }
    /**
     * Overrides PropertiesChanged implemention to serialize objects as JSON.
     *
     * @param {*} value Property value to serialize.
     * @return {string | undefined} String serialized from the provided property
     *     value.
     * @override
     */
    _serializeValue(value) {
      switch (typeof value) {
        case "object":
          if (value instanceof Date) {
            return value.toString();
          } else if (value) {
            if (isTrustedType(value)) {
              return (
                /** @type {?} */
                value
              );
            }
            try {
              return JSON.stringify(value);
            } catch (x2) {
              return "";
            }
          }
        default:
          return super._serializeValue(value);
      }
    }
    /**
     * Converts a string to a typed JavaScript value.
     *
     * This method is called by Polymer when reading HTML attribute values to
     * JS properties.  Users may override this method on Polymer element
     * prototypes to provide deserialization for custom `type`s.  Note,
     * the `type` argument is the value of the `type` field provided in the
     * `properties` configuration object for a given property, and is
     * by convention the constructor for the type to deserialize.
     *
     *
     * @param {?string} value Attribute value to deserialize.
     * @param {*=} type Type to deserialize the string to.
     * @return {*} Typed value deserialized from the provided string.
     * @override
     */
    _deserializeValue(value, type) {
      let outValue;
      switch (type) {
        case Object:
          try {
            outValue = JSON.parse(
              /** @type {string} */
              value
            );
          } catch (x2) {
            outValue = value;
          }
          break;
        case Array:
          try {
            outValue = JSON.parse(
              /** @type {string} */
              value
            );
          } catch (x2) {
            outValue = null;
            console.warn(`Polymer::Attributes: couldn't decode Array as JSON: ${value}`);
          }
          break;
        case Date:
          outValue = isNaN(value) ? String(value) : Number(value);
          outValue = new Date(outValue);
          break;
        default:
          outValue = super._deserializeValue(value, type);
          break;
      }
      return outValue;
    }
    /* eslint-enable no-fallthrough */
    /**
     * Overrides PropertiesChanged implementation to save existing prototype
     * property value so that it can be reset.
     * @param {string} property Name of the property
     * @param {boolean=} readOnly When true, no setter is created
     *
     * When calling on a prototype, any overwritten values are saved in
     * `__dataProto`, and it is up to the subclasser to decide how/when
     * to set those properties back into the accessor.  When calling on an
     * instance, the overwritten value is set via `_setPendingProperty`,
     * and the user should call `_invalidateProperties` or `_flushProperties`
     * for the values to take effect.
     * @protected
     * @return {void}
     * @override
     */
    _definePropertyAccessor(property, readOnly) {
      saveAccessorValue(this, property);
      super._definePropertyAccessor(property, readOnly);
    }
    /**
     * Returns true if this library created an accessor for the given property.
     *
     * @param {string} property Property name
     * @return {boolean} True if an accessor was created
     * @override
     */
    _hasAccessor(property) {
      return this.__dataHasAccessor && this.__dataHasAccessor[property];
    }
    /**
     * Returns true if the specified property has a pending change.
     *
     * @param {string} prop Property name
     * @return {boolean} True if property has a pending change
     * @protected
     * @override
     */
    _isPropertyPending(prop) {
      return Boolean(this.__dataPending && prop in this.__dataPending);
    }
  }
  return PropertyAccessors2;
});
/**
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/
const templateExtensions = {
  "dom-if": true,
  "dom-repeat": true
};
let placeholderBugDetect = false;
let placeholderBug = false;
function hasPlaceholderBug() {
  if (!placeholderBugDetect) {
    placeholderBugDetect = true;
    const t2 = document.createElement("textarea");
    t2.placeholder = "a";
    placeholderBug = t2.placeholder === t2.textContent;
  }
  return placeholderBug;
}
function fixPlaceholder(node) {
  if (hasPlaceholderBug() && node.localName === "textarea" && node.placeholder && node.placeholder === node.textContent) {
    node.textContent = null;
  }
}
const copyAttributeWithTemplateEventPolicy = (() => {
  const polymerTemplateEventAttributePolicy = window.trustedTypes && window.trustedTypes.createPolicy(
    "polymer-template-event-attribute-policy",
    {
      createScript: (x2) => x2
    }
  );
  return (dest, src, name) => {
    const value = src.getAttribute(name);
    if (polymerTemplateEventAttributePolicy && name.startsWith("on-")) {
      dest.setAttribute(
        name,
        polymerTemplateEventAttributePolicy.createScript(value, name)
      );
      return;
    }
    dest.setAttribute(name, value);
  };
})();
function wrapTemplateExtension(node) {
  let is = node.getAttribute("is");
  if (is && templateExtensions[is]) {
    let t2 = node;
    t2.removeAttribute("is");
    node = t2.ownerDocument.createElement(is);
    t2.parentNode.replaceChild(node, t2);
    node.appendChild(t2);
    while (t2.attributes.length) {
      const { name } = t2.attributes[0];
      copyAttributeWithTemplateEventPolicy(node, t2, name);
      t2.removeAttribute(name);
    }
  }
  return node;
}
function findTemplateNode(root2, nodeInfo) {
  let parent = nodeInfo.parentInfo && findTemplateNode(root2, nodeInfo.parentInfo);
  if (parent) {
    for (let n = parent.firstChild, i2 = 0; n; n = n.nextSibling) {
      if (nodeInfo.parentIndex === i2++) {
        return n;
      }
    }
  } else {
    return root2;
  }
}
function applyIdToMap(inst, map, node, nodeInfo) {
  if (nodeInfo.id) {
    map[nodeInfo.id] = node;
  }
}
function applyEventListener(inst, node, nodeInfo) {
  if (nodeInfo.events && nodeInfo.events.length) {
    for (let j = 0, e$ = nodeInfo.events, e2; j < e$.length && (e2 = e$[j]); j++) {
      inst._addMethodEventListenerToNode(node, e2.name, e2.value, inst);
    }
  }
}
function applyTemplateInfo(inst, node, nodeInfo, parentTemplateInfo) {
  if (nodeInfo.templateInfo) {
    node._templateInfo = nodeInfo.templateInfo;
    node._parentTemplateInfo = parentTemplateInfo;
  }
}
function createNodeEventHandler(context, eventName, methodName) {
  context = context._methodHost || context;
  let handler = function(e2) {
    if (context[methodName]) {
      context[methodName](e2, e2.detail);
    } else {
      console.warn("listener method `" + methodName + "` not defined");
    }
  };
  return handler;
}
const TemplateStamp = dedupingMixin(
  /**
   * @template T
   * @param {function(new:T)} superClass Class to apply mixin to.
   * @return {function(new:T)} superClass with mixin applied.
   */
  (superClass) => {
    class TemplateStamp2 extends superClass {
      /**
       * Scans a template to produce template metadata.
       *
       * Template-specific metadata are stored in the object returned, and node-
       * specific metadata are stored in objects in its flattened `nodeInfoList`
       * array.  Only nodes in the template that were parsed as nodes of
       * interest contain an object in `nodeInfoList`.  Each `nodeInfo` object
       * contains an `index` (`childNodes` index in parent) and optionally
       * `parent`, which points to node info of its parent (including its index).
       *
       * The template metadata object returned from this method has the following
       * structure (many fields optional):
       *
       * ```js
       *   {
       *     // Flattened list of node metadata (for nodes that generated metadata)
       *     nodeInfoList: [
       *       {
       *         // `id` attribute for any nodes with id's for generating `$` map
       *         id: {string},
       *         // `on-event="handler"` metadata
       *         events: [
       *           {
       *             name: {string},   // event name
       *             value: {string},  // handler method name
       *           }, ...
       *         ],
       *         // Notes when the template contained a `<slot>` for shady DOM
       *         // optimization purposes
       *         hasInsertionPoint: {boolean},
       *         // For nested `<template>`` nodes, nested template metadata
       *         templateInfo: {object}, // nested template metadata
       *         // Metadata to allow efficient retrieval of instanced node
       *         // corresponding to this metadata
       *         parentInfo: {number},   // reference to parent nodeInfo>
       *         parentIndex: {number},  // index in parent's `childNodes` collection
       *         infoIndex: {number},    // index of this `nodeInfo` in `templateInfo.nodeInfoList`
       *       },
       *       ...
       *     ],
       *     // When true, the template had the `strip-whitespace` attribute
       *     // or was nested in a template with that setting
       *     stripWhitespace: {boolean},
       *     // For nested templates, nested template content is moved into
       *     // a document fragment stored here; this is an optimization to
       *     // avoid the cost of nested template cloning
       *     content: {DocumentFragment}
       *   }
       * ```
       *
       * This method kicks off a recursive treewalk as follows:
       *
       * ```
       *    _parseTemplate <---------------------+
       *      _parseTemplateContent              |
       *        _parseTemplateNode  <------------|--+
       *          _parseTemplateNestedTemplate --+  |
       *          _parseTemplateChildNodes ---------+
       *          _parseTemplateNodeAttributes
       *            _parseTemplateNodeAttribute
       *
       * ```
       *
       * These methods may be overridden to add custom metadata about templates
       * to either `templateInfo` or `nodeInfo`.
       *
       * Note that this method may be destructive to the template, in that
       * e.g. event annotations may be removed after being noted in the
       * template metadata.
       *
       * @param {!HTMLTemplateElement} template Template to parse
       * @param {TemplateInfo=} outerTemplateInfo Template metadata from the outer
       *   template, for parsing nested templates
       * @return {!TemplateInfo} Parsed template metadata
       * @nocollapse
       */
      static _parseTemplate(template2, outerTemplateInfo) {
        if (!template2._templateInfo) {
          let templateInfo = template2._templateInfo = {};
          templateInfo.nodeInfoList = [];
          templateInfo.nestedTemplate = Boolean(outerTemplateInfo);
          templateInfo.stripWhiteSpace = outerTemplateInfo && outerTemplateInfo.stripWhiteSpace || template2.hasAttribute && template2.hasAttribute("strip-whitespace");
          this._parseTemplateContent(
            template2,
            templateInfo,
            /** @type {?} */
            { parent: null }
          );
        }
        return template2._templateInfo;
      }
      /**
       * See docs for _parseTemplateNode.
       *
       * @param {!HTMLTemplateElement} template .
       * @param {!TemplateInfo} templateInfo .
       * @param {!NodeInfo} nodeInfo .
       * @return {boolean} .
       * @nocollapse
       */
      static _parseTemplateContent(template2, templateInfo, nodeInfo) {
        return this._parseTemplateNode(template2.content, templateInfo, nodeInfo);
      }
      /**
       * Parses template node and adds template and node metadata based on
       * the current node, and its `childNodes` and `attributes`.
       *
       * This method may be overridden to add custom node or template specific
       * metadata based on this node.
       *
       * @param {Node} node Node to parse
       * @param {!TemplateInfo} templateInfo Template metadata for current template
       * @param {!NodeInfo} nodeInfo Node metadata for current template.
       * @return {boolean} `true` if the visited node added node-specific
       *   metadata to `nodeInfo`
       * @nocollapse
       */
      static _parseTemplateNode(node, templateInfo, nodeInfo) {
        let noted = false;
        let element = (
          /** @type {!HTMLTemplateElement} */
          node
        );
        if (element.localName == "template" && !element.hasAttribute("preserve-content")) {
          noted = this._parseTemplateNestedTemplate(element, templateInfo, nodeInfo) || noted;
        } else if (element.localName === "slot") {
          templateInfo.hasInsertionPoint = true;
        }
        fixPlaceholder(element);
        if (element.firstChild) {
          this._parseTemplateChildNodes(element, templateInfo, nodeInfo);
        }
        if (element.hasAttributes && element.hasAttributes()) {
          noted = this._parseTemplateNodeAttributes(element, templateInfo, nodeInfo) || noted;
        }
        return noted || nodeInfo.noted;
      }
      /**
       * Parses template child nodes for the given root node.
       *
       * This method also wraps whitelisted legacy template extensions
       * (`is="dom-if"` and `is="dom-repeat"`) with their equivalent element
       * wrappers, collapses text nodes, and strips whitespace from the template
       * if the `templateInfo.stripWhitespace` setting was provided.
       *
       * @param {Node} root Root node whose `childNodes` will be parsed
       * @param {!TemplateInfo} templateInfo Template metadata for current template
       * @param {!NodeInfo} nodeInfo Node metadata for current template.
       * @return {void}
       */
      static _parseTemplateChildNodes(root2, templateInfo, nodeInfo) {
        if (root2.localName === "script" || root2.localName === "style") {
          return;
        }
        for (let node = root2.firstChild, parentIndex = 0, next; node; node = next) {
          if (node.localName == "template") {
            node = wrapTemplateExtension(node);
          }
          next = node.nextSibling;
          if (node.nodeType === Node.TEXT_NODE) {
            let n = next;
            while (n && n.nodeType === Node.TEXT_NODE) {
              node.textContent += n.textContent;
              next = n.nextSibling;
              root2.removeChild(n);
              n = next;
            }
            if (templateInfo.stripWhiteSpace && !node.textContent.trim()) {
              root2.removeChild(node);
              continue;
            }
          }
          let childInfo = (
            /** @type {!NodeInfo} */
            { parentIndex, parentInfo: nodeInfo }
          );
          if (this._parseTemplateNode(node, templateInfo, childInfo)) {
            childInfo.infoIndex = templateInfo.nodeInfoList.push(childInfo) - 1;
          }
          if (node.parentNode) {
            parentIndex++;
          }
        }
      }
      /**
       * Parses template content for the given nested `<template>`.
       *
       * Nested template info is stored as `templateInfo` in the current node's
       * `nodeInfo`. `template.content` is removed and stored in `templateInfo`.
       * It will then be the responsibility of the host to set it back to the
       * template and for users stamping nested templates to use the
       * `_contentForTemplate` method to retrieve the content for this template
       * (an optimization to avoid the cost of cloning nested template content).
       *
       * @param {HTMLTemplateElement} node Node to parse (a <template>)
       * @param {TemplateInfo} outerTemplateInfo Template metadata for current template
       *   that includes the template `node`
       * @param {!NodeInfo} nodeInfo Node metadata for current template.
       * @return {boolean} `true` if the visited node added node-specific
       *   metadata to `nodeInfo`
       * @nocollapse
       */
      static _parseTemplateNestedTemplate(node, outerTemplateInfo, nodeInfo) {
        let element = (
          /** @type {!HTMLTemplateElement} */
          node
        );
        let templateInfo = this._parseTemplate(element, outerTemplateInfo);
        let content = templateInfo.content = element.content.ownerDocument.createDocumentFragment();
        content.appendChild(element.content);
        nodeInfo.templateInfo = templateInfo;
        return true;
      }
      /**
       * Parses template node attributes and adds node metadata to `nodeInfo`
       * for nodes of interest.
       *
       * @param {Element} node Node to parse
       * @param {!TemplateInfo} templateInfo Template metadata for current
       *     template
       * @param {!NodeInfo} nodeInfo Node metadata for current template.
       * @return {boolean} `true` if the visited node added node-specific
       *   metadata to `nodeInfo`
       * @nocollapse
       */
      static _parseTemplateNodeAttributes(node, templateInfo, nodeInfo) {
        let noted = false;
        let attrs = Array.from(node.attributes);
        for (let i2 = attrs.length - 1, a3; a3 = attrs[i2]; i2--) {
          noted = this._parseTemplateNodeAttribute(node, templateInfo, nodeInfo, a3.name, a3.value) || noted;
        }
        return noted;
      }
      /**
       * Parses a single template node attribute and adds node metadata to
       * `nodeInfo` for attributes of interest.
       *
       * This implementation adds metadata for `on-event="handler"` attributes
       * and `id` attributes.
       *
       * @param {Element} node Node to parse
       * @param {!TemplateInfo} templateInfo Template metadata for current template
       * @param {!NodeInfo} nodeInfo Node metadata for current template.
       * @param {string} name Attribute name
       * @param {string} value Attribute value
       * @return {boolean} `true` if the visited node added node-specific
       *   metadata to `nodeInfo`
       * @nocollapse
       */
      static _parseTemplateNodeAttribute(node, templateInfo, nodeInfo, name, value) {
        if (name.slice(0, 3) === "on-") {
          node.removeAttribute(name);
          nodeInfo.events = nodeInfo.events || [];
          nodeInfo.events.push({
            name: name.slice(3),
            value
          });
          return true;
        } else if (name === "id") {
          nodeInfo.id = value;
          return true;
        }
        return false;
      }
      /**
       * Returns the `content` document fragment for a given template.
       *
       * For nested templates, Polymer performs an optimization to cache nested
       * template content to avoid the cost of cloning deeply nested templates.
       * This method retrieves the cached content for a given template.
       *
       * @param {HTMLTemplateElement} template Template to retrieve `content` for
       * @return {DocumentFragment} Content fragment
       * @nocollapse
       */
      static _contentForTemplate(template2) {
        let templateInfo = (
          /** @type {HTMLTemplateElementWithInfo} */
          template2._templateInfo
        );
        return templateInfo && templateInfo.content || template2.content;
      }
      /**
       * Clones the provided template content and returns a document fragment
       * containing the cloned dom.
       *
       * The template is parsed (once and memoized) using this library's
       * template parsing features, and provides the following value-added
       * features:
       * * Adds declarative event listeners for `on-event="handler"` attributes
       * * Generates an "id map" for all nodes with id's under `$` on returned
       *   document fragment
       * * Passes template info including `content` back to templates as
       *   `_templateInfo` (a performance optimization to avoid deep template
       *   cloning)
       *
       * Note that the memoized template parsing process is destructive to the
       * template: attributes for bindings and declarative event listeners are
       * removed after being noted in notes, and any nested `<template>.content`
       * is removed and stored in notes as well.
       *
       * @param {!HTMLTemplateElement} template Template to stamp
       * @param {TemplateInfo=} templateInfo Optional template info associated
       *   with the template to be stamped; if omitted the template will be
       *   automatically parsed.
       * @return {!StampedTemplate} Cloned template content
       * @override
       */
      _stampTemplate(template2, templateInfo) {
        if (template2 && !template2.content && window.HTMLTemplateElement && HTMLTemplateElement.decorate) {
          HTMLTemplateElement.decorate(template2);
        }
        templateInfo = templateInfo || this.constructor._parseTemplate(template2);
        let nodeInfo = templateInfo.nodeInfoList;
        let content = templateInfo.content || template2.content;
        let dom = (
          /** @type {DocumentFragment} */
          document.importNode(content, true)
        );
        dom.__noInsertionPoint = !templateInfo.hasInsertionPoint;
        let nodes = dom.nodeList = new Array(nodeInfo.length);
        dom.$ = {};
        for (let i2 = 0, l = nodeInfo.length, info; i2 < l && (info = nodeInfo[i2]); i2++) {
          let node = nodes[i2] = findTemplateNode(dom, info);
          applyIdToMap(this, dom.$, node, info);
          applyTemplateInfo(this, node, info, templateInfo);
          applyEventListener(this, node, info);
        }
        dom = /** @type {!StampedTemplate} */
        dom;
        return dom;
      }
      /**
       * Adds an event listener by method name for the event provided.
       *
       * This method generates a handler function that looks up the method
       * name at handling time.
       *
       * @param {!EventTarget} node Node to add listener on
       * @param {string} eventName Name of event
       * @param {string} methodName Name of method
       * @param {*=} context Context the method will be called on (defaults
       *   to `node`)
       * @return {Function} Generated handler function
       * @override
       */
      _addMethodEventListenerToNode(node, eventName, methodName, context) {
        context = context || node;
        let handler = createNodeEventHandler(context, eventName, methodName);
        this._addEventListenerToNode(node, eventName, handler);
        return handler;
      }
      /**
       * Override point for adding custom or simulated event handling.
       *
       * @param {!EventTarget} node Node to add event listener to
       * @param {string} eventName Name of event
       * @param {function(!Event):void} handler Listener function to add
       * @return {void}
       * @override
       */
      _addEventListenerToNode(node, eventName, handler) {
        node.addEventListener(eventName, handler);
      }
      /**
       * Override point for adding custom or simulated event handling.
       *
       * @param {!EventTarget} node Node to remove event listener from
       * @param {string} eventName Name of event
       * @param {function(!Event):void} handler Listener function to remove
       * @return {void}
       * @override
       */
      _removeEventListenerFromNode(node, eventName, handler) {
        node.removeEventListener(eventName, handler);
      }
    }
    return TemplateStamp2;
  }
);
/**
 * @fileoverview
 * @suppress {checkPrototypalTypes}
 * @license Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt The complete set of authors may be found
 * at http://polymer.github.io/AUTHORS.txt The complete set of contributors may
 * be found at http://polymer.github.io/CONTRIBUTORS.txt Code distributed by
 * Google as part of the polymer project is also subject to an additional IP
 * rights grant found at http://polymer.github.io/PATENTS.txt
 */
let dedupeId = 0;
const NOOP = [];
const TYPES = {
  COMPUTE: "__computeEffects",
  REFLECT: "__reflectEffects",
  NOTIFY: "__notifyEffects",
  PROPAGATE: "__propagateEffects",
  OBSERVE: "__observeEffects",
  READ_ONLY: "__readOnly"
};
const COMPUTE_INFO = "__computeInfo";
const capitalAttributeRegex = /[A-Z]/;
function ensureOwnEffectMap(model, type, cloneArrays) {
  let effects = model[type];
  if (!effects) {
    effects = model[type] = {};
  } else if (!model.hasOwnProperty(type)) {
    effects = model[type] = Object.create(model[type]);
    if (cloneArrays) {
      for (let p in effects) {
        let protoFx = effects[p];
        let instFx = effects[p] = Array(protoFx.length);
        for (let i2 = 0; i2 < protoFx.length; i2++) {
          instFx[i2] = protoFx[i2];
        }
      }
    }
  }
  return effects;
}
function runEffects(inst, effects, props, oldProps, hasPaths, extraArgs) {
  if (effects) {
    let ran = false;
    const id = dedupeId++;
    for (let prop in props) {
      let rootProperty = hasPaths ? root(prop) : prop;
      let fxs = effects[rootProperty];
      if (fxs) {
        for (let i2 = 0, l = fxs.length, fx; i2 < l && (fx = fxs[i2]); i2++) {
          if ((!fx.info || fx.info.lastRun !== id) && (!hasPaths || pathMatchesTrigger(prop, fx.trigger))) {
            if (fx.info) {
              fx.info.lastRun = id;
            }
            fx.fn(inst, prop, props, oldProps, fx.info, hasPaths, extraArgs);
            ran = true;
          }
        }
      }
    }
    return ran;
  }
  return false;
}
function runEffectsForProperty(inst, effects, dedupeId2, prop, props, oldProps, hasPaths, extraArgs) {
  let ran = false;
  let rootProperty = hasPaths ? root(prop) : prop;
  let fxs = effects[rootProperty];
  if (fxs) {
    for (let i2 = 0, l = fxs.length, fx; i2 < l && (fx = fxs[i2]); i2++) {
      if ((!fx.info || fx.info.lastRun !== dedupeId2) && (!hasPaths || pathMatchesTrigger(prop, fx.trigger))) {
        if (fx.info) {
          fx.info.lastRun = dedupeId2;
        }
        fx.fn(inst, prop, props, oldProps, fx.info, hasPaths, extraArgs);
        ran = true;
      }
    }
  }
  return ran;
}
function pathMatchesTrigger(path, trigger) {
  if (trigger) {
    let triggerPath = (
      /** @type {string} */
      trigger.name
    );
    return triggerPath == path || !!(trigger.structured && isAncestor(triggerPath, path)) || !!(trigger.wildcard && isDescendant(triggerPath, path));
  } else {
    return true;
  }
}
function runObserverEffect(inst, property, props, oldProps, info) {
  let fn = typeof info.method === "string" ? inst[info.method] : info.method;
  let changedProp = info.property;
  if (fn) {
    fn.call(inst, inst.__data[changedProp], oldProps[changedProp]);
  } else if (!info.dynamicFn) {
    console.warn("observer method `" + info.method + "` not defined");
  }
}
function runNotifyEffects(inst, notifyProps, props, oldProps, hasPaths) {
  let fxs = inst[TYPES.NOTIFY];
  let notified;
  let id = dedupeId++;
  for (let prop in notifyProps) {
    if (notifyProps[prop]) {
      if (fxs && runEffectsForProperty(inst, fxs, id, prop, props, oldProps, hasPaths)) {
        notified = true;
      } else if (hasPaths && notifyPath(inst, prop, props)) {
        notified = true;
      }
    }
  }
  let host;
  if (notified && (host = inst.__dataHost) && host._invalidateProperties) {
    host._invalidateProperties();
  }
}
function notifyPath(inst, path, props) {
  let rootProperty = root(path);
  if (rootProperty !== path) {
    let eventName = camelToDashCase(rootProperty) + "-changed";
    dispatchNotifyEvent(inst, eventName, props[path], path);
    return true;
  }
  return false;
}
function dispatchNotifyEvent(inst, eventName, value, path) {
  let detail = {
    value,
    queueProperty: true
  };
  if (path) {
    detail.path = path;
  }
  wrap$1(
    /** @type {!HTMLElement} */
    inst
  ).dispatchEvent(new CustomEvent(eventName, { detail }));
}
function runNotifyEffect(inst, property, props, oldProps, info, hasPaths) {
  let rootProperty = hasPaths ? root(property) : property;
  let path = rootProperty != property ? property : null;
  let value = path ? get$1(inst, path) : inst.__data[property];
  if (path && value === void 0) {
    value = props[property];
  }
  dispatchNotifyEvent(inst, info.eventName, value, path);
}
function handleNotification(event, inst, fromProp, toPath, negate) {
  let value;
  let detail = (
    /** @type {Object} */
    event.detail
  );
  let fromPath = detail && detail.path;
  if (fromPath) {
    toPath = translate(fromProp, toPath, fromPath);
    value = detail && detail.value;
  } else {
    value = event.currentTarget[fromProp];
  }
  value = negate ? !value : value;
  if (!inst[TYPES.READ_ONLY] || !inst[TYPES.READ_ONLY][toPath]) {
    if (inst._setPendingPropertyOrPath(toPath, value, true, Boolean(fromPath)) && (!detail || !detail.queueProperty)) {
      inst._invalidateProperties();
    }
  }
}
function runReflectEffect(inst, property, props, oldProps, info) {
  let value = inst.__data[property];
  if (sanitizeDOMValue) {
    value = sanitizeDOMValue(
      value,
      info.attrName,
      "attribute",
      /** @type {Node} */
      inst
    );
  }
  inst._propertyToAttribute(property, info.attrName, value);
}
function runComputedEffects(inst, changedProps, oldProps, hasPaths) {
  let computeEffects = inst[TYPES.COMPUTE];
  if (computeEffects) {
    if (orderedComputed) {
      dedupeId++;
      const order = getComputedOrder(inst);
      const queue = [];
      for (let p in changedProps) {
        enqueueEffectsFor(p, computeEffects, queue, order, hasPaths);
      }
      let info;
      while (info = queue.shift()) {
        if (runComputedEffect(inst, "", changedProps, oldProps, info)) {
          enqueueEffectsFor(info.methodInfo, computeEffects, queue, order, hasPaths);
        }
      }
      Object.assign(
        /** @type {!Object} */
        oldProps,
        inst.__dataOld
      );
      Object.assign(
        /** @type {!Object} */
        changedProps,
        inst.__dataPending
      );
      inst.__dataPending = null;
    } else {
      let inputProps = changedProps;
      while (runEffects(inst, computeEffects, inputProps, oldProps, hasPaths)) {
        Object.assign(
          /** @type {!Object} */
          oldProps,
          inst.__dataOld
        );
        Object.assign(
          /** @type {!Object} */
          changedProps,
          inst.__dataPending
        );
        inputProps = inst.__dataPending;
        inst.__dataPending = null;
      }
    }
  }
}
const insertEffect = (info, queue, order) => {
  let start = 0;
  let end = queue.length - 1;
  let idx = -1;
  while (start <= end) {
    const mid = start + end >> 1;
    const cmp = order.get(queue[mid].methodInfo) - order.get(info.methodInfo);
    if (cmp < 0) {
      start = mid + 1;
    } else if (cmp > 0) {
      end = mid - 1;
    } else {
      idx = mid;
      break;
    }
  }
  if (idx < 0) {
    idx = end + 1;
  }
  queue.splice(idx, 0, info);
};
const enqueueEffectsFor = (prop, computeEffects, queue, order, hasPaths) => {
  const rootProperty = hasPaths ? root(prop) : prop;
  const fxs = computeEffects[rootProperty];
  if (fxs) {
    for (let i2 = 0; i2 < fxs.length; i2++) {
      const fx = fxs[i2];
      if (fx.info.lastRun !== dedupeId && (!hasPaths || pathMatchesTrigger(prop, fx.trigger))) {
        fx.info.lastRun = dedupeId;
        insertEffect(fx.info, queue, order);
      }
    }
  }
};
function getComputedOrder(inst) {
  let ordered = inst.constructor.__orderedComputedDeps;
  if (!ordered) {
    ordered = /* @__PURE__ */ new Map();
    const effects = inst[TYPES.COMPUTE];
    let { counts, ready, total } = dependencyCounts(inst);
    let curr;
    while (curr = ready.shift()) {
      ordered.set(curr, ordered.size);
      const computedByCurr = effects[curr];
      if (computedByCurr) {
        computedByCurr.forEach((fx) => {
          const computedProp = fx.info.methodInfo;
          --total;
          if (--counts[computedProp] === 0) {
            ready.push(computedProp);
          }
        });
      }
    }
    if (total !== 0) {
      const el = (
        /** @type {HTMLElement} */
        inst
      );
      console.warn(`Computed graph for ${el.localName} incomplete; circular?`);
    }
    inst.constructor.__orderedComputedDeps = ordered;
  }
  return ordered;
}
function dependencyCounts(inst) {
  const infoForComputed = inst[COMPUTE_INFO];
  const counts = {};
  const computedDeps = inst[TYPES.COMPUTE];
  const ready = [];
  let total = 0;
  for (let p in infoForComputed) {
    const info = infoForComputed[p];
    total += counts[p] = info.args.filter((a3) => !a3.literal).length + (info.dynamicFn ? 1 : 0);
  }
  for (let p in computedDeps) {
    if (!infoForComputed[p]) {
      ready.push(p);
    }
  }
  return { counts, ready, total };
}
function runComputedEffect(inst, property, changedProps, oldProps, info) {
  let result = runMethodEffect(inst, property, changedProps, oldProps, info);
  if (result === NOOP) {
    return false;
  }
  let computedProp = info.methodInfo;
  if (inst.__dataHasAccessor && inst.__dataHasAccessor[computedProp]) {
    return inst._setPendingProperty(computedProp, result, true);
  } else {
    inst[computedProp] = result;
    return false;
  }
}
function computeLinkedPaths(inst, path, value) {
  let links = inst.__dataLinkedPaths;
  if (links) {
    let link;
    for (let a3 in links) {
      let b2 = links[a3];
      if (isDescendant(a3, path)) {
        link = translate(a3, b2, path);
        inst._setPendingPropertyOrPath(link, value, true, true);
      } else if (isDescendant(b2, path)) {
        link = translate(b2, a3, path);
        inst._setPendingPropertyOrPath(link, value, true, true);
      }
    }
  }
}
function addBinding(constructor, templateInfo, nodeInfo, kind, target, parts, literal) {
  nodeInfo.bindings = nodeInfo.bindings || [];
  let binding = { kind, target, parts, literal, isCompound: parts.length !== 1 };
  nodeInfo.bindings.push(binding);
  if (shouldAddListener(binding)) {
    let { event, negate } = binding.parts[0];
    binding.listenerEvent = event || camelToDashCase(target) + "-changed";
    binding.listenerNegate = negate;
  }
  let index = templateInfo.nodeInfoList.length;
  for (let i2 = 0; i2 < binding.parts.length; i2++) {
    let part = binding.parts[i2];
    part.compoundIndex = i2;
    addEffectForBindingPart(constructor, templateInfo, binding, part, index);
  }
}
function addEffectForBindingPart(constructor, templateInfo, binding, part, index) {
  if (!part.literal) {
    if (binding.kind === "attribute" && binding.target[0] === "-") {
      console.warn("Cannot set attribute " + binding.target + ' because "-" is not a valid attribute starting character');
    } else {
      let dependencies = part.dependencies;
      let info = { index, binding, part, evaluator: constructor };
      for (let j = 0; j < dependencies.length; j++) {
        let trigger = dependencies[j];
        if (typeof trigger == "string") {
          trigger = parseArg(trigger);
          trigger.wildcard = true;
        }
        constructor._addTemplatePropertyEffect(templateInfo, trigger.rootProperty, {
          fn: runBindingEffect,
          info,
          trigger
        });
      }
    }
  }
}
function runBindingEffect(inst, path, props, oldProps, info, hasPaths, nodeList) {
  let node = nodeList[info.index];
  let binding = info.binding;
  let part = info.part;
  if (hasPaths && part.source && path.length > part.source.length && binding.kind == "property" && !binding.isCompound && node.__isPropertyEffectsClient && node.__dataHasAccessor && node.__dataHasAccessor[binding.target]) {
    let value = props[path];
    path = translate(part.source, binding.target, path);
    if (node._setPendingPropertyOrPath(path, value, false, true)) {
      inst._enqueueClient(node);
    }
  } else {
    let value = info.evaluator._evaluateBinding(inst, part, path, props, oldProps, hasPaths);
    if (value !== NOOP) {
      applyBindingValue(inst, node, binding, part, value);
    }
  }
}
function applyBindingValue(inst, node, binding, part, value) {
  value = computeBindingValue(node, value, binding, part);
  if (sanitizeDOMValue) {
    value = sanitizeDOMValue(value, binding.target, binding.kind, node);
  }
  if (binding.kind == "attribute") {
    inst._valueToNodeAttribute(
      /** @type {Element} */
      node,
      value,
      binding.target
    );
  } else {
    let prop = binding.target;
    if (node.__isPropertyEffectsClient && node.__dataHasAccessor && node.__dataHasAccessor[prop]) {
      if (!node[TYPES.READ_ONLY] || !node[TYPES.READ_ONLY][prop]) {
        if (node._setPendingProperty(prop, value)) {
          inst._enqueueClient(node);
        }
      }
    } else {
      inst._setUnmanagedPropertyToNode(node, prop, value);
    }
  }
}
function computeBindingValue(node, value, binding, part) {
  if (binding.isCompound) {
    let storage = node.__dataCompoundStorage[binding.target];
    storage[part.compoundIndex] = value;
    value = storage.join("");
  }
  if (binding.kind !== "attribute") {
    if (binding.target === "textContent" || binding.target === "value" && (node.localName === "input" || node.localName === "textarea")) {
      value = value == void 0 ? "" : value;
    }
  }
  return value;
}
function shouldAddListener(binding) {
  return Boolean(binding.target) && binding.kind != "attribute" && binding.kind != "text" && !binding.isCompound && binding.parts[0].mode === "{";
}
function setupBindings(inst, templateInfo) {
  let { nodeList, nodeInfoList } = templateInfo;
  if (nodeInfoList.length) {
    for (let i2 = 0; i2 < nodeInfoList.length; i2++) {
      let info = nodeInfoList[i2];
      let node = nodeList[i2];
      let bindings = info.bindings;
      if (bindings) {
        for (let i3 = 0; i3 < bindings.length; i3++) {
          let binding = bindings[i3];
          setupCompoundStorage(node, binding);
          addNotifyListener(node, inst, binding);
        }
      }
      node.__dataHost = inst;
    }
  }
}
function setupCompoundStorage(node, binding) {
  if (binding.isCompound) {
    let storage = node.__dataCompoundStorage || (node.__dataCompoundStorage = {});
    let parts = binding.parts;
    let literals = new Array(parts.length);
    for (let j = 0; j < parts.length; j++) {
      literals[j] = parts[j].literal;
    }
    let target = binding.target;
    storage[target] = literals;
    if (binding.literal && binding.kind == "property") {
      if (target === "className") {
        node = wrap$1(node);
      }
      node[target] = binding.literal;
    }
  }
}
function addNotifyListener(node, inst, binding) {
  if (binding.listenerEvent) {
    let part = binding.parts[0];
    node.addEventListener(binding.listenerEvent, function(e2) {
      handleNotification(e2, inst, binding.target, part.source, part.negate);
    });
  }
}
function createMethodEffect(model, sig, type, effectFn, methodInfo, dynamicFn) {
  dynamicFn = sig.static || dynamicFn && (typeof dynamicFn !== "object" || dynamicFn[sig.methodName]);
  let info = {
    methodName: sig.methodName,
    args: sig.args,
    methodInfo,
    dynamicFn
  };
  for (let i2 = 0, arg; i2 < sig.args.length && (arg = sig.args[i2]); i2++) {
    if (!arg.literal) {
      model._addPropertyEffect(arg.rootProperty, type, {
        fn: effectFn,
        info,
        trigger: arg
      });
    }
  }
  if (dynamicFn) {
    model._addPropertyEffect(sig.methodName, type, {
      fn: effectFn,
      info
    });
  }
  return info;
}
function runMethodEffect(inst, property, props, oldProps, info) {
  let context = inst._methodHost || inst;
  let fn = context[info.methodName];
  if (fn) {
    let args = inst._marshalArgs(info.args, property, props);
    return args === NOOP ? NOOP : fn.apply(context, args);
  } else if (!info.dynamicFn) {
    console.warn("method `" + info.methodName + "` not defined");
  }
}
const emptyArray = [];
const IDENT = "(?:[a-zA-Z_$][\\w.:$\\-*]*)";
const NUMBER = "(?:[-+]?[0-9]*\\.?[0-9]+(?:[eE][-+]?[0-9]+)?)";
const SQUOTE_STRING = "(?:'(?:[^'\\\\]|\\\\.)*')";
const DQUOTE_STRING = '(?:"(?:[^"\\\\]|\\\\.)*")';
const STRING = "(?:" + SQUOTE_STRING + "|" + DQUOTE_STRING + ")";
const ARGUMENT = "(?:(" + IDENT + "|" + NUMBER + "|" + STRING + ")\\s*)";
const ARGUMENTS = "(?:" + ARGUMENT + "(?:,\\s*" + ARGUMENT + ")*)";
const ARGUMENT_LIST = "(?:\\(\\s*(?:" + ARGUMENTS + "?)\\)\\s*)";
const BINDING = "(" + IDENT + "\\s*" + ARGUMENT_LIST + "?)";
const OPEN_BRACKET = "(\\[\\[|{{)\\s*";
const CLOSE_BRACKET = "(?:]]|}})";
const NEGATE = "(?:(!)\\s*)?";
const EXPRESSION = OPEN_BRACKET + NEGATE + BINDING + CLOSE_BRACKET;
const bindingRegex = new RegExp(EXPRESSION, "g");
function literalFromParts(parts) {
  let s3 = "";
  for (let i2 = 0; i2 < parts.length; i2++) {
    let literal = parts[i2].literal;
    s3 += literal || "";
  }
  return s3;
}
function parseMethod(expression) {
  let m3 = expression.match(/([^\s]+?)\(([\s\S]*)\)/);
  if (m3) {
    let methodName = m3[1];
    let sig = { methodName, static: true, args: emptyArray };
    if (m3[2].trim()) {
      let args = m3[2].replace(/\\,/g, "&comma;").split(",");
      return parseArgs(args, sig);
    } else {
      return sig;
    }
  }
  return null;
}
function parseArgs(argList, sig) {
  sig.args = argList.map(function(rawArg) {
    let arg = parseArg(rawArg);
    if (!arg.literal) {
      sig.static = false;
    }
    return arg;
  }, this);
  return sig;
}
function parseArg(rawArg) {
  let arg = rawArg.trim().replace(/&comma;/g, ",").replace(/\\(.)/g, "$1");
  let a3 = {
    name: arg,
    value: "",
    literal: false
  };
  let fc = arg[0];
  if (fc === "-") {
    fc = arg[1];
  }
  if (fc >= "0" && fc <= "9") {
    fc = "#";
  }
  switch (fc) {
    case "'":
    case '"':
      a3.value = arg.slice(1, -1);
      a3.literal = true;
      break;
    case "#":
      a3.value = Number(arg);
      a3.literal = true;
      break;
  }
  if (!a3.literal) {
    a3.rootProperty = root(arg);
    a3.structured = isPath(arg);
    if (a3.structured) {
      a3.wildcard = arg.slice(-2) == ".*";
      if (a3.wildcard) {
        a3.name = arg.slice(0, -2);
      }
    }
  }
  return a3;
}
function getArgValue(data, props, path) {
  let value = get$1(data, path);
  if (value === void 0) {
    value = props[path];
  }
  return value;
}
function notifySplices(inst, array, path, splices) {
  const splicesData = { indexSplices: splices };
  if (legacyUndefined && !inst._overrideLegacyUndefined) {
    array.splices = splicesData;
  }
  inst.notifyPath(path + ".splices", splicesData);
  inst.notifyPath(path + ".length", array.length);
  if (legacyUndefined && !inst._overrideLegacyUndefined) {
    splicesData.indexSplices = [];
  }
}
function notifySplice(inst, array, path, index, addedCount, removed) {
  notifySplices(inst, array, path, [{
    index,
    addedCount,
    removed,
    object: array,
    type: "splice"
  }]);
}
function upper(name) {
  return name[0].toUpperCase() + name.substring(1);
}
const PropertyEffects = dedupingMixin((superClass) => {
  const propertyEffectsBase = TemplateStamp(PropertyAccessors(superClass));
  class PropertyEffects2 extends propertyEffectsBase {
    constructor() {
      super();
      this.__isPropertyEffectsClient = true;
      this.__dataClientsReady;
      this.__dataPendingClients;
      this.__dataToNotify;
      this.__dataLinkedPaths;
      this.__dataHasPaths;
      this.__dataCompoundStorage;
      this.__dataHost;
      this.__dataTemp;
      this.__dataClientsInitialized;
      this.__data;
      this.__dataPending;
      this.__dataOld;
      this.__computeEffects;
      this.__computeInfo;
      this.__reflectEffects;
      this.__notifyEffects;
      this.__propagateEffects;
      this.__observeEffects;
      this.__readOnly;
      this.__templateInfo;
      this._overrideLegacyUndefined;
    }
    get PROPERTY_EFFECT_TYPES() {
      return TYPES;
    }
    /**
     * @override
     * @return {void}
     */
    _initializeProperties() {
      super._initializeProperties();
      this._registerHost();
      this.__dataClientsReady = false;
      this.__dataPendingClients = null;
      this.__dataToNotify = null;
      this.__dataLinkedPaths = null;
      this.__dataHasPaths = false;
      this.__dataCompoundStorage = this.__dataCompoundStorage || null;
      this.__dataHost = this.__dataHost || null;
      this.__dataTemp = {};
      this.__dataClientsInitialized = false;
    }
    _registerHost() {
      if (hostStack.length) {
        let host = hostStack[hostStack.length - 1];
        host._enqueueClient(this);
        this.__dataHost = host;
      }
    }
    /**
     * Overrides `PropertyAccessors` implementation to provide a
     * more efficient implementation of initializing properties from
     * the prototype on the instance.
     *
     * @override
     * @param {Object} props Properties to initialize on the prototype
     * @return {void}
     */
    _initializeProtoProperties(props) {
      this.__data = Object.create(props);
      this.__dataPending = Object.create(props);
      this.__dataOld = {};
    }
    /**
     * Overrides `PropertyAccessors` implementation to avoid setting
     * `_setProperty`'s `shouldNotify: true`.
     *
     * @override
     * @param {Object} props Properties to initialize on the instance
     * @return {void}
     */
    _initializeInstanceProperties(props) {
      let readOnly = this[TYPES.READ_ONLY];
      for (let prop in props) {
        if (!readOnly || !readOnly[prop]) {
          this.__dataPending = this.__dataPending || {};
          this.__dataOld = this.__dataOld || {};
          this.__data[prop] = this.__dataPending[prop] = props[prop];
        }
      }
    }
    // Prototype setup ----------------------------------------
    /**
     * Equivalent to static `addPropertyEffect` API but can be called on
     * an instance to add effects at runtime.  See that method for
     * full API docs.
     *
     * @override
     * @param {string} property Property that should trigger the effect
     * @param {string} type Effect type, from this.PROPERTY_EFFECT_TYPES
     * @param {Object=} effect Effect metadata object
     * @return {void}
     * @protected
     */
    _addPropertyEffect(property, type, effect) {
      this._createPropertyAccessor(property, type == TYPES.READ_ONLY);
      let effects = ensureOwnEffectMap(this, type, true)[property];
      if (!effects) {
        effects = this[type][property] = [];
      }
      effects.push(effect);
    }
    /**
     * Removes the given property effect.
     *
     * @override
     * @param {string} property Property the effect was associated with
     * @param {string} type Effect type, from this.PROPERTY_EFFECT_TYPES
     * @param {Object=} effect Effect metadata object to remove
     * @return {void}
     */
    _removePropertyEffect(property, type, effect) {
      let effects = ensureOwnEffectMap(this, type, true)[property];
      let idx = effects.indexOf(effect);
      if (idx >= 0) {
        effects.splice(idx, 1);
      }
    }
    /**
     * Returns whether the current prototype/instance has a property effect
     * of a certain type.
     *
     * @override
     * @param {string} property Property name
     * @param {string=} type Effect type, from this.PROPERTY_EFFECT_TYPES
     * @return {boolean} True if the prototype/instance has an effect of this
     *     type
     * @protected
     */
    _hasPropertyEffect(property, type) {
      let effects = this[type];
      return Boolean(effects && effects[property]);
    }
    /**
     * Returns whether the current prototype/instance has a "read only"
     * accessor for the given property.
     *
     * @override
     * @param {string} property Property name
     * @return {boolean} True if the prototype/instance has an effect of this
     *     type
     * @protected
     */
    _hasReadOnlyEffect(property) {
      return this._hasPropertyEffect(property, TYPES.READ_ONLY);
    }
    /**
     * Returns whether the current prototype/instance has a "notify"
     * property effect for the given property.
     *
     * @override
     * @param {string} property Property name
     * @return {boolean} True if the prototype/instance has an effect of this
     *     type
     * @protected
     */
    _hasNotifyEffect(property) {
      return this._hasPropertyEffect(property, TYPES.NOTIFY);
    }
    /**
     * Returns whether the current prototype/instance has a "reflect to
     * attribute" property effect for the given property.
     *
     * @override
     * @param {string} property Property name
     * @return {boolean} True if the prototype/instance has an effect of this
     *     type
     * @protected
     */
    _hasReflectEffect(property) {
      return this._hasPropertyEffect(property, TYPES.REFLECT);
    }
    /**
     * Returns whether the current prototype/instance has a "computed"
     * property effect for the given property.
     *
     * @override
     * @param {string} property Property name
     * @return {boolean} True if the prototype/instance has an effect of this
     *     type
     * @protected
     */
    _hasComputedEffect(property) {
      return this._hasPropertyEffect(property, TYPES.COMPUTE);
    }
    // Runtime ----------------------------------------
    /**
     * Sets a pending property or path.  If the root property of the path in
     * question had no accessor, the path is set, otherwise it is enqueued
     * via `_setPendingProperty`.
     *
     * This function isolates relatively expensive functionality necessary
     * for the public API (`set`, `setProperties`, `notifyPath`, and property
     * change listeners via {{...}} bindings), such that it is only done
     * when paths enter the system, and not at every propagation step.  It
     * also sets a `__dataHasPaths` flag on the instance which is used to
     * fast-path slower path-matching code in the property effects host paths.
     *
     * `path` can be a path string or array of path parts as accepted by the
     * public API.
     *
     * @override
     * @param {string | !Array<number|string>} path Path to set
     * @param {*} value Value to set
     * @param {boolean=} shouldNotify Set to true if this change should
     *  cause a property notification event dispatch
     * @param {boolean=} isPathNotification If the path being set is a path
     *   notification of an already changed value, as opposed to a request
     *   to set and notify the change.  In the latter `false` case, a dirty
     *   check is performed and then the value is set to the path before
     *   enqueuing the pending property change.
     * @return {boolean} Returns true if the property/path was enqueued in
     *   the pending changes bag.
     * @protected
     */
    _setPendingPropertyOrPath(path, value, shouldNotify, isPathNotification) {
      if (isPathNotification || root(Array.isArray(path) ? path[0] : path) !== path) {
        if (!isPathNotification) {
          let old = get$1(this, path);
          path = /** @type {string} */
          set(this, path, value);
          if (!path || !super._shouldPropertyChange(path, value, old)) {
            return false;
          }
        }
        this.__dataHasPaths = true;
        if (this._setPendingProperty(
          /**@type{string}*/
          path,
          value,
          shouldNotify
        )) {
          computeLinkedPaths(
            this,
            /**@type{string}*/
            path,
            value
          );
          return true;
        }
      } else {
        if (this.__dataHasAccessor && this.__dataHasAccessor[path]) {
          return this._setPendingProperty(
            /**@type{string}*/
            path,
            value,
            shouldNotify
          );
        } else {
          this[path] = value;
        }
      }
      return false;
    }
    /**
     * Applies a value to a non-Polymer element/node's property.
     *
     * The implementation makes a best-effort at binding interop:
     * Some native element properties have side-effects when
     * re-setting the same value (e.g. setting `<input>.value` resets the
     * cursor position), so we do a dirty-check before setting the value.
     * However, for better interop with non-Polymer custom elements that
     * accept objects, we explicitly re-set object changes coming from the
     * Polymer world (which may include deep object changes without the
     * top reference changing), erring on the side of providing more
     * information.
     *
     * Users may override this method to provide alternate approaches.
     *
     * @override
     * @param {!Node} node The node to set a property on
     * @param {string} prop The property to set
     * @param {*} value The value to set
     * @return {void}
     * @protected
     */
    _setUnmanagedPropertyToNode(node, prop, value) {
      if (value !== node[prop] || typeof value == "object") {
        if (prop === "className") {
          node = /** @type {!Node} */
          wrap$1(node);
        }
        node[prop] = value;
      }
    }
    /**
     * Overrides the `PropertiesChanged` implementation to introduce special
     * dirty check logic depending on the property & value being set:
     *
     * 1. Any value set to a path (e.g. 'obj.prop': 42 or 'obj.prop': {...})
     *    Stored in `__dataTemp`, dirty checked against `__dataTemp`
     * 2. Object set to simple property (e.g. 'prop': {...})
     *    Stored in `__dataTemp` and `__data`, dirty checked against
     *    `__dataTemp` by default implementation of `_shouldPropertyChange`
     * 3. Primitive value set to simple property (e.g. 'prop': 42)
     *    Stored in `__data`, dirty checked against `__data`
     *
     * The dirty-check is important to prevent cycles due to two-way
     * notification, but paths and objects are only dirty checked against any
     * previous value set during this turn via a "temporary cache" that is
     * cleared when the last `_propertiesChanged` exits. This is so:
     * a. any cached array paths (e.g. 'array.3.prop') may be invalidated
     *    due to array mutations like shift/unshift/splice; this is fine
     *    since path changes are dirty-checked at user entry points like `set`
     * b. dirty-checking for objects only lasts one turn to allow the user
     *    to mutate the object in-place and re-set it with the same identity
     *    and have all sub-properties re-propagated in a subsequent turn.
     *
     * The temp cache is not necessarily sufficient to prevent invalid array
     * paths, since a splice can happen during the same turn (with pathological
     * user code); we could introduce a "fixup" for temporarily cached array
     * paths if needed: https://github.com/Polymer/polymer/issues/4227
     *
     * @override
     * @param {string} property Name of the property
     * @param {*} value Value to set
     * @param {boolean=} shouldNotify True if property should fire notification
     *   event (applies only for `notify: true` properties)
     * @return {boolean} Returns true if the property changed
     */
    _setPendingProperty(property, value, shouldNotify) {
      let propIsPath = this.__dataHasPaths && isPath(property);
      let prevProps = propIsPath ? this.__dataTemp : this.__data;
      if (this._shouldPropertyChange(property, value, prevProps[property])) {
        if (!this.__dataPending) {
          this.__dataPending = {};
          this.__dataOld = {};
        }
        if (!(property in this.__dataOld)) {
          this.__dataOld[property] = this.__data[property];
        }
        if (propIsPath) {
          this.__dataTemp[property] = value;
        } else {
          this.__data[property] = value;
        }
        this.__dataPending[property] = value;
        if (propIsPath || this[TYPES.NOTIFY] && this[TYPES.NOTIFY][property]) {
          this.__dataToNotify = this.__dataToNotify || {};
          this.__dataToNotify[property] = shouldNotify;
        }
        return true;
      }
      return false;
    }
    /**
     * Overrides base implementation to ensure all accessors set `shouldNotify`
     * to true, for per-property notification tracking.
     *
     * @override
     * @param {string} property Name of the property
     * @param {*} value Value to set
     * @return {void}
     */
    _setProperty(property, value) {
      if (this._setPendingProperty(property, value, true)) {
        this._invalidateProperties();
      }
    }
    /**
     * Overrides `PropertyAccessor`'s default async queuing of
     * `_propertiesChanged`: if `__dataReady` is false (has not yet been
     * manually flushed), the function no-ops; otherwise flushes
     * `_propertiesChanged` synchronously.
     *
     * @override
     * @return {void}
     */
    _invalidateProperties() {
      if (this.__dataReady) {
        this._flushProperties();
      }
    }
    /**
     * Enqueues the given client on a list of pending clients, whose
     * pending property changes can later be flushed via a call to
     * `_flushClients`.
     *
     * @override
     * @param {Object} client PropertyEffects client to enqueue
     * @return {void}
     * @protected
     */
    _enqueueClient(client) {
      this.__dataPendingClients = this.__dataPendingClients || [];
      if (client !== this) {
        this.__dataPendingClients.push(client);
      }
    }
    /**
     * Flushes any clients previously enqueued via `_enqueueClient`, causing
     * their `_flushProperties` method to run.
     *
     * @override
     * @return {void}
     * @protected
     */
    _flushClients() {
      if (!this.__dataClientsReady) {
        this.__dataClientsReady = true;
        this._readyClients();
        this.__dataReady = true;
      } else {
        this.__enableOrFlushClients();
      }
    }
    // NOTE: We ensure clients either enable or flush as appropriate. This
    // handles two corner cases:
    // (1) clients flush properly when connected/enabled before the host
    // enables; e.g.
    //   (a) Templatize stamps with no properties and does not flush and
    //   (b) the instance is inserted into dom and
    //   (c) then the instance flushes.
    // (2) clients enable properly when not connected/enabled when the host
    // flushes; e.g.
    //   (a) a template is runtime stamped and not yet connected/enabled
    //   (b) a host sets a property, causing stamped dom to flush
    //   (c) the stamped dom enables.
    __enableOrFlushClients() {
      let clients = this.__dataPendingClients;
      if (clients) {
        this.__dataPendingClients = null;
        for (let i2 = 0; i2 < clients.length; i2++) {
          let client = clients[i2];
          if (!client.__dataEnabled) {
            client._enableProperties();
          } else if (client.__dataPending) {
            client._flushProperties();
          }
        }
      }
    }
    /**
     * Perform any initial setup on client dom. Called before the first
     * `_flushProperties` call on client dom and before any element
     * observers are called.
     *
     * @override
     * @return {void}
     * @protected
     */
    _readyClients() {
      this.__enableOrFlushClients();
    }
    /**
     * Sets a bag of property changes to this instance, and
     * synchronously processes all effects of the properties as a batch.
     *
     * Property names must be simple properties, not paths.  Batched
     * path propagation is not supported.
     *
     * @override
     * @param {Object} props Bag of one or more key-value pairs whose key is
     *   a property and value is the new value to set for that property.
     * @param {boolean=} setReadOnly When true, any private values set in
     *   `props` will be set. By default, `setProperties` will not set
     *   `readOnly: true` root properties.
     * @return {void}
     * @public
     */
    setProperties(props, setReadOnly) {
      for (let path in props) {
        if (setReadOnly || !this[TYPES.READ_ONLY] || !this[TYPES.READ_ONLY][path]) {
          this._setPendingPropertyOrPath(path, props[path], true);
        }
      }
      this._invalidateProperties();
    }
    /**
     * Overrides `PropertyAccessors` so that property accessor
     * side effects are not enabled until after client dom is fully ready.
     * Also calls `_flushClients` callback to ensure client dom is enabled
     * that was not enabled as a result of flushing properties.
     *
     * @override
     * @return {void}
     */
    ready() {
      this._flushProperties();
      if (!this.__dataClientsReady) {
        this._flushClients();
      }
      if (this.__dataPending) {
        this._flushProperties();
      }
    }
    /**
     * Implements `PropertyAccessors`'s properties changed callback.
     *
     * Runs each class of effects for the batch of changed properties in
     * a specific order (compute, propagate, reflect, observe, notify).
     *
     * @override
     * @param {!Object} currentProps Bag of all current accessor values
     * @param {?Object} changedProps Bag of properties changed since the last
     *   call to `_propertiesChanged`
     * @param {?Object} oldProps Bag of previous values for each property
     *   in `changedProps`
     * @return {void}
     */
    _propertiesChanged(currentProps, changedProps, oldProps) {
      let hasPaths = this.__dataHasPaths;
      this.__dataHasPaths = false;
      let notifyProps;
      runComputedEffects(this, changedProps, oldProps, hasPaths);
      notifyProps = this.__dataToNotify;
      this.__dataToNotify = null;
      this._propagatePropertyChanges(changedProps, oldProps, hasPaths);
      this._flushClients();
      runEffects(this, this[TYPES.REFLECT], changedProps, oldProps, hasPaths);
      runEffects(this, this[TYPES.OBSERVE], changedProps, oldProps, hasPaths);
      if (notifyProps) {
        runNotifyEffects(this, notifyProps, changedProps, oldProps, hasPaths);
      }
      if (this.__dataCounter == 1) {
        this.__dataTemp = {};
      }
    }
    /**
     * Called to propagate any property changes to stamped template nodes
     * managed by this element.
     *
     * @override
     * @param {Object} changedProps Bag of changed properties
     * @param {Object} oldProps Bag of previous values for changed properties
     * @param {boolean} hasPaths True with `props` contains one or more paths
     * @return {void}
     * @protected
     */
    _propagatePropertyChanges(changedProps, oldProps, hasPaths) {
      if (this[TYPES.PROPAGATE]) {
        runEffects(this, this[TYPES.PROPAGATE], changedProps, oldProps, hasPaths);
      }
      if (this.__templateInfo) {
        this._runEffectsForTemplate(this.__templateInfo, changedProps, oldProps, hasPaths);
      }
    }
    _runEffectsForTemplate(templateInfo, changedProps, oldProps, hasPaths) {
      const baseRunEffects = (changedProps2, hasPaths2) => {
        runEffects(
          this,
          templateInfo.propertyEffects,
          changedProps2,
          oldProps,
          hasPaths2,
          templateInfo.nodeList
        );
        for (let info = templateInfo.firstChild; info; info = info.nextSibling) {
          this._runEffectsForTemplate(info, changedProps2, oldProps, hasPaths2);
        }
      };
      if (templateInfo.runEffects) {
        templateInfo.runEffects(baseRunEffects, changedProps, hasPaths);
      } else {
        baseRunEffects(changedProps, hasPaths);
      }
    }
    /**
     * Aliases one data path as another, such that path notifications from one
     * are routed to the other.
     *
     * @override
     * @param {string | !Array<string|number>} to Target path to link.
     * @param {string | !Array<string|number>} from Source path to link.
     * @return {void}
     * @public
     */
    linkPaths(to, from) {
      to = normalize(to);
      from = normalize(from);
      this.__dataLinkedPaths = this.__dataLinkedPaths || {};
      this.__dataLinkedPaths[to] = from;
    }
    /**
     * Removes a data path alias previously established with `_linkPaths`.
     *
     * Note, the path to unlink should be the target (`to`) used when
     * linking the paths.
     *
     * @override
     * @param {string | !Array<string|number>} path Target path to unlink.
     * @return {void}
     * @public
     */
    unlinkPaths(path) {
      path = normalize(path);
      if (this.__dataLinkedPaths) {
        delete this.__dataLinkedPaths[path];
      }
    }
    /**
     * Notify that an array has changed.
     *
     * Example:
     *
     *     this.items = [ {name: 'Jim'}, {name: 'Todd'}, {name: 'Bill'} ];
     *     ...
     *     this.items.splice(1, 1, {name: 'Sam'});
     *     this.items.push({name: 'Bob'});
     *     this.notifySplices('items', [
     *       { index: 1, removed: [{name: 'Todd'}], addedCount: 1,
     *         object: this.items, type: 'splice' },
     *       { index: 3, removed: [], addedCount: 1,
     *         object: this.items, type: 'splice'}
     *     ]);
     *
     * @param {string} path Path that should be notified.
     * @param {Array} splices Array of splice records indicating ordered
     *   changes that occurred to the array. Each record should have the
     *   following fields:
     *    * index: index at which the change occurred
     *    * removed: array of items that were removed from this index
     *    * addedCount: number of new items added at this index
     *    * object: a reference to the array in question
     *    * type: the string literal 'splice'
     *
     *   Note that splice records _must_ be normalized such that they are
     *   reported in index order (raw results from `Object.observe` are not
     *   ordered and must be normalized/merged before notifying).
     *
     * @override
     * @return {void}
     * @public
     */
    notifySplices(path, splices) {
      let info = { path: "" };
      let array = (
        /** @type {Array} */
        get$1(this, path, info)
      );
      notifySplices(this, array, info.path, splices);
    }
    /**
     * Convenience method for reading a value from a path.
     *
     * Note, if any part in the path is undefined, this method returns
     * `undefined` (this method does not throw when dereferencing undefined
     * paths).
     *
     * @override
     * @param {(string|!Array<(string|number)>)} path Path to the value
     *   to read.  The path may be specified as a string (e.g. `foo.bar.baz`)
     *   or an array of path parts (e.g. `['foo.bar', 'baz']`).  Note that
     *   bracketed expressions are not supported; string-based path parts
     *   *must* be separated by dots.  Note that when dereferencing array
     *   indices, the index may be used as a dotted part directly
     *   (e.g. `users.12.name` or `['users', 12, 'name']`).
     * @param {Object=} root Root object from which the path is evaluated.
     * @return {*} Value at the path, or `undefined` if any part of the path
     *   is undefined.
     * @public
     */
    get(path, root2) {
      return get$1(root2 || this, path);
    }
    /**
     * Convenience method for setting a value to a path and notifying any
     * elements bound to the same path.
     *
     * Note, if any part in the path except for the last is undefined,
     * this method does nothing (this method does not throw when
     * dereferencing undefined paths).
     *
     * @override
     * @param {(string|!Array<(string|number)>)} path Path to the value
     *   to write.  The path may be specified as a string (e.g. `'foo.bar.baz'`)
     *   or an array of path parts (e.g. `['foo.bar', 'baz']`).  Note that
     *   bracketed expressions are not supported; string-based path parts
     *   *must* be separated by dots.  Note that when dereferencing array
     *   indices, the index may be used as a dotted part directly
     *   (e.g. `'users.12.name'` or `['users', 12, 'name']`).
     * @param {*} value Value to set at the specified path.
     * @param {Object=} root Root object from which the path is evaluated.
     *   When specified, no notification will occur.
     * @return {void}
     * @public
     */
    set(path, value, root2) {
      if (root2) {
        set(root2, path, value);
      } else {
        if (!this[TYPES.READ_ONLY] || !this[TYPES.READ_ONLY][
          /** @type {string} */
          path
        ]) {
          if (this._setPendingPropertyOrPath(path, value, true)) {
            this._invalidateProperties();
          }
        }
      }
    }
    /**
     * Adds items onto the end of the array at the path specified.
     *
     * The arguments after `path` and return value match that of
     * `Array.prototype.push`.
     *
     * This method notifies other paths to the same array that a
     * splice occurred to the array.
     *
     * @override
     * @param {string | !Array<string|number>} path Path to array.
     * @param {...*} items Items to push onto array
     * @return {number} New length of the array.
     * @public
     */
    push(path, ...items) {
      let info = { path: "" };
      let array = (
        /** @type {Array}*/
        get$1(this, path, info)
      );
      let len = array.length;
      let ret = array.push(...items);
      if (items.length) {
        notifySplice(this, array, info.path, len, items.length, []);
      }
      return ret;
    }
    /**
     * Removes an item from the end of array at the path specified.
     *
     * The arguments after `path` and return value match that of
     * `Array.prototype.pop`.
     *
     * This method notifies other paths to the same array that a
     * splice occurred to the array.
     *
     * @override
     * @param {string | !Array<string|number>} path Path to array.
     * @return {*} Item that was removed.
     * @public
     */
    pop(path) {
      let info = { path: "" };
      let array = (
        /** @type {Array} */
        get$1(this, path, info)
      );
      let hadLength = Boolean(array.length);
      let ret = array.pop();
      if (hadLength) {
        notifySplice(this, array, info.path, array.length, 0, [ret]);
      }
      return ret;
    }
    /**
     * Starting from the start index specified, removes 0 or more items
     * from the array and inserts 0 or more new items in their place.
     *
     * The arguments after `path` and return value match that of
     * `Array.prototype.splice`.
     *
     * This method notifies other paths to the same array that a
     * splice occurred to the array.
     *
     * @override
     * @param {string | !Array<string|number>} path Path to array.
     * @param {number} start Index from which to start removing/inserting.
     * @param {number=} deleteCount Number of items to remove.
     * @param {...*} items Items to insert into array.
     * @return {!Array} Array of removed items.
     * @public
     */
    splice(path, start, deleteCount, ...items) {
      let info = { path: "" };
      let array = (
        /** @type {Array} */
        get$1(this, path, info)
      );
      if (start < 0) {
        start = array.length - Math.floor(-start);
      } else if (start) {
        start = Math.floor(start);
      }
      let ret;
      if (arguments.length === 2) {
        ret = array.splice(start);
      } else {
        ret = array.splice(start, deleteCount, ...items);
      }
      if (items.length || ret.length) {
        notifySplice(this, array, info.path, start, items.length, ret);
      }
      return ret;
    }
    /**
     * Removes an item from the beginning of array at the path specified.
     *
     * The arguments after `path` and return value match that of
     * `Array.prototype.pop`.
     *
     * This method notifies other paths to the same array that a
     * splice occurred to the array.
     *
     * @override
     * @param {string | !Array<string|number>} path Path to array.
     * @return {*} Item that was removed.
     * @public
     */
    shift(path) {
      let info = { path: "" };
      let array = (
        /** @type {Array} */
        get$1(this, path, info)
      );
      let hadLength = Boolean(array.length);
      let ret = array.shift();
      if (hadLength) {
        notifySplice(this, array, info.path, 0, 0, [ret]);
      }
      return ret;
    }
    /**
     * Adds items onto the beginning of the array at the path specified.
     *
     * The arguments after `path` and return value match that of
     * `Array.prototype.push`.
     *
     * This method notifies other paths to the same array that a
     * splice occurred to the array.
     *
     * @override
     * @param {string | !Array<string|number>} path Path to array.
     * @param {...*} items Items to insert info array
     * @return {number} New length of the array.
     * @public
     */
    unshift(path, ...items) {
      let info = { path: "" };
      let array = (
        /** @type {Array} */
        get$1(this, path, info)
      );
      let ret = array.unshift(...items);
      if (items.length) {
        notifySplice(this, array, info.path, 0, items.length, []);
      }
      return ret;
    }
    /**
     * Notify that a path has changed.
     *
     * Example:
     *
     *     this.item.user.name = 'Bob';
     *     this.notifyPath('item.user.name');
     *
     * @override
     * @param {string} path Path that should be notified.
     * @param {*=} value Value at the path (optional).
     * @return {void}
     * @public
     */
    notifyPath(path, value) {
      let propPath;
      if (arguments.length == 1) {
        let info = { path: "" };
        value = get$1(this, path, info);
        propPath = info.path;
      } else if (Array.isArray(path)) {
        propPath = normalize(path);
      } else {
        propPath = /** @type{string} */
        path;
      }
      if (this._setPendingPropertyOrPath(propPath, value, true, true)) {
        this._invalidateProperties();
      }
    }
    /**
     * Equivalent to static `createReadOnlyProperty` API but can be called on
     * an instance to add effects at runtime.  See that method for
     * full API docs.
     *
     * @override
     * @param {string} property Property name
     * @param {boolean=} protectedSetter Creates a custom protected setter
     *   when `true`.
     * @return {void}
     * @protected
     */
    _createReadOnlyProperty(property, protectedSetter) {
      this._addPropertyEffect(property, TYPES.READ_ONLY);
      if (protectedSetter) {
        this["_set" + upper(property)] = /** @this {PropertyEffects} */
        function(value) {
          this._setProperty(property, value);
        };
      }
    }
    /**
     * Equivalent to static `createPropertyObserver` API but can be called on
     * an instance to add effects at runtime.  See that method for
     * full API docs.
     *
     * @override
     * @param {string} property Property name
     * @param {string|function(*,*)} method Function or name of observer method
     *     to call
     * @param {boolean=} dynamicFn Whether the method name should be included as
     *   a dependency to the effect.
     * @return {void}
     * @protected
     */
    _createPropertyObserver(property, method, dynamicFn) {
      let info = { property, method, dynamicFn: Boolean(dynamicFn) };
      this._addPropertyEffect(property, TYPES.OBSERVE, {
        fn: runObserverEffect,
        info,
        trigger: { name: property }
      });
      if (dynamicFn) {
        this._addPropertyEffect(
          /** @type {string} */
          method,
          TYPES.OBSERVE,
          {
            fn: runObserverEffect,
            info,
            trigger: { name: method }
          }
        );
      }
    }
    /**
     * Equivalent to static `createMethodObserver` API but can be called on
     * an instance to add effects at runtime.  See that method for
     * full API docs.
     *
     * @override
     * @param {string} expression Method expression
     * @param {boolean|Object=} dynamicFn Boolean or object map indicating
     *   whether method names should be included as a dependency to the effect.
     * @return {void}
     * @protected
     */
    _createMethodObserver(expression, dynamicFn) {
      let sig = parseMethod(expression);
      if (!sig) {
        throw new Error("Malformed observer expression '" + expression + "'");
      }
      createMethodEffect(this, sig, TYPES.OBSERVE, runMethodEffect, null, dynamicFn);
    }
    /**
     * Equivalent to static `createNotifyingProperty` API but can be called on
     * an instance to add effects at runtime.  See that method for
     * full API docs.
     *
     * @override
     * @param {string} property Property name
     * @return {void}
     * @protected
     */
    _createNotifyingProperty(property) {
      this._addPropertyEffect(property, TYPES.NOTIFY, {
        fn: runNotifyEffect,
        info: {
          eventName: camelToDashCase(property) + "-changed",
          property
        }
      });
    }
    /**
     * Equivalent to static `createReflectedProperty` API but can be called on
     * an instance to add effects at runtime.  See that method for
     * full API docs.
     *
     * @override
     * @param {string} property Property name
     * @return {void}
     * @protected
     * @suppress {missingProperties} go/missingfnprops
     */
    _createReflectedProperty(property) {
      let attr = this.constructor.attributeNameForProperty(property);
      if (attr[0] === "-") {
        console.warn("Property " + property + " cannot be reflected to attribute " + attr + ' because "-" is not a valid starting attribute name. Use a lowercase first letter for the property instead.');
      } else {
        this._addPropertyEffect(property, TYPES.REFLECT, {
          fn: runReflectEffect,
          info: {
            attrName: attr
          }
        });
      }
    }
    /**
     * Equivalent to static `createComputedProperty` API but can be called on
     * an instance to add effects at runtime.  See that method for
     * full API docs.
     *
     * @override
     * @param {string} property Name of computed property to set
     * @param {string} expression Method expression
     * @param {boolean|Object=} dynamicFn Boolean or object map indicating
     *   whether method names should be included as a dependency to the effect.
     * @return {void}
     * @protected
     */
    _createComputedProperty(property, expression, dynamicFn) {
      let sig = parseMethod(expression);
      if (!sig) {
        throw new Error("Malformed computed expression '" + expression + "'");
      }
      const info = createMethodEffect(this, sig, TYPES.COMPUTE, runComputedEffect, property, dynamicFn);
      ensureOwnEffectMap(this, COMPUTE_INFO)[property] = info;
    }
    /**
     * Gather the argument values for a method specified in the provided array
     * of argument metadata.
     *
     * The `path` and `value` arguments are used to fill in wildcard descriptor
     * when the method is being called as a result of a path notification.
     *
     * @param {!Array<!MethodArg>} args Array of argument metadata
     * @param {string} path Property/path name that triggered the method effect
     * @param {Object} props Bag of current property changes
     * @return {!Array<*>} Array of argument values
     * @private
     */
    _marshalArgs(args, path, props) {
      const data = this.__data;
      const values = [];
      for (let i2 = 0, l = args.length; i2 < l; i2++) {
        let { name, structured, wildcard, value, literal } = args[i2];
        if (!literal) {
          if (wildcard) {
            const matches2 = isDescendant(name, path);
            const pathValue = getArgValue(data, props, matches2 ? path : name);
            value = {
              path: matches2 ? path : name,
              value: pathValue,
              base: matches2 ? get$1(data, name) : pathValue
            };
          } else {
            value = structured ? getArgValue(data, props, name) : data[name];
          }
        }
        if (legacyUndefined && !this._overrideLegacyUndefined && value === void 0 && args.length > 1) {
          return NOOP;
        }
        values[i2] = value;
      }
      return values;
    }
    // -- static class methods ------------
    /**
     * Ensures an accessor exists for the specified property, and adds
     * to a list of "property effects" that will run when the accessor for
     * the specified property is set.  Effects are grouped by "type", which
     * roughly corresponds to a phase in effect processing.  The effect
     * metadata should be in the following form:
     *
     *     {
     *       fn: effectFunction, // Reference to function to call to perform effect
     *       info: { ... }       // Effect metadata passed to function
     *       trigger: {          // Optional triggering metadata; if not provided
     *         name: string      // the property is treated as a wildcard
     *         structured: boolean
     *         wildcard: boolean
     *       }
     *     }
     *
     * Effects are called from `_propertiesChanged` in the following order by
     * type:
     *
     * 1. COMPUTE
     * 2. PROPAGATE
     * 3. REFLECT
     * 4. OBSERVE
     * 5. NOTIFY
     *
     * Effect functions are called with the following signature:
     *
     *     effectFunction(inst, path, props, oldProps, info, hasPaths)
     *
     * @param {string} property Property that should trigger the effect
     * @param {string} type Effect type, from this.PROPERTY_EFFECT_TYPES
     * @param {Object=} effect Effect metadata object
     * @return {void}
     * @protected
     * @nocollapse
     */
    static addPropertyEffect(property, type, effect) {
      this.prototype._addPropertyEffect(property, type, effect);
    }
    /**
     * Creates a single-property observer for the given property.
     *
     * @param {string} property Property name
     * @param {string|function(*,*)} method Function or name of observer method to call
     * @param {boolean=} dynamicFn Whether the method name should be included as
     *   a dependency to the effect.
     * @return {void}
     * @protected
     * @nocollapse
     */
    static createPropertyObserver(property, method, dynamicFn) {
      this.prototype._createPropertyObserver(property, method, dynamicFn);
    }
    /**
     * Creates a multi-property "method observer" based on the provided
     * expression, which should be a string in the form of a normal JavaScript
     * function signature: `'methodName(arg1, [..., argn])'`.  Each argument
     * should correspond to a property or path in the context of this
     * prototype (or instance), or may be a literal string or number.
     *
     * @param {string} expression Method expression
     * @param {boolean|Object=} dynamicFn Boolean or object map indicating
     * @return {void}
     *   whether method names should be included as a dependency to the effect.
     * @protected
     * @nocollapse
     */
    static createMethodObserver(expression, dynamicFn) {
      this.prototype._createMethodObserver(expression, dynamicFn);
    }
    /**
     * Causes the setter for the given property to dispatch `<property>-changed`
     * events to notify of changes to the property.
     *
     * @param {string} property Property name
     * @return {void}
     * @protected
     * @nocollapse
     */
    static createNotifyingProperty(property) {
      this.prototype._createNotifyingProperty(property);
    }
    /**
     * Creates a read-only accessor for the given property.
     *
     * To set the property, use the protected `_setProperty` API.
     * To create a custom protected setter (e.g. `_setMyProp()` for
     * property `myProp`), pass `true` for `protectedSetter`.
     *
     * Note, if the property will have other property effects, this method
     * should be called first, before adding other effects.
     *
     * @param {string} property Property name
     * @param {boolean=} protectedSetter Creates a custom protected setter
     *   when `true`.
     * @return {void}
     * @protected
     * @nocollapse
     */
    static createReadOnlyProperty(property, protectedSetter) {
      this.prototype._createReadOnlyProperty(property, protectedSetter);
    }
    /**
     * Causes the setter for the given property to reflect the property value
     * to a (dash-cased) attribute of the same name.
     *
     * @param {string} property Property name
     * @return {void}
     * @protected
     * @nocollapse
     */
    static createReflectedProperty(property) {
      this.prototype._createReflectedProperty(property);
    }
    /**
     * Creates a computed property whose value is set to the result of the
     * method described by the given `expression` each time one or more
     * arguments to the method changes.  The expression should be a string
     * in the form of a normal JavaScript function signature:
     * `'methodName(arg1, [..., argn])'`
     *
     * @param {string} property Name of computed property to set
     * @param {string} expression Method expression
     * @param {boolean|Object=} dynamicFn Boolean or object map indicating whether
     *   method names should be included as a dependency to the effect.
     * @return {void}
     * @protected
     * @nocollapse
     */
    static createComputedProperty(property, expression, dynamicFn) {
      this.prototype._createComputedProperty(property, expression, dynamicFn);
    }
    /**
     * Parses the provided template to ensure binding effects are created
     * for them, and then ensures property accessors are created for any
     * dependent properties in the template.  Binding effects for bound
     * templates are stored in a linked list on the instance so that
     * templates can be efficiently stamped and unstamped.
     *
     * @param {!HTMLTemplateElement} template Template containing binding
     *   bindings
     * @return {!TemplateInfo} Template metadata object
     * @protected
     * @nocollapse
     */
    static bindTemplate(template2) {
      return this.prototype._bindTemplate(template2);
    }
    // -- binding ----------------------------------------------
    /*
     * Overview of binding flow:
     *
     * During finalization (`instanceBinding==false`, `wasPreBound==false`):
     *  `_bindTemplate(t, false)` called directly during finalization - parses
     *  the template (for the first time), and then assigns that _prototypical_
     *  template info to `__preboundTemplateInfo` _on the prototype_; note in
     *  this case `wasPreBound` is false; this is the first time we're binding
     *  it, thus we create accessors.
     *
     * During first stamping (`instanceBinding==true`, `wasPreBound==true`):
     *   `_stampTemplate` calls `_bindTemplate(t, true)`: the `templateInfo`
     *   returned matches the prebound one, and so this is `wasPreBound == true`
     *   state; thus we _skip_ creating accessors, but _do_ create an instance
     *   of the template info to serve as the start of our linked list (needs to
     *   be an instance, not the prototypical one, so that we can add `nodeList`
     *   to it to contain the `nodeInfo`-ordered list of instance nodes for
     *   bindings, and so we can chain runtime-stamped template infos off of
     *   it). At this point, the call to `_stampTemplate` calls
     *   `applyTemplateInfo` for each nested `<template>` found during parsing
     *   to hand prototypical `_templateInfo` to them; we also pass the _parent_
     *   `templateInfo` to the `<template>` so that we have the instance-time
     *   parent to link the `templateInfo` under in the case it was
     *   runtime-stamped.
     *
     * During subsequent runtime stamping (`instanceBinding==true`,
     *   `wasPreBound==false`): `_stampTemplate` calls `_bindTemplate(t, true)`
     *   - here `templateInfo` is guaranteed to _not_ match the prebound one,
     *   because it was either a different template altogether, or even if it
     *   was the same template, the step above created a instance of the info;
     *   in this case `wasPreBound == false`, so we _do_ create accessors, _and_
     *   link a instance into the linked list.
     */
    /**
     * Equivalent to static `bindTemplate` API but can be called on an instance
     * to add effects at runtime.  See that method for full API docs.
     *
     * This method may be called on the prototype (for prototypical template
     * binding, to avoid creating accessors every instance) once per prototype,
     * and will be called with `runtimeBinding: true` by `_stampTemplate` to
     * create and link an instance of the template metadata associated with a
     * particular stamping.
     *
     * @override
     * @param {!HTMLTemplateElement} template Template containing binding
     * bindings
     * @param {boolean=} instanceBinding When false (default), performs
     * "prototypical" binding of the template and overwrites any previously
     * bound template for the class. When true (as passed from
     * `_stampTemplate`), the template info is instanced and linked into the
     * list of bound templates.
     * @return {!TemplateInfo} Template metadata object; for `runtimeBinding`,
     * this is an instance of the prototypical template info
     * @protected
     * @suppress {missingProperties} go/missingfnprops
     */
    _bindTemplate(template2, instanceBinding) {
      let templateInfo = this.constructor._parseTemplate(template2);
      let wasPreBound = this.__preBoundTemplateInfo == templateInfo;
      if (!wasPreBound) {
        for (let prop in templateInfo.propertyEffects) {
          this._createPropertyAccessor(prop);
        }
      }
      if (instanceBinding) {
        templateInfo = /** @type {!TemplateInfo} */
        Object.create(templateInfo);
        templateInfo.wasPreBound = wasPreBound;
        if (!this.__templateInfo) {
          this.__templateInfo = templateInfo;
        } else {
          const parent = template2._parentTemplateInfo || this.__templateInfo;
          const previous = parent.lastChild;
          templateInfo.parent = parent;
          parent.lastChild = templateInfo;
          templateInfo.previousSibling = previous;
          if (previous) {
            previous.nextSibling = templateInfo;
          } else {
            parent.firstChild = templateInfo;
          }
        }
      } else {
        this.__preBoundTemplateInfo = templateInfo;
      }
      return templateInfo;
    }
    /**
     * Adds a property effect to the given template metadata, which is run
     * at the "propagate" stage of `_propertiesChanged` when the template
     * has been bound to the element via `_bindTemplate`.
     *
     * The `effect` object should match the format in `_addPropertyEffect`.
     *
     * @param {Object} templateInfo Template metadata to add effect to
     * @param {string} prop Property that should trigger the effect
     * @param {Object=} effect Effect metadata object
     * @return {void}
     * @protected
     * @nocollapse
     */
    static _addTemplatePropertyEffect(templateInfo, prop, effect) {
      let hostProps = templateInfo.hostProps = templateInfo.hostProps || {};
      hostProps[prop] = true;
      let effects = templateInfo.propertyEffects = templateInfo.propertyEffects || {};
      let propEffects = effects[prop] = effects[prop] || [];
      propEffects.push(effect);
    }
    /**
     * Stamps the provided template and performs instance-time setup for
     * Polymer template features, including data bindings, declarative event
     * listeners, and the `this.$` map of `id`'s to nodes.  A document fragment
     * is returned containing the stamped DOM, ready for insertion into the
     * DOM.
     *
     * This method may be called more than once; however note that due to
     * `shadycss` polyfill limitations, only styles from templates prepared
     * using `ShadyCSS.prepareTemplate` will be correctly polyfilled (scoped
     * to the shadow root and support CSS custom properties), and note that
     * `ShadyCSS.prepareTemplate` may only be called once per element. As such,
     * any styles required by in runtime-stamped templates must be included
     * in the main element template.
     *
     * @param {!HTMLTemplateElement} template Template to stamp
     * @param {TemplateInfo=} templateInfo Optional bound template info associated
     *   with the template to be stamped; if omitted the template will be
     *   automatically bound.
     * @return {!StampedTemplate} Cloned template content
     * @override
     * @protected
     */
    _stampTemplate(template2, templateInfo) {
      templateInfo = templateInfo || /** @type {!TemplateInfo} */
      this._bindTemplate(template2, true);
      hostStack.push(this);
      let dom = super._stampTemplate(template2, templateInfo);
      hostStack.pop();
      templateInfo.nodeList = dom.nodeList;
      if (!templateInfo.wasPreBound) {
        let nodes = templateInfo.childNodes = [];
        for (let n = dom.firstChild; n; n = n.nextSibling) {
          nodes.push(n);
        }
      }
      dom.templateInfo = templateInfo;
      setupBindings(this, templateInfo);
      if (this.__dataClientsReady) {
        this._runEffectsForTemplate(templateInfo, this.__data, null, false);
        this._flushClients();
      }
      return dom;
    }
    /**
     * Removes and unbinds the nodes previously contained in the provided
     * DocumentFragment returned from `_stampTemplate`.
     *
     * @override
     * @param {!StampedTemplate} dom DocumentFragment previously returned
     *   from `_stampTemplate` associated with the nodes to be removed
     * @return {void}
     * @protected
     */
    _removeBoundDom(dom) {
      const templateInfo = dom.templateInfo;
      const { previousSibling, nextSibling, parent } = templateInfo;
      if (previousSibling) {
        previousSibling.nextSibling = nextSibling;
      } else if (parent) {
        parent.firstChild = nextSibling;
      }
      if (nextSibling) {
        nextSibling.previousSibling = previousSibling;
      } else if (parent) {
        parent.lastChild = previousSibling;
      }
      templateInfo.nextSibling = templateInfo.previousSibling = null;
      let nodes = templateInfo.childNodes;
      for (let i2 = 0; i2 < nodes.length; i2++) {
        let node = nodes[i2];
        wrap$1(wrap$1(node).parentNode).removeChild(node);
      }
    }
    /**
     * Overrides default `TemplateStamp` implementation to add support for
     * parsing bindings from `TextNode`'s' `textContent`.  A `bindings`
     * array is added to `nodeInfo` and populated with binding metadata
     * with information capturing the binding target, and a `parts` array
     * with one or more metadata objects capturing the source(s) of the
     * binding.
     *
     * @param {Node} node Node to parse
     * @param {TemplateInfo} templateInfo Template metadata for current template
     * @param {NodeInfo} nodeInfo Node metadata for current template node
     * @return {boolean} `true` if the visited node added node-specific
     *   metadata to `nodeInfo`
     * @protected
     * @suppress {missingProperties} Interfaces in closure do not inherit statics, but classes do
     * @nocollapse
     */
    static _parseTemplateNode(node, templateInfo, nodeInfo) {
      let noted = propertyEffectsBase._parseTemplateNode.call(
        this,
        node,
        templateInfo,
        nodeInfo
      );
      if (node.nodeType === Node.TEXT_NODE) {
        let parts = this._parseBindings(node.textContent, templateInfo);
        if (parts) {
          node.textContent = literalFromParts(parts) || " ";
          addBinding(this, templateInfo, nodeInfo, "text", "textContent", parts);
          noted = true;
        }
      }
      return noted;
    }
    /**
     * Overrides default `TemplateStamp` implementation to add support for
     * parsing bindings from attributes.  A `bindings`
     * array is added to `nodeInfo` and populated with binding metadata
     * with information capturing the binding target, and a `parts` array
     * with one or more metadata objects capturing the source(s) of the
     * binding.
     *
     * @param {Element} node Node to parse
     * @param {TemplateInfo} templateInfo Template metadata for current template
     * @param {NodeInfo} nodeInfo Node metadata for current template node
     * @param {string} name Attribute name
     * @param {string} value Attribute value
     * @return {boolean} `true` if the visited node added node-specific
     *   metadata to `nodeInfo`
     * @protected
     * @suppress {missingProperties} Interfaces in closure do not inherit statics, but classes do
     * @nocollapse
     */
    static _parseTemplateNodeAttribute(node, templateInfo, nodeInfo, name, value) {
      let parts = this._parseBindings(value, templateInfo);
      if (parts) {
        let origName = name;
        let kind = "property";
        if (capitalAttributeRegex.test(name)) {
          kind = "attribute";
        } else if (name[name.length - 1] == "$") {
          name = name.slice(0, -1);
          kind = "attribute";
        }
        let literal = literalFromParts(parts);
        if (literal && kind == "attribute") {
          if (name == "class" && node.hasAttribute("class")) {
            literal += " " + node.getAttribute(name);
          }
          node.setAttribute(name, literal);
        }
        if (kind == "attribute" && origName == "disable-upgrade$") {
          node.setAttribute(name, "");
        }
        if (node.localName === "input" && origName === "value") {
          node.setAttribute(origName, "");
        }
        node.removeAttribute(origName);
        if (kind === "property") {
          name = dashToCamelCase(name);
        }
        addBinding(this, templateInfo, nodeInfo, kind, name, parts, literal);
        return true;
      } else {
        return propertyEffectsBase._parseTemplateNodeAttribute.call(
          this,
          node,
          templateInfo,
          nodeInfo,
          name,
          value
        );
      }
    }
    /**
     * Overrides default `TemplateStamp` implementation to add support for
     * binding the properties that a nested template depends on to the template
     * as `_host_<property>`.
     *
     * @param {Node} node Node to parse
     * @param {TemplateInfo} templateInfo Template metadata for current template
     * @param {NodeInfo} nodeInfo Node metadata for current template node
     * @return {boolean} `true` if the visited node added node-specific
     *   metadata to `nodeInfo`
     * @protected
     * @suppress {missingProperties} Interfaces in closure do not inherit statics, but classes do
     * @nocollapse
     */
    static _parseTemplateNestedTemplate(node, templateInfo, nodeInfo) {
      let noted = propertyEffectsBase._parseTemplateNestedTemplate.call(
        this,
        node,
        templateInfo,
        nodeInfo
      );
      const parent = node.parentNode;
      const nestedTemplateInfo = nodeInfo.templateInfo;
      const isDomIf = parent.localName === "dom-if";
      const isDomRepeat = parent.localName === "dom-repeat";
      if (removeNestedTemplates && (isDomIf || isDomRepeat)) {
        parent.removeChild(node);
        nodeInfo = nodeInfo.parentInfo;
        nodeInfo.templateInfo = nestedTemplateInfo;
        nodeInfo.noted = true;
        noted = false;
      }
      let hostProps = nestedTemplateInfo.hostProps;
      if (fastDomIf && isDomIf) {
        if (hostProps) {
          templateInfo.hostProps = Object.assign(templateInfo.hostProps || {}, hostProps);
          if (!removeNestedTemplates) {
            nodeInfo.parentInfo.noted = true;
          }
        }
      } else {
        let mode = "{";
        for (let source in hostProps) {
          let parts = [{ mode, source, dependencies: [source], hostProp: true }];
          addBinding(this, templateInfo, nodeInfo, "property", "_host_" + source, parts);
        }
      }
      return noted;
    }
    /**
     * Called to parse text in a template (either attribute values or
     * textContent) into binding metadata.
     *
     * Any overrides of this method should return an array of binding part
     * metadata  representing one or more bindings found in the provided text
     * and any "literal" text in between.  Any non-literal parts will be passed
     * to `_evaluateBinding` when any dependencies change.  The only required
     * fields of each "part" in the returned array are as follows:
     *
     * - `dependencies` - Array containing trigger metadata for each property
     *   that should trigger the binding to update
     * - `literal` - String containing text if the part represents a literal;
     *   in this case no `dependencies` are needed
     *
     * Additional metadata for use by `_evaluateBinding` may be provided in
     * each part object as needed.
     *
     * The default implementation handles the following types of bindings
     * (one or more may be intermixed with literal strings):
     * - Property binding: `[[prop]]`
     * - Path binding: `[[object.prop]]`
     * - Negated property or path bindings: `[[!prop]]` or `[[!object.prop]]`
     * - Two-way property or path bindings (supports negation):
     *   `{{prop}}`, `{{object.prop}}`, `{{!prop}}` or `{{!object.prop}}`
     * - Inline computed method (supports negation):
     *   `[[compute(a, 'literal', b)]]`, `[[!compute(a, 'literal', b)]]`
     *
     * The default implementation uses a regular expression for best
     * performance. However, the regular expression uses a white-list of
     * allowed characters in a data-binding, which causes problems for
     * data-bindings that do use characters not in this white-list.
     *
     * Instead of updating the white-list with all allowed characters,
     * there is a StrictBindingParser (see lib/mixins/strict-binding-parser)
     * that uses a state machine instead. This state machine is able to handle
     * all characters. However, it is slightly less performant, therefore we
     * extracted it into a separate optional mixin.
     *
     * @param {string} text Text to parse from attribute or textContent
     * @param {Object} templateInfo Current template metadata
     * @return {Array<!BindingPart>} Array of binding part metadata
     * @protected
     * @nocollapse
     */
    static _parseBindings(text, templateInfo) {
      let parts = [];
      let lastIndex = 0;
      let m3;
      while ((m3 = bindingRegex.exec(text)) !== null) {
        if (m3.index > lastIndex) {
          parts.push({ literal: text.slice(lastIndex, m3.index) });
        }
        let mode = m3[1][0];
        let negate = Boolean(m3[2]);
        let source = m3[3].trim();
        let customEvent = false, notifyEvent = "", colon = -1;
        if (mode == "{" && (colon = source.indexOf("::")) > 0) {
          notifyEvent = source.substring(colon + 2);
          source = source.substring(0, colon);
          customEvent = true;
        }
        let signature = parseMethod(source);
        let dependencies = [];
        if (signature) {
          let { args, methodName } = signature;
          for (let i2 = 0; i2 < args.length; i2++) {
            let arg = args[i2];
            if (!arg.literal) {
              dependencies.push(arg);
            }
          }
          let dynamicFns = templateInfo.dynamicFns;
          if (dynamicFns && dynamicFns[methodName] || signature.static) {
            dependencies.push(methodName);
            signature.dynamicFn = true;
          }
        } else {
          dependencies.push(source);
        }
        parts.push({
          source,
          mode,
          negate,
          customEvent,
          signature,
          dependencies,
          event: notifyEvent
        });
        lastIndex = bindingRegex.lastIndex;
      }
      if (lastIndex && lastIndex < text.length) {
        let literal = text.substring(lastIndex);
        if (literal) {
          parts.push({
            literal
          });
        }
      }
      if (parts.length) {
        return parts;
      } else {
        return null;
      }
    }
    /**
     * Called to evaluate a previously parsed binding part based on a set of
     * one or more changed dependencies.
     *
     * @param {!Polymer_PropertyEffects} inst Element that should be used as
     *     scope for binding dependencies
     * @param {BindingPart} part Binding part metadata
     * @param {string} path Property/path that triggered this effect
     * @param {Object} props Bag of current property changes
     * @param {Object} oldProps Bag of previous values for changed properties
     * @param {boolean} hasPaths True with `props` contains one or more paths
     * @return {*} Value the binding part evaluated to
     * @protected
     * @nocollapse
     */
    static _evaluateBinding(inst, part, path, props, oldProps, hasPaths) {
      let value;
      if (part.signature) {
        value = runMethodEffect(inst, path, props, oldProps, part.signature);
      } else if (path != part.source) {
        value = get$1(inst, part.source);
      } else {
        if (hasPaths && isPath(path)) {
          value = get$1(inst, path);
        } else {
          value = inst.__data[path];
        }
      }
      if (part.negate) {
        value = !value;
      }
      return value;
    }
  }
  return PropertyEffects2;
});
const hostStack = [];
/**
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/
function register$1(prototype) {
}
/**
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/
function normalizeProperties(props) {
  const output = {};
  for (let p in props) {
    const o = props[p];
    output[p] = typeof o === "function" ? { type: o } : o;
  }
  return output;
}
const PropertiesMixin = dedupingMixin((superClass) => {
  const base = PropertiesChanged(superClass);
  function superPropertiesClass(constructor) {
    const superCtor = Object.getPrototypeOf(constructor);
    return superCtor.prototype instanceof PropertiesMixin2 ? (
      /** @type {!PropertiesMixinConstructor} */
      superCtor
    ) : null;
  }
  function ownProperties(constructor) {
    if (!constructor.hasOwnProperty(JSCompiler_renameProperty("__ownProperties", constructor))) {
      let props = null;
      if (constructor.hasOwnProperty(JSCompiler_renameProperty("properties", constructor))) {
        const properties = constructor.properties;
        if (properties) {
          props = normalizeProperties(properties);
        }
      }
      constructor.__ownProperties = props;
    }
    return constructor.__ownProperties;
  }
  class PropertiesMixin2 extends base {
    /**
     * Implements standard custom elements getter to observes the attributes
     * listed in `properties`.
     * @suppress {missingProperties} Interfaces in closure do not inherit statics, but classes do
     * @nocollapse
     */
    static get observedAttributes() {
      if (!this.hasOwnProperty(JSCompiler_renameProperty("__observedAttributes", this))) {
        register$1(this.prototype);
        const props = this._properties;
        this.__observedAttributes = props ? Object.keys(props).map((p) => this.prototype._addPropertyToAttributeMap(p)) : [];
      }
      return this.__observedAttributes;
    }
    /**
     * Finalizes an element definition, including ensuring any super classes
     * are also finalized. This includes ensuring property
     * accessors exist on the element prototype. This method calls
     * `_finalizeClass` to finalize each constructor in the prototype chain.
     * @return {void}
     * @nocollapse
     */
    static finalize() {
      if (!this.hasOwnProperty(JSCompiler_renameProperty("__finalized", this))) {
        const superCtor = superPropertiesClass(
          /** @type {!PropertiesMixinConstructor} */
          this
        );
        if (superCtor) {
          superCtor.finalize();
        }
        this.__finalized = true;
        this._finalizeClass();
      }
    }
    /**
     * Finalize an element class. This includes ensuring property
     * accessors exist on the element prototype. This method is called by
     * `finalize` and finalizes the class constructor.
     *
     * @protected
     * @nocollapse
     */
    static _finalizeClass() {
      const props = ownProperties(
        /** @type {!PropertiesMixinConstructor} */
        this
      );
      if (props) {
        this.createProperties(props);
      }
    }
    /**
     * Returns a memoized version of all properties, including those inherited
     * from super classes. Properties not in object format are converted to
     * at least {type}.
     *
     * @return {Object} Object containing properties for this class
     * @protected
     * @nocollapse
     */
    static get _properties() {
      if (!this.hasOwnProperty(
        JSCompiler_renameProperty("__properties", this)
      )) {
        const superCtor = superPropertiesClass(
          /** @type {!PropertiesMixinConstructor} */
          this
        );
        this.__properties = Object.assign(
          {},
          superCtor && superCtor._properties,
          ownProperties(
            /** @type {PropertiesMixinConstructor} */
            this
          )
        );
      }
      return this.__properties;
    }
    /**
     * Overrides `PropertiesChanged` method to return type specified in the
     * static `properties` object for the given property.
     * @param {string} name Name of property
     * @return {*} Type to which to deserialize attribute
     *
     * @protected
     * @nocollapse
     */
    static typeForProperty(name) {
      const info = this._properties[name];
      return info && info.type;
    }
    /**
     * Overrides `PropertiesChanged` method and adds a call to
     * `finalize` which lazily configures the element's property accessors.
     * @override
     * @return {void}
     */
    _initializeProperties() {
      this.constructor.finalize();
      super._initializeProperties();
    }
    /**
     * Called when the element is added to a document.
     * Calls `_enableProperties` to turn on property system from
     * `PropertiesChanged`.
     * @suppress {missingProperties} Super may or may not implement the callback
     * @return {void}
     * @override
     */
    connectedCallback() {
      if (super.connectedCallback) {
        super.connectedCallback();
      }
      this._enableProperties();
    }
    /**
     * Called when the element is removed from a document
     * @suppress {missingProperties} Super may or may not implement the callback
     * @return {void}
     * @override
     */
    disconnectedCallback() {
      if (super.disconnectedCallback) {
        super.disconnectedCallback();
      }
    }
  }
  return PropertiesMixin2;
});
/**
 * @fileoverview
 * @suppress {checkPrototypalTypes}
 * @license Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt The complete set of authors may be found
 * at http://polymer.github.io/AUTHORS.txt The complete set of contributors may
 * be found at http://polymer.github.io/CONTRIBUTORS.txt Code distributed by
 * Google as part of the polymer project is also subject to an additional IP
 * rights grant found at http://polymer.github.io/PATENTS.txt
 */
const version = "3.5.2";
const builtCSS = window.ShadyCSS && window.ShadyCSS["cssBuild"];
const ElementMixin$1 = dedupingMixin((base) => {
  const polymerElementBase = PropertiesMixin(PropertyEffects(base));
  function propertyDefaults(constructor) {
    if (!constructor.hasOwnProperty(
      JSCompiler_renameProperty("__propertyDefaults", constructor)
    )) {
      constructor.__propertyDefaults = null;
      let props = constructor._properties;
      for (let p in props) {
        let info = props[p];
        if ("value" in info) {
          constructor.__propertyDefaults = constructor.__propertyDefaults || {};
          constructor.__propertyDefaults[p] = info;
        }
      }
    }
    return constructor.__propertyDefaults;
  }
  function ownObservers(constructor) {
    if (!constructor.hasOwnProperty(
      JSCompiler_renameProperty("__ownObservers", constructor)
    )) {
      constructor.__ownObservers = constructor.hasOwnProperty(
        JSCompiler_renameProperty("observers", constructor)
      ) ? (
        /** @type {PolymerElementConstructor} */
        constructor.observers
      ) : null;
    }
    return constructor.__ownObservers;
  }
  function createPropertyFromConfig(proto2, name, info, allProps) {
    if (info.computed) {
      info.readOnly = true;
    }
    if (info.computed) {
      if (proto2._hasReadOnlyEffect(name)) {
        console.warn(`Cannot redefine computed property '${name}'.`);
      } else {
        proto2._createComputedProperty(name, info.computed, allProps);
      }
    }
    if (info.readOnly && !proto2._hasReadOnlyEffect(name)) {
      proto2._createReadOnlyProperty(name, !info.computed);
    } else if (info.readOnly === false && proto2._hasReadOnlyEffect(name)) {
      console.warn(`Cannot make readOnly property '${name}' non-readOnly.`);
    }
    if (info.reflectToAttribute && !proto2._hasReflectEffect(name)) {
      proto2._createReflectedProperty(name);
    } else if (info.reflectToAttribute === false && proto2._hasReflectEffect(name)) {
      console.warn(`Cannot make reflected property '${name}' non-reflected.`);
    }
    if (info.notify && !proto2._hasNotifyEffect(name)) {
      proto2._createNotifyingProperty(name);
    } else if (info.notify === false && proto2._hasNotifyEffect(name)) {
      console.warn(`Cannot make notify property '${name}' non-notify.`);
    }
    if (info.observer) {
      proto2._createPropertyObserver(name, info.observer, allProps[info.observer]);
    }
    proto2._addPropertyToAttributeMap(name);
  }
  function processElementStyles(klass, template2, is, baseURI) {
    if (!builtCSS) {
      const templateStyles = template2.content.querySelectorAll("style");
      const stylesWithImports = stylesFromTemplate(template2);
      const linkedStyles = stylesFromModuleImports(is);
      const firstTemplateChild = template2.content.firstElementChild;
      for (let idx = 0; idx < linkedStyles.length; idx++) {
        let s3 = linkedStyles[idx];
        s3.textContent = klass._processStyleText(s3.textContent, baseURI);
        template2.content.insertBefore(s3, firstTemplateChild);
      }
      let templateStyleIndex = 0;
      for (let i2 = 0; i2 < stylesWithImports.length; i2++) {
        let s3 = stylesWithImports[i2];
        let templateStyle = templateStyles[templateStyleIndex];
        if (templateStyle !== s3) {
          s3 = s3.cloneNode(true);
          templateStyle.parentNode.insertBefore(s3, templateStyle);
        } else {
          templateStyleIndex++;
        }
        s3.textContent = klass._processStyleText(s3.textContent, baseURI);
      }
    }
    if (window.ShadyCSS) {
      window.ShadyCSS.prepareTemplate(template2, is);
    }
    if (useAdoptedStyleSheetsWithBuiltCSS && builtCSS && supportsAdoptingStyleSheets) {
      const styles2 = template2.content.querySelectorAll("style");
      if (styles2) {
        let css2 = "";
        Array.from(styles2).forEach((s3) => {
          css2 += s3.textContent;
          s3.parentNode.removeChild(s3);
        });
        klass._styleSheet = new CSSStyleSheet();
        klass._styleSheet.replaceSync(css2);
      }
    }
  }
  function getTemplateFromDomModule(is) {
    let template2 = null;
    if (is && (!strictTemplatePolicy || allowTemplateFromDomModule)) {
      template2 = /** @type {?HTMLTemplateElement} */
      DomModule.import(is, "template");
      if (strictTemplatePolicy && !template2) {
        throw new Error(`strictTemplatePolicy: expecting dom-module or null template for ${is}`);
      }
    }
    return template2;
  }
  class PolymerElement2 extends polymerElementBase {
    /**
     * Current Polymer version in Semver notation.
     * @type {string} Semver notation of the current version of Polymer.
     * @nocollapse
     */
    static get polymerElementVersion() {
      return version;
    }
    /**
     * Override of PropertiesMixin _finalizeClass to create observers and
     * find the template.
     * @return {void}
     * @protected
     * @suppress {missingProperties} Interfaces in closure do not inherit statics, but classes do
     * @nocollapse
     */
    static _finalizeClass() {
      polymerElementBase._finalizeClass.call(this);
      const observers = ownObservers(this);
      if (observers) {
        this.createObservers(observers, this._properties);
      }
      this._prepareTemplate();
    }
    /** @nocollapse */
    static _prepareTemplate() {
      let template2 = (
        /** @type {PolymerElementConstructor} */
        this.template
      );
      if (template2) {
        if (typeof template2 === "string") {
          console.error("template getter must return HTMLTemplateElement");
          template2 = null;
        } else if (!legacyOptimizations) {
          template2 = template2.cloneNode(true);
        }
      }
      this.prototype._template = template2;
    }
    /**
     * Override of PropertiesChanged createProperties to create accessors
     * and property effects for all of the properties.
     * @param {!Object} props .
     * @return {void}
     * @protected
     * @nocollapse
     */
    static createProperties(props) {
      for (let p in props) {
        createPropertyFromConfig(
          /** @type {?} */
          this.prototype,
          p,
          props[p],
          props
        );
      }
    }
    /**
     * Creates observers for the given `observers` array.
     * Leverages `PropertyEffects` to create observers.
     * @param {Object} observers Array of observer descriptors for
     *   this class
     * @param {Object} dynamicFns Object containing keys for any properties
     *   that are functions and should trigger the effect when the function
     *   reference is changed
     * @return {void}
     * @protected
     * @nocollapse
     */
    static createObservers(observers, dynamicFns) {
      const proto2 = this.prototype;
      for (let i2 = 0; i2 < observers.length; i2++) {
        proto2._createMethodObserver(observers[i2], dynamicFns);
      }
    }
    /**
     * Returns the template that will be stamped into this element's shadow root.
     *
     * If a `static get is()` getter is defined, the default implementation will
     * return the first `<template>` in a `dom-module` whose `id` matches this
     * element's `is` (note that a `_template` property on the class prototype
     * takes precedence over the `dom-module` template, to maintain legacy
     * element semantics; a subclass will subsequently fall back to its super
     * class template if neither a `prototype._template` or a `dom-module` for
     * the class's `is` was found).
     *
     * Users may override this getter to return an arbitrary template
     * (in which case the `is` getter is unnecessary). The template returned
     * must be an `HTMLTemplateElement`.
     *
     * Note that when subclassing, if the super class overrode the default
     * implementation and the subclass would like to provide an alternate
     * template via a `dom-module`, it should override this getter and
     * return `DomModule.import(this.is, 'template')`.
     *
     * If a subclass would like to modify the super class template, it should
     * clone it rather than modify it in place.  If the getter does expensive
     * work such as cloning/modifying a template, it should memoize the
     * template for maximum performance:
     *
     *   let memoizedTemplate;
     *   class MySubClass extends MySuperClass {
     *     static get template() {
     *       if (!memoizedTemplate) {
     *         memoizedTemplate = super.template.cloneNode(true);
     *         let subContent = document.createElement('div');
     *         subContent.textContent = 'This came from MySubClass';
     *         memoizedTemplate.content.appendChild(subContent);
     *       }
     *       return memoizedTemplate;
     *     }
     *   }
     *
     * @return {!HTMLTemplateElement|string} Template to be stamped
     * @nocollapse
     */
    static get template() {
      if (!this.hasOwnProperty(JSCompiler_renameProperty("_template", this))) {
        let protoTemplate = this.prototype.hasOwnProperty(
          JSCompiler_renameProperty("_template", this.prototype)
        ) ? this.prototype._template : void 0;
        if (typeof protoTemplate === "function") {
          protoTemplate = protoTemplate();
        }
        this._template = // If user has put template on prototype (e.g. in legacy via registered
        // callback or info object), prefer that first. Note that `null` is
        // used as a sentinel to indicate "no template" and can be used to
        // override a super template, whereas `undefined` is used as a
        // sentinel to mean "fall-back to default template lookup" via
        // dom-module and/or super.template.
        protoTemplate !== void 0 ? protoTemplate : (
          // Look in dom-module associated with this element's is
          this.hasOwnProperty(JSCompiler_renameProperty("is", this)) && getTemplateFromDomModule(
            /** @type {PolymerElementConstructor}*/
            this.is
          ) || // Next look for superclass template (call the super impl this
          // way so that `this` points to the superclass)
          Object.getPrototypeOf(
            /** @type {PolymerElementConstructor}*/
            this.prototype
          ).constructor.template
        );
      }
      return this._template;
    }
    /**
     * Set the template.
     *
     * @param {!HTMLTemplateElement|string} value Template to set.
     * @nocollapse
     */
    static set template(value) {
      this._template = value;
    }
    /**
     * Path matching the url from which the element was imported.
     *
     * This path is used to resolve url's in template style cssText.
     * The `importPath` property is also set on element instances and can be
     * used to create bindings relative to the import path.
     *
     * For elements defined in ES modules, users should implement
     * `static get importMeta() { return import.meta; }`, and the default
     * implementation of `importPath` will  return `import.meta.url`'s path.
     * For elements defined in HTML imports, this getter will return the path
     * to the document containing a `dom-module` element matching this
     * element's static `is` property.
     *
     * Note, this path should contain a trailing `/`.
     *
     * @return {string} The import path for this element class
     * @suppress {missingProperties}
     * @nocollapse
     */
    static get importPath() {
      if (!this.hasOwnProperty(JSCompiler_renameProperty("_importPath", this))) {
        const meta = this.importMeta;
        if (meta) {
          this._importPath = pathFromUrl(meta.url);
        } else {
          const module2 = DomModule.import(
            /** @type {PolymerElementConstructor} */
            this.is
          );
          this._importPath = module2 && module2.assetpath || Object.getPrototypeOf(
            /** @type {PolymerElementConstructor}*/
            this.prototype
          ).constructor.importPath;
        }
      }
      return this._importPath;
    }
    constructor() {
      super();
      this._template;
      this._importPath;
      this.rootPath;
      this.importPath;
      this.root;
      this.$;
    }
    /**
     * Overrides the default `PropertyAccessors` to ensure class
     * metaprogramming related to property accessors and effects has
     * completed (calls `finalize`).
     *
     * It also initializes any property defaults provided via `value` in
     * `properties` metadata.
     *
     * @return {void}
     * @override
     * @suppress {invalidCasts,missingProperties} go/missingfnprops
     */
    _initializeProperties() {
      this.constructor.finalize();
      this.constructor._finalizeTemplate(
        /** @type {!HTMLElement} */
        this.localName
      );
      super._initializeProperties();
      this.rootPath = rootPath;
      this.importPath = this.constructor.importPath;
      let p$ = propertyDefaults(this.constructor);
      if (!p$) {
        return;
      }
      for (let p in p$) {
        let info = p$[p];
        if (this._canApplyPropertyDefault(p)) {
          let value = typeof info.value == "function" ? info.value.call(this) : info.value;
          if (this._hasAccessor(p)) {
            this._setPendingProperty(p, value, true);
          } else {
            this[p] = value;
          }
        }
      }
    }
    /**
     * Determines if a property dfeault can be applied. For example, this
     * prevents a default from being applied when a property that has no
     * accessor is overridden by its host before upgrade (e.g. via a binding).
     * @override
     * @param {string} property Name of the property
     * @return {boolean} Returns true if the property default can be applied.
     */
    _canApplyPropertyDefault(property) {
      return !this.hasOwnProperty(property);
    }
    /**
     * Gather style text for a style element in the template.
     *
     * @param {string} cssText Text containing styling to process
     * @param {string} baseURI Base URI to rebase CSS paths against
     * @return {string} The processed CSS text
     * @protected
     * @nocollapse
     */
    static _processStyleText(cssText, baseURI) {
      return resolveCss(cssText, baseURI);
    }
    /**
    * Configures an element `proto` to function with a given `template`.
    * The element name `is` and extends `ext` must be specified for ShadyCSS
    * style scoping.
    *
    * @param {string} is Tag name (or type extension name) for this element
    * @return {void}
    * @protected
    * @nocollapse
    */
    static _finalizeTemplate(is) {
      const template2 = this.prototype._template;
      if (template2 && !template2.__polymerFinalized) {
        template2.__polymerFinalized = true;
        const importPath = this.importPath;
        const baseURI = importPath ? resolveUrl(importPath) : "";
        processElementStyles(this, template2, is, baseURI);
        this.prototype._bindTemplate(template2);
      }
    }
    /**
     * Provides a default implementation of the standard Custom Elements
     * `connectedCallback`.
     *
     * The default implementation enables the property effects system and
     * flushes any pending properties, and updates shimmed CSS properties
     * when using the ShadyCSS scoping/custom properties polyfill.
     *
     * @override
     * @suppress {missingProperties, invalidCasts} Super may or may not
     *     implement the callback
     * @return {void}
     */
    connectedCallback() {
      if (window.ShadyCSS && this._template) {
        window.ShadyCSS.styleElement(
          /** @type {!HTMLElement} */
          this
        );
      }
      super.connectedCallback();
    }
    /**
     * Stamps the element template.
     *
     * @return {void}
     * @override
     */
    ready() {
      if (this._template) {
        this.root = this._stampTemplate(this._template);
        this.$ = this.root.$;
      }
      super.ready();
    }
    /**
     * Implements `PropertyEffects`'s `_readyClients` call. Attaches
     * element dom by calling `_attachDom` with the dom stamped from the
     * element's template via `_stampTemplate`. Note that this allows
     * client dom to be attached to the element prior to any observers
     * running.
     *
     * @return {void}
     * @override
     */
    _readyClients() {
      if (this._template) {
        this.root = this._attachDom(
          /** @type {StampedTemplate} */
          this.root
        );
      }
      super._readyClients();
    }
    /**
     * Attaches an element's stamped dom to itself. By default,
     * this method creates a `shadowRoot` and adds the dom to it.
     * However, this method may be overridden to allow an element
     * to put its dom in another location.
     *
     * @override
     * @throws {Error}
     * @suppress {missingReturn}
     * @param {StampedTemplate} dom to attach to the element.
     * @return {ShadowRoot} node to which the dom has been attached.
     */
    _attachDom(dom) {
      const n = wrap$1(this);
      if (n.attachShadow) {
        if (dom) {
          if (!n.shadowRoot) {
            n.attachShadow({ mode: "open", shadyUpgradeFragment: dom });
            n.shadowRoot.appendChild(dom);
            if (this.constructor._styleSheet) {
              n.shadowRoot.adoptedStyleSheets = [this.constructor._styleSheet];
            }
          }
          if (syncInitialRender && window.ShadyDOM) {
            window.ShadyDOM.flushInitial(n.shadowRoot);
          }
          return n.shadowRoot;
        }
        return null;
      } else {
        throw new Error("ShadowDOM not available. PolymerElement can create dom as children instead of in ShadowDOM by setting `this.root = this;` before `ready`.");
      }
    }
    /**
     * When using the ShadyCSS scoping and custom property shim, causes all
     * shimmed styles in this element (and its subtree) to be updated
     * based on current custom property values.
     *
     * The optional parameter overrides inline custom property styles with an
     * object of properties where the keys are CSS properties, and the values
     * are strings.
     *
     * Example: `this.updateStyles({'--color': 'blue'})`
     *
     * These properties are retained unless a value of `null` is set.
     *
     * Note: This function does not support updating CSS mixins.
     * You can not dynamically change the value of an `@apply`.
     *
     * @override
     * @param {Object=} properties Bag of custom property key/values to
     *   apply to this element.
     * @return {void}
     * @suppress {invalidCasts}
     */
    updateStyles(properties) {
      if (window.ShadyCSS) {
        window.ShadyCSS.styleSubtree(
          /** @type {!HTMLElement} */
          this,
          properties
        );
      }
    }
    /**
     * Rewrites a given URL relative to a base URL. The base URL defaults to
     * the original location of the document containing the `dom-module` for
     * this element. This method will return the same URL before and after
     * bundling.
     *
     * Note that this function performs no resolution for URLs that start
     * with `/` (absolute URLs) or `#` (hash identifiers).  For general purpose
     * URL resolution, use `window.URL`.
     *
     * @override
     * @param {string} url URL to resolve.
     * @param {string=} base Optional base URL to resolve against, defaults
     * to the element's `importPath`
     * @return {string} Rewritten URL relative to base
     */
    resolveUrl(url, base2) {
      if (!base2 && this.importPath) {
        base2 = resolveUrl(this.importPath);
      }
      return resolveUrl(url, base2);
    }
    /**
     * Overrides `PropertyEffects` to add map of dynamic functions on
     * template info, for consumption by `PropertyEffects` template binding
     * code. This map determines which method templates should have accessors
     * created for them.
     *
     * @param {!HTMLTemplateElement} template Template
     * @param {!TemplateInfo} templateInfo Template metadata for current template
     * @param {!NodeInfo} nodeInfo Node metadata for current template.
     * @return {boolean} .
     * @suppress {missingProperties} Interfaces in closure do not inherit statics, but classes do
     * @nocollapse
     */
    static _parseTemplateContent(template2, templateInfo, nodeInfo) {
      templateInfo.dynamicFns = templateInfo.dynamicFns || this._properties;
      return polymerElementBase._parseTemplateContent.call(
        this,
        template2,
        templateInfo,
        nodeInfo
      );
    }
    /**
     * Overrides `PropertyEffects` to warn on use of undeclared properties in
     * template.
     *
     * @param {Object} templateInfo Template metadata to add effect to
     * @param {string} prop Property that should trigger the effect
     * @param {Object=} effect Effect metadata object
     * @return {void}
     * @protected
     * @suppress {missingProperties} Interfaces in closure do not inherit statics, but classes do
     * @nocollapse
     */
    static _addTemplatePropertyEffect(templateInfo, prop, effect) {
      if (legacyWarnings && !(prop in this._properties) && // Methods used in templates with no dependencies (or only literal
      // dependencies) become accessors with template effects; ignore these
      !(effect.info.part.signature && effect.info.part.signature.static) && // Warnings for bindings added to nested templates are handled by
      // templatizer so ignore both the host-to-template bindings
      // (`hostProp`) and TemplateInstance-to-child bindings
      // (`nestedTemplate`)
      !effect.info.part.hostProp && !templateInfo.nestedTemplate) {
        console.warn(`Property '${prop}' used in template but not declared in 'properties'; attribute will not be observed.`);
      }
      return polymerElementBase._addTemplatePropertyEffect.call(
        this,
        templateInfo,
        prop,
        effect
      );
    }
  }
  return PolymerElement2;
});
/**
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/
const policy = window.trustedTypes && trustedTypes.createPolicy("polymer-html-literal", { createHTML: (s3) => s3 });
class LiteralString {
  /**
   * @param {!ITemplateArray} strings Constant parts of tagged template literal
   * @param {!Array<*>} values Variable parts of tagged template literal
   */
  constructor(strings, values) {
    assertValidTemplateStringParameters(strings, values);
    const string = values.reduce(
      (acc, v, idx) => acc + literalValue(v) + strings[idx + 1],
      strings[0]
    );
    this.value = string.toString();
  }
  /**
   * @return {string} LiteralString string value
   * @override
   */
  toString() {
    return this.value;
  }
}
function literalValue(value) {
  if (value instanceof LiteralString) {
    return (
      /** @type {!LiteralString} */
      value.value
    );
  } else {
    throw new Error(
      `non-literal value passed to Polymer's htmlLiteral function: ${value}`
    );
  }
}
function htmlValue(value) {
  if (value instanceof HTMLTemplateElement) {
    return (
      /** @type {!HTMLTemplateElement } */
      value.innerHTML
    );
  } else if (value instanceof LiteralString) {
    return literalValue(value);
  } else {
    throw new Error(
      `non-template value passed to Polymer's html function: ${value}`
    );
  }
}
const html = function html2(strings, ...values) {
  assertValidTemplateStringParameters(strings, values);
  const template2 = (
    /** @type {!HTMLTemplateElement} */
    document.createElement("template")
  );
  let value = values.reduce(
    (acc, v, idx) => acc + htmlValue(v) + strings[idx + 1],
    strings[0]
  );
  if (policy) {
    value = policy.createHTML(value);
  }
  template2.innerHTML = value;
  return template2;
};
const assertValidTemplateStringParameters = (strings, values) => {
  if (!Array.isArray(strings) || !Array.isArray(strings.raw) || values.length !== strings.length - 1) {
    throw new TypeError("Invalid call to the html template tag");
  }
};
/**
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/
const PolymerElement = ElementMixin$1(HTMLElement);
/**
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/
const wrap = (node) => node;
const HAS_NATIVE_TA = typeof document.head.style.touchAction === "string";
const GESTURE_KEY = "__polymerGestures";
const HANDLED_OBJ = "__polymerGesturesHandled";
const TOUCH_ACTION = "__polymerGesturesTouchAction";
const TAP_DISTANCE = 25;
const TRACK_DISTANCE = 5;
const TRACK_LENGTH = 2;
const MOUSE_EVENTS = ["mousedown", "mousemove", "mouseup", "click"];
const MOUSE_WHICH_TO_BUTTONS = [0, 1, 4, 2];
const MOUSE_HAS_BUTTONS = (function() {
  try {
    return new MouseEvent("test", { buttons: 1 }).buttons === 1;
  } catch (_) {
    return false;
  }
})();
function isMouseEvent(name) {
  return MOUSE_EVENTS.indexOf(name) > -1;
}
let supportsPassive = false;
(function() {
  try {
    const opts = Object.defineProperty({}, "passive", {
      // eslint-disable-next-line getter-return
      get() {
        supportsPassive = true;
      }
    });
    window.addEventListener("test", null, opts);
    window.removeEventListener("test", null, opts);
  } catch (_) {
  }
})();
function PASSIVE_TOUCH(eventName) {
  if (isMouseEvent(eventName) || eventName === "touchend") {
    return;
  }
}
const IS_TOUCH_ONLY = navigator.userAgent.match(/iP(?:[oa]d|hone)|Android/u);
const canBeDisabled = {
  button: true,
  command: true,
  fieldset: true,
  input: true,
  keygen: true,
  optgroup: true,
  option: true,
  select: true,
  textarea: true
};
function hasLeftMouseButton(ev) {
  const type = ev.type;
  if (!isMouseEvent(type)) {
    return false;
  }
  if (type === "mousemove") {
    let buttons = ev.buttons === void 0 ? 1 : ev.buttons;
    if (ev instanceof window.MouseEvent && !MOUSE_HAS_BUTTONS) {
      buttons = MOUSE_WHICH_TO_BUTTONS[ev.which] || 0;
    }
    return Boolean(buttons & 1);
  }
  const button2 = ev.button === void 0 ? 0 : ev.button;
  return button2 === 0;
}
function isSyntheticClick(ev) {
  if (ev.type === "click") {
    if (ev.detail === 0) {
      return true;
    }
    const t2 = _findOriginalTarget(ev);
    if (!t2.nodeType || /** @type {Element} */
    t2.nodeType !== Node.ELEMENT_NODE) {
      return true;
    }
    const bcr = (
      /** @type {Element} */
      t2.getBoundingClientRect()
    );
    const x2 = ev.pageX, y3 = ev.pageY;
    return !(x2 >= bcr.left && x2 <= bcr.right && y3 >= bcr.top && y3 <= bcr.bottom);
  }
  return false;
}
const POINTERSTATE = {
  touch: {
    x: 0,
    y: 0,
    id: -1,
    scrollDecided: false
  }
};
function firstTouchAction(ev) {
  let ta = "auto";
  const path = getComposedPath(ev);
  for (let i2 = 0, n; i2 < path.length; i2++) {
    n = path[i2];
    if (n[TOUCH_ACTION]) {
      ta = n[TOUCH_ACTION];
      break;
    }
  }
  return ta;
}
function trackDocument(stateObj, movefn, upfn) {
  stateObj.movefn = movefn;
  stateObj.upfn = upfn;
  document.addEventListener("mousemove", movefn);
  document.addEventListener("mouseup", upfn);
}
function untrackDocument(stateObj) {
  document.removeEventListener("mousemove", stateObj.movefn);
  document.removeEventListener("mouseup", stateObj.upfn);
  stateObj.movefn = null;
  stateObj.upfn = null;
}
const getComposedPath = window.ShadyDOM && window.ShadyDOM.noPatch ? window.ShadyDOM.composedPath : (event) => event.composedPath && event.composedPath() || [];
const gestures = {};
const recognizers = [];
function deepTargetFind(x2, y3) {
  let node = document.elementFromPoint(x2, y3);
  let next = node;
  while (next && next.shadowRoot && !window.ShadyDOM) {
    const oldNext = next;
    next = next.shadowRoot.elementFromPoint(x2, y3);
    if (oldNext === next) {
      break;
    }
    if (next) {
      node = next;
    }
  }
  return node;
}
function _findOriginalTarget(ev) {
  const path = getComposedPath(
    /** @type {?Event} */
    ev
  );
  return path.length > 0 ? path[0] : ev.target;
}
function _handleNative(ev) {
  const type = ev.type;
  const node = ev.currentTarget;
  const gobj = node[GESTURE_KEY];
  if (!gobj) {
    return;
  }
  const gs = gobj[type];
  if (!gs) {
    return;
  }
  if (!ev[HANDLED_OBJ]) {
    ev[HANDLED_OBJ] = {};
    if (type.startsWith("touch")) {
      const t2 = ev.changedTouches[0];
      if (type === "touchstart") {
        if (ev.touches.length === 1) {
          POINTERSTATE.touch.id = t2.identifier;
        }
      }
      if (POINTERSTATE.touch.id !== t2.identifier) {
        return;
      }
      if (!HAS_NATIVE_TA) {
        if (type === "touchstart" || type === "touchmove") {
          _handleTouchAction(ev);
        }
      }
    }
  }
  const handled = ev[HANDLED_OBJ];
  if (handled.skip) {
    return;
  }
  for (let i2 = 0, r; i2 < recognizers.length; i2++) {
    r = recognizers[i2];
    if (gs[r.name] && !handled[r.name]) {
      if (r.flow && r.flow.start.indexOf(ev.type) > -1 && r.reset) {
        r.reset();
      }
    }
  }
  for (let i2 = 0, r; i2 < recognizers.length; i2++) {
    r = recognizers[i2];
    if (gs[r.name] && !handled[r.name]) {
      handled[r.name] = true;
      r[type](ev);
    }
  }
}
function _handleTouchAction(ev) {
  const t2 = ev.changedTouches[0];
  const type = ev.type;
  if (type === "touchstart") {
    POINTERSTATE.touch.x = t2.clientX;
    POINTERSTATE.touch.y = t2.clientY;
    POINTERSTATE.touch.scrollDecided = false;
  } else if (type === "touchmove") {
    if (POINTERSTATE.touch.scrollDecided) {
      return;
    }
    POINTERSTATE.touch.scrollDecided = true;
    const ta = firstTouchAction(ev);
    let shouldPrevent = false;
    const dx = Math.abs(POINTERSTATE.touch.x - t2.clientX);
    const dy = Math.abs(POINTERSTATE.touch.y - t2.clientY);
    if (!ev.cancelable) ;
    else if (ta === "none") {
      shouldPrevent = true;
    } else if (ta === "pan-x") {
      shouldPrevent = dy > dx;
    } else if (ta === "pan-y") {
      shouldPrevent = dx > dy;
    }
    if (shouldPrevent) {
      ev.preventDefault();
    } else {
      prevent("track");
    }
  }
}
function addListener(node, evType, handler) {
  if (gestures[evType]) {
    _add(node, evType, handler);
    return true;
  }
  return false;
}
function removeListener(node, evType, handler) {
  if (gestures[evType]) {
    _remove(node, evType, handler);
    return true;
  }
  return false;
}
function _add(node, evType, handler) {
  const recognizer = gestures[evType];
  const deps = recognizer.deps;
  const name = recognizer.name;
  let gobj = node[GESTURE_KEY];
  if (!gobj) {
    node[GESTURE_KEY] = gobj = {};
  }
  for (let i2 = 0, dep, gd; i2 < deps.length; i2++) {
    dep = deps[i2];
    if (IS_TOUCH_ONLY && isMouseEvent(dep) && dep !== "click") {
      continue;
    }
    gd = gobj[dep];
    if (!gd) {
      gobj[dep] = gd = { _count: 0 };
    }
    if (gd._count === 0) {
      node.addEventListener(dep, _handleNative, PASSIVE_TOUCH(dep));
    }
    gd[name] = (gd[name] || 0) + 1;
    gd._count = (gd._count || 0) + 1;
  }
  node.addEventListener(evType, handler);
  if (recognizer.touchAction) {
    setTouchAction(node, recognizer.touchAction);
  }
}
function _remove(node, evType, handler) {
  const recognizer = gestures[evType];
  const deps = recognizer.deps;
  const name = recognizer.name;
  const gobj = node[GESTURE_KEY];
  if (gobj) {
    for (let i2 = 0, dep, gd; i2 < deps.length; i2++) {
      dep = deps[i2];
      gd = gobj[dep];
      if (gd && gd[name]) {
        gd[name] = (gd[name] || 1) - 1;
        gd._count = (gd._count || 1) - 1;
        if (gd._count === 0) {
          node.removeEventListener(dep, _handleNative, PASSIVE_TOUCH(dep));
        }
      }
    }
  }
  node.removeEventListener(evType, handler);
}
function register(recog) {
  recognizers.push(recog);
  recog.emits.forEach((emit) => {
    gestures[emit] = recog;
  });
}
function _findRecognizerByEvent(evName) {
  for (let i2 = 0, r; i2 < recognizers.length; i2++) {
    r = recognizers[i2];
    for (let j = 0, n; j < r.emits.length; j++) {
      n = r.emits[j];
      if (n === evName) {
        return r;
      }
    }
  }
  return null;
}
function setTouchAction(node, value) {
  if (HAS_NATIVE_TA && node instanceof HTMLElement) {
    microTask$1.run(() => {
      node.style.touchAction = value;
    });
  }
  node[TOUCH_ACTION] = value;
}
function _fire(target, type, detail) {
  const ev = new Event(type, { bubbles: true, cancelable: true, composed: true });
  ev.detail = detail;
  wrap(
    /** @type {!Node} */
    target
  ).dispatchEvent(ev);
  if (ev.defaultPrevented) {
    const preventer = detail.preventer || detail.sourceEvent;
    if (preventer && preventer.preventDefault) {
      preventer.preventDefault();
    }
  }
}
function prevent(evName) {
  const recognizer = _findRecognizerByEvent(evName);
  if (recognizer.info) {
    recognizer.info.prevent = true;
  }
}
register({
  name: "downup",
  deps: ["mousedown", "touchstart", "touchend"],
  flow: {
    start: ["mousedown", "touchstart"],
    end: ["mouseup", "touchend"]
  },
  emits: ["down", "up"],
  info: {
    movefn: null,
    upfn: null
  },
  /**
   * @this {GestureRecognizer}
   * @return {void}
   */
  reset() {
    untrackDocument(this.info);
  },
  /**
   * @this {GestureRecognizer}
   * @param {MouseEvent} e
   * @return {void}
   */
  mousedown(e2) {
    if (!hasLeftMouseButton(e2)) {
      return;
    }
    const t2 = _findOriginalTarget(e2);
    const self2 = this;
    const movefn = (e3) => {
      if (!hasLeftMouseButton(e3)) {
        downupFire("up", t2, e3);
        untrackDocument(self2.info);
      }
    };
    const upfn = (e3) => {
      if (hasLeftMouseButton(e3)) {
        downupFire("up", t2, e3);
      }
      untrackDocument(self2.info);
    };
    trackDocument(this.info, movefn, upfn);
    downupFire("down", t2, e2);
  },
  /**
   * @this {GestureRecognizer}
   * @param {TouchEvent} e
   * @return {void}
   */
  touchstart(e2) {
    downupFire("down", _findOriginalTarget(e2), e2.changedTouches[0], e2);
  },
  /**
   * @this {GestureRecognizer}
   * @param {TouchEvent} e
   * @return {void}
   */
  touchend(e2) {
    downupFire("up", _findOriginalTarget(e2), e2.changedTouches[0], e2);
  }
});
function downupFire(type, target, event, preventer) {
  if (!target) {
    return;
  }
  _fire(target, type, {
    x: event.clientX,
    y: event.clientY,
    sourceEvent: event,
    preventer,
    prevent(e2) {
      return prevent(e2);
    }
  });
}
register({
  name: "track",
  touchAction: "none",
  deps: ["mousedown", "touchstart", "touchmove", "touchend"],
  flow: {
    start: ["mousedown", "touchstart"],
    end: ["mouseup", "touchend"]
  },
  emits: ["track"],
  info: {
    x: 0,
    y: 0,
    state: "start",
    started: false,
    moves: [],
    /** @this {GestureInfo} */
    addMove(move) {
      if (this.moves.length > TRACK_LENGTH) {
        this.moves.shift();
      }
      this.moves.push(move);
    },
    movefn: null,
    upfn: null,
    prevent: false
  },
  /**
   * @this {GestureRecognizer}
   * @return {void}
   */
  reset() {
    this.info.state = "start";
    this.info.started = false;
    this.info.moves = [];
    this.info.x = 0;
    this.info.y = 0;
    this.info.prevent = false;
    untrackDocument(this.info);
  },
  /**
   * @this {GestureRecognizer}
   * @param {MouseEvent} e
   * @return {void}
   */
  mousedown(e2) {
    if (!hasLeftMouseButton(e2)) {
      return;
    }
    const t2 = _findOriginalTarget(e2);
    const self2 = this;
    const movefn = (e3) => {
      const x2 = e3.clientX, y3 = e3.clientY;
      if (trackHasMovedEnough(self2.info, x2, y3)) {
        self2.info.state = self2.info.started ? e3.type === "mouseup" ? "end" : "track" : "start";
        if (self2.info.state === "start") {
          prevent("tap");
        }
        self2.info.addMove({ x: x2, y: y3 });
        if (!hasLeftMouseButton(e3)) {
          self2.info.state = "end";
          untrackDocument(self2.info);
        }
        if (t2) {
          trackFire(self2.info, t2, e3);
        }
        self2.info.started = true;
      }
    };
    const upfn = (e3) => {
      if (self2.info.started) {
        movefn(e3);
      }
      untrackDocument(self2.info);
    };
    trackDocument(this.info, movefn, upfn);
    this.info.x = e2.clientX;
    this.info.y = e2.clientY;
  },
  /**
   * @this {GestureRecognizer}
   * @param {TouchEvent} e
   * @return {void}
   */
  touchstart(e2) {
    const ct = e2.changedTouches[0];
    this.info.x = ct.clientX;
    this.info.y = ct.clientY;
  },
  /**
   * @this {GestureRecognizer}
   * @param {TouchEvent} e
   * @return {void}
   */
  touchmove(e2) {
    const t2 = _findOriginalTarget(e2);
    const ct = e2.changedTouches[0];
    const x2 = ct.clientX, y3 = ct.clientY;
    if (trackHasMovedEnough(this.info, x2, y3)) {
      if (this.info.state === "start") {
        prevent("tap");
      }
      this.info.addMove({ x: x2, y: y3 });
      trackFire(this.info, t2, ct);
      this.info.state = "track";
      this.info.started = true;
    }
  },
  /**
   * @this {GestureRecognizer}
   * @param {TouchEvent} e
   * @return {void}
   */
  touchend(e2) {
    const t2 = _findOriginalTarget(e2);
    const ct = e2.changedTouches[0];
    if (this.info.started) {
      this.info.state = "end";
      this.info.addMove({ x: ct.clientX, y: ct.clientY });
      trackFire(this.info, t2, ct);
    }
  }
});
function trackHasMovedEnough(info, x2, y3) {
  if (info.prevent) {
    return false;
  }
  if (info.started) {
    return true;
  }
  const dx = Math.abs(info.x - x2);
  const dy = Math.abs(info.y - y3);
  return dx >= TRACK_DISTANCE || dy >= TRACK_DISTANCE;
}
function trackFire(info, target, touch) {
  if (!target) {
    return;
  }
  const secondlast = info.moves[info.moves.length - 2];
  const lastmove = info.moves[info.moves.length - 1];
  const dx = lastmove.x - info.x;
  const dy = lastmove.y - info.y;
  let ddx, ddy = 0;
  if (secondlast) {
    ddx = lastmove.x - secondlast.x;
    ddy = lastmove.y - secondlast.y;
  }
  _fire(target, "track", {
    state: info.state,
    x: touch.clientX,
    y: touch.clientY,
    dx,
    dy,
    ddx,
    ddy,
    sourceEvent: touch,
    hover() {
      return deepTargetFind(touch.clientX, touch.clientY);
    }
  });
}
register({
  name: "tap",
  deps: ["mousedown", "click", "touchstart", "touchend"],
  flow: {
    start: ["mousedown", "touchstart"],
    end: ["click", "touchend"]
  },
  emits: ["tap"],
  info: {
    x: NaN,
    y: NaN,
    prevent: false
  },
  /**
   * @this {GestureRecognizer}
   * @return {void}
   */
  reset() {
    this.info.x = NaN;
    this.info.y = NaN;
    this.info.prevent = false;
  },
  /**
   * @this {GestureRecognizer}
   * @param {MouseEvent} e
   * @return {void}
   */
  mousedown(e2) {
    if (hasLeftMouseButton(e2)) {
      this.info.x = e2.clientX;
      this.info.y = e2.clientY;
    }
  },
  /**
   * @this {GestureRecognizer}
   * @param {MouseEvent} e
   * @return {void}
   */
  click(e2) {
    if (hasLeftMouseButton(e2)) {
      trackForward(this.info, e2);
    }
  },
  /**
   * @this {GestureRecognizer}
   * @param {TouchEvent} e
   * @return {void}
   */
  touchstart(e2) {
    const touch = e2.changedTouches[0];
    this.info.x = touch.clientX;
    this.info.y = touch.clientY;
  },
  /**
   * @this {GestureRecognizer}
   * @param {TouchEvent} e
   * @return {void}
   */
  touchend(e2) {
    trackForward(this.info, e2.changedTouches[0], e2);
  }
});
function trackForward(info, e2, preventer) {
  const dx = Math.abs(e2.clientX - info.x);
  const dy = Math.abs(e2.clientY - info.y);
  const t2 = _findOriginalTarget(preventer || e2);
  if (!t2 || canBeDisabled[
    /** @type {!HTMLElement} */
    t2.localName
  ] && t2.hasAttribute("disabled")) {
    return;
  }
  if (isNaN(dx) || isNaN(dy) || dx <= TAP_DISTANCE && dy <= TAP_DISTANCE || isSyntheticClick(e2)) {
    if (!info.prevent) {
      _fire(t2, "tap", {
        x: e2.clientX,
        y: e2.clientY,
        sourceEvent: e2,
        preventer
      });
    }
  }
}
/**
 * @license
 * Copyright (c) 2021 - 2025 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const DisabledMixin = dedupingMixin(
  (superclass) => class DisabledMixinClass extends superclass {
    static get properties() {
      return {
        /**
         * If true, the user cannot interact with this element.
         */
        disabled: {
          type: Boolean,
          value: false,
          observer: "_disabledChanged",
          reflectToAttribute: true,
          sync: true
        }
      };
    }
    /**
     * @param {boolean} disabled
     * @protected
     */
    _disabledChanged(disabled) {
      this._setAriaDisabled(disabled);
    }
    /**
     * @param {boolean} disabled
     * @protected
     */
    _setAriaDisabled(disabled) {
      if (disabled) {
        this.setAttribute("aria-disabled", "true");
      } else {
        this.removeAttribute("aria-disabled");
      }
    }
    /**
     * Overrides the default element `click` method in order to prevent
     * firing the `click` event when the element is disabled.
     * @protected
     * @override
     */
    click() {
      if (!this.disabled) {
        super.click();
      }
    }
  }
);
/**
 * @license
 * Copyright (c) 2021 - 2025 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const KeyboardMixin = dedupingMixin(
  (superclass) => class KeyboardMixinClass extends superclass {
    /** @protected */
    ready() {
      super.ready();
      this.addEventListener("keydown", (event) => {
        this._onKeyDown(event);
      });
      this.addEventListener("keyup", (event) => {
        this._onKeyUp(event);
      });
    }
    /**
     * A handler for the `keydown` event. By default, it calls
     * separate methods for handling "Enter" and "Escape" keys.
     * Override the method to implement your own behavior.
     *
     * @param {KeyboardEvent} event
     * @protected
     */
    _onKeyDown(event) {
      switch (event.key) {
        case "Enter":
          this._onEnter(event);
          break;
        case "Escape":
          this._onEscape(event);
          break;
      }
    }
    /**
     * A handler for the `keyup` event. By default, it does nothing.
     * Override the method to implement your own behavior.
     *
     * @param {KeyboardEvent} _event
     * @protected
     */
    _onKeyUp(_event) {
    }
    /**
     * A handler for the "Enter" key. By default, it does nothing.
     * Override the method to implement your own behavior.
     *
     * @param {KeyboardEvent} _event
     * @protected
     */
    _onEnter(_event) {
    }
    /**
     * A handler for the "Escape" key. By default, it does nothing.
     * Override the method to implement your own behavior.
     *
     * @param {KeyboardEvent} _event
     * @protected
     */
    _onEscape(_event) {
    }
  }
);
/**
 * @license
 * Copyright (c) 2021 - 2025 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const ActiveMixin = (superclass) => class ActiveMixinClass extends DisabledMixin(KeyboardMixin(superclass)) {
  /**
   * An array of activation keys.
   *
   * See possible values here:
   * https://developer.mozilla.org/ru/docs/Web/API/KeyboardEvent/key/Key_Values
   *
   * @protected
   * @return {!Array<!string>}
   */
  get _activeKeys() {
    return [" "];
  }
  /** @protected */
  ready() {
    super.ready();
    addListener(this, "down", (event) => {
      if (this._shouldSetActive(event)) {
        this._setActive(true);
      }
    });
    addListener(this, "up", () => {
      this._setActive(false);
    });
  }
  /** @protected */
  disconnectedCallback() {
    super.disconnectedCallback();
    this._setActive(false);
  }
  /**
   * @param {KeyboardEvent | MouseEvent} _event
   * @protected
   */
  _shouldSetActive(_event) {
    return !this.disabled;
  }
  /**
   * Sets the `active` attribute on the element if an activation key is pressed.
   *
   * @param {KeyboardEvent} event
   * @protected
   * @override
   */
  _onKeyDown(event) {
    super._onKeyDown(event);
    if (this._shouldSetActive(event) && this._activeKeys.includes(event.key)) {
      this._setActive(true);
      document.addEventListener(
        "keyup",
        (e2) => {
          if (this._activeKeys.includes(e2.key)) {
            this._setActive(false);
          }
        },
        { once: true }
      );
    }
  }
  /**
   * Toggles the `active` attribute on the element.
   *
   * @param {boolean} active
   * @protected
   */
  _setActive(active) {
    this.toggleAttribute("active", active);
  }
};
/**
 * @license
 * Copyright (c) 2019 - 2025 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const accordionHeading = css`
  :host {
    display: block;
    outline: none;
    -webkit-user-select: none;
    user-select: none;
  }

  :host([hidden]) {
    display: none !important;
  }

  button {
    display: flex;
    align-items: center;
    justify-content: inherit;
    width: 100%;
    margin: 0;
    padding: 0;
    background-color: initial;
    color: inherit;
    border: initial;
    outline: none;
    font: inherit;
    text-align: inherit;
  }
`;
/**
 * @license
 * Copyright (c) 2019 - 2025 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
registerStyles$1("vaadin-accordion-heading", accordionHeading, { moduleId: "vaadin-accordion-heading-styles" });
class AccordionHeading extends ActiveMixin(DirMixin(ThemableMixin(PolymerElement))) {
  static get is() {
    return "vaadin-accordion-heading";
  }
  static get template() {
    return html`
      <button id="button" part="content" disabled$="[[disabled]]" aria-expanded$="[[__updateAriaExpanded(opened)]]">
        <span part="toggle" aria-hidden="true"></span>
        <slot></slot>
      </button>
    `;
  }
  static get properties() {
    return {
      /**
       * When true, the element is opened.
       */
      opened: {
        type: Boolean,
        reflectToAttribute: true,
        value: false
      }
    };
  }
  /**
   * @param {DocumentFragment} dom
   * @return {null}
   * @protected
   * @override
   */
  _attachDom(dom) {
    const root2 = this.attachShadow({ mode: "open", delegatesFocus: true });
    root2.appendChild(dom);
    return root2;
  }
  /** @protected */
  ready() {
    super.ready();
    if (!this.hasAttribute("role")) {
      this.setAttribute("role", "heading");
    }
  }
  /** @private */
  __updateAriaExpanded(opened) {
    return opened ? "true" : "false";
  }
}
defineCustomElement(AccordionHeading);
const details = css`
  :host {
    margin: var(--lumo-space-xs) 0;
    outline: none;
    --_focus-ring-color: var(--vaadin-focus-ring-color, var(--lumo-primary-color-50pct));
    --_focus-ring-width: var(--vaadin-focus-ring-width, 2px);
  }

  :host([focus-ring]) ::slotted([slot='summary']) {
    box-shadow: 0 0 0 var(--_focus-ring-width) var(--_focus-ring-color);
  }

  [part='content'] {
    padding: var(--lumo-space-xs) 0 var(--lumo-space-s);
    font-size: var(--lumo-font-size-m);
    line-height: var(--lumo-line-height-m);
  }

  :host([theme~='filled']) {
    background-color: var(--lumo-contrast-5pct);
    border-radius: var(--lumo-border-radius-m);
  }

  :host([theme~='filled']) [part='content'] {
    padding-left: var(--lumo-space-m);
    padding-right: var(--lumo-space-m);
  }

  :host([theme~='small']) [part$='content'] {
    font-size: var(--lumo-font-size-s);
  }
`;
registerStyles$1("vaadin-details", details, { moduleId: "lumo-details" });
const accordionPanel$1 = css`
  :host {
    margin: 0;
    border-bottom: solid 1px var(--lumo-contrast-10pct);
  }

  :host(:last-child) {
    border-bottom: none;
  }

  :host([theme~='filled']) {
    border-bottom: none;
  }

  :host([theme~='filled']:not(:last-child)) {
    margin-bottom: 2px;
  }
`;
registerStyles$1("vaadin-accordion-panel", [details, accordionPanel$1], { moduleId: "lumo-accordion-panel" });
/**
 * @license
 * Copyright (c) 2021 - 2025 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const FocusMixin = dedupingMixin(
  (superclass) => class FocusMixinClass extends superclass {
    /**
     * @protected
     * @return {boolean}
     */
    get _keyboardActive() {
      return isKeyboardActive();
    }
    /** @protected */
    ready() {
      this.addEventListener("focusin", (e2) => {
        if (this._shouldSetFocus(e2)) {
          this._setFocused(true);
        }
      });
      this.addEventListener("focusout", (e2) => {
        if (this._shouldRemoveFocus(e2)) {
          this._setFocused(false);
        }
      });
      super.ready();
    }
    /** @protected */
    disconnectedCallback() {
      super.disconnectedCallback();
      if (this.hasAttribute("focused")) {
        this._setFocused(false);
      }
    }
    /**
     * Override to change how focused and focus-ring attributes are set.
     *
     * @param {boolean} focused
     * @protected
     */
    _setFocused(focused) {
      this.toggleAttribute("focused", focused);
      this.toggleAttribute("focus-ring", focused && this._keyboardActive);
    }
    /**
     * Override to define if the field receives focus based on the event.
     *
     * @param {FocusEvent} _event
     * @return {boolean}
     * @protected
     */
    _shouldSetFocus(_event) {
      return true;
    }
    /**
     * Override to define if the field loses focus based on the event.
     *
     * @param {FocusEvent} _event
     * @return {boolean}
     * @protected
     */
    _shouldRemoveFocus(_event) {
      return true;
    }
  }
);
/**
 * @license
 * Copyright (c) 2021 - 2025 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const TabindexMixin = (superclass) => class TabindexMixinClass extends DisabledMixin(superclass) {
  static get properties() {
    return {
      /**
       * Indicates whether the element can be focused and where it participates in sequential keyboard navigation.
       *
       * @protected
       */
      tabindex: {
        type: Number,
        reflectToAttribute: true,
        observer: "_tabindexChanged"
      },
      /**
       * Stores the last known tabindex since the element has been disabled.
       *
       * @protected
       */
      _lastTabIndex: {
        type: Number
      }
    };
  }
  /**
   * When the element gets disabled, the observer saves the last known tabindex
   * and makes the element not focusable by setting tabindex to -1.
   * As soon as the element gets enabled, the observer restores the last known tabindex
   * so that the element can be focusable again.
   *
   * @protected
   * @override
   */
  _disabledChanged(disabled, oldDisabled) {
    super._disabledChanged(disabled, oldDisabled);
    if (this.__shouldAllowFocusWhenDisabled()) {
      return;
    }
    if (disabled) {
      if (this.tabindex !== void 0) {
        this._lastTabIndex = this.tabindex;
      }
      this.tabindex = -1;
    } else if (oldDisabled) {
      this.tabindex = this._lastTabIndex;
    }
  }
  /**
   * When the user has changed tabindex while the element is disabled,
   * the observer reverts tabindex to -1 and rather saves the new tabindex value to apply it later.
   * The new value will be applied as soon as the element becomes enabled.
   *
   * @protected
   */
  _tabindexChanged(tabindex) {
    if (this.__shouldAllowFocusWhenDisabled()) {
      return;
    }
    if (this.disabled && tabindex !== -1) {
      this._lastTabIndex = tabindex;
      this.tabindex = -1;
    }
  }
  /**
   * Overrides the native `focus` method in order to prevent
   * focusing the element when it is disabled. Note, setting
   * `tabindex` to -1 does not prevent the element from being
   * programmatically focusable.
   *
   * @protected
   * @override
   */
  focus() {
    if (!this.disabled || this.__shouldAllowFocusWhenDisabled()) {
      super.focus();
    }
  }
  /**
   * Returns whether the component should be focusable when disabled.
   * Returns false by default.
   *
   * @private
   * @return {boolean}
   */
  __shouldAllowFocusWhenDisabled() {
    return false;
  }
};
/**
 * @license
 * Copyright (c) 2021 - 2025 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const DelegateFocusMixin = dedupingMixin(
  (superclass) => class DelegateFocusMixinClass extends FocusMixin(TabindexMixin(superclass)) {
    static get properties() {
      return {
        /**
         * Specify that this control should have input focus when the page loads.
         */
        autofocus: {
          type: Boolean
        },
        /**
         * A reference to the focusable element controlled by the mixin.
         * It can be an input, textarea, button or any element with tabindex > -1.
         *
         * Any component implementing this mixin is expected to provide it
         * by using `this._setFocusElement(input)` Polymer API.
         *
         * Toggling `tabindex` attribute on the host element propagates its value to `focusElement`.
         *
         * @protected
         * @type {!HTMLElement}
         */
        focusElement: {
          type: Object,
          readOnly: true,
          observer: "_focusElementChanged"
        },
        /**
         * Override the property from `TabIndexMixin`
         * to ensure the `tabindex` attribute of the focus element
         * will be restored to `0` after re-enabling the element.
         *
         * @protected
         * @override
         */
        _lastTabIndex: {
          value: 0
        }
      };
    }
    constructor() {
      super();
      this._boundOnBlur = this._onBlur.bind(this);
      this._boundOnFocus = this._onFocus.bind(this);
    }
    /** @protected */
    ready() {
      super.ready();
      if (this.autofocus && !this.disabled) {
        requestAnimationFrame(() => {
          this.focus();
          this.setAttribute("focus-ring", "");
        });
      }
    }
    /**
     * @protected
     * @override
     */
    focus() {
      if (this.focusElement && !this.disabled) {
        this.focusElement.focus();
      }
    }
    /**
     * @protected
     * @override
     */
    blur() {
      if (this.focusElement) {
        this.focusElement.blur();
      }
    }
    /**
     * @protected
     * @override
     */
    click() {
      if (this.focusElement && !this.disabled) {
        this.focusElement.click();
      }
    }
    /** @protected */
    _focusElementChanged(element, oldElement) {
      if (element) {
        element.disabled = this.disabled;
        this._addFocusListeners(element);
        this.__forwardTabIndex(this.tabindex);
      } else if (oldElement) {
        this._removeFocusListeners(oldElement);
      }
    }
    /**
     * @param {HTMLElement} element
     * @protected
     */
    _addFocusListeners(element) {
      element.addEventListener("blur", this._boundOnBlur);
      element.addEventListener("focus", this._boundOnFocus);
    }
    /**
     * @param {HTMLElement} element
     * @protected
     */
    _removeFocusListeners(element) {
      element.removeEventListener("blur", this._boundOnBlur);
      element.removeEventListener("focus", this._boundOnFocus);
    }
    /**
     * Focus event does not bubble, so we dispatch it manually
     * on the host element to support adding focus listeners
     * when the focusable element is placed in light DOM.
     * @param {FocusEvent} event
     * @protected
     */
    _onFocus(event) {
      event.stopPropagation();
      this.dispatchEvent(new Event("focus"));
    }
    /**
     * Blur event does not bubble, so we dispatch it manually
     * on the host element to support adding blur listeners
     * when the focusable element is placed in light DOM.
     * @param {FocusEvent} event
     * @protected
     */
    _onBlur(event) {
      event.stopPropagation();
      this.dispatchEvent(new Event("blur"));
    }
    /**
     * @param {FocusEvent} event
     * @return {boolean}
     * @protected
     * @override
     */
    _shouldSetFocus(event) {
      return event.target === this.focusElement;
    }
    /**
     * @param {FocusEvent} event
     * @return {boolean}
     * @protected
     * @override
     */
    _shouldRemoveFocus(event) {
      return event.target === this.focusElement;
    }
    /**
     * @param {boolean} disabled
     * @param {boolean} oldDisabled
     * @protected
     * @override
     */
    _disabledChanged(disabled, oldDisabled) {
      super._disabledChanged(disabled, oldDisabled);
      if (this.focusElement) {
        this.focusElement.disabled = disabled;
      }
      if (disabled) {
        this.blur();
      }
    }
    /**
     * Override an observer from `TabindexMixin`.
     * Do not call super to remove tabindex attribute
     * from the host after it has been forwarded.
     * @param {string} tabindex
     * @protected
     * @override
     */
    _tabindexChanged(tabindex) {
      this.__forwardTabIndex(tabindex);
    }
    /** @private */
    __forwardTabIndex(tabindex) {
      if (tabindex !== void 0 && this.focusElement) {
        this.focusElement.tabIndex = tabindex;
        if (tabindex !== -1) {
          this.tabindex = void 0;
        }
      }
      if (this.disabled && tabindex) {
        if (tabindex !== -1) {
          this._lastTabIndex = tabindex;
        }
        this.tabindex = void 0;
      }
    }
  }
);
/**
 * @license
 * Copyright (c) 2021 - 2025 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const DelegateStateMixin = dedupingMixin(
  (superclass) => class DelegateStateMixinClass extends superclass {
    static get properties() {
      return {
        /**
         * A target element to which attributes and properties are delegated.
         * @protected
         */
        stateTarget: {
          type: Object,
          observer: "_stateTargetChanged"
        }
      };
    }
    /**
     * An array of the host attributes to delegate to the target element.
     */
    static get delegateAttrs() {
      return [];
    }
    /**
     * An array of the host properties to delegate to the target element.
     */
    static get delegateProps() {
      return [];
    }
    /** @protected */
    ready() {
      super.ready();
      this._createDelegateAttrsObserver();
      this._createDelegatePropsObserver();
    }
    /** @protected */
    _stateTargetChanged(target) {
      if (target) {
        this._ensureAttrsDelegated();
        this._ensurePropsDelegated();
      }
    }
    /** @protected */
    _createDelegateAttrsObserver() {
      this._createMethodObserver(`_delegateAttrsChanged(${this.constructor.delegateAttrs.join(", ")})`);
    }
    /** @protected */
    _createDelegatePropsObserver() {
      this._createMethodObserver(`_delegatePropsChanged(${this.constructor.delegateProps.join(", ")})`);
    }
    /** @protected */
    _ensureAttrsDelegated() {
      this.constructor.delegateAttrs.forEach((name) => {
        this._delegateAttribute(name, this[name]);
      });
    }
    /** @protected */
    _ensurePropsDelegated() {
      this.constructor.delegateProps.forEach((name) => {
        this._delegateProperty(name, this[name]);
      });
    }
    /** @protected */
    _delegateAttrsChanged(...values) {
      this.constructor.delegateAttrs.forEach((name, index) => {
        this._delegateAttribute(name, values[index]);
      });
    }
    /** @protected */
    _delegatePropsChanged(...values) {
      this.constructor.delegateProps.forEach((name, index) => {
        this._delegateProperty(name, values[index]);
      });
    }
    /** @protected */
    _delegateAttribute(name, value) {
      if (!this.stateTarget) {
        return;
      }
      if (name === "invalid") {
        this._delegateAttribute("aria-invalid", value ? "true" : false);
      }
      if (typeof value === "boolean") {
        this.stateTarget.toggleAttribute(name, value);
      } else if (value) {
        this.stateTarget.setAttribute(name, value);
      } else {
        this.stateTarget.removeAttribute(name);
      }
    }
    /** @protected */
    _delegateProperty(name, value) {
      if (!this.stateTarget) {
        return;
      }
      this.stateTarget[name] = value;
    }
  }
);
/**
 * @license
 * Copyright (c) 2023 - 2025 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
class SlotObserver {
  constructor(slot, callback) {
    this.slot = slot;
    this.callback = callback;
    this._storedNodes = [];
    this._connected = false;
    this._scheduled = false;
    this._boundSchedule = () => {
      this._schedule();
    };
    this.connect();
    this._schedule();
  }
  /**
   * Activates an observer. This method is automatically called when
   * a `SlotObserver` is created. It should only be called to  re-activate
   * an observer that has been deactivated via the `disconnect` method.
   */
  connect() {
    this.slot.addEventListener("slotchange", this._boundSchedule);
    this._connected = true;
  }
  /**
   * Deactivates the observer. After calling this method the observer callback
   * will not be called when changes to slotted nodes occur. The `connect` method
   * may be subsequently called to reactivate the observer.
   */
  disconnect() {
    this.slot.removeEventListener("slotchange", this._boundSchedule);
    this._connected = false;
  }
  /** @private */
  _schedule() {
    if (!this._scheduled) {
      this._scheduled = true;
      queueMicrotask(() => {
        this.flush();
      });
    }
  }
  /**
   * Run the observer callback synchronously.
   */
  flush() {
    if (!this._connected) {
      return;
    }
    this._scheduled = false;
    this._processNodes();
  }
  /** @private */
  _processNodes() {
    const currentNodes = this.slot.assignedNodes({ flatten: true });
    let addedNodes = [];
    const removedNodes = [];
    const movedNodes = [];
    if (currentNodes.length) {
      addedNodes = currentNodes.filter((node) => !this._storedNodes.includes(node));
    }
    if (this._storedNodes.length) {
      this._storedNodes.forEach((node, index) => {
        const idx = currentNodes.indexOf(node);
        if (idx === -1) {
          removedNodes.push(node);
        } else if (idx !== index) {
          movedNodes.push(node);
        }
      });
    }
    if (addedNodes.length || removedNodes.length || movedNodes.length) {
      this.callback({ addedNodes, currentNodes, movedNodes, removedNodes });
    }
    this._storedNodes = currentNodes;
  }
}
/**
 * @license
 * Copyright (c) 2021 - 2025 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
let uniqueId = 0;
function generateUniqueId() {
  return uniqueId++;
}
/**
 * @license
 * Copyright (c) 2021 - 2025 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
class SlotController extends EventTarget {
  /**
   * Ensure that every instance has unique ID.
   *
   * @param {HTMLElement} host
   * @param {string} slotName
   * @return {string}
   * @protected
   */
  static generateId(host, prefix = "default") {
    return `${prefix}-${host.localName}-${generateUniqueId()}`;
  }
  constructor(host, slotName, tagName, config = {}) {
    super();
    const { initializer, multiple, observe, useUniqueId, uniqueIdPrefix } = config;
    this.host = host;
    this.slotName = slotName;
    this.tagName = tagName;
    this.observe = typeof observe === "boolean" ? observe : true;
    this.multiple = typeof multiple === "boolean" ? multiple : false;
    this.slotInitializer = initializer;
    if (multiple) {
      this.nodes = [];
    }
    if (useUniqueId) {
      this.defaultId = this.constructor.generateId(host, uniqueIdPrefix || slotName);
    }
  }
  hostConnected() {
    if (!this.initialized) {
      if (this.multiple) {
        this.initMultiple();
      } else {
        this.initSingle();
      }
      if (this.observe) {
        this.observeSlot();
      }
      this.initialized = true;
    }
  }
  /** @protected */
  initSingle() {
    let node = this.getSlotChild();
    if (!node) {
      node = this.attachDefaultNode();
      this.initNode(node);
    } else {
      this.node = node;
      this.initAddedNode(node);
    }
  }
  /** @protected */
  initMultiple() {
    const children = this.getSlotChildren();
    if (children.length === 0) {
      const defaultNode = this.attachDefaultNode();
      if (defaultNode) {
        this.nodes = [defaultNode];
        this.initNode(defaultNode);
      }
    } else {
      this.nodes = children;
      children.forEach((node) => {
        this.initAddedNode(node);
      });
    }
  }
  /**
   * Create and attach default node using the provided tag name, if any.
   * @return {Node | undefined}
   * @protected
   */
  attachDefaultNode() {
    const { host, slotName, tagName } = this;
    let node = this.defaultNode;
    if (!node && tagName) {
      node = document.createElement(tagName);
      if (node instanceof Element) {
        if (slotName !== "") {
          node.setAttribute("slot", slotName);
        }
        this.defaultNode = node;
      }
    }
    if (node) {
      this.node = node;
      host.appendChild(node);
    }
    return node;
  }
  /**
   * Return the list of nodes matching the slot managed by the controller.
   * @return {Node}
   */
  getSlotChildren() {
    const { slotName } = this;
    return Array.from(this.host.childNodes).filter((node) => {
      return node.nodeType === Node.ELEMENT_NODE && node.slot === slotName || node.nodeType === Node.TEXT_NODE && node.textContent.trim() && slotName === "";
    });
  }
  /**
   * Return a reference to the node managed by the controller.
   * @return {Node}
   */
  getSlotChild() {
    return this.getSlotChildren()[0];
  }
  /**
   * Run `slotInitializer` for the node managed by the controller.
   *
   * @param {Node} node
   * @protected
   */
  initNode(node) {
    const { slotInitializer } = this;
    if (slotInitializer) {
      slotInitializer(node, this.host);
    }
  }
  /**
   * Override to initialize the newly added custom node.
   *
   * @param {Node} _node
   * @protected
   */
  initCustomNode(_node) {
  }
  /**
   * Override to teardown slotted node when it's removed.
   *
   * @param {Node} _node
   * @protected
   */
  teardownNode(_node) {
  }
  /**
   * Run both `initCustomNode` and `initNode` for a custom slotted node.
   *
   * @param {Node} node
   * @protected
   */
  initAddedNode(node) {
    if (node !== this.defaultNode) {
      this.initCustomNode(node);
      this.initNode(node);
    }
  }
  /**
   * Setup the observer to manage slot content changes.
   * @protected
   */
  observeSlot() {
    const { slotName } = this;
    const selector = slotName === "" ? "slot:not([name])" : `slot[name=${slotName}]`;
    const slot = this.host.shadowRoot.querySelector(selector);
    this.__slotObserver = new SlotObserver(slot, ({ addedNodes, removedNodes }) => {
      const current = this.multiple ? this.nodes : [this.node];
      const newNodes = addedNodes.filter((node) => !isEmptyTextNode(node) && !current.includes(node));
      if (removedNodes.length) {
        this.nodes = current.filter((node) => !removedNodes.includes(node));
        removedNodes.forEach((node) => {
          this.teardownNode(node);
        });
      }
      if (newNodes && newNodes.length > 0) {
        if (this.multiple) {
          if (this.defaultNode) {
            this.defaultNode.remove();
          }
          this.nodes = [...current, ...newNodes].filter((node) => node !== this.defaultNode);
          newNodes.forEach((node) => {
            this.initAddedNode(node);
          });
        } else {
          if (this.node) {
            this.node.remove();
          }
          this.node = newNodes[0];
          this.initAddedNode(this.node);
        }
      }
    });
  }
}
/**
 * @license
 * Copyright (c) 2022 - 2025 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
class TooltipController extends SlotController {
  constructor(host) {
    super(host, "tooltip");
    this.setTarget(host);
  }
  /**
   * Override to initialize the newly added custom tooltip.
   *
   * @param {Node} tooltipNode
   * @protected
   * @override
   */
  initCustomNode(tooltipNode) {
    tooltipNode.target = this.target;
    if (this.ariaTarget !== void 0) {
      tooltipNode.ariaTarget = this.ariaTarget;
    }
    if (this.context !== void 0) {
      tooltipNode.context = this.context;
    }
    if (this.manual !== void 0) {
      tooltipNode.manual = this.manual;
    }
    if (this.opened !== void 0) {
      tooltipNode.opened = this.opened;
    }
    if (this.position !== void 0) {
      tooltipNode._position = this.position;
    }
    if (this.shouldShow !== void 0) {
      tooltipNode.shouldShow = this.shouldShow;
    }
    this.__notifyChange();
  }
  /**
   * Override to notify the host when the tooltip is removed.
   *
   * @param {Node} tooltipNode
   * @protected
   * @override
   */
  teardownNode() {
    this.__notifyChange();
  }
  /**
   * Set an HTML element for linking with the tooltip overlay
   * via `aria-describedby` attribute used by screen readers.
   * @param {HTMLElement} ariaTarget
   */
  setAriaTarget(ariaTarget) {
    this.ariaTarget = ariaTarget;
    const tooltipNode = this.node;
    if (tooltipNode) {
      tooltipNode.ariaTarget = ariaTarget;
    }
  }
  /**
   * Set a context object to be used by generator.
   * @param {object} context
   */
  setContext(context) {
    this.context = context;
    const tooltipNode = this.node;
    if (tooltipNode) {
      tooltipNode.context = context;
    }
  }
  /**
   * Toggle manual state on the slotted tooltip.
   * @param {boolean} manual
   */
  setManual(manual) {
    this.manual = manual;
    const tooltipNode = this.node;
    if (tooltipNode) {
      tooltipNode.manual = manual;
    }
  }
  /**
   * Toggle opened state on the slotted tooltip.
   * @param {boolean} opened
   */
  setOpened(opened) {
    this.opened = opened;
    const tooltipNode = this.node;
    if (tooltipNode) {
      tooltipNode.opened = opened;
    }
  }
  /**
   * Set default position for the slotted tooltip.
   * This can be overridden by setting the position
   * using corresponding property or attribute.
   * @param {string} position
   */
  setPosition(position) {
    this.position = position;
    const tooltipNode = this.node;
    if (tooltipNode) {
      tooltipNode._position = position;
    }
  }
  /**
   * Set function used to detect whether to show
   * the tooltip based on a condition.
   * @param {Function} shouldShow
   */
  setShouldShow(shouldShow) {
    this.shouldShow = shouldShow;
    const tooltipNode = this.node;
    if (tooltipNode) {
      tooltipNode.shouldShow = shouldShow;
    }
  }
  /**
   * Set an HTML element to attach the tooltip to.
   * @param {HTMLElement} target
   */
  setTarget(target) {
    this.target = target;
    const tooltipNode = this.node;
    if (tooltipNode) {
      tooltipNode.target = target;
    }
  }
  /** @private */
  __notifyChange() {
    this.dispatchEvent(new CustomEvent("tooltip-changed", { detail: { node: this.node } }));
  }
}
/**
 * @license
 * Copyright (c) 2022 - 2025 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
class SlotChildObserveController extends SlotController {
  constructor(host, slot, tagName, config = {}) {
    super(host, slot, tagName, { ...config, useUniqueId: true });
  }
  /**
   * Override to initialize the newly added custom node.
   *
   * @param {Node} node
   * @protected
   * @override
   */
  initCustomNode(node) {
    this.__updateNodeId(node);
    this.__notifyChange(node);
  }
  /**
   * Override to notify the controller host about removal of
   * the custom node, and to apply the default one if needed.
   *
   * @param {Node} _node
   * @protected
   * @override
   */
  teardownNode(_node) {
    const node = this.getSlotChild();
    if (node && node !== this.defaultNode) {
      this.__notifyChange(node);
    } else {
      this.restoreDefaultNode();
      this.updateDefaultNode(this.node);
    }
  }
  /**
   * Override method inherited from `SlotMixin`
   * to set ID attribute on the default node.
   *
   * @return {Node}
   * @protected
   * @override
   */
  attachDefaultNode() {
    const node = super.attachDefaultNode();
    if (node) {
      this.__updateNodeId(node);
    }
    return node;
  }
  /**
   * Override to restore default node when a custom one is removed.
   *
   * @protected
   */
  restoreDefaultNode() {
  }
  /**
   * Override to update default node text on property change.
   *
   * @param {Node} node
   * @protected
   */
  updateDefaultNode(node) {
    this.__notifyChange(node);
  }
  /**
   * Setup the mutation observer on the node to update ID and notify host.
   * Node doesn't get observed automatically until this method is called.
   *
   * @param {Node} node
   * @protected
   */
  observeNode(node) {
    if (this.__nodeObserver) {
      this.__nodeObserver.disconnect();
    }
    this.__nodeObserver = new MutationObserver((mutations) => {
      mutations.forEach((mutation) => {
        const target = mutation.target;
        const isCurrentNodeMutation = target === this.node;
        if (mutation.type === "attributes") {
          if (isCurrentNodeMutation) {
            this.__updateNodeId(target);
          }
        } else if (isCurrentNodeMutation || target.parentElement === this.node) {
          this.__notifyChange(this.node);
        }
      });
    });
    this.__nodeObserver.observe(node, {
      attributes: true,
      attributeFilter: ["id"],
      childList: true,
      subtree: true,
      characterData: true
    });
  }
  /**
   * Returns true if a node is an HTML element with children,
   * or is a defined custom element, or has non-empty text.
   *
   * @param {Node} node
   * @return {boolean}
   * @private
   */
  __hasContent(node) {
    if (!node) {
      return false;
    }
    return node.nodeType === Node.ELEMENT_NODE && (customElements.get(node.localName) || node.children.length > 0) || node.textContent && node.textContent.trim() !== "";
  }
  /**
   * Fire an event to notify the controller host about node changes.
   *
   * @param {Node} node
   * @private
   */
  __notifyChange(node) {
    this.dispatchEvent(
      new CustomEvent("slot-content-changed", {
        detail: { hasContent: this.__hasContent(node), node }
      })
    );
  }
  /**
   * Set default ID on the node in case it is an HTML element.
   *
   * @param {Node} node
   * @private
   */
  __updateNodeId(node) {
    const isFirstNode = !this.nodes || node === this.nodes[0];
    if (node.nodeType === Node.ELEMENT_NODE && (!this.multiple || isFirstNode) && !node.id) {
      node.id = this.defaultId;
    }
  }
}
/**
 * @license
 * Copyright (c) 2019 - 2025 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
class ContentController extends SlotChildObserveController {
  /**
   * Override method from `SlotController` to change
   * the ID prefix for the default slot content.
   *
   * @param {HTMLElement} host
   * @return {string}
   * @protected
   * @override
   */
  static generateId(host) {
    return super.generateId(host, "content");
  }
  constructor(host) {
    super(host, "", null, { multiple: true });
  }
}
/**
 * @license
 * Copyright (c) 2019 - 2025 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const CollapsibleMixin = (superClass) => class CollapsibleMixinClass extends superClass {
  static get properties() {
    return {
      /**
       * If true, the collapsible content is visible.
       * @type {boolean}
       */
      opened: {
        type: Boolean,
        value: false,
        reflectToAttribute: true,
        notify: true
      },
      /**
       * List of elements assigned to the default `<slot>`
       * that represent the collapsible content.
       *
       * @protected
       */
      _contentElements: {
        type: Array
      }
    };
  }
  static get observers() {
    return ["_openedOrContentChanged(opened, _contentElements)"];
  }
  constructor() {
    super();
    this._contentController = new ContentController(this);
    this._contentController.addEventListener("slot-content-changed", (event) => {
      const content = event.target.nodes || [];
      this._contentElements = content.filter((node) => node.parentNode === this);
    });
  }
  /** @protected */
  ready() {
    super.ready();
    this.addController(this._contentController);
    this.addEventListener("click", ({ target }) => {
      if (this.disabled) {
        return;
      }
      if (target.localName === "a") {
        return;
      }
      const summary = this.focusElement;
      if (summary && (target === summary || summary.contains(target))) {
        this.opened = !this.opened;
      }
    });
  }
  /** @private */
  _openedOrContentChanged(opened, elements) {
    if (elements) {
      elements.forEach((el) => {
        el.setAttribute("aria-hidden", opened ? "false" : "true");
      });
    }
  }
};
/**
 * @license
 * Copyright (c) 2019 - 2025 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
class SummaryController extends SlotChildObserveController {
  constructor(host, tagName) {
    super(host, "summary", tagName);
  }
  /**
   * Set summary based on corresponding host property.
   *
   * @param {string} summary
   */
  setSummary(summary) {
    this.summary = summary;
    const summaryNode = this.getSlotChild();
    if (!summaryNode) {
      this.restoreDefaultNode();
    }
    if (this.node === this.defaultNode) {
      this.updateDefaultNode(this.node);
    }
  }
  /**
   * Override method inherited from `SlotChildObserveController`
   * to restore and observe the default summary element.
   *
   * @protected
   * @override
   */
  restoreDefaultNode() {
    const { summary } = this;
    if (summary && summary.trim() !== "") {
      this.attachDefaultNode();
    }
  }
  /**
   * Override method inherited from `SlotChildObserveController`
   * to update the default summary element text content.
   *
   * @param {Node | undefined} node
   * @protected
   * @override
   */
  updateDefaultNode(node) {
    if (node) {
      node.textContent = this.summary;
    }
    super.updateDefaultNode(node);
  }
}
/**
 * @license
 * Copyright (c) 2019 - 2025 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const AccordionPanelMixin = (superClass) => class AccordionPanelMixinClass extends CollapsibleMixin(DelegateFocusMixin(DelegateStateMixin(superClass))) {
  static get properties() {
    return {
      /**
       * A text that is displayed in the heading, if no
       * element is assigned to the `summary` slot.
       */
      summary: {
        type: String,
        observer: "_summaryChanged"
      }
    };
  }
  static get observers() {
    return ["__updateAriaAttributes(focusElement, _contentElements)"];
  }
  static get delegateProps() {
    return ["disabled", "opened", "_theme"];
  }
  constructor() {
    super();
    this._summaryController = new SummaryController(this, "vaadin-accordion-heading");
    this._summaryController.addEventListener("slot-content-changed", (event) => {
      const { node } = event.target;
      this._setFocusElement(node);
      this.stateTarget = node;
      this._tooltipController.setTarget(node);
    });
    this._tooltipController = new TooltipController(this);
    this._tooltipController.setPosition("bottom-start");
  }
  /**
   * @protected
   * @override
   */
  __forwardTabIndex(tabindex) {
    super.__forwardTabIndex(tabindex);
    if (tabindex !== void 0 && this.focusElement) {
      this.focusElement.$.button.tabIndex = tabindex;
      this.focusElement.tabIndex = -1;
    }
  }
  /** @protected */
  ready() {
    super.ready();
    this.addController(this._summaryController);
    this.addController(this._tooltipController);
  }
  /**
   * Override method from `DelegateStateMixin` to set delegate `theme`
   * using attribute instead of property (needed for the Lit version).
   * @protected
   * @override
   */
  _delegateProperty(name, value) {
    if (!this.stateTarget) {
      return;
    }
    if (name === "_theme") {
      this._delegateAttribute("theme", value);
      return;
    }
    super._delegateProperty(name, value);
  }
  /**
   * Override method inherited from `DisabledMixin`
   * to not set `aria-disabled` on the host element.
   *
   * @protected
   * @override
   */
  _setAriaDisabled() {
  }
  /** @private */
  _summaryChanged(summary) {
    this._summaryController.setSummary(summary);
  }
  /** @private */
  __updateAriaAttributes(focusElement, contentElements) {
    if (focusElement && contentElements) {
      const node = contentElements[0];
      if (node) {
        node.setAttribute("role", "region");
        node.setAttribute("aria-labelledby", focusElement.id);
      }
      if (node && node.id) {
        focusElement.setAttribute("aria-controls", node.id);
      } else {
        focusElement.removeAttribute("aria-controls");
      }
    }
  }
};
/**
 * @license
 * Copyright (c) 2019 - 2025 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const accordionPanel = css`
  :host {
    display: block;
  }

  :host([hidden]) {
    display: none !important;
  }

  [part='content'] {
    display: none;
    overflow: hidden;
  }

  :host([opened]) [part='content'] {
    display: block;
    overflow: visible;
  }
`;
/**
 * @license
 * Copyright (c) 2019 - 2025 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
registerStyles$1("vaadin-accordion-panel", accordionPanel, { moduleId: "vaadin-accordion-panel-styles" });
class AccordionPanel extends AccordionPanelMixin(ThemableMixin(ControllerMixin(PolymerElement))) {
  static get is() {
    return "vaadin-accordion-panel";
  }
  static get template() {
    return html`
      <slot name="summary"></slot>

      <div part="content">
        <slot></slot>
      </div>

      <slot name="tooltip"></slot>
    `;
  }
}
defineCustomElement(AccordionPanel);
const DEV_MODE_CODE_REGEXP = /\/\*[\*!]\s+vaadin-dev-mode:start([\s\S]*)vaadin-dev-mode:end\s+\*\*\//i;
const FlowClients = window.Vaadin && window.Vaadin.Flow && window.Vaadin.Flow.clients;
function isMinified() {
  function test() {
    return true;
  }
  return uncommentAndRun(test);
}
function isDevelopmentMode() {
  try {
    if (isForcedDevelopmentMode()) {
      return true;
    }
    if (!isLocalhost()) {
      return false;
    }
    if (FlowClients) {
      return !isFlowProductionMode();
    }
    return !isMinified();
  } catch (e2) {
    return false;
  }
}
function isForcedDevelopmentMode() {
  return localStorage.getItem("vaadin.developmentmode.force");
}
function isLocalhost() {
  return ["localhost", "127.0.0.1"].indexOf(window.location.hostname) >= 0;
}
function isFlowProductionMode() {
  if (FlowClients) {
    const productionModeApps = Object.keys(FlowClients).map((key) => FlowClients[key]).filter((client) => client.productionMode);
    if (productionModeApps.length > 0) {
      return true;
    }
  }
  return false;
}
function uncommentAndRun(callback, args) {
  if (typeof callback !== "function") {
    return;
  }
  const match2 = DEV_MODE_CODE_REGEXP.exec(callback.toString());
  if (match2) {
    try {
      callback = new Function(match2[1]);
    } catch (e2) {
      console.log("vaadin-development-mode-detector: uncommentAndRun() failed", e2);
    }
  }
  return callback(args);
}
window["Vaadin"] = window["Vaadin"] || {};
const runIfDevelopmentMode = function(callback, args) {
  if (window.Vaadin.developmentMode) {
    return uncommentAndRun(callback, args);
  }
};
if (window.Vaadin.developmentMode === void 0) {
  window.Vaadin.developmentMode = isDevelopmentMode();
}
function maybeGatherAndSendStats() {
  /*! vaadin-dev-mode:start
    (function () {
  'use strict';
  
  var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) {
    return typeof obj;
  } : function (obj) {
    return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
  };
  
  var classCallCheck = function (instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  };
  
  var createClass = function () {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
  
    return function (Constructor, protoProps, staticProps) {
      if (protoProps) defineProperties(Constructor.prototype, protoProps);
      if (staticProps) defineProperties(Constructor, staticProps);
      return Constructor;
    };
  }();
  
  var getPolymerVersion = function getPolymerVersion() {
    return window.Polymer && window.Polymer.version;
  };
  
  var StatisticsGatherer = function () {
    function StatisticsGatherer(logger) {
      classCallCheck(this, StatisticsGatherer);
  
      this.now = new Date().getTime();
      this.logger = logger;
    }
  
    createClass(StatisticsGatherer, [{
      key: 'frameworkVersionDetectors',
      value: function frameworkVersionDetectors() {
        return {
          'Flow': function Flow() {
            if (window.Vaadin && window.Vaadin.Flow && window.Vaadin.Flow.clients) {
              var flowVersions = Object.keys(window.Vaadin.Flow.clients).map(function (key) {
                return window.Vaadin.Flow.clients[key];
              }).filter(function (client) {
                return client.getVersionInfo;
              }).map(function (client) {
                return client.getVersionInfo().flow;
              });
              if (flowVersions.length > 0) {
                return flowVersions[0];
              }
            }
          },
          'Vaadin Framework': function VaadinFramework() {
            if (window.vaadin && window.vaadin.clients) {
              var frameworkVersions = Object.values(window.vaadin.clients).filter(function (client) {
                return client.getVersionInfo;
              }).map(function (client) {
                return client.getVersionInfo().vaadinVersion;
              });
              if (frameworkVersions.length > 0) {
                return frameworkVersions[0];
              }
            }
          },
          'AngularJs': function AngularJs() {
            if (window.angular && window.angular.version && window.angular.version) {
              return window.angular.version.full;
            }
          },
          'Angular': function Angular() {
            if (window.ng) {
              var tags = document.querySelectorAll("[ng-version]");
              if (tags.length > 0) {
                return tags[0].getAttribute("ng-version");
              }
              return "Unknown";
            }
          },
          'Backbone.js': function BackboneJs() {
            if (window.Backbone) {
              return window.Backbone.VERSION;
            }
          },
          'React': function React() {
            var reactSelector = '[data-reactroot], [data-reactid]';
            if (!!document.querySelector(reactSelector)) {
              // React does not publish the version by default
              return "unknown";
            }
          },
          'Ember': function Ember() {
            if (window.Em && window.Em.VERSION) {
              return window.Em.VERSION;
            } else if (window.Ember && window.Ember.VERSION) {
              return window.Ember.VERSION;
            }
          },
          'jQuery': function (_jQuery) {
            function jQuery() {
              return _jQuery.apply(this, arguments);
            }
  
            jQuery.toString = function () {
              return _jQuery.toString();
            };
  
            return jQuery;
          }(function () {
            if (typeof jQuery === 'function' && jQuery.prototype.jquery !== undefined) {
              return jQuery.prototype.jquery;
            }
          }),
          'Polymer': function Polymer() {
            var version = getPolymerVersion();
            if (version) {
              return version;
            }
          },
          'LitElement': function LitElement() {
            var version = window.litElementVersions && window.litElementVersions[0];
            if (version) {
              return version;
            }
          },
          'LitHtml': function LitHtml() {
            var version = window.litHtmlVersions && window.litHtmlVersions[0];
            if (version) {
              return version;
            }
          },
          'Vue.js': function VueJs() {
            if (window.Vue) {
              return window.Vue.version;
            }
          }
        };
      }
    }, {
      key: 'getUsedVaadinElements',
      value: function getUsedVaadinElements(elements) {
        var version = getPolymerVersion();
        var elementClasses = void 0;
        // NOTE: In case you edit the code here, YOU MUST UPDATE any statistics reporting code in Flow.
        // Check all locations calling the method getEntries() in
        // https://github.com/vaadin/flow/blob/master/flow-server/src/main/java/com/vaadin/flow/internal/UsageStatistics.java#L106
        // Currently it is only used by BootstrapHandler.
        if (version && version.indexOf('2') === 0) {
          // Polymer 2: components classes are stored in window.Vaadin
          elementClasses = Object.keys(window.Vaadin).map(function (c) {
            return window.Vaadin[c];
          }).filter(function (c) {
            return c.is;
          });
        } else {
          // Polymer 3: components classes are stored in window.Vaadin.registrations
          elementClasses = window.Vaadin.registrations || [];
        }
        elementClasses.forEach(function (klass) {
          var version = klass.version ? klass.version : "0.0.0";
          elements[klass.is] = { version: version };
        });
      }
    }, {
      key: 'getUsedVaadinThemes',
      value: function getUsedVaadinThemes(themes) {
        ['Lumo', 'Material'].forEach(function (themeName) {
          var theme;
          var version = getPolymerVersion();
          if (version && version.indexOf('2') === 0) {
            // Polymer 2: themes are stored in window.Vaadin
            theme = window.Vaadin[themeName];
          } else {
            // Polymer 3: themes are stored in custom element registry
            theme = customElements.get('vaadin-' + themeName.toLowerCase() + '-styles');
          }
          if (theme && theme.version) {
            themes[themeName] = { version: theme.version };
          }
        });
      }
    }, {
      key: 'getFrameworks',
      value: function getFrameworks(frameworks) {
        var detectors = this.frameworkVersionDetectors();
        Object.keys(detectors).forEach(function (framework) {
          var detector = detectors[framework];
          try {
            var version = detector();
            if (version) {
              frameworks[framework] = { version: version };
            }
          } catch (e) {}
        });
      }
    }, {
      key: 'gather',
      value: function gather(storage) {
        var storedStats = storage.read();
        var gatheredStats = {};
        var types = ["elements", "frameworks", "themes"];
  
        types.forEach(function (type) {
          gatheredStats[type] = {};
          if (!storedStats[type]) {
            storedStats[type] = {};
          }
        });
  
        var previousStats = JSON.stringify(storedStats);
  
        this.getUsedVaadinElements(gatheredStats.elements);
        this.getFrameworks(gatheredStats.frameworks);
        this.getUsedVaadinThemes(gatheredStats.themes);
  
        var now = this.now;
        types.forEach(function (type) {
          var keys = Object.keys(gatheredStats[type]);
          keys.forEach(function (key) {
            if (!storedStats[type][key] || _typeof(storedStats[type][key]) != _typeof({})) {
              storedStats[type][key] = { firstUsed: now };
            }
            // Discards any previously logged version number
            storedStats[type][key].version = gatheredStats[type][key].version;
            storedStats[type][key].lastUsed = now;
          });
        });
  
        var newStats = JSON.stringify(storedStats);
        storage.write(newStats);
        if (newStats != previousStats && Object.keys(storedStats).length > 0) {
          this.logger.debug("New stats: " + newStats);
        }
      }
    }]);
    return StatisticsGatherer;
  }();
  
  var StatisticsStorage = function () {
    function StatisticsStorage(key) {
      classCallCheck(this, StatisticsStorage);
  
      this.key = key;
    }
  
    createClass(StatisticsStorage, [{
      key: 'read',
      value: function read() {
        var localStorageStatsString = localStorage.getItem(this.key);
        try {
          return JSON.parse(localStorageStatsString ? localStorageStatsString : '{}');
        } catch (e) {
          return {};
        }
      }
    }, {
      key: 'write',
      value: function write(data) {
        localStorage.setItem(this.key, data);
      }
    }, {
      key: 'clear',
      value: function clear() {
        localStorage.removeItem(this.key);
      }
    }, {
      key: 'isEmpty',
      value: function isEmpty() {
        var storedStats = this.read();
        var empty = true;
        Object.keys(storedStats).forEach(function (key) {
          if (Object.keys(storedStats[key]).length > 0) {
            empty = false;
          }
        });
  
        return empty;
      }
    }]);
    return StatisticsStorage;
  }();
  
  var StatisticsSender = function () {
    function StatisticsSender(url, logger) {
      classCallCheck(this, StatisticsSender);
  
      this.url = url;
      this.logger = logger;
    }
  
    createClass(StatisticsSender, [{
      key: 'send',
      value: function send(data, errorHandler) {
        var logger = this.logger;
  
        if (navigator.onLine === false) {
          logger.debug("Offline, can't send");
          errorHandler();
          return;
        }
        logger.debug("Sending data to " + this.url);
  
        var req = new XMLHttpRequest();
        req.withCredentials = true;
        req.addEventListener("load", function () {
          // Stats sent, nothing more to do
          logger.debug("Response: " + req.responseText);
        });
        req.addEventListener("error", function () {
          logger.debug("Send failed");
          errorHandler();
        });
        req.addEventListener("abort", function () {
          logger.debug("Send aborted");
          errorHandler();
        });
        req.open("POST", this.url);
        req.setRequestHeader("Content-Type", "application/json");
        req.send(data);
      }
    }]);
    return StatisticsSender;
  }();
  
  var StatisticsLogger = function () {
    function StatisticsLogger(id) {
      classCallCheck(this, StatisticsLogger);
  
      this.id = id;
    }
  
    createClass(StatisticsLogger, [{
      key: '_isDebug',
      value: function _isDebug() {
        return localStorage.getItem("vaadin." + this.id + ".debug");
      }
    }, {
      key: 'debug',
      value: function debug(msg) {
        if (this._isDebug()) {
          console.info(this.id + ": " + msg);
        }
      }
    }]);
    return StatisticsLogger;
  }();
  
  var UsageStatistics = function () {
    function UsageStatistics() {
      classCallCheck(this, UsageStatistics);
  
      this.now = new Date();
      this.timeNow = this.now.getTime();
      this.gatherDelay = 10; // Delay between loading this file and gathering stats
      this.initialDelay = 24 * 60 * 60;
  
      this.logger = new StatisticsLogger("statistics");
      this.storage = new StatisticsStorage("vaadin.statistics.basket");
      this.gatherer = new StatisticsGatherer(this.logger);
      this.sender = new StatisticsSender("https://tools.vaadin.com/usage-stats/submit", this.logger);
    }
  
    createClass(UsageStatistics, [{
      key: 'maybeGatherAndSend',
      value: function maybeGatherAndSend() {
        var _this = this;
  
        if (localStorage.getItem(UsageStatistics.optOutKey)) {
          return;
        }
        this.gatherer.gather(this.storage);
        setTimeout(function () {
          _this.maybeSend();
        }, this.gatherDelay * 1000);
      }
    }, {
      key: 'lottery',
      value: function lottery() {
        return true;
      }
    }, {
      key: 'currentMonth',
      value: function currentMonth() {
        return this.now.getYear() * 12 + this.now.getMonth();
      }
    }, {
      key: 'maybeSend',
      value: function maybeSend() {
        var firstUse = Number(localStorage.getItem(UsageStatistics.firstUseKey));
        var monthProcessed = Number(localStorage.getItem(UsageStatistics.monthProcessedKey));
  
        if (!firstUse) {
          // Use a grace period to avoid interfering with tests, incognito mode etc
          firstUse = this.timeNow;
          localStorage.setItem(UsageStatistics.firstUseKey, firstUse);
        }
  
        if (this.timeNow < firstUse + this.initialDelay * 1000) {
          this.logger.debug("No statistics will be sent until the initial delay of " + this.initialDelay + "s has passed");
          return;
        }
        if (this.currentMonth() <= monthProcessed) {
          this.logger.debug("This month has already been processed");
          return;
        }
        localStorage.setItem(UsageStatistics.monthProcessedKey, this.currentMonth());
        // Use random sampling
        if (this.lottery()) {
          this.logger.debug("Congratulations, we have a winner!");
        } else {
          this.logger.debug("Sorry, no stats from you this time");
          return;
        }
  
        this.send();
      }
    }, {
      key: 'send',
      value: function send() {
        // Ensure we have the latest data
        this.gatherer.gather(this.storage);
  
        // Read, send and clean up
        var data = this.storage.read();
        data["firstUse"] = Number(localStorage.getItem(UsageStatistics.firstUseKey));
        data["usageStatisticsVersion"] = UsageStatistics.version;
        var info = 'This request contains usage statistics gathered from the application running in development mode. \n\nStatistics gathering is automatically disabled and excluded from production builds.\n\nFor details and to opt-out, see https://github.com/vaadin/vaadin-usage-statistics.\n\n\n\n';
        var self = this;
        this.sender.send(info + JSON.stringify(data), function () {
          // Revert the 'month processed' flag
          localStorage.setItem(UsageStatistics.monthProcessedKey, self.currentMonth() - 1);
        });
      }
    }], [{
      key: 'version',
      get: function get$1() {
        return '2.1.2';
      }
    }, {
      key: 'firstUseKey',
      get: function get$1() {
        return 'vaadin.statistics.firstuse';
      }
    }, {
      key: 'monthProcessedKey',
      get: function get$1() {
        return 'vaadin.statistics.monthProcessed';
      }
    }, {
      key: 'optOutKey',
      get: function get$1() {
        return 'vaadin.statistics.optout';
      }
    }]);
    return UsageStatistics;
  }();
  
  try {
    window.Vaadin = window.Vaadin || {};
    window.Vaadin.usageStatsChecker = window.Vaadin.usageStatsChecker || new UsageStatistics();
    window.Vaadin.usageStatsChecker.maybeGatherAndSend();
  } catch (e) {
    // Intentionally ignored as this is not a problem in the app being developed
  }
  
  }());
  
    vaadin-dev-mode:end **/
}
const usageStatistics = function() {
  if (typeof runIfDevelopmentMode === "function") {
    return runIfDevelopmentMode(maybeGatherAndSendStats);
  }
};
/**
 * @license
 * Copyright (c) 2021 - 2025 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
if (!window.Vaadin) {
  window.Vaadin = {};
}
if (!window.Vaadin.registrations) {
  window.Vaadin.registrations = [];
}
if (!window.Vaadin.developmentModeCallback) {
  window.Vaadin.developmentModeCallback = {};
}
window.Vaadin.developmentModeCallback["vaadin-usage-statistics"] = function() {
  usageStatistics();
};
let statsJob;
const registered = /* @__PURE__ */ new Set();
const ElementMixin = (superClass) => class VaadinElementMixin extends DirMixin(superClass) {
  /** @protected */
  static finalize() {
    super.finalize();
    const { is } = this;
    if (is && !registered.has(is)) {
      window.Vaadin.registrations.push(this);
      registered.add(is);
      if (window.Vaadin.developmentModeCallback) {
        statsJob = Debouncer$1.debounce(statsJob, idlePeriod$1, () => {
          window.Vaadin.developmentModeCallback["vaadin-usage-statistics"]();
        });
        enqueueDebouncer$1(statsJob);
      }
    }
  }
  constructor() {
    super();
    if (document.doctype === null) {
      console.warn(
        'Vaadin components require the "standards mode" declaration. Please add <!DOCTYPE html> to the HTML document.'
      );
    }
  }
};
/**
 * @license
 * Copyright (c) 2022 - 2025 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const KeyboardDirectionMixin = (superclass) => class KeyboardDirectionMixinClass extends KeyboardMixin(superclass) {
  /**
   * @return {Element | null}
   * @protected
   */
  get focused() {
    return (this._getItems() || []).find(isElementFocused);
  }
  /**
   * @return {boolean}
   * @protected
   */
  get _vertical() {
    return true;
  }
  /** @protected */
  focus() {
    const items = this._getItems();
    if (Array.isArray(items)) {
      const idx = this._getAvailableIndex(items, 0, null, (item2) => !isElementHidden(item2));
      if (idx >= 0) {
        this._focus(idx);
      }
    }
  }
  /**
   * Get the list of items participating in keyboard navigation.
   * By default, it treats all the light DOM children as items.
   * Override this method to provide custom list of elements.
   *
   * @return {Element[]}
   * @protected
   */
  _getItems() {
    return Array.from(this.children);
  }
  /**
   * Override an event listener from `KeyboardMixin`.
   *
   * @param {!KeyboardEvent} event
   * @protected
   * @override
   */
  _onKeyDown(event) {
    super._onKeyDown(event);
    if (event.metaKey || event.ctrlKey) {
      return;
    }
    const { key } = event;
    const items = this._getItems() || [];
    const currentIdx = items.indexOf(this.focused);
    let idx;
    let increment;
    const isRTL = !this._vertical && this.getAttribute("dir") === "rtl";
    const dirIncrement = isRTL ? -1 : 1;
    if (this.__isPrevKey(key)) {
      increment = -dirIncrement;
      idx = currentIdx - dirIncrement;
    } else if (this.__isNextKey(key)) {
      increment = dirIncrement;
      idx = currentIdx + dirIncrement;
    } else if (key === "Home") {
      increment = 1;
      idx = 0;
    } else if (key === "End") {
      increment = -1;
      idx = items.length - 1;
    }
    idx = this._getAvailableIndex(items, idx, increment, (item2) => !isElementHidden(item2));
    if (idx >= 0) {
      event.preventDefault();
      this._focus(idx, true);
    }
  }
  /**
   * @param {string} key
   * @return {boolean}
   * @private
   */
  __isPrevKey(key) {
    return this._vertical ? key === "ArrowUp" : key === "ArrowLeft";
  }
  /**
   * @param {string} key
   * @return {boolean}
   * @private
   */
  __isNextKey(key) {
    return this._vertical ? key === "ArrowDown" : key === "ArrowRight";
  }
  /**
   * Focus the item at given index. Override this method to add custom logic.
   *
   * @param {number} index
   * @param {boolean} navigating
   * @protected
   */
  _focus(index, navigating = false) {
    const items = this._getItems();
    this._focusItem(items[index], navigating);
  }
  /**
   * Focus the given item. Override this method to add custom logic.
   *
   * @param {Element} item
   * @param {boolean} navigating
   * @protected
   */
  _focusItem(item2) {
    if (item2) {
      item2.focus();
      item2.setAttribute("focus-ring", "");
    }
  }
  /**
   * Returns index of the next item that satisfies the given condition,
   * based on the index of the current item and a numeric increment.
   *
   * @param {Element[]} items - array of items to iterate over
   * @param {number} index - index of the current item
   * @param {number} increment - numeric increment, can be either 1 or -1
   * @param {Function} condition - function used to check the item
   * @return {number}
   * @protected
   */
  _getAvailableIndex(items, index, increment, condition) {
    const totalItems = items.length;
    let idx = index;
    for (let i2 = 0; typeof idx === "number" && i2 < totalItems; i2 += 1, idx += increment || 1) {
      if (idx < 0) {
        idx = totalItems - 1;
      } else if (idx >= totalItems) {
        idx = 0;
      }
      const item2 = items[idx];
      if (this._isItemFocusable(item2) && this.__isMatchingItem(item2, condition)) {
        return idx;
      }
    }
    return -1;
  }
  /**
   * Returns true if the item matches condition.
   *
   * @param {Element} item - item to check
   * @param {Function} condition - function used to check the item
   * @return {number}
   * @private
   */
  __isMatchingItem(item2, condition) {
    return typeof condition === "function" ? condition(item2) : true;
  }
  /**
   * Returns whether the item is focusable. By default,
   * returns true if the item is not disabled.
   *
   * @param {Element} item
   * @return {boolean}
   * @protected
   */
  _isItemFocusable(item2) {
    return !item2.hasAttribute("disabled");
  }
};
/**
 * @license
 * Copyright (c) 2019 - 2025 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const AccordionMixin = (superClass) => class AccordionMixinClass extends KeyboardDirectionMixin(superClass) {
  static get properties() {
    return {
      /**
       * The index of currently opened panel. First panel is opened by
       * default. Only one panel can be opened at the same time.
       * Setting null or undefined closes all the accordion panels.
       * @type {number}
       */
      opened: {
        type: Number,
        value: 0,
        notify: true,
        reflectToAttribute: true
      },
      /**
       * The list of `<vaadin-accordion-panel>` child elements.
       * It is populated from the elements passed to the light DOM,
       * and updated dynamically when adding or removing panels.
       * @type {!Array<!AccordionPanel>}
       */
      items: {
        type: Array,
        readOnly: true,
        notify: true
      }
    };
  }
  static get observers() {
    return ["_updateItems(items, opened)"];
  }
  constructor() {
    super();
    this._boundUpdateOpened = this._updateOpened.bind(this);
  }
  /**
   * Override getter from `KeyboardDirectionMixin`
   * to check if the heading element has focus.
   *
   * @return {Element | null}
   * @protected
   * @override
   */
  get focused() {
    return (this._getItems() || []).find((item2) => isElementFocused(item2.focusElement));
  }
  /**
   * @protected
   * @override
   */
  focus() {
    if (this._observer) {
      this._observer.flush();
    }
    super.focus();
  }
  /** @protected */
  ready() {
    super.ready();
    const slot = this.shadowRoot.querySelector("slot");
    this._observer = new SlotObserver(slot, (info) => {
      this._setItems(this._filterItems(Array.from(this.children)));
      this._filterItems(info.addedNodes).forEach((el) => {
        el.addEventListener("opened-changed", this._boundUpdateOpened);
      });
    });
  }
  /**
   * Override method inherited from `KeyboardDirectionMixin`
   * to use the stored list of accordion panels as items.
   *
   * @return {Element[]}
   * @protected
   * @override
   */
  _getItems() {
    return this.items;
  }
  /**
   * @param {!Array<!Element>} array
   * @return {!Array<!AccordionPanel>}
   * @protected
   */
  _filterItems(array) {
    return array.filter((el) => el instanceof customElements.get("vaadin-accordion-panel"));
  }
  /** @private */
  _updateItems(items, opened) {
    if (items) {
      this.__itemsSync = true;
      const itemToOpen = items[opened];
      items.forEach((item2) => {
        item2.opened = item2 === itemToOpen;
      });
      this.__itemsSync = false;
    }
  }
  /**
   * Override an event listener from `KeyboardMixin`
   * to only handle details toggle buttons events.
   *
   * @param {!KeyboardEvent} event
   * @protected
   * @override
   */
  _onKeyDown(event) {
    if (!this.items.some((item2) => item2.focusElement === event.target)) {
      return;
    }
    super._onKeyDown(event);
  }
  /** @private */
  _updateOpened(e2) {
    if (this.__itemsSync) {
      return;
    }
    const target = this._filterItems(e2.composedPath())[0];
    const idx = this.items.indexOf(target);
    if (e2.detail.value) {
      if (target.disabled || idx === -1) {
        return;
      }
      this.opened = idx;
    } else if (!this.items.some((item2) => item2.opened)) {
      this.opened = null;
    }
  }
};
/**
 * @license
 * Copyright (c) 2019 - 2025 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
class Accordion extends AccordionMixin(ThemableMixin(ElementMixin(PolymerElement))) {
  static get template() {
    return html`
      <style>
        :host {
          display: block;
        }

        :host([hidden]) {
          display: none !important;
        }
      </style>
      <slot></slot>
    `;
  }
  static get is() {
    return "vaadin-accordion";
  }
}
defineCustomElement(Accordion);
/**
 * @license
 * Copyright (c) 2017 - 2025 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const INTERACTION_EVENTS = ["mousedown", "mouseup", "click", "dblclick", "keypress", "keydown", "keyup"];
const ButtonMixin = (superClass) => class ButtonMixinClass extends ActiveMixin(TabindexMixin(FocusMixin(superClass))) {
  constructor() {
    super();
    this.__onInteractionEvent = this.__onInteractionEvent.bind(this);
    INTERACTION_EVENTS.forEach((eventType) => {
      this.addEventListener(eventType, this.__onInteractionEvent, true);
    });
    this.tabindex = 0;
  }
  /**
   * By default, `Space` is the only possible activation key for a focusable HTML element.
   * Nonetheless, the button is an exception as it can be also activated by pressing `Enter`.
   * See the "Keyboard Support" section in https://www.w3.org/TR/wai-aria-practices/examples/button/button.html.
   *
   * @protected
   * @override
   */
  get _activeKeys() {
    return ["Enter", " "];
  }
  /** @protected */
  ready() {
    super.ready();
    if (!this.hasAttribute("role")) {
      this.setAttribute("role", "button");
    }
    if (this.__shouldAllowFocusWhenDisabled()) {
      this.style.setProperty("--_vaadin-button-disabled-pointer-events", "auto");
    }
  }
  /**
   * Since the button component is designed on the base of the `[role=button]` attribute,
   * and doesn't have a native <button> inside, in order to be fully accessible from the keyboard,
   * it should manually fire the `click` event once an activation key is pressed,
   * as it follows from the WAI-ARIA specifications:
   * https://www.w3.org/TR/wai-aria-practices-1.1/#button
   *
   * According to the UI Events specifications,
   * the `click` event should be fired exactly on `keydown`:
   * https://www.w3.org/TR/uievents/#event-type-keydown
   *
   * @param {KeyboardEvent} event
   * @protected
   * @override
   */
  _onKeyDown(event) {
    super._onKeyDown(event);
    if (event.altKey || event.shiftKey || event.ctrlKey || event.metaKey) {
      return;
    }
    if (this._activeKeys.includes(event.key)) {
      event.preventDefault();
      this.click();
    }
  }
  /** @private */
  __onInteractionEvent(event) {
    if (this.__shouldSuppressInteractionEvent(event)) {
      event.stopImmediatePropagation();
    }
  }
  /**
   * Returns whether to suppress interaction events like `click`, `keydown`, etc.
   * By default suppresses all interaction events when the button is disabled.
   *
   * @private
   */
  __shouldSuppressInteractionEvent(_event) {
    return this.disabled;
  }
};
/**
 * @license
 * Copyright (c) 2019 - 2025 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
class DetailsSummary extends ButtonMixin(DirMixin(ThemableMixin(PolymerElement))) {
  static get is() {
    return "vaadin-details-summary";
  }
  static get template() {
    return html`
      <style>
        :host {
          display: block;
          outline: none;
          white-space: nowrap;
          -webkit-user-select: none;
          user-select: none;
        }

        :host([hidden]) {
          display: none !important;
        }

        :host([disabled]) {
          pointer-events: none;
        }
      </style>
      <span part="toggle" aria-hidden="true"></span>
      <div part="content"><slot></slot></div>
    `;
  }
  static get properties() {
    return {
      /**
       * When true, the element is opened.
       */
      opened: {
        type: Boolean,
        reflectToAttribute: true
      }
    };
  }
}
defineCustomElement(DetailsSummary);
/**
 * @license
 * Copyright (c) 2017 - 2025 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const DetailsBaseMixin = (superClass) => class DetailsBaseMixin extends CollapsibleMixin(DelegateFocusMixin(DelegateStateMixin(superClass))) {
  static get properties() {
    return {
      /**
       * A text that is displayed in the summary, if no
       * element is assigned to the `summary` slot.
       */
      summary: {
        type: String,
        observer: "_summaryChanged"
      }
    };
  }
  static get observers() {
    return ["__updateAriaControls(focusElement, _contentElements)", "__updateAriaExpanded(focusElement, opened)"];
  }
  static get delegateProps() {
    return ["disabled", "opened", "_theme"];
  }
  constructor() {
    super();
    this._summaryController = new SummaryController(this, "vaadin-details-summary");
    this._summaryController.addEventListener("slot-content-changed", (event) => {
      const { node } = event.target;
      this._setFocusElement(node);
      this.stateTarget = node;
      this._tooltipController.setTarget(node);
    });
    this._tooltipController = new TooltipController(this);
    this._tooltipController.setPosition("bottom-start");
  }
  /** @protected */
  ready() {
    super.ready();
    this.addController(this._summaryController);
    this.addController(this._tooltipController);
  }
  /**
   * Override method from `DelegateStateMixin` to set delegate `theme`
   * using attribute instead of property (needed for the Lit version).
   * @protected
   * @override
   */
  _delegateProperty(name, value) {
    if (!this.stateTarget) {
      return;
    }
    if (name === "_theme") {
      this._delegateAttribute("theme", value);
      return;
    }
    super._delegateProperty(name, value);
  }
  /**
   * Override method inherited from `DisabledMixin`
   * to not set `aria-disabled` on the host element.
   *
   * @protected
   * @override
   */
  _setAriaDisabled() {
  }
  /** @private */
  _summaryChanged(summary) {
    this._summaryController.setSummary(summary);
  }
  /** @private */
  __updateAriaControls(summary, contentElements) {
    if (summary && contentElements) {
      const node = contentElements[0];
      if (node && node.id) {
        summary.setAttribute("aria-controls", node.id);
      } else {
        summary.removeAttribute("aria-controls");
      }
    }
  }
  /** @private */
  __updateAriaExpanded(focusElement, opened) {
    if (focusElement) {
      focusElement.setAttribute("aria-expanded", opened ? "true" : "false");
    }
  }
};
/**
 * @license
 * Copyright (c) 2019 - 2025 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
class Details extends DetailsBaseMixin(ElementMixin(ThemableMixin(ControllerMixin(PolymerElement)))) {
  static get template() {
    return html`
      <style>
        :host {
          display: block;
        }

        :host([hidden]) {
          display: none !important;
        }

        [part='content'] {
          display: none;
        }

        :host([opened]) [part='content'] {
          display: block;
        }
      </style>

      <slot name="summary"></slot>

      <div part="content">
        <slot></slot>
      </div>

      <slot name="tooltip"></slot>
    `;
  }
  static get is() {
    return "vaadin-details";
  }
}
defineCustomElement(Details);
registerStyles$1(
  "vaadin-app-layout",
  css`
    [part='navbar'],
    [part='drawer'] {
      background-color: var(--lumo-base-color);
      background-clip: padding-box;
    }

    [part='navbar'] {
      min-height: var(--lumo-size-xl);
      border-bottom: 1px solid var(--lumo-contrast-10pct);
    }

    [part='navbar'][bottom] {
      border-bottom: none;
      border-top: 1px solid var(--lumo-contrast-10pct);
    }

    [part='drawer'] {
      border-inline-end: 1px solid var(--lumo-contrast-10pct);
    }

    :host([overlay]) [part='drawer'] {
      border-inline-end: none;
      box-shadow: var(--lumo-box-shadow-s);
    }

    :host([primary-section='navbar']) [part='navbar'] {
      border: none;
      background-image: linear-gradient(var(--lumo-contrast-5pct), var(--lumo-contrast-5pct));
    }

    :host([primary-section='drawer']:not([overlay])) [part='drawer'] {
      background-image: linear-gradient(var(--lumo-shade-5pct), var(--lumo-shade-5pct));
    }

    [part='backdrop'] {
      background-color: var(--lumo-shade-20pct);
      opacity: 1;
    }

    [part] ::slotted(h2),
    [part] ::slotted(h3),
    [part] ::slotted(h4) {
      margin-top: var(--lumo-space-xs) !important;
      margin-bottom: var(--lumo-space-xs) !important;
    }
  `,
  { moduleId: "lumo-app-layout" }
);
/**
 * @license
 * Copyright (c) 2018 - 2025 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
function _detectIosNavbar() {
  if (isIOS) {
    const innerHeight = window.innerHeight;
    const innerWidth = window.innerWidth;
    const landscape = innerWidth > innerHeight;
    const clientHeight = document.documentElement.clientHeight;
    if (landscape && clientHeight > innerHeight) {
      document.documentElement.style.setProperty("--vaadin-viewport-offset-bottom", `${clientHeight - innerHeight}px`);
    } else {
      document.documentElement.style.setProperty("--vaadin-viewport-offset-bottom", "");
    }
  }
}
_detectIosNavbar();
window.addEventListener("resize", _detectIosNavbar);
const template$7 = document.createElement("template");
template$7.innerHTML = `
  <style>
    /* Use units so that the values can be used in calc() */
    html {
      --safe-area-inset-top: env(safe-area-inset-top, 0px);
      --safe-area-inset-right: env(safe-area-inset-right, 0px);
      --safe-area-inset-bottom: env(safe-area-inset-bottom, 0px);
      --safe-area-inset-left: env(safe-area-inset-left, 0px);
    }
  </style>
`;
document.head.appendChild(template$7.content);
/**
 * @license
 * Copyright (c) 2025 - 2025 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
function deepMerge(target, ...sources) {
  const isArray = (item2) => Array.isArray(item2);
  const isObject = (item2) => item2 && typeof item2 === "object" && !isArray(item2);
  const merge = (target2, source) => {
    if (isObject(source) && isObject(target2)) {
      Object.keys(source).forEach((key) => {
        const sourceValue = source[key];
        if (isObject(sourceValue)) {
          if (!target2[key]) {
            target2[key] = {};
          }
          merge(target2[key], sourceValue);
        } else if (isArray(sourceValue)) {
          target2[key] = [...sourceValue];
        } else if (sourceValue !== void 0 && sourceValue !== null) {
          target2[key] = sourceValue;
        }
      });
    }
  };
  sources.forEach((source) => {
    merge(target, source);
  });
  return target;
}
const I18nMixin = (defaultI18n, superClass) => class I18nMixinClass extends superClass {
  static get properties() {
    return {
      /** @private */
      // Technically declaring a Polymer property is not needed, as we have a
      // getter/setter for it below. However, the React components currently
      // rely on the Polymer property declaration to detect which properties
      // are available on a custom element, so we add a dummy declaration for
      // it.
      i18n: {
        type: Object
      },
      /** @private */
      __effectiveI18n: {
        type: Object,
        sync: true
      }
    };
  }
  constructor() {
    super();
    this.i18n = deepMerge({}, defaultI18n);
  }
  /**
   * The object used to localize this component. To change the default
   * localization, replace this with an object that provides all properties, or
   * just the individual properties you want to change.
   *
   * Should be overridden by subclasses to provide a custom JSDoc with the
   * default I18N properties.
   *
   * @returns {Object}
   */
  get i18n() {
    return this.__customI18n;
  }
  /**
   * The object used to localize this component. To change the default
   * localization, replace this with an object that provides all properties, or
   * just the individual properties you want to change.
   *
   * Should be overridden by subclasses to provide a custom JSDoc with the
   * default I18N properties.
   *
   * @param {Object} value
   */
  set i18n(value) {
    if (value === this.__customI18n) {
      return;
    }
    this.__customI18n = value;
    this.__effectiveI18n = deepMerge({}, defaultI18n, this.__customI18n);
  }
};
/**
 * @license
 * Copyright (c) 2018 - 2025 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const DEFAULT_I18N$2 = {
  drawer: "Drawer"
};
const AppLayoutMixin = (superclass) => class AppLayoutMixinClass extends I18nMixin(DEFAULT_I18N$2, superclass) {
  static get properties() {
    return {
      /**
       * Defines whether navbar or drawer will come first visually.
       * - By default (`primary-section="navbar"`), the navbar takes the full available width and moves the drawer down.
       * - If `primary-section="drawer"` is set, then the drawer will move the navbar, taking the full available height.
       * @attr {navbar|drawer} primary-section
       * @type {!PrimarySection}
       */
      primarySection: {
        type: String,
        value: "navbar",
        notify: true,
        reflectToAttribute: true,
        observer: "__primarySectionChanged",
        sync: true
      },
      /**
       * Controls whether the drawer is opened (visible) or not.
       * Its default value depends on the viewport:
       * - `true`, for desktop size views
       * - `false`, for mobile size views
       * @attr {boolean} drawer-opened
       * @type {boolean}
       */
      drawerOpened: {
        type: Boolean,
        notify: true,
        value: true,
        reflectToAttribute: true,
        observer: "__drawerOpenedChanged",
        sync: true
      },
      /**
       * Drawer is an overlay on top of the content
       * Controlled via CSS using `--vaadin-app-layout-drawer-overlay: true|false`;
       * @type {boolean}
       */
      overlay: {
        type: Boolean,
        notify: true,
        readOnly: true,
        value: false,
        reflectToAttribute: true,
        observer: "__overlayChanged",
        sync: true
      },
      /**
       * A global event that causes the drawer to close (be hidden) when it is in overlay mode.
       * - The default is `vaadin-router-location-changed` dispatched by Vaadin Router
       *
       * @attr {string} close-drawer-on
       * @type {string}
       */
      closeDrawerOn: {
        type: String,
        value: "vaadin-router-location-changed",
        observer: "_closeDrawerOnChanged"
      }
    };
  }
  static get observers() {
    return ["__i18nChanged(__effectiveI18n)"];
  }
  /**
   * Helper static method that dispatches a `close-overlay-drawer` event
   */
  static dispatchCloseOverlayDrawerEvent() {
    window.dispatchEvent(new CustomEvent("close-overlay-drawer"));
  }
  /**
   * The object used to localize this component. To change the default
   * localization, replace this with an object that provides all properties, or
   * just the individual properties you want to change.
   *
   * The object has the following structure and default values:
   * ```
   * {
   *   drawer: 'Drawer'
   * }
   * ```
   * @return {!AppLayoutI18n}
   */
  get i18n() {
    return super.i18n;
  }
  set i18n(value) {
    super.i18n = value;
  }
  constructor() {
    super();
    this.__boundResizeListener = this._resize.bind(this);
    this.__drawerToggleClickListener = this._drawerToggleClick.bind(this);
    this.__onDrawerKeyDown = this.__onDrawerKeyDown.bind(this);
    this.__closeOverlayDrawerListener = this.__closeOverlayDrawer.bind(this);
    this.__trapFocusInDrawer = this.__trapFocusInDrawer.bind(this);
    this.__releaseFocusFromDrawer = this.__releaseFocusFromDrawer.bind(this);
    this.__ariaModalController = new AriaModalController(this, () => [
      ...this.querySelectorAll('vaadin-drawer-toggle, [slot="drawer"]')
    ]);
    this.__focusTrapController = new FocusTrapController(this);
  }
  /** @protected */
  connectedCallback() {
    super.connectedCallback();
    this._blockAnimationUntilAfterNextRender();
    window.addEventListener("resize", this.__boundResizeListener);
    this.addEventListener("drawer-toggle-click", this.__drawerToggleClickListener);
    beforeNextRender(this, this._afterFirstRender);
    this._updateTouchOptimizedMode();
    this._updateDrawerSize();
    this._updateOverlayMode();
    this._navbarSizeObserver = new ResizeObserver(() => {
      requestAnimationFrame(() => {
        if (this.__isDrawerAnimating) {
          this.__updateOffsetSizePending = true;
        } else {
          this._updateOffsetSize();
        }
      });
    });
    this._navbarSizeObserver.observe(this.$.navbarTop);
    this._navbarSizeObserver.observe(this.$.navbarBottom);
    this._navbarSizeObserver.observe(this.$.drawer);
    window.addEventListener("close-overlay-drawer", this.__closeOverlayDrawerListener);
    window.addEventListener("keydown", this.__onDrawerKeyDown);
  }
  /** @protected */
  ready() {
    super.ready();
    this.addController(this.__focusTrapController);
    this.__setAriaExpanded();
    this.$.drawer.addEventListener("transitionstart", () => {
      this.__isDrawerAnimating = true;
    });
    this.$.drawer.addEventListener("transitionend", () => {
      if (this.__updateOffsetSizePending) {
        this.__updateOffsetSizePending = false;
        this._updateOffsetSize();
      }
      requestAnimationFrame(() => {
        this.__isDrawerAnimating = false;
      });
    });
  }
  /** @protected */
  disconnectedCallback() {
    super.disconnectedCallback();
    window.removeEventListener("resize", this.__boundResizeListener);
    this.removeEventListener("drawer-toggle-click", this.__drawerToggleClickListener);
    window.removeEventListener("close-overlay-drawer", this.__drawerToggleClickListener);
    window.removeEventListener("keydown", this.__onDrawerKeyDown);
  }
  /**
   * A callback for the `primarySection` property observer.
   *
   * Ensures the property is set to its default value `navbar`
   * whenever the new value is not one of the valid values: `navbar`, `drawer`.
   *
   * @param {string} value
   * @private
   */
  __primarySectionChanged(value) {
    const isValid2 = ["navbar", "drawer"].includes(value);
    if (!isValid2) {
      this.primarySection = "navbar";
    }
  }
  /**
   * A callback for the `drawerOpened` property observer.
   *
   * When the drawer opens, the method ensures the drawer has a proper height and sets focus on it.
   * As long as the drawer is open, the focus is trapped within the drawer.
   *
   * When the drawer closes, the method releases focus from the drawer, setting focus on the drawer toggle.
   *
   * @param {boolean} drawerOpened
   * @param {boolean} oldDrawerOpened
   * @private
   */
  __drawerOpenedChanged(drawerOpened, oldDrawerOpened) {
    if (this.overlay) {
      if (drawerOpened) {
        this.__trapFocusInDrawer();
      } else if (oldDrawerOpened) {
        this.__releaseFocusFromDrawer();
      }
    }
    this.__setAriaExpanded();
  }
  /**
   * A callback for the `overlay` property observer.
   *
   * When layout resizes while in the overlay mode, drawer opened state
   * is not changed, but focus trap needs to be removed.
   *
   * @param {boolean} overlay
   * @param {boolean} oldOverlay
   * @private
   */
  __overlayChanged(_overlay, oldOverlay) {
    if (oldOverlay) {
      this.__restoreFocus();
    }
  }
  /**
   * A callback for the `i18n` property observer.
   *
   * The method ensures the drawer has ARIA attributes updated
   * once the `i18n` property changes.
   *
   * @private
   */
  __i18nChanged() {
    this.__updateDrawerAriaAttributes();
  }
  /** @protected */
  _afterFirstRender() {
    this._blockAnimationUntilAfterNextRender();
    this._updateOffsetSize();
  }
  /** @private */
  _drawerToggleClick(e2) {
    e2.stopPropagation();
    this.drawerOpened = !this.drawerOpened;
  }
  /** @private */
  __closeOverlayDrawer() {
    if (this.overlay) {
      this.drawerOpened = false;
    }
  }
  /** @private */
  __setAriaExpanded() {
    const toggle = this.querySelector("vaadin-drawer-toggle");
    if (toggle) {
      toggle.setAttribute("aria-expanded", this.drawerOpened);
    }
  }
  /** @protected */
  _updateDrawerSize() {
    const childCount = this.querySelectorAll("[slot=drawer]").length;
    const drawer = this.$.drawer;
    if (childCount === 0) {
      drawer.setAttribute("hidden", "");
      this.style.setProperty("--_vaadin-app-layout-drawer-width", 0);
    } else {
      drawer.removeAttribute("hidden");
      this.style.removeProperty("--_vaadin-app-layout-drawer-width");
    }
    this._updateOffsetSize();
  }
  /** @private */
  _resize() {
    this._blockAnimationUntilAfterNextRender();
    this._updateTouchOptimizedMode();
    this._updateOverlayMode();
  }
  /** @protected */
  _updateOffsetSize() {
    const navbar = this.$.navbarTop;
    const navbarRect = navbar.getBoundingClientRect();
    const navbarBottom = this.$.navbarBottom;
    const navbarBottomRect = navbarBottom.getBoundingClientRect();
    const drawer = this.$.drawer;
    const drawerRect = drawer.getBoundingClientRect();
    this.style.setProperty("--_vaadin-app-layout-navbar-offset-size", `${navbarRect.height}px`);
    this.style.setProperty("--_vaadin-app-layout-navbar-offset-size-bottom", `${navbarBottomRect.height}px`);
    this.style.setProperty("--_vaadin-app-layout-drawer-offset-size", `${drawerRect.width}px`);
  }
  /** @protected */
  _updateOverlayMode() {
    const overlay2 = this._getCustomPropertyValue("--vaadin-app-layout-drawer-overlay") === "true";
    if (!this.overlay && overlay2) {
      this._drawerStateSaved = this.drawerOpened;
      this.drawerOpened = false;
    }
    this._setOverlay(overlay2);
    if (!this.overlay && this._drawerStateSaved) {
      this.drawerOpened = this._drawerStateSaved;
      this._drawerStateSaved = null;
    }
    this.__updateDrawerAriaAttributes();
  }
  /**
   * Updates ARIA attributes on the drawer depending on the drawer mode.
   *
   * - In the overlay mode, the method marks the drawer with ARIA attributes as a dialog
   * labelled with the `i18n.drawer` property.
   * - In the normal mode, the method removes the ARIA attributes that has been set for the overlay mode.
   *
   * @private
   */
  __updateDrawerAriaAttributes() {
    const drawer = this.$.drawer;
    if (this.overlay) {
      drawer.setAttribute("role", "dialog");
      drawer.setAttribute("aria-modal", "true");
      drawer.setAttribute("aria-label", this.__effectiveI18n.drawer);
    } else {
      drawer.removeAttribute("role");
      drawer.removeAttribute("aria-modal");
      drawer.removeAttribute("aria-label");
    }
  }
  /**
   * Returns a promise that resolves when the drawer opening/closing CSS transition ends.
   *
   * The method relies on the `--vaadin-app-layout-transition` CSS variable to detect whether
   * the drawer has a CSS transition that needs to be awaited. If the CSS variable equals `none`,
   * the promise resolves immediately.
   *
   * @return {Promise}
   * @private
   */
  __drawerTransitionComplete() {
    return new Promise((resolve) => {
      if (this._getCustomPropertyValue("--vaadin-app-layout-transition") === "none") {
        resolve();
        return;
      }
      this.$.drawer.addEventListener("transitionend", resolve, { once: true });
    });
  }
  /** @private */
  async __trapFocusInDrawer() {
    await this.__drawerTransitionComplete();
    if (!this.drawerOpened) {
      return;
    }
    this.$.drawer.setAttribute("tabindex", "0");
    this.__ariaModalController.showModal();
    this.__focusTrapController.trapFocus(this.$.drawer);
  }
  /** @private */
  async __releaseFocusFromDrawer() {
    await this.__drawerTransitionComplete();
    if (this.drawerOpened) {
      return;
    }
    this.__restoreFocus();
    const toggle = this.querySelector("vaadin-drawer-toggle");
    if (toggle) {
      toggle.focus();
      toggle.setAttribute("focus-ring", "focus");
    }
  }
  /** @private */
  __restoreFocus() {
    this.__ariaModalController.close();
    this.__focusTrapController.releaseFocus();
    this.$.drawer.removeAttribute("tabindex");
  }
  /**
   * Closes the drawer on Escape press if it has been opened in the overlay mode.
   *
   * @param {KeyboardEvent} event
   * @private
   */
  __onDrawerKeyDown(event) {
    if (event.key === "Escape" && this.overlay) {
      this.drawerOpened = false;
    }
  }
  /** @private */
  _closeDrawerOnChanged(closeDrawerOn, oldCloseDrawerOn) {
    if (oldCloseDrawerOn) {
      window.removeEventListener(oldCloseDrawerOn, this.__closeOverlayDrawerListener);
    }
    if (closeDrawerOn) {
      window.addEventListener(closeDrawerOn, this.__closeOverlayDrawerListener);
    }
  }
  /** @private */
  _onBackdropClick() {
    this._close();
  }
  /** @private */
  _onBackdropTouchend(event) {
    event.preventDefault();
    this._close();
  }
  /** @protected */
  _close() {
    this.drawerOpened = false;
  }
  /** @private */
  _getCustomPropertyValue(customProperty) {
    const customPropertyValue = getComputedStyle(this).getPropertyValue(customProperty);
    return (customPropertyValue || "").trim().toLowerCase();
  }
  /** @protected */
  _updateTouchOptimizedMode() {
    const touchOptimized = this._getCustomPropertyValue("--vaadin-app-layout-touch-optimized") === "true";
    const navbarItems = this.querySelectorAll('[slot*="navbar"]');
    if (navbarItems.length > 0) {
      Array.from(navbarItems).forEach((navbar) => {
        if (navbar.getAttribute("slot").indexOf("touch-optimized") > -1) {
          navbar.__touchOptimized = true;
        }
        if (touchOptimized && navbar.__touchOptimized) {
          navbar.setAttribute("slot", "navbar-bottom");
        } else {
          navbar.setAttribute("slot", "navbar");
        }
      });
    }
    if (this.$.navbarTop.querySelector("[name=navbar]").assignedNodes().length === 0) {
      this.$.navbarTop.setAttribute("hidden", "");
    } else {
      this.$.navbarTop.removeAttribute("hidden");
    }
    if (this.$.navbarBottom.querySelector("[name=navbar-bottom]").assignedNodes().length === 0) {
      this.$.navbarBottom.setAttribute("hidden", "");
    } else {
      this.$.navbarBottom.removeAttribute("hidden");
    }
    this._updateOffsetSize();
  }
  /** @protected */
  _blockAnimationUntilAfterNextRender() {
    this.setAttribute("no-anim", "");
    afterNextRender(this, () => {
      this.removeAttribute("no-anim");
    });
  }
  /**
   * App Layout listens to `close-overlay-drawer` on the window level.
   * A custom event can be dispatched and the App Layout will close the drawer in overlay.
   *
   * That can be used, for instance, when a navigation occurs when user clicks in a menu item inside the drawer.
   *
   * See `dispatchCloseOverlayDrawerEvent()` helper method.
   *
   * @event close-overlay-drawer
   */
};
/**
 * @license
 * Copyright (c) 2018 - 2025 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const appLayoutStyles = css`
  :host {
    display: block;
    box-sizing: border-box;
    height: 100%;
    --vaadin-app-layout-transition: 200ms;
    transition: padding var(--vaadin-app-layout-transition);
    --_vaadin-app-layout-drawer-width: var(--vaadin-app-layout-drawer-width, 16em);
    --vaadin-app-layout-touch-optimized: false;
    --vaadin-app-layout-navbar-offset-top: var(--_vaadin-app-layout-navbar-offset-size);
    --vaadin-app-layout-navbar-offset-bottom: var(--_vaadin-app-layout-navbar-offset-size-bottom);
    padding-block: var(--vaadin-app-layout-navbar-offset-top) var(--vaadin-app-layout-navbar-offset-bottom);
    padding-inline-start: var(--vaadin-app-layout-navbar-offset-left);
  }

  :host([hidden]),
  [hidden] {
    display: none !important;
  }

  :host([no-anim]) {
    --vaadin-app-layout-transition: none !important;
  }

  :host([drawer-opened]) {
    --vaadin-app-layout-drawer-offset-left: var(--_vaadin-app-layout-drawer-offset-size);
  }

  :host([overlay]) {
    --vaadin-app-layout-drawer-offset-left: 0;
    --vaadin-app-layout-navbar-offset-left: 0;
  }

  :host(:not([no-scroll])) [content] {
    overflow: auto;
  }

  [content] {
    height: 100%;
  }

  @media (pointer: coarse) and (max-width: 800px) and (min-height: 500px) {
    :host {
      --vaadin-app-layout-touch-optimized: true;
    }
  }

  [part='navbar'] {
    position: fixed;
    display: flex;
    align-items: center;
    top: 0;
    inset-inline: 0;
    transition: inset-inline-start var(--vaadin-app-layout-transition);
    padding-top: var(--safe-area-inset-top);
    padding-left: var(--safe-area-inset-left);
    padding-right: var(--safe-area-inset-right);
    z-index: 1;
  }

  :host([primary-section='drawer'][drawer-opened]:not([overlay])) [part='navbar'] {
    inset-inline-start: var(--vaadin-app-layout-drawer-offset-left, 0);
  }

  :host([primary-section='drawer']) [part='drawer'] {
    top: 0;
  }

  [part='navbar'][bottom] {
    top: auto;
    bottom: 0;
    padding-bottom: var(--safe-area-inset-bottom);
  }

  [part='drawer'] {
    overflow: auto;
    position: fixed;
    top: var(--vaadin-app-layout-navbar-offset-top, 0);
    bottom: var(--vaadin-app-layout-navbar-offset-bottom, var(--vaadin-viewport-offset-bottom, 0));
    inset-inline: var(--vaadin-app-layout-navbar-offset-left, 0) auto;
    transition:
      transform var(--vaadin-app-layout-transition),
      visibility var(--vaadin-app-layout-transition);
    transform: translateX(-100%);
    max-width: 90%;
    width: var(--_vaadin-app-layout-drawer-width);
    box-sizing: border-box;
    padding: var(--safe-area-inset-top) 0 var(--safe-area-inset-bottom) var(--safe-area-inset-left);
    outline: none;
    /* The drawer should be inaccessible by the tabbing navigation when it is closed. */
    visibility: hidden;
    display: flex;
    flex-direction: column;
  }

  :host([drawer-opened]) [part='drawer'] {
    /* The drawer should be accessible by the tabbing navigation when it is opened. */
    visibility: visible;
    transform: translateX(0%);
    touch-action: manipulation;
  }

  [part='backdrop'] {
    background-color: #000;
    opacity: 0.3;
  }

  :host(:not([drawer-opened])) [part='backdrop'] {
    opacity: 0;
  }

  :host([overlay]) [part='backdrop'] {
    position: fixed;
    inset: 0;
    pointer-events: none;
    transition: opacity var(--vaadin-app-layout-transition);
    -webkit-tap-highlight-color: transparent;
  }

  :host([overlay]) [part='drawer'] {
    top: 0;
    bottom: 0;
  }

  :host([overlay]) [part='drawer'],
  :host([overlay]) [part='backdrop'] {
    z-index: 2;
  }

  :host([drawer-opened][overlay]) [part='backdrop'] {
    pointer-events: auto;
    touch-action: manipulation;
  }

  :host([dir='rtl']) [part='drawer'] {
    transform: translateX(100%);
  }

  :host([dir='rtl'][drawer-opened]) [part='drawer'] {
    transform: translateX(0%);
  }

  :host([drawer-opened]:not([overlay])) {
    padding-inline-start: var(--vaadin-app-layout-drawer-offset-left);
  }

  @media (max-width: 800px), (max-height: 600px) {
    :host {
      --vaadin-app-layout-drawer-overlay: true;
      --_vaadin-app-layout-drawer-width: var(--vaadin-app-layout-drawer-width, 20em);
    }
  }

  /* If a vaadin-scroller is used in the drawer, allow it to take all remaining space and contain scrolling */
  [part='drawer'] ::slotted(vaadin-scroller) {
    flex: 1;
    overscroll-behavior: contain;
  }
`;
/**
 * @license
 * Copyright (c) 2018 - 2025 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
registerStyles$1("vaadin-app-layout", appLayoutStyles, { moduleId: "vaadin-app-layout-styles" });
class AppLayout extends AppLayoutMixin(ElementMixin(ThemableMixin(ControllerMixin(PolymerElement)))) {
  static get template() {
    return html`
      <div part="navbar" id="navbarTop">
        <slot name="navbar" on-slotchange="_updateTouchOptimizedMode"></slot>
      </div>
      <div part="backdrop" on-click="_onBackdropClick" on-touchend="_onBackdropTouchend"></div>
      <div part="drawer" id="drawer">
        <slot name="drawer" id="drawerSlot" on-slotchange="_updateDrawerSize"></slot>
      </div>
      <div content>
        <slot></slot>
      </div>
      <div part="navbar" id="navbarBottom" bottom hidden>
        <slot name="navbar-bottom"></slot>
      </div>
      <div hidden>
        <slot id="touchSlot" name="navbar touch-optimized" on-slotchange="_updateTouchOptimizedMode"></slot>
      </div>
    `;
  }
  static get is() {
    return "vaadin-app-layout";
  }
}
defineCustomElement(AppLayout);
const button = css`
  :host {
    /* Sizing */
    --lumo-button-size: var(--lumo-size-m);
    min-width: var(--vaadin-button-min-width, calc(var(--_button-size) * 2));
    height: var(--_button-size);
    padding: var(--vaadin-button-padding, 0 calc(var(--_button-size) / 3 + var(--lumo-border-radius-m) / 2));
    margin: var(--vaadin-button-margin, var(--lumo-space-xs) 0);
    box-sizing: border-box;
    /* Style */
    font-family: var(--lumo-font-family);
    font-size: var(--vaadin-button-font-size, var(--lumo-font-size-m));
    font-weight: var(--vaadin-button-font-weight, 500);
    color: var(--_lumo-button-text-color);
    background: var(--_lumo-button-background);
    border: var(--vaadin-button-border, none);
    border-radius: var(--vaadin-button-border-radius, var(--lumo-border-radius-m));
    cursor: var(--lumo-clickable-cursor);
    -webkit-tap-highlight-color: transparent;
    -webkit-font-smoothing: antialiased;
    -moz-osx-font-smoothing: grayscale;
    flex-shrink: 0;
    --_button-size: var(--vaadin-button-height, var(--lumo-button-size));
    --_focus-ring-color: var(--vaadin-focus-ring-color, var(--lumo-primary-color-50pct));
    --_focus-ring-width: var(--vaadin-focus-ring-width, 2px);
    /* Used by notification */
    --_lumo-button-background: var(--vaadin-button-background, var(--lumo-contrast-5pct));
    --_lumo-button-text-color: var(--vaadin-button-text-color, var(--lumo-primary-text-color));
    --_lumo-button-primary-background: var(--vaadin-button-primary-background, var(--lumo-primary-color));
    --_lumo-button-primary-text-color: var(--vaadin-button-primary-text-color, var(--lumo-primary-contrast-color));
  }

  /* Set only for the internal parts so we don't affect the host vertical alignment */
  [part='label'],
  [part='prefix'],
  [part='suffix'] {
    line-height: var(--lumo-line-height-xs);
  }

  [part='label'] {
    padding: calc(var(--lumo-button-size) / 6) 0;
  }

  :host([theme~='small']) {
    font-size: var(--lumo-font-size-s);
    --lumo-button-size: var(--lumo-size-s);
  }

  :host([theme~='large']) {
    font-size: var(--lumo-font-size-l);
    --lumo-button-size: var(--lumo-size-l);
  }

  /* For interaction states */
  :host::before,
  :host::after {
    content: '';
    /* We rely on the host always being relative */
    position: absolute;
    z-index: 1;
    inset: 0;
    background-color: currentColor;
    border-radius: inherit;
    opacity: 0;
    pointer-events: none;
  }

  /* Hover */

  @media (any-hover: hover) {
    :host(:not([disabled]):hover)::before {
      opacity: 0.02;
    }
  }

  /* Active */

  :host::after {
    transition:
      opacity 1.4s,
      transform 0.1s;
    filter: blur(8px);
  }

  :host([active])::before {
    opacity: 0.05;
    transition-duration: 0s;
  }

  :host([active])::after {
    opacity: 0.1;
    transition-duration: 0s, 0s;
    transform: scale(0);
  }

  /* Keyboard focus */

  :host([focus-ring]) {
    box-shadow:
      0 0 0 calc(1px * var(--_focus-ring-gap-on, 0)) var(--_focus-ring-gap-color, var(--lumo-base-color)),
      0 0 0 calc(var(--_focus-ring-width) + 1px * var(--_focus-ring-gap-on, 0)) var(--_focus-ring-color);
  }

  :host([theme~='primary'][focus-ring]) {
    --_focus-ring-gap-on: 1;
  }

  /* Types (primary, tertiary, tertiary-inline */

  :host([theme~='tertiary']),
  :host([theme~='tertiary-inline']) {
    --_background: transparent !important;
    background: var(--vaadin-button-tertiary-background, var(--_background));
    min-width: 0;
  }

  :host([theme~='tertiary']) {
    border: var(--vaadin-button-tertiary-border, none);
    color: var(--vaadin-button-tertiary-text-color, var(--lumo-primary-text-color));
    font-weight: var(--vaadin-button-tertiary-font-weight, 500);
    padding: var(--vaadin-button-tertiary-padding, 0 calc(var(--_button-size) / 6));
  }

  :host([theme~='tertiary-inline'])::before {
    display: none;
  }

  :host([theme~='tertiary-inline']) {
    margin: 0;
    height: auto;
    padding: 0;
    line-height: inherit;
    font-size: inherit;
  }

  :host([theme~='tertiary-inline']) [part='label'] {
    padding: 0;
    overflow: visible;
    line-height: inherit;
  }

  :host([theme~='primary']) {
    background: var(--_lumo-button-primary-background);
    border: var(--vaadin-button-primary-border, none);
    color: var(--_lumo-button-primary-text-color);
    font-weight: var(--vaadin-button-primary-font-weight, 600);
    min-width: calc(var(--lumo-button-size) * 2.5);
  }

  :host([theme~='primary'])::before {
    background-color: black;
  }

  @media (any-hover: hover) {
    :host([theme~='primary']:not([disabled]):hover)::before {
      opacity: 0.05;
    }
  }

  :host([theme~='primary'][active])::before {
    opacity: 0.1;
  }

  :host([theme~='primary'][active])::after {
    opacity: 0.2;
  }

  /* Colors (success, warning, error, contrast) */

  :host([theme~='success']) {
    color: var(--lumo-success-text-color);
  }

  :host([theme~='success'][theme~='primary']) {
    background-color: var(--lumo-success-color);
    color: var(--lumo-success-contrast-color);
  }

  :host([theme~='warning']) {
    color: var(--lumo-warning-text-color);
  }

  :host([theme~='warning'][theme~='primary']) {
    background-color: var(--lumo-warning-color);
    color: var(--lumo-warning-contrast-color);
  }

  :host([theme~='error']) {
    color: var(--lumo-error-text-color);
  }

  :host([theme~='error'][theme~='primary']) {
    background-color: var(--lumo-error-color);
    color: var(--lumo-error-contrast-color);
  }

  :host([theme~='contrast']) {
    color: var(--lumo-contrast);
  }

  :host([theme~='contrast'][theme~='primary']) {
    background-color: var(--lumo-contrast);
    color: var(--lumo-base-color);
  }

  /* Disabled state. Keep selectors after other color variants. */

  :host([disabled]) {
    color: var(--lumo-disabled-text-color);
  }

  :host([theme~='primary'][disabled]) {
    background-color: var(--lumo-contrast-30pct);
    color: var(--lumo-base-color);
  }

  :host([theme~='primary'][disabled]) [part] {
    opacity: 0.7;
  }

  /* Icons */

  [part] ::slotted(vaadin-icon) {
    display: inline-block;
    width: var(--lumo-icon-size-m);
    height: var(--lumo-icon-size-m);
  }

  /* Vaadin icons are based on a 16x16 grid (unlike Lumo and Material icons with 24x24), so they look too big by default */
  [part] ::slotted(vaadin-icon[icon^='vaadin:']) {
    padding: 0.25em;
    box-sizing: border-box !important;
  }

  [part='prefix'] {
    margin-left: -0.25em;
    margin-right: 0.25em;
  }

  [part='suffix'] {
    margin-left: 0.25em;
    margin-right: -0.25em;
  }

  /* Icon-only */

  :host([theme~='icon']:not([theme~='tertiary-inline'])) {
    min-width: var(--lumo-button-size);
    padding-left: calc(var(--lumo-button-size) / 4);
    padding-right: calc(var(--lumo-button-size) / 4);
  }

  :host([theme~='icon']) [part='prefix'],
  :host([theme~='icon']) [part='suffix'] {
    margin-left: 0;
    margin-right: 0;
  }

  /* RTL specific styles */

  :host([dir='rtl']) [part='prefix'] {
    margin-left: 0.25em;
    margin-right: -0.25em;
  }

  :host([dir='rtl']) [part='suffix'] {
    margin-left: -0.25em;
    margin-right: 0.25em;
  }

  :host([dir='rtl'][theme~='icon']) [part='prefix'],
  :host([dir='rtl'][theme~='icon']) [part='suffix'] {
    margin-left: 0;
    margin-right: 0;
  }
`;
registerStyles$1("vaadin-button", button, { moduleId: "lumo-button" });
/**
 * @license
 * Copyright (c) 2017 - 2025 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const buttonStyles = css`
  :host {
    display: inline-block;
    position: relative;
    outline: none;
    white-space: nowrap;
    -webkit-user-select: none;
    user-select: none;
  }

  :host([hidden]) {
    display: none !important;
  }

  :host([disabled]) {
    pointer-events: var(--_vaadin-button-disabled-pointer-events, none);
    cursor: not-allowed;
  }

  /* Aligns the button with form fields when placed on the same line.
  Note, to make it work, the form fields should have the same "::before" pseudo-element. */
  .vaadin-button-container::before {
    content: '\\2003';
    display: inline-block;
    width: 0;
    max-height: 100%;
  }

  .vaadin-button-container {
    display: inline-flex;
    align-items: center;
    justify-content: center;
    text-align: center;
    width: 100%;
    height: 100%;
    min-height: inherit;
    text-shadow: inherit;
  }

  [part='prefix'],
  [part='suffix'] {
    flex: none;
  }

  [part='label'] {
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
  }

  @media (forced-colors: active) {
    :host {
      outline: 1px solid;
      outline-offset: -1px;
    }

    :host([focused]) {
      outline-width: 2px;
    }

    :host([disabled]) {
      outline-color: GrayText;
    }
  }
`;
const buttonTemplate = (html3) => html3`
  <div class="vaadin-button-container">
    <span part="prefix" aria-hidden="true">
      <slot name="prefix"></slot>
    </span>
    <span part="label">
      <slot></slot>
    </span>
    <span part="suffix" aria-hidden="true">
      <slot name="suffix"></slot>
    </span>
  </div>
  <slot name="tooltip"></slot>
`;
/**
 * @license
 * Copyright (c) 2017 - 2025 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
registerStyles$1("vaadin-button", buttonStyles, { moduleId: "vaadin-button-styles" });
class Button extends ButtonMixin(ElementMixin(ThemableMixin(ControllerMixin(PolymerElement)))) {
  static get properties() {
    return {
      /**
       * When disabled, the button is rendered as "dimmed" and prevents all
       * user interactions (mouse and keyboard).
       *
       * Since disabled buttons are not focusable and cannot react to hover
       * events by default, it can cause accessibility issues by making them
       * entirely invisible to assistive technologies, and prevents the use
       * of Tooltips to explain why the action is not available. This can be
       * addressed by enabling the feature flag `accessibleDisabledButtons`,
       * which makes disabled buttons focusable and hoverable, while still
       * preventing them from being triggered:
       *
       * ```
       * // Set before any button is attached to the DOM.
       * window.Vaadin.featureFlags.accessibleDisabledButtons = true
       * ```
       */
      disabled: {
        type: Boolean,
        value: false
      }
    };
  }
  static get is() {
    return "vaadin-button";
  }
  static get template() {
    return buttonTemplate(html);
  }
  /** @protected */
  ready() {
    super.ready();
    this._tooltipController = new TooltipController(this);
    this.addController(this._tooltipController);
  }
  /** @override */
  __shouldAllowFocusWhenDisabled() {
    return window.Vaadin.featureFlags.accessibleDisabledButtons;
  }
}
defineCustomElement(Button);
const drawerToggle$1 = css`
  :host {
    width: var(--lumo-size-l);
    height: var(--lumo-size-l);
    min-width: auto;
    margin: 0 var(--lumo-space-s);
    padding: 0;
    background: transparent;
  }

  [part='icon'],
  [part='icon']::after,
  [part='icon']::before {
    position: inherit;
    height: auto;
    width: auto;
    background: transparent;
    top: auto;
  }

  [part='icon']::before {
    font-family: lumo-icons;
    font-size: var(--lumo-icon-size-m);
    content: var(--lumo-icons-menu);
  }

  :host([slot~='navbar']) {
    color: var(--lumo-secondary-text-color);
  }
`;
registerStyles$1("vaadin-drawer-toggle", [button, drawerToggle$1], { moduleId: "lumo-drawer-toggle" });
/**
 * @license
 * Copyright (c) 2018 - 2025 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const drawerToggle = css`
  :host {
    display: inline-flex;
    align-items: center;
    justify-content: center;
    cursor: default;
    position: relative;
    outline: none;
    height: 24px;
    width: 24px;
    padding: 4px;
  }

  [part='icon'],
  [part='icon']::after,
  [part='icon']::before {
    position: absolute;
    top: 8px;
    height: 3px;
    width: 24px;
    background-color: #000;
  }

  [part='icon']::after,
  [part='icon']::before {
    content: '';
  }

  [part='icon']::after {
    top: 6px;
  }

  [part='icon']::before {
    top: 12px;
  }
`;
/**
 * @license
 * Copyright (c) 2018 - 2025 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
registerStyles$1("vaadin-drawer-toggle", [buttonStyles, drawerToggle], { moduleId: "vaadin-drawer-toggle-styles" });
class DrawerToggle extends ButtonMixin(DirMixin(ThemableMixin(PolymerElement))) {
  static get template() {
    return html`
      <slot id="slot">
        <div part="icon"></div>
      </slot>
      <div part="icon" hidden$="[[!_showFallbackIcon]]"></div>
    `;
  }
  static get is() {
    return "vaadin-drawer-toggle";
  }
  static get properties() {
    return {
      ariaLabel: {
        type: String,
        value: "Toggle navigation panel",
        reflectToAttribute: true
      },
      /** @private */
      _showFallbackIcon: {
        type: Boolean,
        value: false
      }
    };
  }
  constructor() {
    super();
    this.addEventListener("click", () => {
      this.dispatchEvent(new CustomEvent("drawer-toggle-click", { bubbles: true, composed: true }));
    });
  }
  /** @protected */
  ready() {
    super.ready();
    this._toggleFallbackIcon();
    this.$.slot.addEventListener("slotchange", () => {
      this._toggleFallbackIcon();
    });
  }
  /** @private */
  _toggleFallbackIcon() {
    const nodes = this.$.slot.assignedNodes();
    this._showFallbackIcon = nodes.length > 0 && nodes.every((node) => isEmptyTextNode(node));
  }
}
defineCustomElement(DrawerToggle);
const tooltipOverlay = css`
  :host {
    --vaadin-tooltip-offset-top: var(--lumo-space-xs);
    --vaadin-tooltip-offset-bottom: var(--lumo-space-xs);
    --vaadin-tooltip-offset-start: var(--lumo-space-xs);
    --vaadin-tooltip-offset-end: var(--lumo-space-xs);
  }

  [part='overlay'] {
    background: var(--lumo-base-color) linear-gradient(var(--lumo-contrast-5pct), var(--lumo-contrast-5pct));
    color: var(--lumo-body-text-color);
    font-size: var(--lumo-font-size-xs);
    line-height: var(--lumo-line-height-s);
  }

  [part='content'] {
    padding: var(--lumo-space-xs) var(--lumo-space-s);
  }
`;
registerStyles$1("vaadin-tooltip-overlay", [overlay, tooltipOverlay], { moduleId: "lumo-tooltip-overlay" });
/**
 * @license
 * Copyright (c) 2022 - 2025 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const getClosestOverlay = (node) => {
  let n = node;
  while (n && n !== node.ownerDocument) {
    n = n.parentNode || n.host;
    if (n && n._hasOverlayStackMixin) {
      return n;
    }
  }
  return null;
};
const PopoverOverlayMixin = (superClass) => class PopoverOverlayMixinClass extends PositionMixin(OverlayMixin(superClass)) {
  static get properties() {
    return {
      position: {
        type: String,
        reflectToAttribute: true
      }
    };
  }
  static get observers() {
    return ["__openedOrTargetChanged(opened, positionTarget)"];
  }
  /**
   * Tag name prefix used by custom properties.
   * @protected
   * @return {string}
   */
  get _tagNamePrefix() {
    return "vaadin-popover";
  }
  /**
   * @protected
   * @override
   */
  _updatePosition() {
    super._updatePosition();
    if (!this.positionTarget || !this.opened) {
      return;
    }
    if (this.owner) {
      const style = getComputedStyle(this.owner);
      ["top", "bottom", "start", "end"].forEach((prop) => {
        const propertyName = `--${this._tagNamePrefix}-offset-${prop}`;
        this.style.setProperty(propertyName, style.getPropertyValue(propertyName));
      });
    }
    this.removeAttribute("arrow-centered");
    if (this.position === "bottom" || this.position === "top") {
      const targetRect = this.positionTarget.getBoundingClientRect();
      const overlayRect = this.$.overlay.getBoundingClientRect();
      const offset = targetRect.width / 2 - overlayRect.width / 2;
      if (this.style.left) {
        const left = overlayRect.left + offset;
        if (left > 0) {
          this.style.left = `${left}px`;
          this.setAttribute("arrow-centered", "");
        }
      }
      if (this.style.right) {
        const right = parseFloat(this.style.right) + offset;
        if (right > 0) {
          this.style.right = `${right}px`;
          this.setAttribute("arrow-centered", "");
        }
      }
    }
    if (this.position === "start" || this.position === "end") {
      const targetRect = this.positionTarget.getBoundingClientRect();
      const overlayRect = this.$.overlay.getBoundingClientRect();
      const offset = targetRect.height / 2 - overlayRect.height / 2;
      this.style.top = `${overlayRect.top + offset}px`;
    }
  }
  /** @private */
  __openedOrTargetChanged(opened, target) {
    if (target) {
      const parent = getClosestOverlay(target);
      if (parent) {
        setNestedOverlay(parent, opened ? this : null);
      }
    }
  }
};
/**
 * @license
 * Copyright (c) 2022 - 2025 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const tooltipOverlayStyles = css`
  [part='overlay'] {
    max-width: 40ch;
  }

  [part='content'] {
    white-space: pre-wrap;
  }

  :host([position^='top'][top-aligned]) [part='overlay'],
  :host([position^='bottom'][top-aligned]) [part='overlay'] {
    margin-top: var(--vaadin-tooltip-offset-top, 0);
  }

  :host([position^='top'][bottom-aligned]) [part='overlay'],
  :host([position^='bottom'][bottom-aligned]) [part='overlay'] {
    margin-bottom: var(--vaadin-tooltip-offset-bottom, 0);
  }

  :host([position^='start'][start-aligned]) [part='overlay'],
  :host([position^='end'][start-aligned]) [part='overlay'] {
    margin-inline-start: var(--vaadin-tooltip-offset-start, 0);
  }

  :host([position^='start'][end-aligned]) [part='overlay'],
  :host([position^='end'][end-aligned]) [part='overlay'] {
    margin-inline-end: var(--vaadin-tooltip-offset-end, 0);
  }

  @media (forced-colors: active) {
    [part='overlay'] {
      outline: 1px dashed;
    }
  }
`;
/**
 * @license
 * Copyright (c) 2022 - 2025 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
registerStyles$1("vaadin-tooltip-overlay", [overlayStyles, tooltipOverlayStyles], {
  moduleId: "vaadin-tooltip-overlay-styles"
});
class TooltipOverlay extends PopoverOverlayMixin(DirMixin(ThemableMixin(PolymerElement))) {
  static get is() {
    return "vaadin-tooltip-overlay";
  }
  static get template() {
    return html`
      <div id="backdrop" part="backdrop" hidden></div>
      <div part="overlay" id="overlay">
        <div part="content" id="content"><slot></slot></div>
      </div>
    `;
  }
  /**
   * Tag name prefix used by custom properties.
   * @protected
   * @return {string}
   */
  get _tagNamePrefix() {
    return "vaadin-tooltip";
  }
  requestContentUpdate() {
    super.requestContentUpdate();
    this.toggleAttribute("hidden", this.textContent.trim() === "");
  }
}
defineCustomElement(TooltipOverlay);
/**
 * @license
 * Copyright (c) 2023 - 2025 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const OverlayClassMixin = (superclass) => class OverlayClassMixinClass extends superclass {
  static get properties() {
    return {
      /**
       * A space-delimited list of CSS class names to set on the overlay element.
       * This property does not affect other CSS class names set manually via JS.
       *
       * Note, if the CSS class name was set with this property, clearing it will
       * remove it from the overlay, even if the same class name was also added
       * manually, e.g. by using `classList.add()` in the `renderer` function.
       *
       * @attr {string} overlay-class
       */
      overlayClass: {
        type: String
      },
      /**
       * An overlay element on which CSS class names are set.
       *
       * @protected
       */
      _overlayElement: {
        type: Object
      }
    };
  }
  static get observers() {
    return ["__updateOverlayClassNames(overlayClass, _overlayElement)"];
  }
  /** @private */
  __updateOverlayClassNames(overlayClass, overlayElement) {
    if (!overlayElement) {
      return;
    }
    if (overlayClass === void 0) {
      return;
    }
    const { classList } = overlayElement;
    if (!this.__initialClasses) {
      this.__initialClasses = new Set(classList);
    }
    if (Array.isArray(this.__previousClasses)) {
      const classesToRemove = this.__previousClasses.filter((name) => !this.__initialClasses.has(name));
      if (classesToRemove.length > 0) {
        classList.remove(...classesToRemove);
      }
    }
    const classesToAdd = typeof overlayClass === "string" ? overlayClass.split(" ").filter(Boolean) : [];
    if (classesToAdd.length > 0) {
      classList.add(...classesToAdd);
    }
    this.__previousClasses = classesToAdd;
  }
};
/**
 * @license
 * Copyright (c) 2024 - 2025 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const PopoverPositionMixin = (superClass) => class PopoverPositionMixinClass extends superClass {
  static get properties() {
    return {
      /**
       * Position of the overlay with respect to the target.
       * Supported values: `top-start`, `top`, `top-end`,
       * `bottom-start`, `bottom`, `bottom-end`, `start-top`,
       * `start`, `start-bottom`, `end-top`, `end`, `end-bottom`.
       */
      position: {
        type: String
      },
      /**
       * Default value used when `position` property is not set.
       * @protected
       */
      _position: {
        type: String,
        value: "bottom"
      },
      /** @private */
      __effectivePosition: {
        type: String,
        computed: "__computePosition(position, _position)"
      }
    };
  }
  /** @protected */
  __computeHorizontalAlign(position) {
    return ["top-end", "bottom-end", "start-top", "start", "start-bottom"].includes(position) ? "end" : "start";
  }
  /** @protected */
  __computeNoHorizontalOverlap(position) {
    return ["start-top", "start", "start-bottom", "end-top", "end", "end-bottom"].includes(position);
  }
  /** @protected */
  __computeNoVerticalOverlap(position) {
    return ["top-start", "top-end", "top", "bottom-start", "bottom", "bottom-end"].includes(position);
  }
  /** @protected */
  __computeVerticalAlign(position) {
    return ["top-start", "top-end", "top", "start-bottom", "end-bottom"].includes(position) ? "bottom" : "top";
  }
  /** @private */
  __computePosition(position, defaultPosition) {
    return position || defaultPosition;
  }
};
/**
 * @license
 * Copyright (c) 2024 - 2025 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const PopoverTargetMixin = (superClass) => class PopoverTargetMixinClass extends superClass {
  static get properties() {
    return {
      /**
       * The id of the element to be used as `target` value.
       * The element should be in the DOM by the time when
       * the attribute is set, otherwise a warning is shown.
       */
      for: {
        type: String,
        observer: "__forChanged"
      },
      /**
       * Reference to the DOM element used both to trigger the overlay
       * by user interaction and to visually position it on the screen.
       *
       * Defaults to an element referenced with `for` attribute, in
       * which case it must be located in the same shadow scope.
       */
      target: {
        type: Object
      },
      /** @private */
      __isConnected: {
        type: Boolean,
        sync: true
      }
    };
  }
  static get observers() {
    return ["__targetOrConnectedChanged(target, __isConnected)"];
  }
  /** @protected */
  connectedCallback() {
    super.connectedCallback();
    this.__isConnected = true;
  }
  /** @protected */
  disconnectedCallback() {
    super.disconnectedCallback();
    this.__isConnected = false;
  }
  /** @private */
  __forChanged(forId) {
    if (forId) {
      this.__setTargetByIdDebouncer = Debouncer$1.debounce(
        this.__setTargetByIdDebouncer,
        microTask$1,
        () => this.__setTargetById(forId)
      );
    }
  }
  /** @private */
  __setTargetById(targetId) {
    if (!this.isConnected) {
      return;
    }
    const target = this.getRootNode().getElementById(targetId);
    if (target) {
      this.target = target;
    } else {
      console.warn(`No element with id="${targetId}" set via "for" property found on the page.`);
    }
  }
  /** @private */
  __targetOrConnectedChanged(target, isConnected) {
    if (this.__previousTarget && (this.__previousTarget !== target || !isConnected)) {
      this._removeTargetListeners(this.__previousTarget);
    }
    if (target && isConnected) {
      this._addTargetListeners(target);
    }
    this.__previousTarget = target;
  }
  /**
   * @param {HTMLElement} _target
   * @protected
   */
  _addTargetListeners(_target) {
  }
  /**
   * @param {HTMLElement} _target
   * @protected
   */
  _removeTargetListeners(_target) {
  }
};
/**
 * @license
 * Copyright (c) 2022 - 2025 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const DEFAULT_DELAY$1 = 500;
let defaultFocusDelay$3 = DEFAULT_DELAY$1;
let defaultHoverDelay$3 = DEFAULT_DELAY$1;
let defaultHideDelay$3 = DEFAULT_DELAY$1;
const closing = /* @__PURE__ */ new Set();
let warmedUp = false;
let warmUpTimeout = null;
let cooldownTimeout = null;
class TooltipStateController {
  constructor(host) {
    this.host = host;
  }
  /** @private */
  get openedProp() {
    return this.host.manual ? "opened" : "_autoOpened";
  }
  /** @private */
  get focusDelay() {
    const tooltip = this.host;
    return tooltip.focusDelay != null && tooltip.focusDelay >= 0 ? tooltip.focusDelay : defaultFocusDelay$3;
  }
  /** @private */
  get hoverDelay() {
    const tooltip = this.host;
    return tooltip.hoverDelay != null && tooltip.hoverDelay >= 0 ? tooltip.hoverDelay : defaultHoverDelay$3;
  }
  /** @private */
  get hideDelay() {
    const tooltip = this.host;
    return tooltip.hideDelay != null && tooltip.hideDelay >= 0 ? tooltip.hideDelay : defaultHideDelay$3;
  }
  /**
   * Whether closing is currently in progress.
   * @return {boolean}
   */
  get isClosing() {
    return closing.has(this.host);
  }
  /**
   * Schedule opening the tooltip.
   * @param {Object} options
   */
  open(options = { immediate: false }) {
    const { immediate, hover, focus } = options;
    const isHover = hover && this.hoverDelay > 0;
    const isFocus = focus && this.focusDelay > 0;
    if (!immediate && (isHover || isFocus) && !this.__closeTimeout) {
      this.__warmupTooltip(isFocus);
    } else {
      this.__showTooltip();
    }
  }
  /**
   * Schedule closing the tooltip.
   * @param {boolean} immediate
   */
  close(immediate) {
    if (!immediate && this.hideDelay > 0) {
      this.__scheduleClose();
    } else {
      this.__abortClose();
      this._setOpened(false);
    }
    this.__abortWarmUp();
    if (warmedUp) {
      this.__abortCooldown();
      this.__scheduleCooldown();
    }
  }
  /** @private */
  _isOpened() {
    return this.host[this.openedProp];
  }
  /** @private */
  _setOpened(opened) {
    this.host[this.openedProp] = opened;
  }
  /** @private */
  __flushClosingTooltips() {
    closing.forEach((tooltip) => {
      tooltip._stateController.close(true);
      closing.delete(tooltip);
    });
  }
  /** @private */
  __showTooltip() {
    this.__abortClose();
    this.__flushClosingTooltips();
    this._setOpened(true);
    warmedUp = true;
    this.__abortWarmUp();
    this.__abortCooldown();
  }
  /** @private */
  __warmupTooltip(isFocus) {
    if (!this._isOpened()) {
      if (warmedUp) {
        this.__showTooltip();
      } else if (warmUpTimeout == null) {
        this.__scheduleWarmUp(isFocus);
      }
    }
  }
  /** @private */
  __abortClose() {
    if (this.__closeTimeout) {
      clearTimeout(this.__closeTimeout);
      this.__closeTimeout = null;
    }
    if (this.isClosing) {
      closing.delete(this.host);
    }
  }
  /** @private */
  __abortCooldown() {
    if (cooldownTimeout) {
      clearTimeout(cooldownTimeout);
      cooldownTimeout = null;
    }
  }
  /** @private */
  __abortWarmUp() {
    if (warmUpTimeout) {
      clearTimeout(warmUpTimeout);
      warmUpTimeout = null;
    }
  }
  /** @private */
  __scheduleClose() {
    if (this._isOpened() && !this.isClosing) {
      closing.add(this.host);
      this.__closeTimeout = setTimeout(() => {
        closing.delete(this.host);
        this.__closeTimeout = null;
        this._setOpened(false);
      }, this.hideDelay);
    }
  }
  /** @private */
  __scheduleCooldown() {
    cooldownTimeout = setTimeout(() => {
      cooldownTimeout = null;
      warmedUp = false;
    }, this.hideDelay);
  }
  /** @private */
  __scheduleWarmUp(isFocus) {
    const delay = isFocus ? this.focusDelay : this.hoverDelay;
    warmUpTimeout = setTimeout(() => {
      warmUpTimeout = null;
      warmedUp = true;
      this.__showTooltip();
    }, delay);
  }
}
const TooltipMixin = (superClass) => class TooltipMixinClass extends PopoverPositionMixin(PopoverTargetMixin(OverlayClassMixin(superClass))) {
  static get properties() {
    return {
      /**
       * Element used to link with the `aria-describedby`
       * attribute. Supports array of multiple elements.
       * When not set, defaults to `target`.
       */
      ariaTarget: {
        type: Object
      },
      /**
       * Object with properties passed to `generator` and
       * `shouldShow` functions for generating tooltip text
       * or detecting whether to show the tooltip or not.
       */
      context: {
        type: Object,
        value: () => {
          return {};
        }
      },
      /**
       * The delay in milliseconds before the tooltip
       * is opened on keyboard focus, when not in manual mode.
       * @attr {number} focus-delay
       */
      focusDelay: {
        type: Number
      },
      /**
       * Function used to generate the tooltip content.
       * When provided, it overrides the `text` property.
       * Use the `context` property to provide argument
       * that can be passed to the generator function.
       */
      generator: {
        type: Object
      },
      /**
       * The delay in milliseconds before the tooltip
       * is closed on losing hover, when not in manual mode.
       * On blur, the tooltip is closed immediately.
       * @attr {number} hide-delay
       */
      hideDelay: {
        type: Number
      },
      /**
       * The delay in milliseconds before the tooltip
       * is opened on hover, when not in manual mode.
       * @attr {number} hover-delay
       */
      hoverDelay: {
        type: Number
      },
      /**
       * When true, the tooltip is controlled programmatically
       * instead of reacting to focus and mouse events.
       */
      manual: {
        type: Boolean,
        value: false,
        sync: true
      },
      /**
       * When true, the tooltip is opened programmatically.
       * Only works if `manual` is set to `true`.
       */
      opened: {
        type: Boolean,
        value: false,
        sync: true
      },
      /**
       * Function used to detect whether to show the tooltip based on a condition,
       * called every time the tooltip is about to be shown on hover and focus.
       * The function takes two parameters: `target` and `context`, which contain
       * values of the corresponding tooltip properties at the time of calling.
       * The tooltip is only shown when the function invocation returns `true`.
       */
      shouldShow: {
        type: Object,
        value: () => {
          return (_target, _context) => true;
        }
      },
      /**
       * String used as a tooltip content.
       */
      text: {
        type: String,
        observer: "__textChanged"
      },
      /**
       * Set to true when the overlay is opened using auto-added
       * event listeners: mouseenter and focusin (keyboard only).
       * @protected
       */
      _autoOpened: {
        type: Boolean,
        observer: "__autoOpenedChanged",
        sync: true
      },
      /**
       * Element used to link with the `aria-describedby`
       * attribute. When not set, defaults to `target`.
       * @protected
       */
      _effectiveAriaTarget: {
        type: Object,
        computed: "__computeAriaTarget(ariaTarget, target)",
        observer: "__effectiveAriaTargetChanged"
      },
      /** @private */
      __isTargetHidden: {
        type: Boolean,
        value: false
      },
      /** @private */
      _isConnected: {
        type: Boolean,
        sync: true
      },
      /** @private */
      _srLabel: {
        type: Object
      },
      /** @private */
      _overlayContent: {
        type: String
      }
    };
  }
  static get observers() {
    return [
      "__generatorChanged(_overlayElement, generator, context)",
      "__updateSrLabelText(_srLabel, _overlayContent)"
    ];
  }
  /**
   * Sets the default focus delay to be used by all tooltip instances,
   * except for those that have focus delay configured using property.
   *
   * @param {number} focusDelay
   */
  static setDefaultFocusDelay(focusDelay) {
    defaultFocusDelay$3 = focusDelay != null && focusDelay >= 0 ? focusDelay : DEFAULT_DELAY$1;
  }
  /**
   * Sets the default hide delay to be used by all tooltip instances,
   * except for those that have hide delay configured using property.
   *
   * @param {number} hideDelay
   */
  static setDefaultHideDelay(hideDelay) {
    defaultHideDelay$3 = hideDelay != null && hideDelay >= 0 ? hideDelay : DEFAULT_DELAY$1;
  }
  /**
   * Sets the default hover delay to be used by all tooltip instances,
   * except for those that have hover delay configured using property.
   *
   * @param {number} hoverDelay
   */
  static setDefaultHoverDelay(hoverDelay) {
    defaultHoverDelay$3 = hoverDelay != null && hoverDelay >= 0 ? hoverDelay : DEFAULT_DELAY$1;
  }
  constructor() {
    super();
    this._uniqueId = `vaadin-tooltip-${generateUniqueId()}`;
    this._renderer = this.__tooltipRenderer.bind(this);
    this.__onFocusin = this.__onFocusin.bind(this);
    this.__onFocusout = this.__onFocusout.bind(this);
    this.__onMouseDown = this.__onMouseDown.bind(this);
    this.__onMouseEnter = this.__onMouseEnter.bind(this);
    this.__onMouseLeave = this.__onMouseLeave.bind(this);
    this.__onKeyDown = this.__onKeyDown.bind(this);
    this.__onOverlayOpen = this.__onOverlayOpen.bind(this);
    this.__targetVisibilityObserver = new IntersectionObserver(
      (entries) => {
        entries.forEach((entry) => this.__onTargetVisibilityChange(entry.isIntersecting));
      },
      { threshold: 0 }
    );
    this._stateController = new TooltipStateController(this);
  }
  /** @protected */
  connectedCallback() {
    super.connectedCallback();
    this._isConnected = true;
    document.body.addEventListener("vaadin-overlay-open", this.__onOverlayOpen);
  }
  /** @protected */
  disconnectedCallback() {
    super.disconnectedCallback();
    if (this._autoOpened) {
      this._stateController.close(true);
    }
    this._isConnected = false;
    document.body.removeEventListener("vaadin-overlay-open", this.__onOverlayOpen);
  }
  /** @protected */
  ready() {
    super.ready();
    this._overlayElement = this.$.overlay;
    this._srLabelController = new SlotController(this, "sr-label", "div", {
      initializer: (element) => {
        element.id = this._uniqueId;
        element.setAttribute("role", "tooltip");
        this._srLabel = element;
      }
    });
    this.addController(this._srLabelController);
  }
  /** @private */
  __computeOpened(manual, opened, autoOpened, connected) {
    return connected && (manual ? opened : autoOpened);
  }
  /** @private */
  __autoOpenedChanged(opened, oldOpened) {
    if (opened) {
      document.addEventListener("keydown", this.__onKeyDown, true);
    } else if (oldOpened) {
      document.removeEventListener("keydown", this.__onKeyDown, true);
    }
  }
  /**
   * @param {HTMLElement} target
   * @protected
   * @override
   */
  _addTargetListeners(target) {
    target.addEventListener("mouseenter", this.__onMouseEnter);
    target.addEventListener("mouseleave", this.__onMouseLeave);
    target.addEventListener("focusin", this.__onFocusin);
    target.addEventListener("focusout", this.__onFocusout);
    target.addEventListener("mousedown", this.__onMouseDown);
    requestAnimationFrame(() => {
      this.__targetVisibilityObserver.observe(target);
    });
  }
  /**
   * @param {HTMLElement} target
   * @protected
   * @override
   */
  _removeTargetListeners(target) {
    target.removeEventListener("mouseenter", this.__onMouseEnter);
    target.removeEventListener("mouseleave", this.__onMouseLeave);
    target.removeEventListener("focusin", this.__onFocusin);
    target.removeEventListener("focusout", this.__onFocusout);
    target.removeEventListener("mousedown", this.__onMouseDown);
    this.__targetVisibilityObserver.unobserve(target);
  }
  /** @private */
  __onFocusin(event) {
    if (this.manual) {
      return;
    }
    if (!isKeyboardActive()) {
      return;
    }
    if (this.target.contains(event.relatedTarget)) {
      return;
    }
    if (!this.__isShouldShow()) {
      return;
    }
    this.__focusInside = true;
    if (!this.__isTargetHidden && (!this.__hoverInside || !this._autoOpened)) {
      this._stateController.open({ focus: true });
    }
  }
  /** @private */
  __onFocusout(event) {
    if (this.manual) {
      return;
    }
    if (this.target.contains(event.relatedTarget)) {
      return;
    }
    this.__focusInside = false;
    if (!this.__hoverInside) {
      this._stateController.close(true);
    }
  }
  /** @private */
  __onKeyDown(event) {
    if (event.key === "Escape") {
      event.stopPropagation();
      this._stateController.close(true);
    }
  }
  /** @private */
  __onMouseDown() {
    if (this.manual) {
      return;
    }
    this._stateController.close(true);
  }
  /** @private */
  __onMouseEnter() {
    if (this.manual) {
      return;
    }
    if (!this.__isShouldShow()) {
      return;
    }
    if (this.__hoverInside) {
      return;
    }
    this.__hoverInside = true;
    if (!this.__isTargetHidden && (!this.__focusInside || !this._autoOpened)) {
      this._stateController.open({ hover: true });
    }
  }
  /** @private */
  __onMouseLeave(event) {
    if (event.relatedTarget !== this._overlayElement) {
      this.__handleMouseLeave();
    }
  }
  /** @protected */
  __onOverlayMouseEnter() {
    if (this.manual) {
      return;
    }
    if (this._stateController.isClosing) {
      this._stateController.open({ immediate: true });
    }
  }
  /** @protected */
  __onOverlayMouseLeave(event) {
    if (event.relatedTarget !== this.target) {
      this.__handleMouseLeave();
    }
  }
  /** @private */
  __handleMouseLeave() {
    if (this.manual) {
      return;
    }
    this.__hoverInside = false;
    if (!this.__focusInside) {
      this._stateController.close();
    }
  }
  /** @private */
  __onOverlayOpen() {
    if (this.manual) {
      return;
    }
    if (this._overlayElement.opened && !this._overlayElement._last) {
      this._stateController.close(true);
    }
  }
  /** @private */
  __onTargetVisibilityChange(isVisible) {
    const oldHidden = this.__isTargetHidden;
    this.__isTargetHidden = !isVisible;
    if (oldHidden && isVisible && (this.__focusInside || this.__hoverInside)) {
      this._stateController.open({ immediate: true });
      return;
    }
    if (!isVisible && this._autoOpened) {
      this._stateController.close(true);
    }
  }
  /** @private */
  __isShouldShow() {
    if (typeof this.shouldShow === "function" && this.shouldShow(this.target, this.context) !== true) {
      return false;
    }
    return true;
  }
  /** @private */
  __textChanged(text, oldText) {
    if (this._overlayElement && (text || oldText)) {
      this._overlayElement.requestContentUpdate();
    }
  }
  /** @private */
  __tooltipRenderer(root2) {
    root2.textContent = typeof this.generator === "function" ? this.generator(this.context) : this.text;
    this._overlayContent = root2.textContent;
  }
  /** @private */
  __computeAriaTarget(ariaTarget, target) {
    const isElementNode = (el) => el && el.nodeType === Node.ELEMENT_NODE;
    const isAriaTargetSet = Array.isArray(ariaTarget) ? ariaTarget.some(isElementNode) : ariaTarget;
    return isAriaTargetSet ? ariaTarget : target;
  }
  /** @private */
  __effectiveAriaTargetChanged(ariaTarget, oldAriaTarget) {
    if (oldAriaTarget) {
      [oldAriaTarget].flat().forEach((target) => {
        removeValueFromAttribute(target, "aria-describedby", this._uniqueId);
      });
    }
    if (ariaTarget) {
      [ariaTarget].flat().forEach((target) => {
        addValueToAttribute(target, "aria-describedby", this._uniqueId);
      });
    }
  }
  /** @private */
  __generatorChanged(overlayElement, generator, context) {
    if (overlayElement) {
      if (generator !== this.__oldTextGenerator || context !== this.__oldContext) {
        overlayElement.requestContentUpdate();
      }
      this.__oldTextGenerator = generator;
      this.__oldContext = context;
    }
  }
  /** @private */
  __updateSrLabelText(srLabel, textContent) {
    if (srLabel) {
      srLabel.textContent = textContent;
    }
  }
};
/**
 * @license
 * Copyright (c) 2022 - 2025 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
class Tooltip extends TooltipMixin(ThemePropertyMixin(ElementMixin(ControllerMixin(PolymerElement)))) {
  static get is() {
    return "vaadin-tooltip";
  }
  static get template() {
    return html`
      <style>
        :host {
          display: none;
        }
      </style>
      <vaadin-tooltip-overlay
        id="overlay"
        owner="[[__overlayOwner]]"
        renderer="[[_renderer]]"
        theme$="[[_theme]]"
        opened="[[__computeOpened(manual, opened, _autoOpened, _isConnected)]]"
        position-target="[[target]]"
        position="[[__effectivePosition]]"
        no-horizontal-overlap$="[[__computeNoHorizontalOverlap(__effectivePosition)]]"
        no-vertical-overlap$="[[__computeNoVerticalOverlap(__effectivePosition)]]"
        horizontal-align="[[__computeHorizontalAlign(__effectivePosition)]]"
        vertical-align="[[__computeVerticalAlign(__effectivePosition)]]"
        on-mouseenter="__onOverlayMouseEnter"
        on-mouseleave="__onOverlayMouseLeave"
        modeless
      ></vaadin-tooltip-overlay>

      <slot name="sr-label"></slot>
    `;
  }
  static get properties() {
    return {
      /** @private */
      __overlayOwner: {
        value() {
          return this;
        }
      }
    };
  }
}
defineCustomElement(Tooltip);
const globalStyle = document.createElement("style");
globalStyle.textContent = "html { --vaadin-avatar-size: var(--lumo-size-m); }";
document.head.appendChild(globalStyle);
registerStyles$1(
  "vaadin-avatar",
  css`
    :host {
      color: var(--lumo-secondary-text-color);
      background-color: var(--lumo-contrast-10pct);
      border-radius: 50%;
      outline: none;
      cursor: default;
      user-select: none;
      -webkit-tap-highlight-color: transparent;
      -webkit-font-smoothing: antialiased;
      -moz-osx-font-smoothing: grayscale;
    }

    :host([has-color-index]) {
      color: var(--lumo-base-color);
    }

    :host([focus-ring]) {
      border-color: var(--vaadin-focus-ring-color, var(--lumo-primary-color-50pct));
    }

    [part='icon'],
    [part='abbr'] {
      fill: currentColor;
    }

    [part='abbr'] {
      font-family: var(--lumo-font-family);
      font-size: 2.4375em;
      font-weight: 500;
    }

    :host([theme~='xlarge']) [part='abbr'] {
      font-size: 2.5em;
    }

    :host([theme~='large']) [part='abbr'] {
      font-size: 2.375em;
    }

    :host([theme~='small']) [part='abbr'] {
      font-size: 2.75em;
    }

    :host([theme~='xsmall']) [part='abbr'] {
      font-size: 3em;
    }

    :host([theme~='xlarge']) {
      --vaadin-avatar-size: var(--lumo-size-xl);
    }

    :host([theme~='large']) {
      --vaadin-avatar-size: var(--lumo-size-l);
    }

    :host([theme~='small']) {
      --vaadin-avatar-size: var(--lumo-size-s);
    }

    :host([theme~='xsmall']) {
      --vaadin-avatar-size: var(--lumo-size-xs);
    }
  `,
  { moduleId: "lumo-avatar" }
);
/**
 * @license
 * Copyright (c) 2020 - 2025 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const template$6 = document.createElement("template");
template$6.innerHTML = `
  <style>
    @font-face {
      font-family: 'vaadin-avatar-icons';
      src: url(data:application/font-woff;charset=utf-8;base64,d09GRgABAAAAAAQAAAsAAAAABnwAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAABHU1VCAAABCAAAADsAAABUIIslek9TLzIAAAFEAAAAQwAAAFZAIUmEY21hcAAAAYgAAABLAAABcOspwa1nbHlmAAAB1AAAAEUAAABMYO4o1WhlYWQAAAIcAAAALgAAADYYaAmGaGhlYQAAAkwAAAAdAAAAJAZsA1VobXR4AAACbAAAAAgAAAAIA+gAAGxvY2EAAAJ0AAAABgAAAAYAJgAAbWF4cAAAAnwAAAAeAAAAIAEOACFuYW1lAAACnAAAAUIAAAKavFDYrHBvc3QAAAPgAAAAHQAAAC52hGZ4eJxjYGRgYOBiMGCwY2BycfMJYeDLSSzJY5BiYGGAAJA8MpsxJzM9kYEDxgPKsYBpDiBmg4gCACY7BUgAeJxjYGT8wjiBgZWBgamKaQ8DA0MPhGZ8wGDIyAQUZWBlZsAKAtJcUxgcXjG+YmQO+p/FEMUcxDANKMwIkgMADiUMJQB4nGNgYGBlYGBgBmIdIGZhYGAMYWBkAAE/oCgjWJyZgQsszsKgBFbDAhJ/xfj/P4wE8lnAJAMjG8Mo4AGTMlAeOKwgmIERADU0CX0AeJxjYGIAAmYJpkgGHgYRBgZGJT1GEztGIzlGET5GKEuU8YuSpZKSpQuI+LfLv21emz9jHJQPJP7dsUywsEiwBACG8g9CAAAAeJxjYGRgYADicIOnh+P5bb4ycDO/AIow3JZ4rIJMM0swRQIpDgYmEA8AKwgJOwAAeJxjYGRgYA76nwUkXzAAAbMEAyMDKmACAE2GAskAAAAAAAAAA+gAAAAAAAAAJgAAeJxjYGRgYGBiEAViBjCLgYELCBkY/oP5DAAKuwEwAAB4nI2Qu07DMBSG//SGaCWEhMSAGDx1QU0vYyemdmDrUDEhuamTpkriyHEj9RF4B56Bh2Bg5mmY+8d4Qh3qo9jf+c45thQAt/hGgGYFuHN7s1q4YvbHbdKD5w555LmLAZ499+hfPPfxhDfPA/p33hB0rmmG+PDcwg2+PLfpfzx3yL+eu7gPHj33MAxmnvtYB6+eB/SftZTbtBjJWlppRmmki2qlkkMmzZnKGbVWpkp1Iabh5Ex1qQplpFVbsTmKqk5m1sYiNjoXC11YlWValEbvVWTDnbXlfDyOvQ8jnaOGZGyRouCfky63/AyzFBE0fYUVFBIckLnKZTOXda15s+GZulxgihCTC2eXnC3cfFNV7BfY4Mi9eT3BjNYiZh6zRyMnLdxs050xNE3panuaiD7Ezk2VmGPMiP/1h+71/ATcWYAhAAB4nGNgYoAALgbsgImRiZGZgaW0OLWIgQEACl4B2QAAAA==) format('woff');
      font-weight: normal;
      font-style: normal;
    }
  </style>
`;
document.head.appendChild(template$6.content);
/**
 * @license
 * Copyright (c) 2017 - 2025 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const DEFAULT_I18N$1 = {
  anonymous: "anonymous"
};
const AvatarMixin = (superClass) => class AvatarMixinClass extends I18nMixin(DEFAULT_I18N$1, FocusMixin(superClass)) {
  static get properties() {
    return {
      /**
       * The path to the image
       */
      img: {
        type: String,
        reflectToAttribute: true,
        observer: "__imgChanged"
      },
      /**
       * A shortened form of name that is displayed
       * in the avatar when `img` is not provided.
       */
      abbr: {
        type: String,
        reflectToAttribute: true
      },
      /**
       * Full name of the user
       * used for the tooltip of the avatar.
       */
      name: {
        type: String,
        reflectToAttribute: true
      },
      /**
       * Color index used for avatar background.
       * @attr {number} color-index
       */
      colorIndex: {
        type: Number,
        observer: "__colorIndexChanged"
      },
      /**
       * When true, the avatar has tooltip shown on hover and focus.
       * The tooltip text is based on the `name` and `abbr` properties.
       * When neither is provided, `i18n.anonymous` is used instead.
       * @attr {boolean} with-tooltip
       */
      withTooltip: {
        type: Boolean,
        value: false,
        observer: "__withTooltipChanged"
      },
      /** @protected */
      __imgVisible: Boolean,
      /** @protected */
      __iconVisible: Boolean,
      /** @protected */
      __abbrVisible: Boolean,
      /** @private */
      __tooltipNode: Object
    };
  }
  static get observers() {
    return [
      "__imgOrAbbrOrNameChanged(img, abbr, name)",
      "__i18nChanged(__effectiveI18n)",
      "__tooltipChanged(__tooltipNode, name, abbr)"
    ];
  }
  /**
   * The object used to localize this component. To change the default
   * localization, replace this with an object that provides all properties, or
   * just the individual properties you want to change.
   *
   * The object has the following JSON structure and default values:
   * ```
   * {
   *   // Translation of the anonymous user avatar tooltip.
   *   anonymous: 'anonymous'
   * }
   * ```
   * @return {!AvatarI18n}
   */
  get i18n() {
    return super.i18n;
  }
  set i18n(value) {
    super.i18n = value;
  }
  /** @protected */
  ready() {
    super.ready();
    this.__updateVisibility();
    if (!this.hasAttribute("role")) {
      this.setAttribute("role", "img");
    }
    if (!this.hasAttribute("tabindex")) {
      this.setAttribute("tabindex", "0");
    }
    if (!this.name && !this.abbr) {
      this.__setTooltip();
    }
  }
  /** @private */
  __colorIndexChanged(index) {
    if (index != null) {
      const prop = `--vaadin-user-color-${index}`;
      const isValid2 = Boolean(getComputedStyle(document.documentElement).getPropertyValue(prop));
      if (isValid2) {
        this.setAttribute("has-color-index", "");
        this.style.setProperty("--vaadin-avatar-user-color", `var(${prop})`);
      } else {
        this.removeAttribute("has-color-index");
        console.warn(`The CSS property --vaadin-user-color-${index} is not defined`);
      }
    } else {
      this.removeAttribute("has-color-index");
    }
  }
  /** @private */
  __imgChanged() {
    this.__imgFailedToLoad = false;
  }
  /** @private */
  __imgOrAbbrOrNameChanged(_img, abbr, name) {
    this.__updateVisibility();
    if (abbr && abbr !== this.__generatedAbbr) {
      return;
    }
    if (name) {
      this.abbr = this.__generatedAbbr = name.split(" ").map((word) => word.charAt(0)).join("");
    } else {
      this.abbr = void 0;
    }
  }
  /** @private */
  __tooltipChanged(tooltipNode, name, abbr) {
    if (tooltipNode) {
      if (abbr && abbr !== this.__generatedAbbr) {
        this.__setTooltip(name ? `${name} (${abbr})` : abbr);
      } else {
        this.__setTooltip(name);
      }
    }
    if (abbr) {
      this.setAttribute("aria-label", !tooltipNode && name ? `${name} (${abbr})` : abbr);
    } else {
      this.removeAttribute("aria-label");
    }
  }
  /** @private */
  __withTooltipChanged(withTooltip, oldWithTooltip) {
    if (withTooltip) {
      const tooltipNode = document.createElement("vaadin-tooltip");
      tooltipNode.setAttribute("slot", "tooltip");
      this.appendChild(tooltipNode);
      this.__tooltipNode = tooltipNode;
    } else if (oldWithTooltip) {
      this.__tooltipNode.target = null;
      this.__tooltipNode.remove();
      this.__tooltipNode = null;
    }
  }
  /** @private */
  __i18nChanged(effectiveI18n) {
    if (effectiveI18n && effectiveI18n.anonymous) {
      if (this.__oldAnonymous && this.__tooltipNode && this.__tooltipNode.text === this.__oldAnonymous) {
        this.__setTooltip();
      }
      this.__oldAnonymous = effectiveI18n.anonymous;
    }
  }
  /** @private */
  __updateVisibility() {
    this.__imgVisible = !!this.img && !this.__imgFailedToLoad;
    this.__abbrVisible = !this.__imgVisible && !!this.abbr;
    this.__iconVisible = !this.__imgVisible && !this.abbr;
  }
  /** @private */
  __setTooltip(tooltip) {
    const tooltipNode = this.__tooltipNode;
    if (tooltipNode) {
      tooltipNode.text = tooltip || this.__effectiveI18n.anonymous;
    }
  }
  /** @protected */
  __onImageLoadError() {
    if (this.img) {
      console.warn(`<vaadin-avatar> The specified image could not be loaded: ${this.img}`);
      this.__imgFailedToLoad = true;
      this.__updateVisibility();
    }
  }
};
/**
 * @license
 * Copyright (c) 2017 - 2025 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const avatarStyles = css`
  :host {
    display: inline-block;
    flex: none;
    border-radius: 50%;
    overflow: hidden;
    height: var(--vaadin-avatar-size, 64px);
    width: var(--vaadin-avatar-size, 64px);
    border: var(--vaadin-avatar-outline-width) solid transparent;
    margin: calc(var(--vaadin-avatar-outline-width) * -1);
    background-clip: content-box;
    --vaadin-avatar-outline-width: var(--vaadin-focus-ring-width, 2px);
  }

  img {
    height: 100%;
    width: 100%;
    object-fit: cover;
  }

  [part='icon'] {
    font-size: 5.6em;
  }

  [part='abbr'] {
    font-size: 2.2em;
  }

  [part='icon'] > text {
    font-family: 'vaadin-avatar-icons';
  }

  :host([hidden]) {
    display: none !important;
  }

  svg[hidden] {
    display: none !important;
  }

  :host([has-color-index]) {
    position: relative;
    background-color: var(--vaadin-avatar-user-color);
  }

  :host([has-color-index])::before {
    position: absolute;
    content: '';
    inset: 0;
    border-radius: inherit;
    box-shadow: inset 0 0 0 2px var(--vaadin-avatar-user-color);
  }
`;
/**
 * @license
 * Copyright (c) 2020 - 2025 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
registerStyles$1("vaadin-avatar", avatarStyles, { moduleId: "vaadin-avatar-styles" });
class Avatar extends AvatarMixin(ElementMixin(ThemableMixin(ControllerMixin(PolymerElement)))) {
  static get template() {
    return html`
      <img
        hidden$="[[!__imgVisible]]"
        src$="[[img]]"
        aria-hidden="true"
        on-error="__onImageLoadError"
        draggable="false"
      />
      <svg
        part="icon"
        hidden$="[[!__iconVisible]]"
        id="avatar-icon"
        viewBox="-50 -50 100 100"
        preserveAspectRatio="xMidYMid meet"
        aria-hidden="true"
      >
        <text dy=".35em" text-anchor="middle">&#xea01;</text>
      </svg>
      <svg
        part="abbr"
        hidden$="[[!__abbrVisible]]"
        id="avatar-abbr"
        viewBox="-50 -50 100 100"
        preserveAspectRatio="xMidYMid meet"
        aria-hidden="true"
      >
        <text dy=".35em" text-anchor="middle">[[abbr]]</text>
      </svg>

      <slot name="tooltip"></slot>
    `;
  }
  static get is() {
    return "vaadin-avatar";
  }
  /** @protected */
  ready() {
    super.ready();
    this._tooltipController = new TooltipController(this);
    this.addController(this._tooltipController);
  }
}
defineCustomElement(Avatar);
const item = css`
  :host {
    display: flex;
    align-items: center;
    box-sizing: border-box;
    font-family: var(--lumo-font-family);
    font-size: var(--lumo-font-size-m);
    line-height: var(--lumo-line-height-xs);
    padding: 0.5em calc(var(--lumo-space-l) + var(--lumo-border-radius-m) / 4) 0.5em
      var(--_lumo-list-box-item-padding-left, calc(var(--lumo-border-radius-m) / 4));
    min-height: var(--lumo-size-m);
    outline: none;
    border-radius: var(--lumo-border-radius-m);
    cursor: var(--lumo-clickable-cursor);
    -webkit-font-smoothing: antialiased;
    -moz-osx-font-smoothing: grayscale;
    -webkit-tap-highlight-color: var(--lumo-primary-color-10pct);
    --_focus-ring-color: var(--vaadin-focus-ring-color, var(--lumo-primary-color-50pct));
    --_focus-ring-width: var(--vaadin-focus-ring-width, 2px);
    --_selection-color-text: var(--vaadin-selection-color-text, var(--lumo-primary-text-color));
  }

  /* Checkmark */
  [part='checkmark']::before {
    display: var(--_lumo-item-selected-icon-display, none);
    content: var(--lumo-icons-checkmark);
    font-family: lumo-icons;
    font-size: var(--lumo-icon-size-m);
    line-height: 1;
    font-weight: normal;
    width: 1em;
    height: 1em;
    margin: calc((1 - var(--lumo-line-height-xs)) * var(--lumo-font-size-m) / 2) 0;
    color: var(--_selection-color-text);
    flex: none;
    opacity: 0;
    transition:
      transform 0.2s cubic-bezier(0.12, 0.32, 0.54, 2),
      opacity 0.1s;
  }

  :host([selected]) [part='checkmark']::before {
    opacity: 1;
  }

  :host([active]:not([selected])) [part='checkmark']::before {
    transform: scale(0.8);
    opacity: 0;
    transition-duration: 0s;
  }

  [part='content'] {
    flex: auto;
  }

  /* Disabled */
  :host([disabled]) {
    color: var(--lumo-disabled-text-color);
    cursor: default;
    pointer-events: none;
  }

  /* TODO a workaround until we have "focus-follows-mouse". After that, use the hover style for focus-ring as well */
  @media (any-hover: hover) {
    :host(:hover:not([disabled])) {
      background-color: var(--lumo-primary-color-10pct);
    }
  }

  :host([focus-ring]:not([disabled])) {
    box-shadow: inset 0 0 0 var(--_focus-ring-width) var(--_focus-ring-color);
  }

  /* RTL specific styles */
  :host([dir='rtl']) {
    padding-left: calc(var(--lumo-space-l) + var(--lumo-border-radius-m) / 4);
    padding-right: var(--_lumo-list-box-item-padding-left, calc(var(--lumo-border-radius-m) / 4));
  }

  /* Slotted icons */
  :host ::slotted(vaadin-icon) {
    width: var(--lumo-icon-size-m);
    height: var(--lumo-icon-size-m);
  }
`;
registerStyles$1("vaadin-item", item, { moduleId: "lumo-item" });
const listBox = css`
  :host {
    -webkit-tap-highlight-color: transparent;
    --_lumo-item-selected-icon-display: var(--_lumo-list-box-item-selected-icon-display, block);
  }

  /* Dividers */
  [part='items'] ::slotted(hr) {
    height: 1px;
    border: 0;
    padding: 0;
    margin: var(--lumo-space-s) var(--lumo-border-radius-m);
    background-color: var(--lumo-contrast-10pct);
  }
`;
registerStyles$1("vaadin-list-box", listBox, { moduleId: "lumo-list-box" });
/**
 * @license
 * Copyright (c) 2017 - 2025 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const menuOverlayCore = css`
  :host([opening]),
  :host([closing]) {
    animation: 0.14s lumo-overlay-dummy-animation;
  }

  [part='overlay'] {
    will-change: opacity, transform;
  }

  :host([opening]) [part='overlay'] {
    animation: 0.1s lumo-menu-overlay-enter ease-out both;
  }

  @keyframes lumo-menu-overlay-enter {
    0% {
      opacity: 0;
      transform: translateY(-4px);
    }
  }

  :host([closing]) [part='overlay'] {
    animation: 0.1s lumo-menu-overlay-exit both;
  }

  @keyframes lumo-menu-overlay-exit {
    100% {
      opacity: 0;
    }
  }
`;
registerStyles$1("", menuOverlayCore, { moduleId: "lumo-menu-overlay-core" });
const menuOverlayExt = css`
  /* Small viewport (bottom sheet) styles */
  /* Use direct media queries instead of the state attributes ([phone] and [fullscreen]) provided by the elements */
  @media (max-width: 450px), (max-height: 450px) {
    :host {
      top: 0 !important;
      right: 0 !important;
      bottom: var(--vaadin-overlay-viewport-bottom, 0) !important;
      left: 0 !important;
      align-items: stretch !important;
      justify-content: flex-end !important;
    }

    [part='overlay'] {
      max-height: 50vh;
      width: 100vw;
      border-radius: 0;
      box-shadow: var(--lumo-box-shadow-xl);
    }

    /* The content part scrolls instead of the overlay part, because of the gradient fade-out */
    [part='content'] {
      padding: 30px var(--lumo-space-m);
      max-height: inherit;
      box-sizing: border-box;
      -webkit-overflow-scrolling: touch;
      overflow: auto;
      -webkit-mask-image: linear-gradient(transparent, #000 40px, #000 calc(100% - 40px), transparent);
      mask-image: linear-gradient(transparent, #000 40px, #000 calc(100% - 40px), transparent);
    }

    [part='backdrop'] {
      display: block;
    }

    /* Animations */

    :host([opening]) [part='overlay'] {
      animation: 0.2s lumo-mobile-menu-overlay-enter cubic-bezier(0.215, 0.61, 0.355, 1) both;
    }

    :host([closing]),
    :host([closing]) [part='backdrop'] {
      animation-delay: 0.14s;
    }

    :host([closing]) [part='overlay'] {
      animation: 0.14s 0.14s lumo-mobile-menu-overlay-exit cubic-bezier(0.55, 0.055, 0.675, 0.19) both;
    }
  }

  @keyframes lumo-mobile-menu-overlay-enter {
    0% {
      transform: translateY(150%);
    }
  }

  @keyframes lumo-mobile-menu-overlay-exit {
    100% {
      transform: translateY(150%);
    }
  }
`;
const menuOverlay = [overlay, menuOverlayCore, menuOverlayExt];
registerStyles$1("", menuOverlay, { moduleId: "lumo-menu-overlay" });
registerStyles$1(
  "vaadin-avatar-group",
  css`
    :host {
      --vaadin-avatar-size: var(--lumo-size-m);
    }

    :host([theme~='xlarge']) {
      --vaadin-avatar-group-overlap: 12px;
      --vaadin-avatar-group-overlap-border: 3px;
      --vaadin-avatar-size: var(--lumo-size-xl);
    }

    :host([theme~='large']) {
      --vaadin-avatar-group-overlap: 10px;
      --vaadin-avatar-group-overlap-border: 3px;
      --vaadin-avatar-size: var(--lumo-size-l);
    }

    :host([theme~='small']) {
      --vaadin-avatar-group-overlap: 6px;
      --vaadin-avatar-group-overlap-border: 2px;
      --vaadin-avatar-size: var(--lumo-size-s);
    }

    :host([theme~='xsmall']) {
      --vaadin-avatar-group-overlap: 4px;
      --vaadin-avatar-group-overlap-border: 2px;
      --vaadin-avatar-size: var(--lumo-size-xs);
    }
  `,
  { moduleId: "lumo-avatar-group" }
);
const avatarGroupOverlay = css`
  :host {
    --_lumo-list-box-item-selected-icon-display: none;
    --_lumo-list-box-item-padding-left: calc(var(--lumo-space-m) + var(--lumo-border-radius-m) / 4);
  }

  [part='overlay'] {
    outline: none;
  }
`;
registerStyles$1("vaadin-avatar-group-overlay", [overlay, menuOverlayCore, avatarGroupOverlay], {
  moduleId: "lumo-avatar-group-overlay"
});
registerStyles$1("vaadin-avatar-group-menu", listBox, { moduleId: "lumo-avatar-group-menu" });
registerStyles$1(
  "vaadin-avatar-group-menu-item",
  [
    item,
    css`
      :host {
        padding: var(--lumo-space-xs);
        padding-inline-end: var(--lumo-space-m);
      }

      [part='content'] {
        display: flex;
        align-items: center;
      }

      [part='content'] ::slotted(vaadin-avatar) {
        width: var(--lumo-size-xs);
        height: var(--lumo-size-xs);
        margin-inline-end: var(--lumo-space-s);
      }
    `
  ],
  { moduleId: "lumo-avatar-group-menu-item" }
);
/**
 * @license
 * Copyright (c) 2021 - 2025 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
function getNormalizedScrollLeft(element, direction) {
  const { scrollLeft } = element;
  if (direction !== "rtl") {
    return scrollLeft;
  }
  return element.scrollWidth - element.clientWidth + scrollLeft;
}
function setNormalizedScrollLeft(element, direction, scrollLeft) {
  if (direction !== "rtl") {
    element.scrollLeft = scrollLeft;
  } else {
    element.scrollLeft = element.clientWidth - element.scrollWidth + scrollLeft;
  }
}
/**
 * @license
 * Copyright (c) 2017 - 2025 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const ListMixin = (superClass) => class ListMixinClass extends KeyboardDirectionMixin(superClass) {
  static get properties() {
    return {
      /**
       * If true, the user cannot interact with this element.
       * When the element is disabled, the selected item is
       * not updated when `selected` property is changed.
       */
      disabled: {
        type: Boolean,
        value: false,
        reflectToAttribute: true
      },
      /**
       * The index of the item selected in the items array.
       * Note: Not updated when used in `multiple` selection mode.
       */
      selected: {
        type: Number,
        reflectToAttribute: true,
        notify: true,
        sync: true
      },
      /**
       * Define how items are disposed in the dom.
       * Possible values are: `horizontal|vertical`.
       * It also changes navigation keys from left/right to up/down.
       * @type {!ListOrientation}
       */
      orientation: {
        type: String,
        reflectToAttribute: true,
        value: ""
      },
      /**
       * The list of items from which a selection can be made.
       * It is populated from the elements passed to the light DOM,
       * and updated dynamically when adding or removing items.
       *
       * The item elements must implement `Vaadin.ItemMixin`.
       *
       * Note: unlike `<vaadin-combo-box>`, this property is read-only,
       * so if you want to provide items by iterating array of data,
       * you have to use `dom-repeat` and place it to the light DOM.
       * @type {!Array<!Element> | undefined}
       */
      items: {
        type: Array,
        readOnly: true,
        notify: true
      },
      /**
       * The search buffer for the keyboard selection feature.
       * @private
       */
      _searchBuf: {
        type: String,
        value: ""
      }
    };
  }
  static get observers() {
    return ["_enhanceItems(items, orientation, selected, disabled)"];
  }
  /**
   * @return {boolean}
   * @protected
   */
  get _isRTL() {
    return !this._vertical && this.getAttribute("dir") === "rtl";
  }
  /**
   * @return {!HTMLElement}
   * @protected
   */
  get _scrollerElement() {
    console.warn(`Please implement the '_scrollerElement' property in <${this.localName}>`);
    return this;
  }
  /**
   * @return {boolean}
   * @protected
   */
  get _vertical() {
    return this.orientation !== "horizontal";
  }
  focus() {
    if (this._observer) {
      this._observer.flush();
    }
    const items = Array.isArray(this.items) ? this.items : [];
    const idx = this._getAvailableIndex(items, 0, null, (item2) => item2.tabIndex === 0 && !isElementHidden(item2));
    if (idx >= 0) {
      this._focus(idx);
    } else {
      super.focus();
    }
  }
  /** @protected */
  ready() {
    super.ready();
    this.addEventListener("click", (e2) => this._onClick(e2));
    const slot = this.shadowRoot.querySelector("slot:not([name])");
    this._observer = new SlotObserver(slot, () => {
      this._setItems(this._filterItems(getFlattenedElements(this)));
    });
  }
  /**
   * Override method inherited from `KeyboardDirectionMixin`
   * to use the stored list of item elements.
   *
   * @return {Element[]}
   * @protected
   * @override
   */
  _getItems() {
    return this.items;
  }
  /** @private */
  _enhanceItems(items, orientation, selected, disabled) {
    if (!disabled) {
      if (items) {
        this.setAttribute("aria-orientation", orientation || "vertical");
        items.forEach((item2) => {
          if (orientation) {
            item2.setAttribute("orientation", orientation);
          } else {
            item2.removeAttribute("orientation");
          }
        });
        this._setFocusable(selected < 0 || !selected ? 0 : selected);
        const itemToSelect = items[selected];
        items.forEach((item2) => {
          item2.selected = item2 === itemToSelect;
        });
        if (itemToSelect && !itemToSelect.disabled) {
          this._scrollToItem(selected);
        }
      }
    }
  }
  /**
   * @param {!Array<!Element>} array
   * @return {!Array<!Element>}
   * @protected
   */
  _filterItems(array) {
    return array.filter((e2) => e2._hasVaadinItemMixin);
  }
  /**
   * @param {!MouseEvent} event
   * @protected
   */
  _onClick(event) {
    if (event.metaKey || event.shiftKey || event.ctrlKey || event.defaultPrevented) {
      return;
    }
    const item2 = this._filterItems(event.composedPath())[0];
    let idx;
    if (item2 && !item2.disabled && (idx = this.items.indexOf(item2)) >= 0) {
      this.selected = idx;
    }
  }
  /**
   * @param {number} currentIdx
   * @param {string} key
   * @return {number}
   * @protected
   */
  _searchKey(currentIdx, key) {
    this._searchReset = Debouncer$1.debounce(this._searchReset, timeOut$1.after(500), () => {
      this._searchBuf = "";
    });
    this._searchBuf += key.toLowerCase();
    if (!this.items.some((item2) => this.__isMatchingKey(item2))) {
      this._searchBuf = key.toLowerCase();
    }
    const idx = this._searchBuf.length === 1 ? currentIdx + 1 : currentIdx;
    return this._getAvailableIndex(
      this.items,
      idx,
      1,
      (item2) => this.__isMatchingKey(item2) && getComputedStyle(item2).display !== "none"
    );
  }
  /** @private */
  __isMatchingKey(item2) {
    return item2.textContent.replace(/[^\p{L}\p{Nd}]/gu, "").toLowerCase().startsWith(this._searchBuf);
  }
  /**
   * Override an event listener from `KeyboardMixin`
   * to search items by key.
   *
   * @param {!KeyboardEvent} event
   * @protected
   * @override
   */
  _onKeyDown(event) {
    if (event.metaKey || event.ctrlKey) {
      return;
    }
    const key = event.key;
    const currentIdx = this.items.indexOf(this.focused);
    if (/[\p{L}\p{Nd}]/u.test(key) && key.length === 1) {
      const idx = this._searchKey(currentIdx, key);
      if (idx >= 0) {
        this._focus(idx);
      }
      return;
    }
    super._onKeyDown(event);
  }
  /**
   * @param {number} idx
   * @protected
   */
  _setFocusable(idx) {
    idx = this._getAvailableIndex(this.items, idx, 1);
    const item2 = this.items[idx];
    this.items.forEach((e2) => {
      e2.tabIndex = e2 === item2 ? 0 : -1;
    });
  }
  /**
   * @param {number} idx
   * @protected
   */
  _focus(idx) {
    this.items.forEach((e2, index) => {
      e2.focused = index === idx;
    });
    this._setFocusable(idx);
    this._scrollToItem(idx);
    super._focus(idx);
  }
  /**
   * Scroll the container to have the next item by the edge of the viewport.
   * @param {number} idx
   * @protected
   */
  _scrollToItem(idx) {
    const item2 = this.items[idx];
    if (!item2) {
      return;
    }
    const props = this._vertical ? ["top", "bottom"] : this._isRTL ? ["right", "left"] : ["left", "right"];
    const scrollerRect = this._scrollerElement.getBoundingClientRect();
    const nextItemRect = (this.items[idx + 1] || item2).getBoundingClientRect();
    const prevItemRect = (this.items[idx - 1] || item2).getBoundingClientRect();
    let scrollDistance = 0;
    if (!this._isRTL && nextItemRect[props[1]] >= scrollerRect[props[1]] || this._isRTL && nextItemRect[props[1]] <= scrollerRect[props[1]]) {
      scrollDistance = nextItemRect[props[1]] - scrollerRect[props[1]];
    } else if (!this._isRTL && prevItemRect[props[0]] <= scrollerRect[props[0]] || this._isRTL && prevItemRect[props[0]] >= scrollerRect[props[0]]) {
      scrollDistance = prevItemRect[props[0]] - scrollerRect[props[0]];
    }
    this._scroll(scrollDistance);
  }
  /**
   * @param {number} pixels
   * @protected
   */
  _scroll(pixels) {
    if (this._vertical) {
      this._scrollerElement.scrollTop += pixels;
    } else {
      const dir = this.getAttribute("dir") || "ltr";
      const scrollLeft = getNormalizedScrollLeft(this._scrollerElement, dir) + pixels;
      setNormalizedScrollLeft(this._scrollerElement, dir, scrollLeft);
    }
  }
  /**
   * Fired when the selection is changed.
   * Not fired when used in `multiple` selection mode.
   *
   * @event selected-changed
   * @param {Object} detail
   * @param {Object} detail.value the index of the item selected in the items array.
   */
};
/**
 * @license
 * Copyright (c) 2020 - 2025 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
class AvatarGroupMenu extends ListMixin(ThemableMixin(DirMixin(ControllerMixin(PolymerElement)))) {
  static get is() {
    return "vaadin-avatar-group-menu";
  }
  static get template() {
    return html`
      <style>
        :host {
          display: flex;
        }

        :host([hidden]) {
          display: none !important;
        }

        [part='items'] {
          height: 100%;
          width: 100%;
          overflow-y: auto;
          -webkit-overflow-scrolling: touch;
        }
      </style>
      <div part="items">
        <slot></slot>
      </div>
    `;
  }
  static get properties() {
    return {
      // We don't need to define this property since super default is vertical,
      // but we don't want it to be modified, or be shown in the API docs.
      /** @private */
      orientation: {
        readOnly: true
      }
    };
  }
  /**
   * @return {!HTMLElement}
   * @protected
   * @override
   */
  get _scrollerElement() {
    return this.shadowRoot.querySelector('[part="items"]');
  }
  /** @protected */
  ready() {
    super.ready();
    this.setAttribute("role", "menu");
  }
}
defineCustomElement(AvatarGroupMenu);
/**
 * @license
 * Copyright (c) 2017 - 2025 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const ItemMixin = (superClass) => class VaadinItemMixin extends ActiveMixin(FocusMixin(superClass)) {
  static get properties() {
    return {
      /**
       * Used for mixin detection because `instanceof` does not work with mixins.
       * e.g. in VaadinListMixin it filters items by using the
       * `element._hasVaadinItemMixin` condition.
       * @type {boolean}
       */
      _hasVaadinItemMixin: {
        value: true
      },
      /**
       * If true, the item is in selected state.
       * @type {boolean}
       */
      selected: {
        type: Boolean,
        value: false,
        reflectToAttribute: true,
        observer: "_selectedChanged",
        sync: true
      },
      /** @private */
      _value: String
    };
  }
  /**
   * By default, `Space` is the only possible activation key for a focusable HTML element.
   * Nonetheless, the item is an exception as it can be also activated by pressing `Enter`.
   * See the "Keyboard Support" section in https://www.w3.org/TR/wai-aria-practices/examples/menubar/menubar-1/menubar-1.html.
   *
   * @protected
   * @override
   */
  get _activeKeys() {
    return ["Enter", " "];
  }
  /**
   * @return {string}
   */
  get value() {
    return this._value !== void 0 ? this._value : this.textContent.trim();
  }
  /**
   * @param {string} value
   */
  set value(value) {
    this._value = value;
  }
  /** @protected */
  ready() {
    super.ready();
    const attrValue = this.getAttribute("value");
    if (attrValue !== null) {
      this.value = attrValue;
    }
  }
  /**
   * Override native `focus` to set focused attribute
   * when focusing the item programmatically.
   * @protected
   * @override
   */
  focus() {
    if (this.disabled) {
      return;
    }
    super.focus();
    this._setFocused(true);
  }
  /**
   * @param {KeyboardEvent | MouseEvent} _event
   * @protected
   * @override
   */
  _shouldSetActive(event) {
    return !this.disabled && !(event.type === "keydown" && event.defaultPrevented);
  }
  /** @private */
  _selectedChanged(selected) {
    this.setAttribute("aria-selected", selected);
  }
  /**
   * Override an observer from `DisabledMixin`.
   * @protected
   * @override
   */
  _disabledChanged(disabled) {
    super._disabledChanged(disabled);
    if (disabled) {
      this.selected = false;
      this.blur();
    }
  }
  /**
   * In order to be fully accessible from the keyboard, the item should
   * manually fire the `click` event once an activation key is pressed.
   *
   * According to the UI Events specifications,
   * the `click` event should be fired exactly on `keydown`:
   * https://www.w3.org/TR/uievents/#event-type-keydown
   *
   * @param {KeyboardEvent} event
   * @protected
   * @override
   */
  _onKeyDown(event) {
    super._onKeyDown(event);
    if (this._activeKeys.includes(event.key) && !event.defaultPrevented) {
      event.preventDefault();
      this.click();
    }
  }
};
/**
 * @license
 * Copyright (c) 2020 - 2025 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
class AvatarGroupMenuItem extends ItemMixin(ThemableMixin(DirMixin(PolymerElement))) {
  static get is() {
    return "vaadin-avatar-group-menu-item";
  }
  static get template() {
    return html`
      <style>
        :host {
          display: inline-block;
        }

        :host([hidden]) {
          display: none !important;
        }
      </style>
      <span part="checkmark" aria-hidden="true"></span>
      <div part="content">
        <slot></slot>
      </div>
    `;
  }
  /** @protected */
  ready() {
    super.ready();
    this.setAttribute("role", "menuitem");
  }
}
defineCustomElement(AvatarGroupMenuItem);
/**
 * @license
 * Copyright (c) 2020 - 2025 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
registerStyles$1("vaadin-avatar-group-overlay", [overlayStyles], {
  moduleId: "vaadin-avatar-group-overlay-styles"
});
class AvatarGroupOverlay extends PositionMixin(OverlayMixin(DirMixin(ThemableMixin(PolymerElement)))) {
  static get is() {
    return "vaadin-avatar-group-overlay";
  }
  static get template() {
    return html`
      <div id="backdrop" part="backdrop" hidden$="[[!withBackdrop]]"></div>
      <div part="overlay" id="overlay" tabindex="0">
        <div part="content" id="content">
          <slot></slot>
        </div>
      </div>
    `;
  }
}
defineCustomElement(AvatarGroupOverlay);
/**
 * @license
 * Copyright 2018 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const ifDefined = (value) => value ?? nothing;
/**
 * @license
 * Copyright (c) 2021 - 2025 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const observer = new ResizeObserver((entries) => {
  setTimeout(() => {
    entries.forEach((entry) => {
      if (!entry.target.isConnected) {
        return;
      }
      if (entry.target.resizables) {
        entry.target.resizables.forEach((resizable) => {
          resizable._onResize(entry.contentRect);
        });
      } else {
        entry.target._onResize(entry.contentRect);
      }
    });
  });
});
const ResizeMixin = dedupingMixin(
  (superclass) => class ResizeMixinClass extends superclass {
    /**
     * When true, the parent element resize will be also observed.
     * Override this getter and return `true` to enable this.
     *
     * @protected
     */
    get _observeParent() {
      return false;
    }
    /** @protected */
    connectedCallback() {
      super.connectedCallback();
      observer.observe(this);
      if (this._observeParent) {
        const parent = this.parentNode instanceof ShadowRoot ? this.parentNode.host : this.parentNode;
        if (!parent.resizables) {
          parent.resizables = /* @__PURE__ */ new Set();
          observer.observe(parent);
        }
        parent.resizables.add(this);
        this.__parent = parent;
      }
    }
    /** @protected */
    disconnectedCallback() {
      super.disconnectedCallback();
      observer.unobserve(this);
      const parent = this.__parent;
      if (this._observeParent && parent) {
        const resizables = parent.resizables;
        if (resizables) {
          resizables.delete(this);
          if (resizables.size === 0) {
            observer.unobserve(parent);
          }
        }
        this.__parent = null;
      }
    }
    /**
     * A handler invoked on host resize. By default, it does nothing.
     * Override the method to implement your own behavior.
     *
     * @protected
     */
    _onResize(_contentRect) {
    }
  }
);
/**
 * @license
 * Copyright (c) 2020 - 2025 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const MINIMUM_DISPLAYED_AVATARS = 2;
const DEFAULT_I18N = {
  anonymous: "anonymous",
  activeUsers: {
    one: "Currently one active user",
    many: "Currently {count} active users"
  },
  joined: "{user} joined",
  left: "{user} left"
};
const AvatarGroupMixin = (superClass) => class AvatarGroupMixinClass extends I18nMixin(DEFAULT_I18N, ResizeMixin(OverlayClassMixin(superClass))) {
  static get properties() {
    return {
      /**
       * An array containing the items which will be stamped as avatars.
       *
       * The items objects allow to configure [`name`](#/elements/vaadin-avatar#property-name),
       * [`abbr`](#/elements/vaadin-avatar#property-abbr), [`img`](#/elements/vaadin-avatar#property-img)
       * and [`colorIndex`](#/elements/vaadin-avatar#property-colorIndex) properties on the
       * stamped avatars, and set `className` to provide CSS class names.
       *
       * #### Example
       *
       * ```js
       * group.items = [
       *   {
       *     name: 'User name',
       *     img: 'url-to-image.png',
       *     className: 'even'
       *   },
       *   {
       *     abbr: 'JD',
       *     colorIndex: 1,
       *     className: 'odd'
       *   },
       * ];
       * ```
       *
       * @type {!Array<!AvatarGroupItem> | undefined}
       */
      items: {
        type: Array,
        observer: "__itemsChanged",
        sync: true
      },
      /**
       * The maximum number of avatars to display. By default, all the avatars are displayed.
       * When _maxItemsVisible_ is set, the overflowing avatars are grouped into one avatar with
       * a dropdown. Setting 0 or 1 has no effect so there are always at least two avatars visible.
       * @attr {number} max-items-visible
       */
      maxItemsVisible: {
        type: Number,
        sync: true
      },
      /** @private */
      _avatars: {
        type: Array,
        value: () => [],
        sync: true
      },
      /** @private */
      __itemsInView: {
        type: Number,
        value: null,
        sync: true
      },
      /** @private */
      _overflow: {
        type: Object,
        sync: true
      },
      /** @private */
      _overflowItems: {
        type: Array,
        observer: "__overflowItemsChanged",
        computed: "__computeOverflowItems(items, __itemsInView, maxItemsVisible)"
      },
      /** @private */
      _overflowTooltip: {
        type: Object,
        sync: true
      },
      /** @private */
      _opened: {
        type: Boolean,
        sync: true
      }
    };
  }
  static get observers() {
    return [
      "__i18nItemsChanged(__effectiveI18n, items)",
      "__openedChanged(_opened, _overflow)",
      "__updateAvatarsTheme(_overflow, _avatars, _theme)",
      "__updateAvatars(items, __itemsInView, maxItemsVisible, _overflow, __effectiveI18n)",
      "__updateOverflowAvatar(_overflow, items, __itemsInView, maxItemsVisible)",
      "__updateOverflowTooltip(_overflowTooltip, items, __itemsInView, maxItemsVisible)"
    ];
  }
  /**
   * The object used to localize this component. To change the default
   * localization, replace this with an object that provides all properties, or
   * just the individual properties you want to change.
   *
   * The object has the following JSON structure and default values:
   * ```
   * {
   *   // Translation of the anonymous user avatar tooltip.
   *   anonymous: 'anonymous',
   *   // Translation of the avatar group accessible label.
   *   // {count} is replaced with the actual count of users.
   *   activeUsers: {
   *     one: 'Currently one active user',
   *     many: 'Currently {count} active users'
   *   },
   *   // Screen reader announcement when user joins group.
   *   // {user} is replaced with the name or abbreviation.
   *   // When neither is set, "anonymous" is used instead.
   *   joined: '{user} joined',
   *   // Screen reader announcement when user leaves group.
   *   // {user} is replaced with the name or abbreviation.
   *   // When neither is set, "anonymous" is used instead.
   *   left: '{user} left'
   * }
   * ```
   * @return {!AvatarGroupI18n}
   */
  get i18n() {
    return super.i18n;
  }
  set i18n(value) {
    super.i18n = value;
  }
  /** @protected */
  ready() {
    super.ready();
    this._overflowController = new SlotController(this, "overflow", "vaadin-avatar", {
      initializer: (overflow) => {
        overflow.setAttribute("role", "button");
        overflow.setAttribute("aria-haspopup", "menu");
        overflow.setAttribute("aria-expanded", "false");
        overflow.addEventListener("click", (e2) => this._onOverflowClick(e2));
        overflow.addEventListener("keydown", (e2) => this._onOverflowKeyDown(e2));
        const tooltip = document.createElement("vaadin-tooltip");
        tooltip.setAttribute("slot", "tooltip");
        overflow.appendChild(tooltip);
        this._overflow = overflow;
        this._overflowTooltip = tooltip;
      }
    });
    this.addController(this._overflowController);
    const overlay2 = this.$.overlay;
    overlay2.renderer = this.__overlayRenderer.bind(this);
    this._overlayElement = overlay2;
    afterNextRender(this, () => {
      this.__setItemsInView();
    });
  }
  /** @protected */
  disconnectedCallback() {
    super.disconnectedCallback();
    this._opened = false;
  }
  /** @private */
  __getMessage(user, action) {
    return action.replace("{user}", user.name || user.abbr || this.__effectiveI18n.anonymous);
  }
  /**
   * Renders items when they are provided by the `items` property and clears the content otherwise.
   * @param {!HTMLElement} root
   * @param {!Select} _select
   * @private
   */
  __overlayRenderer(root2) {
    let menu = root2.firstElementChild;
    if (!menu) {
      menu = document.createElement("vaadin-avatar-group-menu");
      menu.addEventListener("keydown", (event) => this._onListKeyDown(event));
      root2.appendChild(menu);
    }
    menu.textContent = "";
    if (!this._overflowItems) {
      return;
    }
    this._overflowItems.forEach((item2) => {
      menu.appendChild(this.__createItemElement(item2));
    });
  }
  /** @private */
  __createItemElement(item2) {
    const itemElement = document.createElement("vaadin-avatar-group-menu-item");
    const avatar = document.createElement("vaadin-avatar");
    itemElement.appendChild(avatar);
    avatar.setAttribute("aria-hidden", "true");
    avatar.setAttribute("tabindex", "-1");
    avatar.i18n = this.__effectiveI18n;
    if (this._theme) {
      avatar.setAttribute("theme", this._theme);
    }
    avatar.name = item2.name;
    avatar.abbr = item2.abbr;
    avatar.img = item2.img;
    avatar.colorIndex = item2.colorIndex;
    if (item2.className) {
      avatar.className = item2.className;
    }
    if (item2.name) {
      const text = document.createTextNode(item2.name);
      itemElement.appendChild(text);
    }
    return itemElement;
  }
  /** @private */
  _onOverflowClick(e2) {
    e2.stopPropagation();
    if (this._opened) {
      this.$.overlay.close();
    } else if (!e2.defaultPrevented) {
      this._opened = true;
    }
  }
  /** @private */
  _onOverflowKeyDown(e2) {
    if (!this._opened) {
      if (/^(Enter|SpaceBar|\s)$/u.test(e2.key)) {
        e2.preventDefault();
        this._opened = true;
      }
    }
  }
  /** @private */
  _onListKeyDown(event) {
    if (event.key === "Escape" || event.key === "Tab") {
      this._opened = false;
    }
  }
  /**
   * @protected
   * @override
   */
  _onResize() {
    this.__setItemsInView();
  }
  /** @private */
  _onVaadinOverlayClose(e2) {
    if (e2.detail.sourceEvent && e2.detail.sourceEvent.composedPath().includes(this)) {
      e2.preventDefault();
    }
  }
  /** @private */
  _onVaadinOverlayOpen() {
    if (this._menuElement) {
      this._menuElement.focus();
    }
  }
  /** @private */
  __renderAvatars(items) {
    render(
      html$1`
          ${items.map(
        (item2) => html$1`
              <vaadin-avatar
                .name="${item2.name}"
                .abbr="${item2.abbr}"
                .img="${item2.img}"
                .colorIndex="${item2.colorIndex}"
                .i18n="${this.__effectiveI18n}"
                class="${ifDefined(item2.className)}"
                with-tooltip
              ></vaadin-avatar>
            `
      )}
        `,
      this,
      { renderBefore: this._overflow }
    );
  }
  /** @private */
  __updateAvatars(items, itemsInView, maxItemsVisible, overflow) {
    if (!overflow || !Array.isArray(items)) {
      return;
    }
    const limit = this.__getLimit(items.length, itemsInView, maxItemsVisible);
    this.__renderAvatars(limit ? items.slice(0, limit) : items);
    this._avatars = [...this.querySelectorAll("vaadin-avatar")];
  }
  /** @private */
  __computeOverflowItems(items, itemsInView, maxItemsVisible) {
    const count = Array.isArray(items) ? items.length : 0;
    const limit = this.__getLimit(count, itemsInView, maxItemsVisible);
    return limit ? items.slice(limit) : [];
  }
  /** @private */
  __updateOverflowAvatar(overflow, items, itemsInView, maxItemsVisible) {
    if (overflow) {
      const count = Array.isArray(items) ? items.length : 0;
      const maxReached = maxItemsVisible != null && count > this.__getMax(maxItemsVisible);
      overflow.abbr = `+${count - this.__getLimit(count, itemsInView, maxItemsVisible)}`;
      overflow.toggleAttribute("hidden", !maxReached && !(itemsInView && itemsInView < count));
    }
  }
  /** @private */
  __updateAvatarsTheme(overflow, avatars, theme) {
    if (overflow) {
      [overflow, ...avatars].forEach((avatar) => {
        if (theme) {
          avatar.setAttribute("theme", theme);
        } else {
          avatar.removeAttribute("theme");
        }
      });
    }
  }
  /** @private */
  __updateOverflowTooltip(tooltip, items, itemsInView, maxItemsVisible) {
    if (!tooltip || !Array.isArray(items)) {
      return;
    }
    const limit = this.__getLimit(items.length, itemsInView, maxItemsVisible);
    if (limit == null) {
      return;
    }
    const result = [];
    for (let i2 = limit; i2 < items.length; i2++) {
      const item2 = items[i2];
      if (item2) {
        result.push(item2.name || item2.abbr || "anonymous");
      }
    }
    tooltip.text = result.join("\n");
  }
  /** @private */
  __getLimit(items, itemsInView, maxItemsVisible) {
    let limit = null;
    const adjustedMax = this.__getMax(maxItemsVisible);
    if (maxItemsVisible != null && adjustedMax < items) {
      limit = adjustedMax - 1;
    } else if (itemsInView && itemsInView < items) {
      limit = itemsInView;
    }
    return Math.min(limit, this.__calculateAvatarsFitWidth());
  }
  /** @private */
  __getMax(maxItemsVisible) {
    return Math.max(maxItemsVisible, MINIMUM_DISPLAYED_AVATARS);
  }
  /** @private */
  __itemsChanged(items, oldItems) {
    this.__setItemsInView();
    let added = [];
    let removed = [];
    const hasNewItems = Array.isArray(items);
    const hasOldItems = Array.isArray(oldItems);
    if (hasOldItems) {
      removed = oldItems.filter((item2) => hasNewItems && !items.includes(item2));
    }
    if (hasNewItems) {
      added = items.filter((item2) => hasOldItems && !oldItems.includes(item2));
    }
    this.__announceItemsChange(added, removed);
  }
  /** @private */
  __announceItemsChange(added, removed) {
    let addedMsg = [];
    let removedMsg = [];
    if (added) {
      addedMsg = added.map((user) => this.__getMessage(user, this.__effectiveI18n.joined || "{user} joined"));
    }
    if (removed) {
      removedMsg = removed.map((user) => this.__getMessage(user, this.__effectiveI18n.left || "{user} left"));
    }
    const messages = removedMsg.concat(addedMsg);
    if (messages.length > 0) {
      announce(messages.join(", "));
    }
  }
  /** @private */
  __i18nItemsChanged(effectiveI18n, items) {
    if (effectiveI18n && effectiveI18n.activeUsers) {
      const count = Array.isArray(items) ? items.length : 0;
      const field = count === 1 ? "one" : "many";
      if (effectiveI18n.activeUsers[field]) {
        this.setAttribute("aria-label", effectiveI18n.activeUsers[field].replace("{count}", count || 0));
      }
      this._avatars.forEach((avatar) => {
        avatar.i18n = effectiveI18n;
      });
    }
  }
  /** @private */
  __openedChanged(opened, overflow) {
    if (!overflow) {
      return;
    }
    if (opened) {
      if (!this._menuElement) {
        this._menuElement = this.$.overlay.querySelector("vaadin-avatar-group-menu");
      }
      this._openedWithFocusRing = overflow.hasAttribute("focus-ring");
    } else if (this.__oldOpened) {
      overflow.focus();
      if (this._openedWithFocusRing) {
        overflow.setAttribute("focus-ring", "");
      }
    }
    overflow.setAttribute("aria-expanded", opened === true);
    this.__oldOpened = opened;
  }
  /** @private */
  __overflowItemsChanged(items, oldItems) {
    if (items || oldItems) {
      this.$.overlay.requestContentUpdate();
    }
  }
  /** @private */
  __setItemsInView() {
    const avatars = this._avatars;
    const items = this.items;
    if (!items || !avatars || avatars.length < 3) {
      return;
    }
    let result = this.__calculateAvatarsFitWidth();
    if (result === items.length - 1) {
      result = items.length;
    }
    if (result >= items.length && this._opened) {
      this.$.overlay.close();
      this.$.overlay._flushAnimation("closing");
    }
    this.__itemsInView = result;
  }
  /** @private */
  __calculateAvatarsFitWidth() {
    if (!this.shadowRoot || this._avatars.length < MINIMUM_DISPLAYED_AVATARS) {
      return MINIMUM_DISPLAYED_AVATARS;
    }
    const avatars = this._avatars;
    const avatarWidth = avatars[0].clientWidth;
    const { marginLeft, marginRight } = getComputedStyle(avatars[1]);
    const offset = this.__isRTL ? parseInt(marginRight, 0) - parseInt(marginLeft, 0) : parseInt(marginLeft, 0) - parseInt(marginRight, 0);
    return Math.floor((this.$.container.offsetWidth - avatarWidth) / (avatarWidth + offset));
  }
};
/**
 * @license
 * Copyright (c) 2020 - 2025 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const avatarGroupStyles = css`
  :host {
    display: block;
    width: 100%; /* prevent collapsing inside non-stretching column flex */
    --vaadin-avatar-group-overlap: 8px;
    --vaadin-avatar-group-overlap-border: 2px;
  }

  :host([hidden]) {
    display: none !important;
  }

  [part='container'] {
    display: flex;
    position: relative;
    width: 100%;
    flex-wrap: nowrap;
  }

  ::slotted(vaadin-avatar:not(:first-child)) {
    -webkit-mask-image: url('data:image/svg+xml;utf8,<svg viewBox=%220 0 300 300%22 fill=%22none%22 xmlns=%22http://www.w3.org/2000/svg%22><path fill-rule=%22evenodd%22 clip-rule=%22evenodd%22 d=%22M300 0H0V300H300V0ZM150 200C177.614 200 200 177.614 200 150C200 122.386 177.614 100 150 100C122.386 100 100 122.386 100 150C100 177.614 122.386 200 150 200Z%22 fill=%22black%22/></svg>');
    mask-image: url('data:image/svg+xml;utf8,<svg viewBox=%220 0 300 300%22 fill=%22none%22 xmlns=%22http://www.w3.org/2000/svg%22><path fill-rule=%22evenodd%22 clip-rule=%22evenodd%22 d=%22M300 0H0V300H300V0ZM150 200C177.614 200 200 177.614 200 150C200 122.386 177.614 100 150 100C122.386 100 100 122.386 100 150C100 177.614 122.386 200 150 200Z%22 fill=%22black%22/></svg>');
    -webkit-mask-size: calc(
      300% + var(--vaadin-avatar-group-overlap-border) * 6 - var(--vaadin-avatar-outline-width) * 6
    );
    mask-size: calc(300% + var(--vaadin-avatar-group-overlap-border) * 6 - var(--vaadin-avatar-outline-width) * 6);
  }

  ::slotted(vaadin-avatar:not([dir='rtl']):not(:first-child)) {
    margin-left: calc(var(--vaadin-avatar-group-overlap) * -1 - var(--vaadin-avatar-outline-width));
    -webkit-mask-position: calc(50% - var(--vaadin-avatar-size) + var(--vaadin-avatar-group-overlap));
    mask-position: calc(50% - var(--vaadin-avatar-size) + var(--vaadin-avatar-group-overlap));
  }

  ::slotted(vaadin-avatar[dir='rtl']:not(:first-child)) {
    margin-right: calc(var(--vaadin-avatar-group-overlap) * -1);
    -webkit-mask-position: calc(
      50% + var(--vaadin-avatar-size) - var(--vaadin-avatar-group-overlap) + var(--vaadin-avatar-outline-width)
    );
    mask-position: calc(
      50% + var(--vaadin-avatar-size) - var(--vaadin-avatar-group-overlap) + var(--vaadin-avatar-outline-width)
    );
  }
`;
/**
 * @license
 * Copyright (c) 2020 - 2025 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
registerStyles$1("vaadin-avatar-group", avatarGroupStyles, { moduleId: "vaadin-avatar-group-styles" });
class AvatarGroup extends AvatarGroupMixin(ElementMixin(ThemableMixin(ControllerMixin(PolymerElement)))) {
  static get template() {
    return html`
      <div id="container" part="container">
        <slot></slot>
        <slot name="overflow"></slot>
      </div>
      <vaadin-avatar-group-overlay
        id="overlay"
        opened="{{_opened}}"
        position-target="[[_overflow]]"
        no-vertical-overlap
        on-vaadin-overlay-close="_onVaadinOverlayClose"
        on-vaadin-overlay-open="_onVaadinOverlayOpen"
      ></vaadin-avatar-group-overlay>
    `;
  }
  static get is() {
    return "vaadin-avatar-group";
  }
}
defineCustomElement(AvatarGroup);
registerStyles$1(
  "vaadin-checkbox",
  css`
    :host {
      color: var(--vaadin-checkbox-label-color, var(--lumo-body-text-color));
      font-size: var(--vaadin-checkbox-label-font-size, var(--lumo-font-size-m));
      font-family: var(--lumo-font-family);
      line-height: var(--lumo-line-height-s);
      -webkit-font-smoothing: antialiased;
      -moz-osx-font-smoothing: grayscale;
      -webkit-tap-highlight-color: transparent;
      -webkit-user-select: none;
      user-select: none;
      cursor: default;
      outline: none;
      --_checkbox-size: var(--vaadin-checkbox-size, calc(var(--lumo-size-m) / 2));
      --_focus-ring-color: var(--vaadin-focus-ring-color, var(--lumo-primary-color-50pct));
      --_focus-ring-width: var(--vaadin-focus-ring-width, 2px);
      --_selection-color: var(--vaadin-selection-color, var(--lumo-primary-color));
      --_invalid-background: var(--vaadin-input-field-invalid-background, var(--lumo-error-color-10pct));
      --_disabled-checkmark-color: var(--vaadin-checkbox-disabled-checkmark-color, var(--lumo-contrast-30pct));
    }

    [part='label'] {
      display: flex;
      position: relative;
      max-width: max-content;
    }

    :host([has-label]) ::slotted(label) {
      padding: var(
        --vaadin-checkbox-label-padding,
        var(--lumo-space-xs) var(--lumo-space-s) var(--lumo-space-xs) var(--lumo-space-xs)
      );
    }

    :host([dir='rtl'][has-label]) ::slotted(label) {
      padding: var(--lumo-space-xs) var(--lumo-space-xs) var(--lumo-space-xs) var(--lumo-space-s);
    }

    :host([has-label][required]) ::slotted(label) {
      padding-inline-end: var(--lumo-space-m);
    }

    [part='checkbox'] {
      width: var(--_checkbox-size);
      height: var(--_checkbox-size);
      margin: var(--lumo-space-xs);
      position: relative;
      border-radius: var(--vaadin-checkbox-border-radius, var(--lumo-border-radius-s));
      background: var(--vaadin-checkbox-background, var(--lumo-contrast-20pct));
      transition:
        transform 0.2s cubic-bezier(0.12, 0.32, 0.54, 2),
        background-color 0.15s;
      cursor: var(--lumo-clickable-cursor);
      /* Default field border color */
      --_input-border-color: var(--vaadin-input-field-border-color, var(--lumo-contrast-50pct));
    }

    :host([indeterminate]),
    :host([checked]) {
      --vaadin-input-field-border-color: transparent;
    }

    :host([indeterminate]) [part='checkbox'],
    :host([checked]) [part='checkbox'] {
      background-color: var(--_selection-color);
    }

    /* Checkmark */
    [part='checkbox']::after {
      pointer-events: none;
      font-family: 'lumo-icons';
      content: var(--vaadin-checkbox-checkmark-char, var(--lumo-icons-checkmark));
      color: var(--vaadin-checkbox-checkmark-color, var(--lumo-primary-contrast-color));
      font-size: var(--vaadin-checkbox-checkmark-size, calc(var(--_checkbox-size) + 2px));
      line-height: 1;
      position: absolute;
      top: -1px;
      left: -1px;
      contain: content;
      opacity: 0;
    }

    :host([checked]) [part='checkbox']::after {
      opacity: 1;
    }

    :host([readonly]:not([checked]):not([indeterminate])) {
      color: var(--lumo-secondary-text-color);
    }

    :host([readonly]:not([checked]):not([indeterminate])) [part='checkbox'] {
      background: transparent;
      box-shadow: none;
    }

    :host([readonly]:not([checked]):not([indeterminate])) [part='checkbox']::after {
      content: '';
      box-sizing: border-box;
      width: 100%;
      height: 100%;
      border-radius: inherit;
      top: 0;
      left: 0;
      opacity: 1;
      border: var(--vaadin-input-field-readonly-border, 1px dashed var(--lumo-contrast-50pct));
    }

    /* Indeterminate checkmark */
    :host([indeterminate]) [part='checkbox']::after {
      content: var(--vaadin-checkbox-checkmark-char-indeterminate, '');
      opacity: 1;
      top: 45%;
      height: 10%;
      left: 22%;
      right: 22%;
      width: auto;
      border: 0;
      background-color: var(--lumo-primary-contrast-color);
    }

    /* Focus ring */
    :host([focus-ring]) [part='checkbox'] {
      box-shadow:
        0 0 0 1px var(--lumo-base-color),
        0 0 0 calc(var(--_focus-ring-width) + 1px) var(--_focus-ring-color),
        inset 0 0 0 var(--_input-border-width, 0) var(--_input-border-color);
    }

    :host([focus-ring][readonly]:not([checked]):not([indeterminate])) [part='checkbox'] {
      box-shadow:
        0 0 0 1px var(--lumo-base-color),
        0 0 0 calc(var(--_focus-ring-width) + 1px) var(--_focus-ring-color);
    }

    /* Disabled */
    :host([disabled]) {
      pointer-events: none;
      --vaadin-input-field-border-color: var(--lumo-contrast-20pct);
    }

    :host([disabled]) ::slotted(label) {
      color: inherit;
    }

    :host([disabled]) [part='checkbox'] {
      background-color: var(--vaadin-checkbox-disabled-background, var(--lumo-contrast-10pct));
    }

    :host([disabled]) [part='checkbox']::after {
      color: var(--_disabled-checkmark-color);
    }

    :host([disabled]) [part='label'],
    :host([disabled]) [part='helper-text'] {
      color: var(--lumo-disabled-text-color);
      -webkit-text-fill-color: var(--lumo-disabled-text-color);
    }

    :host([indeterminate][disabled]) [part='checkbox']::after {
      background-color: var(--_disabled-checkmark-color);
    }

    :host([readonly][checked]:not([disabled])) [part='checkbox'],
    :host([readonly][indeterminate]:not([disabled])) [part='checkbox'] {
      background-color: var(--vaadin-checkbox-readonly-checked-background, var(--lumo-contrast-70pct));
    }

    /* Used for activation "halo" */
    [part='checkbox']::before {
      pointer-events: none;
      color: transparent;
      width: 100%;
      height: 100%;
      line-height: var(--_checkbox-size);
      border-radius: inherit;
      background-color: inherit;
      transform: scale(1.4);
      opacity: 0;
      transition:
        transform 0.1s,
        opacity 0.8s;
    }

    /* Hover */
    :host(:not([checked]):not([indeterminate]):not([disabled]):not([readonly]):not([invalid]):hover) [part='checkbox'] {
      background: var(--vaadin-checkbox-background-hover, var(--lumo-contrast-30pct));
    }

    /* Disable hover for touch devices */
    @media (pointer: coarse) {
      /* prettier-ignore */
      :host(:not([checked]):not([indeterminate]):not([disabled]):not([readonly]):not([invalid]):hover) [part='checkbox'] {
        background: var(--vaadin-checkbox-background, var(--lumo-contrast-20pct));
      }
    }

    /* Active */
    :host([active]) [part='checkbox'] {
      transform: scale(0.9);
      transition-duration: 0.05s;
    }

    :host([active][checked]) [part='checkbox'] {
      transform: scale(1.1);
    }

    :host([active]:not([checked])) [part='checkbox']::before {
      transition-duration: 0.01s, 0.01s;
      transform: scale(0);
      opacity: 0.4;
    }

    /* Required */
    :host([required]) [part='required-indicator'] {
      position: absolute;
      top: var(--lumo-space-xs);
      right: var(--lumo-space-xs);
    }

    :host([required][dir='rtl']) [part='required-indicator'] {
      right: auto;
      left: var(--lumo-space-xs);
    }

    :host([required]) [part='required-indicator']::after {
      content: var(--lumo-required-field-indicator, '\\2022');
      transition: opacity 0.2s;
      color: var(--lumo-required-field-indicator-color, var(--lumo-primary-text-color));
      width: 1em;
      text-align: center;
    }

    :host(:not([has-label])) [part='required-indicator'] {
      display: none;
    }

    /* Invalid */
    :host([invalid]) {
      --vaadin-input-field-border-color: var(--lumo-error-color);
    }

    :host([invalid]) [part='checkbox'] {
      background: var(--_invalid-background);
      background-image: linear-gradient(var(--_invalid-background) 0%, var(--_invalid-background) 100%);
    }

    :host([invalid]:hover) [part='checkbox'] {
      background-image: linear-gradient(var(--_invalid-background) 0%, var(--_invalid-background) 100%),
        linear-gradient(var(--_invalid-background) 0%, var(--_invalid-background) 100%);
    }

    :host([invalid][focus-ring]) {
      --_focus-ring-color: var(--lumo-error-color-50pct);
    }

    :host([invalid]) [part='required-indicator']::after {
      color: var(--lumo-required-field-indicator-color, var(--lumo-error-text-color));
    }

    /* Error message */
    [part='error-message'] {
      font-size: var(--vaadin-input-field-error-font-size, var(--lumo-font-size-xs));
      line-height: var(--lumo-line-height-xs);
      font-weight: var(--vaadin-input-field-error-font-weight, 400);
      color: var(--vaadin-input-field-error-color, var(--lumo-error-text-color));
      will-change: max-height;
      transition: 0.4s max-height;
      max-height: 5em;
      padding-inline-start: var(--lumo-space-xs);
    }

    :host([has-error-message]) [part='error-message']::after,
    :host([has-helper]) [part='helper-text']::after {
      content: '';
      display: block;
      height: 0.4em;
    }

    :host(:not([invalid])) [part='error-message'] {
      max-height: 0;
      overflow: hidden;
    }

    /* Helper */
    [part='helper-text'] {
      display: block;
      color: var(--vaadin-input-field-helper-color, var(--lumo-secondary-text-color));
      font-size: var(--vaadin-input-field-helper-font-size, var(--lumo-font-size-xs));
      line-height: var(--lumo-line-height-xs);
      font-weight: var(--vaadin-input-field-helper-font-weight, 400);
      margin-left: calc(var(--lumo-border-radius-m) / 4);
      transition: color 0.2s;
      padding-inline-start: var(--lumo-space-xs);
    }

    :host(:hover:not([readonly])) [part='helper-text'] {
      color: var(--lumo-body-text-color);
    }

    :host([has-error-message]) ::slotted(label),
    :host([has-helper]) ::slotted(label) {
      padding-bottom: 0;
    }
  `,
  { moduleId: "lumo-checkbox" }
);
/**
 * @license
 * Copyright (c) 2021 - 2025 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const stylesMap = /* @__PURE__ */ new WeakMap();
function getRootStyles(root2) {
  if (!stylesMap.has(root2)) {
    stylesMap.set(root2, /* @__PURE__ */ new Set());
  }
  return stylesMap.get(root2);
}
function insertStyles(styles2, root2) {
  const style = document.createElement("style");
  style.textContent = styles2;
  if (root2 === document) {
    document.head.appendChild(style);
  } else {
    root2.insertBefore(style, root2.firstChild);
  }
}
const SlotStylesMixin = dedupingMixin(
  (superclass) => class SlotStylesMixinClass extends superclass {
    /**
     * List of styles to insert into root.
     * @protected
     */
    get slotStyles() {
      return [];
    }
    /** @protected */
    connectedCallback() {
      super.connectedCallback();
      this.__applySlotStyles();
    }
    /** @private */
    __applySlotStyles() {
      const root2 = this.getRootNode();
      const rootStyles = getRootStyles(root2);
      this.slotStyles.forEach((styles2) => {
        if (!rootStyles.has(styles2)) {
          insertStyles(styles2, root2);
          rootStyles.add(styles2);
        }
      });
    }
  }
);
/**
 * @license
 * Copyright (c) 2021 - 2025 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const InputMixin = dedupingMixin(
  (superclass) => class InputMixinClass extends superclass {
    static get properties() {
      return {
        /**
         * A reference to the input element controlled by the mixin.
         * Any component implementing this mixin is expected to provide it
         * by using `this._setInputElement(input)` Polymer API.
         *
         * A typical case is using `InputController` that does this automatically.
         * However, the input element does not have to always be native <input>:
         * as an example, <vaadin-combo-box-light> accepts other components.
         *
         * @protected
         * @type {!HTMLElement}
         */
        inputElement: {
          type: Object,
          readOnly: true,
          observer: "_inputElementChanged",
          sync: true
        },
        /**
         * String used to define input type.
         * @protected
         */
        type: {
          type: String,
          readOnly: true
        },
        /**
         * The value of the field.
         */
        value: {
          type: String,
          value: "",
          observer: "_valueChanged",
          notify: true,
          sync: true
        }
      };
    }
    constructor() {
      super();
      this._boundOnInput = this._onInput.bind(this);
      this._boundOnChange = this._onChange.bind(this);
    }
    /**
     * Indicates whether the value is different from the default one.
     * Override if the `value` property has a type other than `string`.
     *
     * @protected
     */
    get _hasValue() {
      return this.value != null && this.value !== "";
    }
    /**
     * A property for accessing the input element's value.
     *
     * Override this getter if the property is different from the default `value` one.
     *
     * @protected
     * @return {string}
     */
    get _inputElementValueProperty() {
      return "value";
    }
    /**
     * The input element's value.
     *
     * @protected
     * @return {string}
     */
    get _inputElementValue() {
      return this.inputElement ? this.inputElement[this._inputElementValueProperty] : void 0;
    }
    /**
     * The input element's value.
     *
     * @protected
     */
    set _inputElementValue(value) {
      if (this.inputElement) {
        this.inputElement[this._inputElementValueProperty] = value;
      }
    }
    /**
     * Clear the value of the field.
     */
    clear() {
      this.value = "";
      this._inputElementValue = "";
    }
    /**
     * Add event listeners to the input element instance.
     * Override this method to add custom listeners.
     * @param {!HTMLElement} input
     * @protected
     */
    _addInputListeners(input) {
      input.addEventListener("input", this._boundOnInput);
      input.addEventListener("change", this._boundOnChange);
    }
    /**
     * Remove event listeners from the input element instance.
     * @param {!HTMLElement} input
     * @protected
     */
    _removeInputListeners(input) {
      input.removeEventListener("input", this._boundOnInput);
      input.removeEventListener("change", this._boundOnChange);
    }
    /**
     * A method to forward the value property set on the field
     * programmatically back to the input element value.
     * Override this method to perform additional checks,
     * for example to skip this in certain conditions.
     * @param {string} value
     * @protected
     */
    _forwardInputValue(value) {
      if (!this.inputElement) {
        return;
      }
      this._inputElementValue = value != null ? value : "";
    }
    /**
     * @param {HTMLElement | undefined} input
     * @param {HTMLElement | undefined} oldInput
     * @protected
     */
    _inputElementChanged(input, oldInput) {
      if (input) {
        this._addInputListeners(input);
      } else if (oldInput) {
        this._removeInputListeners(oldInput);
      }
    }
    /**
     * An input event listener used to update the field value.
     *
     * @param {Event} event
     * @protected
     */
    _onInput(event) {
      const target = event.composedPath()[0];
      this.__userInput = event.isTrusted;
      this.value = target.value;
      this.__userInput = false;
    }
    /**
     * A change event listener.
     * Override this method with an actual implementation.
     * @param {Event} _event
     * @protected
     */
    _onChange(_event) {
    }
    /**
     * Toggle the has-value attribute based on the value property.
     *
     * @param {boolean} hasValue
     * @protected
     */
    _toggleHasValue(hasValue) {
      this.toggleAttribute("has-value", hasValue);
    }
    /**
     * Observer called when a value property changes.
     * @param {string | undefined} newVal
     * @param {string | undefined} oldVal
     * @protected
     */
    _valueChanged(newVal, oldVal) {
      this._toggleHasValue(this._hasValue);
      if (newVal === "" && oldVal === void 0) {
        return;
      }
      if (this.__userInput) {
        return;
      }
      this._forwardInputValue(newVal);
    }
  }
);
/**
 * @license
 * Copyright (c) 2021 - 2025 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const CheckedMixin = dedupingMixin(
  (superclass) => class CheckedMixinClass extends DelegateStateMixin(DisabledMixin(InputMixin(superclass))) {
    static get properties() {
      return {
        /**
         * True if the element is checked.
         * @type {boolean}
         */
        checked: {
          type: Boolean,
          value: false,
          notify: true,
          reflectToAttribute: true,
          sync: true
        }
      };
    }
    static get delegateProps() {
      return [...super.delegateProps, "checked"];
    }
    /**
     * @param {Event} event
     * @protected
     * @override
     */
    _onChange(event) {
      const input = event.target;
      this._toggleChecked(input.checked);
    }
    /** @protected */
    _toggleChecked(checked) {
      this.checked = checked;
    }
  }
);
/**
 * @license
 * Copyright (c) 2023 - 2025 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const attributeToTargets = /* @__PURE__ */ new Map();
function getAttrMap(attr) {
  if (!attributeToTargets.has(attr)) {
    attributeToTargets.set(attr, /* @__PURE__ */ new WeakMap());
  }
  return attributeToTargets.get(attr);
}
function cleanAriaIDReference(target, attr) {
  if (!target) {
    return;
  }
  target.removeAttribute(attr);
}
function storeAriaIDReference(target, attr) {
  if (!target || !attr) {
    return;
  }
  const attributeMap = getAttrMap(attr);
  if (attributeMap.has(target)) {
    return;
  }
  const values = deserializeAttributeValue(target.getAttribute(attr));
  attributeMap.set(target, new Set(values));
}
function restoreGeneratedAriaIDReference(target, attr) {
  if (!target || !attr) {
    return;
  }
  const attributeMap = getAttrMap(attr);
  const values = attributeMap.get(target);
  if (!values || values.size === 0) {
    target.removeAttribute(attr);
  } else {
    addValueToAttribute(target, attr, serializeAttributeValue(values));
  }
  attributeMap.delete(target);
}
function setAriaIDReference(target, attr, config = { newId: null, oldId: null, fromUser: false }) {
  if (!target || !attr) {
    return;
  }
  const { newId, oldId, fromUser } = config;
  const attributeMap = getAttrMap(attr);
  const storedValues = attributeMap.get(target);
  if (!fromUser && !!storedValues) {
    oldId && storedValues.delete(oldId);
    newId && storedValues.add(newId);
    return;
  }
  if (fromUser) {
    if (!storedValues) {
      storeAriaIDReference(target, attr);
    } else if (!newId) {
      attributeMap.delete(target);
    }
    cleanAriaIDReference(target, attr);
  }
  removeValueFromAttribute(target, attr, oldId);
  const attributeValue = !newId ? serializeAttributeValue(storedValues) : newId;
  if (attributeValue) {
    addValueToAttribute(target, attr, attributeValue);
  }
}
function removeAriaIDReference(target, attr) {
  storeAriaIDReference(target, attr);
  cleanAriaIDReference(target, attr);
}
/**
 * @license
 * Copyright (c) 2021 - 2025 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
class FieldAriaController {
  constructor(host) {
    this.host = host;
    this.__required = false;
  }
  /**
   * Sets a target element to which ARIA attributes are added.
   *
   * @param {HTMLElement} target
   */
  setTarget(target) {
    this.__target = target;
    this.__setAriaRequiredAttribute(this.__required);
    this.__setLabelIdToAriaAttribute(this.__labelId, this.__labelId);
    if (this.__labelIdFromUser != null) {
      this.__setLabelIdToAriaAttribute(this.__labelIdFromUser, this.__labelIdFromUser, true);
    }
    this.__setErrorIdToAriaAttribute(this.__errorId);
    this.__setHelperIdToAriaAttribute(this.__helperId);
    this.setAriaLabel(this.__label);
  }
  /**
   * Toggles the `aria-required` attribute on the target element
   * if the target is the host component (e.g. a field group).
   * Otherwise, it does nothing.
   *
   * @param {boolean} required
   */
  setRequired(required) {
    this.__setAriaRequiredAttribute(required);
    this.__required = required;
  }
  /**
   * Defines the `aria-label` attribute of the target element.
   *
   * To remove the attribute, pass `null` as `label`.
   *
   * @param {string | null | undefined} label
   */
  setAriaLabel(label) {
    this.__setAriaLabelToAttribute(label);
    this.__label = label;
  }
  /**
   * Links the target element with a slotted label element
   * via the target's attribute `aria-labelledby`.
   *
   * To unlink the previous slotted label element, pass `null` as `labelId`.
   *
   * @param {string | null} labelId
   */
  setLabelId(labelId, fromUser = false) {
    const oldLabelId = fromUser ? this.__labelIdFromUser : this.__labelId;
    this.__setLabelIdToAriaAttribute(labelId, oldLabelId, fromUser);
    if (fromUser) {
      this.__labelIdFromUser = labelId;
    } else {
      this.__labelId = labelId;
    }
  }
  /**
   * Links the target element with a slotted error element via the target's attribute:
   * - `aria-labelledby` if the target is the host component (e.g a field group).
   * - `aria-describedby` otherwise.
   *
   * To unlink the previous slotted error element, pass `null` as `errorId`.
   *
   * @param {string | null} errorId
   */
  setErrorId(errorId) {
    this.__setErrorIdToAriaAttribute(errorId, this.__errorId);
    this.__errorId = errorId;
  }
  /**
   * Links the target element with a slotted helper element via the target's attribute:
   * - `aria-labelledby` if the target is the host component (e.g a field group).
   * - `aria-describedby` otherwise.
   *
   * To unlink the previous slotted helper element, pass `null` as `helperId`.
   *
   * @param {string | null} helperId
   */
  setHelperId(helperId) {
    this.__setHelperIdToAriaAttribute(helperId, this.__helperId);
    this.__helperId = helperId;
  }
  /**
   * @param {string | null | undefined} label
   * @private
   * */
  __setAriaLabelToAttribute(label) {
    if (!this.__target) {
      return;
    }
    if (label) {
      removeAriaIDReference(this.__target, "aria-labelledby");
      this.__target.setAttribute("aria-label", label);
    } else if (this.__label) {
      restoreGeneratedAriaIDReference(this.__target, "aria-labelledby");
      this.__target.removeAttribute("aria-label");
    }
  }
  /**
   * @param {string | null | undefined} labelId
   * @param {string | null | undefined} oldLabelId
   * @param {boolean | null | undefined} fromUser
   * @private
   */
  __setLabelIdToAriaAttribute(labelId, oldLabelId, fromUser) {
    setAriaIDReference(this.__target, "aria-labelledby", { newId: labelId, oldId: oldLabelId, fromUser });
  }
  /**
   * @param {string | null | undefined} errorId
   * @param {string | null | undefined} oldErrorId
   * @private
   */
  __setErrorIdToAriaAttribute(errorId, oldErrorId) {
    setAriaIDReference(this.__target, "aria-describedby", { newId: errorId, oldId: oldErrorId, fromUser: false });
  }
  /**
   * @param {string | null | undefined} helperId
   * @param {string | null | undefined} oldHelperId
   * @private
   */
  __setHelperIdToAriaAttribute(helperId, oldHelperId) {
    setAriaIDReference(this.__target, "aria-describedby", { newId: helperId, oldId: oldHelperId, fromUser: false });
  }
  /**
   * @param {boolean} required
   * @private
   */
  __setAriaRequiredAttribute(required) {
    if (!this.__target) {
      return;
    }
    if (["input", "textarea"].includes(this.__target.localName)) {
      return;
    }
    if (required) {
      this.__target.setAttribute("aria-required", "true");
    } else {
      this.__target.removeAttribute("aria-required");
    }
  }
}
/**
 * @license
 * Copyright (c) 2021 - 2025 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
class ErrorController extends SlotChildObserveController {
  constructor(host) {
    super(host, "error-message", "div");
  }
  /**
   * Set the error message element text content.
   *
   * @param {string} errorMessage
   */
  setErrorMessage(errorMessage) {
    this.errorMessage = errorMessage;
    this.updateDefaultNode(this.node);
  }
  /**
   * Set invalid state for detecting whether to show error message.
   *
   * @param {boolean} invalid
   */
  setInvalid(invalid) {
    this.invalid = invalid;
    this.updateDefaultNode(this.node);
  }
  /**
   * Override method inherited from `SlotController` to not run
   * initializer on the custom slotted node unnecessarily.
   *
   * @param {Node} node
   * @protected
   * @override
   */
  initAddedNode(node) {
    if (node !== this.defaultNode) {
      this.initCustomNode(node);
    }
  }
  /**
   * Override to initialize the newly added default error message.
   *
   * @param {Node} errorNode
   * @protected
   * @override
   */
  initNode(errorNode) {
    this.updateDefaultNode(errorNode);
  }
  /**
   * Override to initialize the newly added custom error message.
   *
   * @param {Node} errorNode
   * @protected
   * @override
   */
  initCustomNode(errorNode) {
    if (errorNode.textContent && !this.errorMessage) {
      this.errorMessage = errorNode.textContent.trim();
    }
    super.initCustomNode(errorNode);
  }
  /**
   * Override method inherited from `SlotChildObserveController`
   * to restore the default error message element.
   *
   * @protected
   * @override
   */
  restoreDefaultNode() {
    this.attachDefaultNode();
  }
  /**
   * Override method inherited from `SlotChildObserveController`
   * to update the error message text and hidden state.
   *
   * Note: unlike with other controllers, this method is
   * called for both default and custom error message.
   *
   * @param {Node | undefined} node
   * @protected
   * @override
   */
  updateDefaultNode(errorNode) {
    const { errorMessage, invalid } = this;
    const hasError = Boolean(invalid && errorMessage && errorMessage.trim() !== "");
    if (errorNode) {
      errorNode.textContent = hasError ? errorMessage : "";
      errorNode.hidden = !hasError;
      if (hasError) {
        announce(errorMessage, { mode: "assertive" });
      }
    }
    super.updateDefaultNode(errorNode);
  }
}
/**
 * @license
 * Copyright (c) 2021 - 2025 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
class HelperController extends SlotChildObserveController {
  constructor(host) {
    super(host, "helper", null);
  }
  /**
   * Set helper text based on corresponding host property.
   *
   * @param {string} helperText
   */
  setHelperText(helperText) {
    this.helperText = helperText;
    const helperNode = this.getSlotChild();
    if (!helperNode) {
      this.restoreDefaultNode();
    }
    if (this.node === this.defaultNode) {
      this.updateDefaultNode(this.node);
    }
  }
  /**
   * Override method inherited from `SlotChildObserveController`
   * to create the default helper element lazily as needed.
   *
   * @param {Node | undefined} node
   * @protected
   * @override
   */
  restoreDefaultNode() {
    const { helperText } = this;
    if (helperText && helperText.trim() !== "") {
      this.tagName = "div";
      const helperNode = this.attachDefaultNode();
      this.observeNode(helperNode);
    }
  }
  /**
   * Override method inherited from `SlotChildObserveController`
   * to update the default helper element text content.
   *
   * @param {Node | undefined} node
   * @protected
   * @override
   */
  updateDefaultNode(node) {
    if (node) {
      node.textContent = this.helperText;
    }
    super.updateDefaultNode(node);
  }
  /**
   * Override to observe the newly added custom node.
   *
   * @param {Node} node
   * @protected
   * @override
   */
  initCustomNode(node) {
    super.initCustomNode(node);
    this.observeNode(node);
  }
}
/**
 * @license
 * Copyright (c) 2021 - 2025 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
class LabelController extends SlotChildObserveController {
  constructor(host) {
    super(host, "label", "label");
  }
  /**
   * Set label based on corresponding host property.
   *
   * @param {string} label
   */
  setLabel(label) {
    this.label = label;
    const labelNode = this.getSlotChild();
    if (!labelNode) {
      this.restoreDefaultNode();
    }
    if (this.node === this.defaultNode) {
      this.updateDefaultNode(this.node);
    }
  }
  /**
   * Override method inherited from `SlotChildObserveController`
   * to restore and observe the default label element.
   *
   * @protected
   * @override
   */
  restoreDefaultNode() {
    const { label } = this;
    if (label && label.trim() !== "") {
      const labelNode = this.attachDefaultNode();
      this.observeNode(labelNode);
    }
  }
  /**
   * Override method inherited from `SlotChildObserveController`
   * to update the default label element text content.
   *
   * @param {Node | undefined} node
   * @protected
   * @override
   */
  updateDefaultNode(node) {
    if (node) {
      node.textContent = this.label;
    }
    super.updateDefaultNode(node);
  }
  /**
   * Override to observe the newly added custom node.
   *
   * @param {Node} node
   * @protected
   * @override
   */
  initCustomNode(node) {
    super.initCustomNode(node);
    this.observeNode(node);
  }
}
/**
 * @license
 * Copyright (c) 2021 - 2025 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const LabelMixin = dedupingMixin(
  (superclass) => class LabelMixinClass extends ControllerMixin(superclass) {
    static get properties() {
      return {
        /**
         * The label text for the input node.
         * When no light dom defined via [slot=label], this value will be used.
         */
        label: {
          type: String,
          observer: "_labelChanged"
        }
      };
    }
    constructor() {
      super();
      this._labelController = new LabelController(this);
      this._labelController.addEventListener("slot-content-changed", (event) => {
        this.toggleAttribute("has-label", event.detail.hasContent);
      });
    }
    /** @protected */
    get _labelId() {
      const node = this._labelNode;
      return node && node.id;
    }
    /** @protected */
    get _labelNode() {
      return this._labelController.node;
    }
    /** @protected */
    ready() {
      super.ready();
      this.addController(this._labelController);
    }
    /** @protected */
    _labelChanged(label) {
      this._labelController.setLabel(label);
    }
  }
);
/**
 * @license
 * Copyright (c) 2021 - 2025 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const ValidateMixin = dedupingMixin(
  (superclass) => class ValidateMixinClass extends superclass {
    static get properties() {
      return {
        /**
         * Set to true when the field is invalid.
         */
        invalid: {
          type: Boolean,
          reflectToAttribute: true,
          notify: true,
          value: false,
          sync: true
        },
        /**
         * Set to true to enable manual validation mode. This mode disables automatic
         * constraint validation, allowing you to control the validation process yourself.
         * You can still trigger constraint validation manually with the `validate()` method
         * or use `checkValidity()` to assess the component's validity without affecting
         * the invalid state. In manual validation mode, you can also manipulate
         * the `invalid` property directly through your application logic without conflicts
         * with the component's internal validation.
         *
         * @attr {boolean} manual-validation
         */
        manualValidation: {
          type: Boolean,
          value: false
        },
        /**
         * Specifies that the user must fill in a value.
         */
        required: {
          type: Boolean,
          reflectToAttribute: true,
          sync: true
        }
      };
    }
    /**
     * Validates the field and sets the `invalid` property based on the result.
     *
     * The method fires a `validated` event with the result of the validation.
     *
     * @return {boolean} True if the value is valid.
     */
    validate() {
      const isValid2 = this.checkValidity();
      this._setInvalid(!isValid2);
      this.dispatchEvent(new CustomEvent("validated", { detail: { valid: isValid2 } }));
      return isValid2;
    }
    /**
     * Returns true if the field value satisfies all constraints (if any).
     *
     * @return {boolean}
     */
    checkValidity() {
      return !this.required || !!this.value;
    }
    /**
     * @param {boolean} invalid
     * @protected
     */
    _setInvalid(invalid) {
      if (this._shouldSetInvalid(invalid)) {
        this.invalid = invalid;
      }
    }
    /**
     * Override this method to define whether the given `invalid` state should be set.
     *
     * @param {boolean} _invalid
     * @return {boolean}
     * @protected
     */
    _shouldSetInvalid(_invalid) {
      return true;
    }
    /** @protected */
    _requestValidation() {
      if (!this.manualValidation) {
        this.validate();
      }
    }
    /**
     * Fired whenever the field is validated.
     *
     * @event validated
     * @param {Object} detail
     * @param {boolean} detail.valid the result of the validation.
     */
  }
);
/**
 * @license
 * Copyright (c) 2021 - 2025 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const FieldMixin = (superclass) => class FieldMixinClass extends ValidateMixin(LabelMixin(ControllerMixin(superclass))) {
  static get properties() {
    return {
      /**
       * A target element to which ARIA attributes are set.
       * @protected
       */
      ariaTarget: {
        type: Object,
        observer: "_ariaTargetChanged"
      },
      /**
       * Error to show when the field is invalid.
       *
       * @attr {string} error-message
       */
      errorMessage: {
        type: String,
        observer: "_errorMessageChanged"
      },
      /**
       * String used for the helper text.
       * @attr {string} helper-text
       */
      helperText: {
        type: String,
        observer: "_helperTextChanged"
      },
      /**
       * String used to label the component to screen reader users.
       * @attr {string} accessible-name
       */
      accessibleName: {
        type: String,
        observer: "_accessibleNameChanged"
      },
      /**
       * Id of the element used as label of the component to screen reader users.
       * @attr {string} accessible-name-ref
       */
      accessibleNameRef: {
        type: String,
        observer: "_accessibleNameRefChanged"
      }
    };
  }
  static get observers() {
    return ["_invalidChanged(invalid)", "_requiredChanged(required)"];
  }
  constructor() {
    super();
    this._fieldAriaController = new FieldAriaController(this);
    this._helperController = new HelperController(this);
    this._errorController = new ErrorController(this);
    this._errorController.addEventListener("slot-content-changed", (event) => {
      this.toggleAttribute("has-error-message", event.detail.hasContent);
    });
    this._labelController.addEventListener("slot-content-changed", (event) => {
      const { hasContent, node } = event.detail;
      this.__labelChanged(hasContent, node);
    });
    this._helperController.addEventListener("slot-content-changed", (event) => {
      const { hasContent, node } = event.detail;
      this.toggleAttribute("has-helper", hasContent);
      this.__helperChanged(hasContent, node);
    });
  }
  /**
   * @protected
   * @return {HTMLElement}
   */
  get _errorNode() {
    return this._errorController.node;
  }
  /**
   * @protected
   * @return {HTMLElement}
   */
  get _helperNode() {
    return this._helperController.node;
  }
  /** @protected */
  ready() {
    super.ready();
    this.addController(this._fieldAriaController);
    this.addController(this._helperController);
    this.addController(this._errorController);
  }
  /** @private */
  __helperChanged(hasHelper, helperNode) {
    if (hasHelper) {
      this._fieldAriaController.setHelperId(helperNode.id);
    } else {
      this._fieldAriaController.setHelperId(null);
    }
  }
  /** @protected */
  _accessibleNameChanged(accessibleName) {
    this._fieldAriaController.setAriaLabel(accessibleName);
  }
  /** @protected */
  _accessibleNameRefChanged(accessibleNameRef) {
    this._fieldAriaController.setLabelId(accessibleNameRef, true);
  }
  /** @private */
  __labelChanged(hasLabel, labelNode) {
    if (hasLabel) {
      this._fieldAriaController.setLabelId(labelNode.id);
    } else {
      this._fieldAriaController.setLabelId(null);
    }
  }
  /**
   * @param {string | null | undefined} errorMessage
   * @protected
   */
  _errorMessageChanged(errorMessage) {
    this._errorController.setErrorMessage(errorMessage);
  }
  /**
   * @param {string} helperText
   * @protected
   */
  _helperTextChanged(helperText) {
    this._helperController.setHelperText(helperText);
  }
  /**
   * @param {HTMLElement | null | undefined} target
   * @protected
   */
  _ariaTargetChanged(target) {
    if (target) {
      this._fieldAriaController.setTarget(target);
    }
  }
  /**
   * @param {boolean} required
   * @protected
   */
  _requiredChanged(required) {
    this._fieldAriaController.setRequired(required);
  }
  /**
   * @param {boolean} invalid
   * @protected
   */
  _invalidChanged(invalid) {
    this._errorController.setInvalid(invalid);
    setTimeout(() => {
      if (invalid) {
        const node = this._errorNode;
        this._fieldAriaController.setErrorId(node && node.id);
      } else {
        this._fieldAriaController.setErrorId(null);
      }
    });
  }
};
/**
 * @license
 * Copyright (c) 2021 - 2025 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
class InputController extends SlotController {
  constructor(host, callback, options = {}) {
    const { uniqueIdPrefix } = options;
    super(host, "input", "input", {
      initializer: (node, host2) => {
        if (host2.value) {
          node.value = host2.value;
        }
        if (host2.type) {
          node.setAttribute("type", host2.type);
        }
        node.id = this.defaultId;
        if (typeof callback === "function") {
          callback(node);
        }
      },
      useUniqueId: true,
      uniqueIdPrefix
    });
  }
}
/**
 * @license
 * Copyright (c) 2021 - 2025 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
class LabelledInputController {
  constructor(input, labelController) {
    this.input = input;
    this.__preventDuplicateLabelClick = this.__preventDuplicateLabelClick.bind(this);
    labelController.addEventListener("slot-content-changed", (event) => {
      this.__initLabel(event.detail.node);
    });
    this.__initLabel(labelController.node);
  }
  /**
   * @param {HTMLElement} label
   * @private
   */
  __initLabel(label) {
    if (label) {
      label.addEventListener("click", this.__preventDuplicateLabelClick);
      if (this.input) {
        label.setAttribute("for", this.input.id);
      }
    }
  }
  /**
   * The native platform fires an event for both the click on the label, and also
   * the subsequent click on the native input element caused by label click.
   * This results in two click events arriving at the host, but we only want one.
   * This method prevents the duplicate click and ensures the correct isTrusted event
   * with the correct event.target arrives at the host.
   * @private
   */
  __preventDuplicateLabelClick() {
    const inputClickHandler = (e2) => {
      e2.stopImmediatePropagation();
      this.input.removeEventListener("click", inputClickHandler);
    };
    this.input.addEventListener("click", inputClickHandler);
  }
}
/**
 * @license
 * Copyright (c) 2017 - 2025 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const CheckboxMixin = (superclass) => class CheckboxMixinClass extends SlotStylesMixin(
  FieldMixin(CheckedMixin(DelegateFocusMixin(ActiveMixin(superclass))))
) {
  static get properties() {
    return {
      /**
       * True if the checkbox is in the indeterminate state which means
       * it is not possible to say whether it is checked or unchecked.
       * The state is reset once the user switches the checkbox by hand.
       *
       * https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input/checkbox#Indeterminate_state_checkboxes
       *
       * @type {boolean}
       */
      indeterminate: {
        type: Boolean,
        notify: true,
        value: false,
        reflectToAttribute: true
      },
      /**
       * The name of the checkbox.
       *
       * @type {string}
       */
      name: {
        type: String,
        value: ""
      },
      /**
       * When true, the user cannot modify the value of the checkbox.
       * The difference between `disabled` and `readonly` is that the
       * read-only checkbox remains focusable, is announced by screen
       * readers and its value can be submitted as part of the form.
       */
      readonly: {
        type: Boolean,
        value: false,
        reflectToAttribute: true
      }
    };
  }
  static get observers() {
    return ["__readonlyChanged(readonly, inputElement)"];
  }
  /** @override */
  static get delegateProps() {
    return [...super.delegateProps, "indeterminate"];
  }
  /** @override */
  static get delegateAttrs() {
    return [...super.delegateAttrs, "name", "invalid", "required"];
  }
  constructor() {
    super();
    this._setType("checkbox");
    this._boundOnInputClick = this._onInputClick.bind(this);
    this.value = "on";
    this.tabindex = 0;
  }
  /** @protected */
  get slotStyles() {
    const tag = this.localName;
    return [
      `
          ${tag} > input[slot='input'] {
            opacity: 0;
          }
        `
    ];
  }
  /** @protected */
  ready() {
    super.ready();
    this.addController(
      new InputController(this, (input) => {
        this._setInputElement(input);
        this._setFocusElement(input);
        this.stateTarget = input;
        this.ariaTarget = input;
      })
    );
    this.addController(new LabelledInputController(this.inputElement, this._labelController));
    this._createMethodObserver("_checkedChanged(checked)");
  }
  /**
   * Override method inherited from `ActiveMixin` to prevent setting `active`
   * attribute when readonly, or when clicking a link placed inside the label,
   * or when clicking slotted helper or error message element.
   *
   * @param {Event} event
   * @return {boolean}
   * @protected
   * @override
   */
  _shouldSetActive(event) {
    if (this.readonly || event.target.localName === "a" || event.target === this._helperNode || event.target === this._errorNode) {
      return false;
    }
    return super._shouldSetActive(event);
  }
  /**
   * Override method inherited from `InputMixin`.
   * @param {!HTMLElement} input
   * @protected
   * @override
   */
  _addInputListeners(input) {
    super._addInputListeners(input);
    input.addEventListener("click", this._boundOnInputClick);
  }
  /**
   * Override method inherited from `InputMixin`.
   * @param {!HTMLElement} input
   * @protected
   * @override
   */
  _removeInputListeners(input) {
    super._removeInputListeners(input);
    input.removeEventListener("click", this._boundOnInputClick);
  }
  /** @private */
  _onInputClick(event) {
    if (this.readonly) {
      event.preventDefault();
    }
  }
  /** @private */
  __readonlyChanged(readonly, inputElement) {
    if (!inputElement) {
      return;
    }
    if (readonly) {
      inputElement.setAttribute("aria-readonly", "true");
    } else {
      inputElement.removeAttribute("aria-readonly");
    }
  }
  /**
   * Override method inherited from `CheckedMixin` to reset
   * `indeterminate` state checkbox is toggled by the user.
   *
   * @param {boolean} checked
   * @protected
   * @override
   */
  _toggleChecked(checked) {
    if (this.indeterminate) {
      this.indeterminate = false;
    }
    super._toggleChecked(checked);
  }
  /**
   * @override
   * @return {boolean}
   */
  checkValidity() {
    return !this.required || !!this.checked;
  }
  /**
   * Override method inherited from `FocusMixin` to validate on blur.
   * @param {boolean} focused
   * @protected
   */
  _setFocused(focused) {
    super._setFocused(focused);
    if (!focused && document.hasFocus()) {
      this._requestValidation();
    }
  }
  /** @private */
  _checkedChanged(checked) {
    if (checked || this.__oldChecked) {
      this._requestValidation();
    }
    this.__oldChecked = checked;
  }
  /**
   * Override an observer from `FieldMixin`
   * to validate when required is removed.
   *
   * @protected
   * @override
   */
  _requiredChanged(required) {
    super._requiredChanged(required);
    if (required === false) {
      this._requestValidation();
    }
  }
  /** @private */
  _onRequiredIndicatorClick() {
    this._labelNode.click();
  }
  /**
   * Fired when the checkbox is checked or unchecked by the user.
   *
   * @event change
   */
};
/**
 * @license
 * Copyright (c) 2017 - 2025 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const checkboxStyles = css`
  :host {
    display: inline-block;
  }

  :host([hidden]) {
    display: none !important;
  }

  :host([disabled]) {
    -webkit-tap-highlight-color: transparent;
  }

  .vaadin-checkbox-container {
    display: grid;
    grid-template-columns: auto 1fr;
    align-items: baseline;
  }

  [part='checkbox'],
  ::slotted(input),
  [part='label'] {
    grid-row: 1;
  }

  [part='checkbox'],
  ::slotted(input) {
    grid-column: 1;
  }

  [part='helper-text'],
  [part='error-message'] {
    grid-column: 2;
  }

  :host(:not([has-helper])) [part='helper-text'],
  :host(:not([has-error-message])) [part='error-message'] {
    display: none;
  }

  [part='checkbox'] {
    width: var(--vaadin-checkbox-size, 1em);
    height: var(--vaadin-checkbox-size, 1em);
    --_input-border-width: var(--vaadin-input-field-border-width, 0);
    --_input-border-color: var(--vaadin-input-field-border-color, transparent);
    box-shadow: inset 0 0 0 var(--_input-border-width, 0) var(--_input-border-color);
  }

  [part='checkbox']::before {
    display: block;
    content: '\\202F';
    line-height: var(--vaadin-checkbox-size, 1em);
    contain: paint;
  }

  /* visually hidden */
  ::slotted(input) {
    cursor: inherit;
    margin: 0;
    align-self: stretch;
    -webkit-appearance: none;
    width: initial;
    height: initial;
  }

  @media (forced-colors: active) {
    [part='checkbox'] {
      outline: 1px solid;
      outline-offset: -1px;
    }

    :host([disabled]) [part='checkbox'],
    :host([disabled]) [part='checkbox']::after {
      outline-color: GrayText;
    }

    :host(:is([checked], [indeterminate])) [part='checkbox']::after {
      outline: 1px solid;
      outline-offset: -1px;
      border-radius: inherit;
    }

    :host([focused]) [part='checkbox'],
    :host([focused]) [part='checkbox']::after {
      outline-width: 2px;
    }
  }
`;
/**
 * @license
 * Copyright (c) 2017 - 2025 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
registerStyles$1("vaadin-checkbox", checkboxStyles, { moduleId: "vaadin-checkbox-styles" });
class Checkbox extends CheckboxMixin(ElementMixin(ThemableMixin(PolymerElement))) {
  static get is() {
    return "vaadin-checkbox";
  }
  static get template() {
    return html`
      <div class="vaadin-checkbox-container">
        <div part="checkbox" aria-hidden="true"></div>
        <slot name="input"></slot>
        <div part="label">
          <slot name="label"></slot>
          <div part="required-indicator" on-click="_onRequiredIndicatorClick"></div>
        </div>
        <div part="helper-text">
          <slot name="helper"></slot>
        </div>
        <div part="error-message">
          <slot name="error-message"></slot>
        </div>
      </div>
      <slot name="tooltip"></slot>
    `;
  }
  /** @protected */
  ready() {
    super.ready();
    this._tooltipController = new TooltipController(this);
    this._tooltipController.setAriaTarget(this.inputElement);
    this.addController(this._tooltipController);
  }
}
defineCustomElement(Checkbox);
/**
 * @license
 * Copyright (c) 2017 - 2025 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const helper = css`
  :host {
    --_helper-spacing: var(--vaadin-input-field-helper-spacing, 0.4em);
  }

  :host([has-helper]) [part='helper-text']::before {
    content: '';
    display: block;
    height: var(--_helper-spacing);
  }

  [part='helper-text'] {
    display: block;
    color: var(--vaadin-input-field-helper-color, var(--lumo-secondary-text-color));
    font-size: var(--vaadin-input-field-helper-font-size, var(--lumo-font-size-xs));
    line-height: var(--lumo-line-height-xs);
    font-weight: var(--vaadin-input-field-helper-font-weight, 400);
    margin-left: calc(var(--lumo-border-radius-m) / 4);
    transition: color 0.2s;
  }

  :host(:hover:not([readonly])) [part='helper-text'] {
    color: var(--lumo-body-text-color);
  }

  :host([disabled]) [part='helper-text'] {
    color: var(--lumo-disabled-text-color);
    -webkit-text-fill-color: var(--lumo-disabled-text-color);
  }

  :host([has-helper][theme~='helper-above-field']) [part='helper-text']::before {
    display: none;
  }

  :host([has-helper][theme~='helper-above-field']) [part='helper-text']::after {
    content: '';
    display: block;
    height: var(--_helper-spacing);
  }

  :host([has-helper][theme~='helper-above-field']) [part='label'] {
    order: 0;
    padding-bottom: var(--_helper-spacing);
  }

  :host([has-helper][theme~='helper-above-field']) [part='helper-text'] {
    order: 1;
  }

  :host([has-helper][theme~='helper-above-field']) [part='label'] + * {
    order: 2;
  }

  :host([has-helper][theme~='helper-above-field']) [part='error-message'] {
    order: 3;
  }
`;
/**
 * @license
 * Copyright (c) 2017 - 2025 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const requiredField = css`
  [part='label'] {
    align-self: flex-start;
    color: var(--vaadin-input-field-label-color, var(--lumo-secondary-text-color));
    font-weight: var(--vaadin-input-field-label-font-weight, 500);
    font-size: var(--vaadin-input-field-label-font-size, var(--lumo-font-size-s));
    margin-left: calc(var(--lumo-border-radius-m) / 4);
    transition: color 0.2s;
    line-height: 1;
    padding-right: 1em;
    padding-bottom: 0.5em;
    /* As a workaround for diacritics being cut off, add a top padding and a
    negative margin to compensate */
    padding-top: 0.25em;
    margin-top: -0.25em;
    overflow: hidden;
    white-space: nowrap;
    text-overflow: ellipsis;
    position: relative;
    max-width: 100%;
    box-sizing: border-box;
  }

  :host([focused]:not([readonly])) [part='label'] {
    color: var(--vaadin-input-field-focused-label-color, var(--lumo-primary-text-color));
  }

  :host(:hover:not([readonly]):not([focused])) [part='label'] {
    color: var(--vaadin-input-field-hovered-label-color, var(--lumo-body-text-color));
  }

  /* Touch device adjustment */
  @media (pointer: coarse) {
    :host(:hover:not([readonly]):not([focused])) [part='label'] {
      color: var(--vaadin-input-field-label-color, var(--lumo-secondary-text-color));
    }
  }

  :host([has-label])::before {
    margin-top: calc(var(--lumo-font-size-s) * 1.5);
  }

  :host([has-label][theme~='small'])::before {
    margin-top: calc(var(--lumo-font-size-xs) * 1.5);
  }

  :host([has-label]) {
    padding-top: var(--lumo-space-m);
  }

  :host([has-label]) ::slotted([slot='tooltip']) {
    --vaadin-tooltip-offset-bottom: calc((var(--lumo-space-m) - var(--lumo-space-xs)) * -1);
  }

  :host([required]) [part='required-indicator']::after {
    content: var(--lumo-required-field-indicator, '\\2022');
    transition: opacity 0.2s;
    color: var(--lumo-required-field-indicator-color, var(--lumo-primary-text-color));
    position: absolute;
    right: 0;
    width: 1em;
    text-align: center;
  }

  :host([invalid]) [part='required-indicator']::after {
    color: var(--lumo-required-field-indicator-color, var(--lumo-error-text-color));
  }

  [part='error-message'] {
    margin-left: calc(var(--lumo-border-radius-m) / 4);
    font-size: var(--vaadin-input-field-error-font-size, var(--lumo-font-size-xs));
    line-height: var(--lumo-line-height-xs);
    font-weight: var(--vaadin-input-field-error-font-weight, 400);
    color: var(--vaadin-input-field-error-color, var(--lumo-error-text-color));
    will-change: max-height;
    transition: 0.4s max-height;
    max-height: 5em;
  }

  :host([has-error-message]) [part='error-message']::before,
  :host([has-error-message]) [part='error-message']::after {
    content: '';
    display: block;
    height: 0.4em;
  }

  :host(:not([invalid])) [part='error-message'] {
    max-height: 0;
    overflow: hidden;
  }

  /* RTL specific styles */

  :host([dir='rtl']) [part='label'] {
    margin-left: 0;
    margin-right: calc(var(--lumo-border-radius-m) / 4);
  }

  :host([dir='rtl']) [part='label'] {
    padding-left: 1em;
    padding-right: 0;
  }

  :host([dir='rtl']) [part='required-indicator']::after {
    right: auto;
    left: 0;
  }

  :host([dir='rtl']) [part='error-message'] {
    margin-left: 0;
    margin-right: calc(var(--lumo-border-radius-m) / 4);
  }
`;
registerStyles$1("", requiredField, { moduleId: "lumo-required-field" });
const checkboxGroup = css`
  :host {
    color: var(--lumo-body-text-color);
    font-size: var(--lumo-font-size-m);
    font-family: var(--lumo-font-family);
    -webkit-font-smoothing: antialiased;
    -moz-osx-font-smoothing: grayscale;
    -webkit-tap-highlight-color: transparent;
    padding: var(--lumo-space-xs) 0;
  }

  :host::before {
    /* Effective height of vaadin-checkbox */
    height: var(--lumo-size-s);
    box-sizing: border-box;
    display: inline-flex;
    align-items: center;
  }

  :host([theme~='vertical']) [part='group-field'] {
    flex-direction: column;
  }

  :host([disabled]) [part='label'] {
    color: var(--lumo-disabled-text-color);
    -webkit-text-fill-color: var(--lumo-disabled-text-color);
  }

  :host([focused]:not([readonly])) [part='label'] {
    color: var(--lumo-primary-text-color);
  }

  :host(:hover:not([readonly]):not([disabled]):not([focused])) [part='label'],
  :host(:hover:not([readonly]):not([disabled]):not([focused])) [part='helper-text'] {
    color: var(--lumo-body-text-color);
  }

  /* Touch device adjustment */
  @media (pointer: coarse) {
    :host(:hover:not([readonly]):not([disabled]):not([focused])) [part='label'] {
      color: var(--lumo-secondary-text-color);
    }
  }
`;
registerStyles$1("vaadin-checkbox-group", [requiredField, helper, checkboxGroup], {
  moduleId: "lumo-checkbox-group"
});
/**
 * @license
 * Copyright (c) 2018 - 2025 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const CheckboxGroupMixin = (superclass) => class CheckboxGroupMixinClass extends FieldMixin(FocusMixin(DisabledMixin(superclass))) {
  static get properties() {
    return {
      /**
       * An array containing values of the currently checked checkboxes.
       *
       * The array is immutable so toggling checkboxes always results in
       * creating a new array.
       *
       * @type {!Array<!string>}
       */
      value: {
        type: Array,
        value: () => [],
        notify: true,
        sync: true,
        observer: "__valueChanged"
      },
      /**
       * When true, the user cannot modify the value of the checkbox group.
       * The difference between `disabled` and `readonly` is that in the
       * read-only checkbox group, all the checkboxes are also read-only,
       * and therefore remain focusable and announced by screen readers.
       */
      readonly: {
        type: Boolean,
        value: false,
        reflectToAttribute: true,
        observer: "__readonlyChanged"
      }
    };
  }
  constructor() {
    super();
    this.__registerCheckbox = this.__registerCheckbox.bind(this);
    this.__unregisterCheckbox = this.__unregisterCheckbox.bind(this);
    this.__onCheckboxCheckedChanged = this.__onCheckboxCheckedChanged.bind(this);
    this._tooltipController = new TooltipController(this);
    this._tooltipController.addEventListener("tooltip-changed", (event) => {
      const tooltip = event.detail.node;
      if (tooltip && tooltip.isConnected) {
        const inputs = this.__checkboxes.map((checkbox) => checkbox.inputElement);
        this._tooltipController.setAriaTarget(inputs);
      } else {
        this._tooltipController.setAriaTarget([]);
      }
    });
  }
  /**
   * A collection of the checkboxes.
   *
   * @return {!Array<!Checkbox>}
   * @private
   */
  get __checkboxes() {
    return this.__filterCheckboxes([...this.children]);
  }
  /** @protected */
  ready() {
    super.ready();
    this.ariaTarget = this;
    this.setAttribute("role", "group");
    const slot = this.shadowRoot.querySelector("slot:not([name])");
    this._observer = new SlotObserver(slot, ({ addedNodes, removedNodes }) => {
      const addedCheckboxes = this.__filterCheckboxes(addedNodes);
      const removedCheckboxes = this.__filterCheckboxes(removedNodes);
      addedCheckboxes.forEach(this.__registerCheckbox);
      removedCheckboxes.forEach(this.__unregisterCheckbox);
      const inputs = this.__checkboxes.map((checkbox) => checkbox.inputElement);
      this._tooltipController.setAriaTarget(inputs);
      this.__warnOfCheckboxesWithoutValue(addedCheckboxes);
    });
    this.addController(this._tooltipController);
  }
  /**
   * Override method inherited from `ValidateMixin`
   * to validate the value array.
   *
   * @override
   * @return {boolean}
   */
  checkValidity() {
    return !this.required || Boolean(this.value && this.value.length > 0);
  }
  /**
   * @param {!Array<!Node>} nodes
   * @return {!Array<!Checkbox>}
   * @private
   */
  __filterCheckboxes(nodes) {
    return nodes.filter((node) => node.nodeType === Node.ELEMENT_NODE && node.localName === "vaadin-checkbox");
  }
  /**
   * @param {!Array<!Checkbox>} checkboxes
   * @private
   */
  __warnOfCheckboxesWithoutValue(checkboxes) {
    const hasCheckboxesWithoutValue = checkboxes.some((checkbox) => {
      const { value } = checkbox;
      return !checkbox.hasAttribute("value") && (!value || value === "on");
    });
    if (hasCheckboxesWithoutValue) {
      console.warn("Please provide the value attribute to all the checkboxes inside the checkbox group.");
    }
  }
  /**
   * Registers the checkbox after adding it to the group.
   *
   * @param {!Checkbox} checkbox
   * @private
   */
  __registerCheckbox(checkbox) {
    checkbox.addEventListener("checked-changed", this.__onCheckboxCheckedChanged);
    if (this.disabled) {
      checkbox.disabled = true;
    }
    if (this.readonly) {
      checkbox.readonly = true;
    }
    if (checkbox.checked) {
      this.__addCheckboxToValue(checkbox.value);
    } else if (this.value && this.value.includes(checkbox.value)) {
      checkbox.checked = true;
    }
  }
  /**
   * Unregisters the checkbox before removing it from the group.
   *
   * @param {!Checkbox} checkbox
   * @private
   */
  __unregisterCheckbox(checkbox) {
    checkbox.removeEventListener("checked-changed", this.__onCheckboxCheckedChanged);
    if (checkbox.checked) {
      this.__removeCheckboxFromValue(checkbox.value);
    }
  }
  /**
   * Override method inherited from `DisabledMixin`
   * to propagate the `disabled` property to the checkboxes.
   *
   * @param {boolean} newValue
   * @param {boolean} oldValue
   * @override
   * @protected
   */
  _disabledChanged(newValue, oldValue) {
    super._disabledChanged(newValue, oldValue);
    if (!newValue && oldValue === void 0) {
      return;
    }
    if (oldValue !== newValue) {
      this.__checkboxes.forEach((checkbox) => {
        checkbox.disabled = newValue;
      });
    }
  }
  /**
   * @param {string} value
   * @private
   */
  __addCheckboxToValue(value) {
    if (!this.value) {
      this.value = [value];
    } else if (!this.value.includes(value)) {
      this.value = [...this.value, value];
    }
  }
  /**
   * @param {string} value
   * @private
   */
  __removeCheckboxFromValue(value) {
    if (this.value && this.value.includes(value)) {
      this.value = this.value.filter((v) => v !== value);
    }
  }
  /**
   * @param {!CustomEvent} event
   * @private
   */
  __onCheckboxCheckedChanged(event) {
    const checkbox = event.target;
    if (checkbox.checked) {
      this.__addCheckboxToValue(checkbox.value);
    } else {
      this.__removeCheckboxFromValue(checkbox.value);
    }
  }
  /**
   * @param {string[] | null | undefined} value
   * @param {string[] | null | undefined} oldValue
   * @private
   */
  __valueChanged(value, oldValue) {
    if (value && value.length === 0 && oldValue === void 0) {
      return;
    }
    this.toggleAttribute("has-value", value && value.length > 0);
    this.__checkboxes.forEach((checkbox) => {
      checkbox.checked = value && value.includes(checkbox.value);
    });
    if (oldValue !== void 0) {
      this._requestValidation();
    }
  }
  /** @private */
  __readonlyChanged(readonly, oldReadonly) {
    if (readonly || oldReadonly) {
      this.__checkboxes.forEach((checkbox) => {
        checkbox.readonly = readonly;
      });
    }
  }
  /**
   * Override method inherited from `FocusMixin`
   * to prevent removing the `focused` attribute
   * when focus moves between checkboxes inside the group.
   *
   * @param {!FocusEvent} event
   * @return {boolean}
   * @protected
   */
  _shouldRemoveFocus(event) {
    return !this.contains(event.relatedTarget);
  }
  /**
   * Override method inherited from `FocusMixin`
   * to run validation when the group loses focus.
   *
   * @param {boolean} focused
   * @override
   * @protected
   */
  _setFocused(focused) {
    super._setFocused(focused);
    if (!focused && document.hasFocus()) {
      this._requestValidation();
    }
  }
};
/**
 * @license
 * Copyright (c) 2018 - 2025 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const checkboxGroupStyles = css`
  :host {
    display: inline-flex;
  }

  :host::before {
    content: '\\2003';
    width: 0;
    display: inline-block;
  }

  :host([hidden]) {
    display: none !important;
  }

  .vaadin-group-field-container {
    display: flex;
    flex-direction: column;
    width: 100%;
  }

  [part='group-field'] {
    display: flex;
    flex-wrap: wrap;
  }

  :host(:not([has-label])) [part='label'] {
    display: none;
  }
`;
/**
 * @license
 * Copyright (c) 2018 - 2025 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
registerStyles$1("vaadin-checkbox-group", checkboxGroupStyles, { moduleId: "vaadin-checkbox-group-styles" });
class CheckboxGroup extends CheckboxGroupMixin(ElementMixin(ThemableMixin(PolymerElement))) {
  static get is() {
    return "vaadin-checkbox-group";
  }
  static get template() {
    return html`
      <div class="vaadin-group-field-container">
        <div part="label">
          <slot name="label"></slot>
          <span part="required-indicator" aria-hidden="true"></span>
        </div>

        <div part="group-field">
          <slot></slot>
        </div>

        <div part="helper-text">
          <slot name="helper"></slot>
        </div>

        <div part="error-message">
          <slot name="error-message"></slot>
        </div>
      </div>

      <slot name="tooltip"></slot>
    `;
  }
}
defineCustomElement(CheckboxGroup);
const comboBoxItem = css`
  :host {
    transition: background-color 100ms;
    overflow: hidden;
    --_lumo-item-selected-icon-display: block;
    --_focus-ring-color: var(--vaadin-focus-ring-color, var(--lumo-primary-color-50pct));
    --_focus-ring-width: var(--vaadin-focus-ring-width, 2px);
  }

  :host([focused]:not([disabled])) {
    box-shadow: inset 0 0 0 var(--_focus-ring-width) var(--_focus-ring-color);
  }
`;
registerStyles$1("vaadin-combo-box-item", [item, comboBoxItem], {
  moduleId: "lumo-combo-box-item"
});
/**
 * @license
 * Copyright (c) 2022 - 2025 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const loader = css`
  [part~='loader'] {
    box-sizing: border-box;
    width: var(--lumo-icon-size-s);
    height: var(--lumo-icon-size-s);
    border: 2px solid transparent;
    border-color: var(--lumo-primary-color-10pct) var(--lumo-primary-color-10pct) var(--lumo-primary-color)
      var(--lumo-primary-color);
    border-radius: calc(0.5 * var(--lumo-icon-size-s));
    opacity: 0;
    pointer-events: none;
  }

  :host(:not([loading])) [part~='loader'] {
    display: none;
  }

  :host([loading]) [part~='loader'] {
    animation:
      1s linear infinite lumo-loader-rotate,
      0.3s 0.1s lumo-loader-fade-in both;
  }

  @keyframes lumo-loader-fade-in {
    0% {
      opacity: 0;
    }

    100% {
      opacity: 1;
    }
  }

  @keyframes lumo-loader-rotate {
    0% {
      transform: rotate(0deg);
    }

    100% {
      transform: rotate(360deg);
    }
  }
`;
const comboBoxOverlay = css`
  [part='content'] {
    padding: 0;
  }

  /* When items are empty, the spinner needs some room */
  :host(:not([closing])) [part~='content'] {
    min-height: calc(2 * var(--lumo-space-s) + var(--lumo-icon-size-s));
  }

  [part~='overlay'] {
    position: relative;
  }

  :host([top-aligned]) [part~='overlay'] {
    margin-top: var(--lumo-space-xs);
  }

  :host([bottom-aligned]) [part~='overlay'] {
    margin-bottom: var(--lumo-space-xs);
  }
`;
const comboBoxLoader = css`
  [part~='loader'] {
    position: absolute;
    z-index: 1;
    inset-inline: var(--lumo-space-s);
    top: var(--lumo-space-s);
    margin-inline: auto 0;
  }
`;
registerStyles$1(
  "vaadin-combo-box-overlay",
  [
    overlay,
    menuOverlayCore,
    comboBoxOverlay,
    loader,
    comboBoxLoader,
    css`
      :host {
        --_vaadin-combo-box-items-container-border-width: var(--lumo-space-xs);
        --_vaadin-combo-box-items-container-border-style: solid;
      }
    `
  ],
  { moduleId: "lumo-combo-box-overlay" }
);
registerStyles$1(
  "vaadin-input-container",
  css`
    :host {
      background: var(--_background);
      padding: 0 calc(0.375em + var(--_input-container-radius) / 4 - 1px);
      font-weight: var(--vaadin-input-field-value-font-weight, 500);
      line-height: 1;
      position: relative;
      cursor: text;
      box-sizing: border-box;
      border-radius:
        /* See https://developer.mozilla.org/en-US/docs/Web/CSS/border-radius#syntax */
        var(--vaadin-input-field-top-start-radius, var(--_input-container-radius))
        var(--vaadin-input-field-top-end-radius, var(--_input-container-radius))
        var(--vaadin-input-field-bottom-end-radius, var(--_input-container-radius))
        var(--vaadin-input-field-bottom-start-radius, var(--_input-container-radius));
      /* Fallback */
      --_input-container-radius: var(--vaadin-input-field-border-radius, var(--lumo-border-radius-m));
      --_input-height: var(--lumo-text-field-size, var(--lumo-size-m));
      /* Default values */
      --_background: var(--vaadin-input-field-background, var(--lumo-contrast-10pct));
      --_hover-highlight: var(--vaadin-input-field-hover-highlight, var(--lumo-contrast-50pct));
      --_input-border-color: var(--vaadin-input-field-border-color, var(--lumo-contrast-50pct));
      --_icon-color: var(--vaadin-input-field-icon-color, var(--lumo-contrast-60pct));
      --_icon-size: var(--vaadin-input-field-icon-size, var(--lumo-icon-size-m));
      --_invalid-background: var(--vaadin-input-field-invalid-background, var(--lumo-error-color-10pct));
      --_invalid-hover-highlight: var(--vaadin-input-field-invalid-hover-highlight, var(--lumo-error-color-50pct));
      --_disabled-background: var(--vaadin-input-field-disabled-background, var(--lumo-contrast-5pct));
      --_disabled-value-color: var(--vaadin-input-field-disabled-value-color, var(--lumo-disabled-text-color));
    }

    :host([dir='rtl']) {
      border-radius:
        /* Don't use logical props, see https://github.com/vaadin/vaadin-time-picker/issues/145 */
        var(--vaadin-input-field-top-end-radius, var(--_input-container-radius))
        var(--vaadin-input-field-top-start-radius, var(--_input-container-radius))
        var(--vaadin-input-field-bottom-start-radius, var(--_input-container-radius))
        var(--vaadin-input-field-bottom-end-radius, var(--_input-container-radius));
    }

    /* Used for hover and activation effects */
    :host::after {
      content: '';
      position: absolute;
      inset: 0;
      border-radius: inherit;
      pointer-events: none;
      background: var(--_hover-highlight);
      opacity: 0;
      transition:
        transform 0.15s,
        opacity 0.2s;
      transform-origin: 100% 0;
    }

    ::slotted(:not([slot$='fix'])) {
      cursor: inherit;
      min-height: var(--vaadin-input-field-height, var(--_input-height));
      padding: 0 0.25em;
      --_lumo-text-field-overflow-mask-image: linear-gradient(to left, transparent, #000 1.25em);
      -webkit-mask-image: var(--_lumo-text-field-overflow-mask-image);
      mask-image: var(--_lumo-text-field-overflow-mask-image);
    }

    /* Read-only */
    :host([readonly]) {
      color: var(--lumo-secondary-text-color);
      background-color: transparent;
      cursor: default;
    }

    :host([readonly])::after {
      background-color: transparent;
      opacity: 1;
      border: var(--vaadin-input-field-readonly-border, 1px dashed var(--lumo-contrast-30pct));
    }

    /* Disabled */
    :host([disabled]) {
      background: var(--_disabled-background);
    }

    :host([disabled]) ::slotted(:not([slot$='fix'])) {
      -webkit-text-fill-color: var(--_disabled-value-color);
      color: var(--_disabled-value-color);
    }

    /* Invalid */
    :host([invalid]) {
      background: var(--_invalid-background);
    }

    :host([invalid]:not([readonly]))::after {
      background: var(--_invalid-hover-highlight);
    }

    /* Slotted icons */
    ::slotted(vaadin-icon) {
      color: var(--_icon-color);
      width: var(--_icon-size);
      height: var(--_icon-size);
    }

    /* Vaadin icons are based on a 16x16 grid (unlike Lumo and Material icons with 24x24), so they look too big by default */
    ::slotted(vaadin-icon[icon^='vaadin:']) {
      padding: 0.25em;
      box-sizing: border-box !important;
    }

    /* Text align */
    :host([dir='rtl']) ::slotted(:not([slot$='fix'])) {
      --_lumo-text-field-overflow-mask-image: linear-gradient(to right, transparent, #000 1.25em);
    }

    @-moz-document url-prefix() {
      :host([dir='rtl']) ::slotted(:not([slot$='fix'])) {
        mask-image: var(--_lumo-text-field-overflow-mask-image);
      }
    }

    :host([theme~='align-left']) ::slotted(:not([slot$='fix'])) {
      text-align: start;
      --_lumo-text-field-overflow-mask-image: none;
    }

    :host([theme~='align-center']) ::slotted(:not([slot$='fix'])) {
      text-align: center;
      --_lumo-text-field-overflow-mask-image: none;
    }

    :host([theme~='align-right']) ::slotted(:not([slot$='fix'])) {
      text-align: end;
      --_lumo-text-field-overflow-mask-image: none;
    }

    @-moz-document url-prefix() {
      /* Firefox is smart enough to align overflowing text to right */
      :host([theme~='align-right']) ::slotted(:not([slot$='fix'])) {
        --_lumo-text-field-overflow-mask-image: linear-gradient(to right, transparent 0.25em, #000 1.5em);
      }
    }

    @-moz-document url-prefix() {
      /* Firefox is smart enough to align overflowing text to right */
      :host([theme~='align-left']) ::slotted(:not([slot$='fix'])) {
        --_lumo-text-field-overflow-mask-image: linear-gradient(to left, transparent 0.25em, #000 1.5em);
      }
    }

    /* RTL specific styles */
    :host([dir='rtl'])::after {
      transform-origin: 0% 0;
    }

    :host([theme~='align-left'][dir='rtl']) ::slotted(:not([slot$='fix'])) {
      --_lumo-text-field-overflow-mask-image: none;
    }

    :host([theme~='align-center'][dir='rtl']) ::slotted(:not([slot$='fix'])) {
      --_lumo-text-field-overflow-mask-image: none;
    }

    :host([theme~='align-right'][dir='rtl']) ::slotted(:not([slot$='fix'])) {
      --_lumo-text-field-overflow-mask-image: none;
    }

    @-moz-document url-prefix() {
      /* Firefox is smart enough to align overflowing text to right */
      :host([theme~='align-right'][dir='rtl']) ::slotted(:not([slot$='fix'])) {
        --_lumo-text-field-overflow-mask-image: linear-gradient(to right, transparent 0.25em, #000 1.5em);
      }
    }

    @-moz-document url-prefix() {
      /* Firefox is smart enough to align overflowing text to right */
      :host([theme~='align-left'][dir='rtl']) ::slotted(:not([slot$='fix'])) {
        --_lumo-text-field-overflow-mask-image: linear-gradient(to left, transparent 0.25em, #000 1.5em);
      }
    }
  `,
  { moduleId: "lumo-input-container" }
);
/**
 * @license
 * Copyright (c) 2017 - 2025 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const fieldButton = css`
  [part$='button'] {
    flex: none;
    width: 1em;
    height: 1em;
    line-height: 1;
    font-size: var(--lumo-icon-size-m);
    text-align: center;
    color: var(--lumo-contrast-60pct);
    transition: 0.2s color;
    cursor: var(--lumo-clickable-cursor);
  }

  [part$='button']:hover {
    color: var(--lumo-contrast-90pct);
  }

  :host([disabled]) [part$='button'],
  :host([readonly]) [part$='button'] {
    color: var(--lumo-contrast-20pct);
    cursor: default;
  }

  [part$='button']::before {
    font-family: 'lumo-icons';
    display: block;
  }
`;
registerStyles$1("", fieldButton, { moduleId: "lumo-field-button" });
/**
 * @license
 * Copyright (c) 2017 - 2025 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const inputField = css`
  :host {
    --lumo-text-field-size: var(--lumo-size-m);
    color: var(--vaadin-input-field-value-color, var(--lumo-body-text-color));
    font-size: var(--vaadin-input-field-value-font-size, var(--lumo-font-size-m));
    font-family: var(--lumo-font-family);
    -webkit-font-smoothing: antialiased;
    -moz-osx-font-smoothing: grayscale;
    -webkit-tap-highlight-color: transparent;
    padding: var(--lumo-space-xs) 0;
    --_focus-ring-color: var(--vaadin-focus-ring-color, var(--lumo-primary-color-50pct));
    --_focus-ring-width: var(--vaadin-focus-ring-width, 2px);
    --_input-height: var(--vaadin-input-field-height, var(--lumo-text-field-size));
    --_disabled-value-color: var(--vaadin-input-field-disabled-value-color, var(--lumo-disabled-text-color));
  }

  :host::before {
    height: var(--_input-height);
    box-sizing: border-box;
    display: inline-flex;
    align-items: center;
  }

  :host([focused]) [part='input-field'] ::slotted(:is(input, textarea)) {
    -webkit-mask-image: none;
    mask-image: none;
  }

  ::slotted(:is(input, textarea):placeholder-shown) {
    color: var(--vaadin-input-field-placeholder-color, var(--lumo-secondary-text-color));
  }

  /* Hover */
  :host(:hover:not([readonly]):not([focused]):not([disabled])) [part='input-field']::after {
    opacity: var(--vaadin-input-field-hover-highlight-opacity, 0.1);
  }

  /* Touch device adjustment */
  @media (pointer: coarse) {
    :host(:hover:not([readonly]):not([focused]):not([disabled])) [part='input-field']::after {
      opacity: 0;
    }

    :host(:active:not([readonly]):not([focused]):not([disabled])) [part='input-field']::after {
      opacity: 0.2;
    }
  }

  /* Trigger when not focusing using the keyboard */
  :host([focused]:not([focus-ring]):not([readonly])) [part='input-field']::after {
    transform: scaleX(0);
    transition-duration: 0.15s, 1s;
  }

  /* Opt-in focus-ring when using pointer devices */
  /* This applies a focus-ring as box-shadow when the element is focused, but
     the ring is only visible / has a width when the respective CSS property is
     "enabled" using a value of 1 */
  :host([focused]) [part='input-field'] {
    /* Borders are implemented using box-shadows as well. To avoid overriding 
       the border on focus, even if the pointer focus-ring is disabled, we need to:
       - Duplicate the border box shadow for this rule
       - Remove the border (by using width of 0) when the focus-ring is visible,
         which is the same behavior as for the keyboard focus-ring below
       - Apply the border when the focus ring is not visible
    */
    --_pointer-focus-visible: clamp(0, var(--lumo-input-field-pointer-focus-visible, 0), 1);
    --_conditional-border-width: calc(calc(1 - var(--_pointer-focus-visible)) * var(--_input-border-width));
    --_conditional-focus-ring-width: calc(var(--_pointer-focus-visible) * var(--_focus-ring-width));
    box-shadow:
      inset 0 0 0 var(--_conditional-border-width) var(--_input-border-color),
      0 0 0 var(--_conditional-focus-ring-width) var(--_focus-ring-color);
  }

  /* Focus-ring when using keyboard navigation */
  :host([focus-ring]) [part='input-field'] {
    box-shadow: 0 0 0 var(--_focus-ring-width) var(--_focus-ring-color);
  }

  /* Read-only and disabled */
  :host(:is([readonly], [disabled])) ::slotted(:is(input, textarea):placeholder-shown) {
    opacity: 0;
  }

  /* Read-only style */
  :host([readonly]) {
    --vaadin-input-field-border-color: transparent;
  }

  /* Disabled style */
  :host([disabled]) {
    pointer-events: none;
    --vaadin-input-field-border-color: var(--lumo-contrast-20pct);
  }

  :host([disabled]) [part='label'],
  :host([disabled]) [part='input-field'] ::slotted([slot$='fix']) {
    color: var(--lumo-disabled-text-color);
    -webkit-text-fill-color: var(--lumo-disabled-text-color);
  }

  :host([disabled]) [part='input-field'] ::slotted(:not([slot$='fix'])) {
    color: var(--_disabled-value-color);
    -webkit-text-fill-color: var(--_disabled-value-color);
  }

  /* Invalid style */
  :host([invalid]) {
    --vaadin-input-field-border-color: var(--lumo-error-color);
    --_focus-ring-color: var(--lumo-error-color-50pct);
  }

  :host([input-prevented]) [part='input-field'] {
    animation: shake 0.15s infinite;
  }

  @keyframes shake {
    25% {
      transform: translateX(4px);
    }
    75% {
      transform: translateX(-4px);
    }
  }

  /* Small theme */
  :host([theme~='small']) {
    font-size: var(--lumo-font-size-s);
    --lumo-text-field-size: var(--lumo-size-s);
  }

  :host([theme~='small']) [part='label'] {
    font-size: var(--lumo-font-size-xs);
  }

  :host([theme~='small']) [part='error-message'] {
    font-size: var(--lumo-font-size-xxs);
  }

  /* Slotted content */
  [part='input-field'] ::slotted(:not(vaadin-icon):not(input):not(textarea)) {
    color: var(--lumo-secondary-text-color);
    font-weight: 400;
  }

  [part='clear-button']::before {
    content: var(--lumo-icons-cross);
  }
`;
const inputFieldShared$1 = [requiredField, fieldButton, helper, inputField];
registerStyles$1("", inputFieldShared$1, {
  moduleId: "lumo-input-field-shared-styles"
});
const comboBox = css`
  [part='toggle-button']::before {
    content: var(--lumo-icons-dropdown);
  }
`;
registerStyles$1("vaadin-combo-box", [inputFieldShared$1, comboBox], { moduleId: "lumo-combo-box" });
/**
 * @license
 * Copyright (c) 2021 - 2025 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const InputContainerMixin = (superClass) => class InputContainerMixinClass extends superClass {
  static get properties() {
    return {
      /**
       * If true, the user cannot interact with this element.
       */
      disabled: {
        type: Boolean,
        reflectToAttribute: true
      },
      /**
       * Set to true to make this element read-only.
       */
      readonly: {
        type: Boolean,
        reflectToAttribute: true
      },
      /**
       * Set to true when the element is invalid.
       */
      invalid: {
        type: Boolean,
        reflectToAttribute: true
      }
    };
  }
  /** @protected */
  ready() {
    super.ready();
    this.addEventListener("pointerdown", (event) => {
      if (event.target === this) {
        event.preventDefault();
      }
    });
    this.addEventListener("click", (event) => {
      if (event.target === this) {
        this.shadowRoot.querySelector("slot:not([name])").assignedNodes({ flatten: true }).forEach((node) => node.focus && node.focus());
      }
    });
  }
};
/**
 * @license
 * Copyright (c) 2021 - 2025 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const inputContainerStyles = css`
  :host {
    display: flex;
    align-items: center;
    flex: 0 1 auto;
    border-radius:
            /* See https://developer.mozilla.org/en-US/docs/Web/CSS/border-radius */
      var(--vaadin-input-field-top-start-radius, var(--__border-radius))
      var(--vaadin-input-field-top-end-radius, var(--__border-radius))
      var(--vaadin-input-field-bottom-end-radius, var(--__border-radius))
      var(--vaadin-input-field-bottom-start-radius, var(--__border-radius));
    --_border-radius: var(--vaadin-input-field-border-radius, 0);
    --_input-border-width: var(--vaadin-input-field-border-width, 0px);
    --_input-border-color: var(--vaadin-input-field-border-color, transparent);
    /* stylelint-disable-next-line length-zero-no-unit */
    box-shadow: inset 0 0 0 var(--_input-border-width, 0) var(--_input-border-color);
  }

  :host([dir='rtl']) {
    border-radius:
            /* Don't use logical props, see https://github.com/vaadin/vaadin-time-picker/issues/145 */
      var(--vaadin-input-field-top-end-radius, var(--_border-radius))
      var(--vaadin-input-field-top-start-radius, var(--_border-radius))
      var(--vaadin-input-field-bottom-start-radius, var(--_border-radius))
      var(--vaadin-input-field-bottom-end-radius, var(--_border-radius));
  }

  :host([hidden]) {
    display: none !important;
  }

  /* Reset the native input styles */
  ::slotted(input) {
    -webkit-appearance: none;
    -moz-appearance: none;
    flex: auto;
    white-space: nowrap;
    overflow: hidden;
    width: 100%;
    height: 100%;
    outline: none;
    margin: 0;
    padding: 0;
    border: 0;
    border-radius: 0;
    min-width: 0;
    font: inherit;
    line-height: normal;
    color: inherit;
    background-color: transparent;
    /* Disable default invalid style in Firefox */
    box-shadow: none;
  }

  ::slotted(*) {
    flex: none;
  }

  ::slotted(:is(input, textarea))::placeholder {
    /* Use ::slotted(input:placeholder-shown) in themes to style the placeholder. */
    /* because ::slotted(...)::placeholder does not work in Safari. */
    font: inherit;
    color: inherit;
    /* Override default opacity in Firefox */
    opacity: 1;
  }
`;
/**
 * @license
 * Copyright (c) 2021 - 2025 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
registerStyles$1("vaadin-input-container", inputContainerStyles, { moduleId: "vaadin-input-container-styles" });
class InputContainer extends InputContainerMixin(ThemableMixin(DirMixin(PolymerElement))) {
  static get is() {
    return "vaadin-input-container";
  }
  static get template() {
    return html`
      <slot name="prefix"></slot>
      <slot></slot>
      <slot name="suffix"></slot>
    `;
  }
}
defineCustomElement(InputContainer);
/**
 * @license
 * Copyright (c) 2015 - 2025 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const ComboBoxItemMixin = (superClass) => class ComboBoxItemMixinClass extends superClass {
  static get properties() {
    return {
      /**
       * The index of the item.
       */
      index: {
        type: Number
      },
      /**
       * The item to render.
       */
      item: {
        type: Object
      },
      /**
       * The text to render in the item.
       */
      label: {
        type: String
      },
      /**
       * True when item is selected.
       */
      selected: {
        type: Boolean,
        value: false,
        reflectToAttribute: true
      },
      /**
       * True when item is focused.
       */
      focused: {
        type: Boolean,
        value: false,
        reflectToAttribute: true
      },
      /**
       * Custom function for rendering the item content.
       */
      renderer: {
        type: Function
      }
    };
  }
  static get observers() {
    return ["__rendererOrItemChanged(renderer, index, item, selected, focused)", "__updateLabel(label, renderer)"];
  }
  static get observedAttributes() {
    return [...super.observedAttributes, "hidden"];
  }
  attributeChangedCallback(name, oldValue, newValue) {
    if (name === "hidden" && newValue !== null) {
      this.index = void 0;
    } else {
      super.attributeChangedCallback(name, oldValue, newValue);
    }
  }
  /** @protected */
  connectedCallback() {
    super.connectedCallback();
    this._owner = this.parentNode.owner;
    const hostDir = this._owner.getAttribute("dir");
    if (hostDir) {
      this.setAttribute("dir", hostDir);
    }
  }
  /**
   * Requests an update for the content of the item.
   * While performing the update, it invokes the renderer passed in the `renderer` property.
   *
   * It is not guaranteed that the update happens immediately (synchronously) after it is requested.
   */
  requestContentUpdate() {
    if (!this.renderer || this.hidden) {
      return;
    }
    const model = {
      index: this.index,
      item: this.item,
      focused: this.focused,
      selected: this.selected
    };
    this.renderer(this, this._owner, model);
  }
  /** @private */
  __rendererOrItemChanged(renderer, index, item2) {
    if (item2 === void 0 || index === void 0) {
      return;
    }
    if (this._oldRenderer !== renderer) {
      this.innerHTML = "";
      delete this._$litPart$;
    }
    if (renderer) {
      this._oldRenderer = renderer;
      this.requestContentUpdate();
    }
  }
  /** @private */
  __updateLabel(label, renderer) {
    if (renderer) {
      return;
    }
    this.textContent = label;
  }
};
/**
 * @license
 * Copyright (c) 2015 - 2025 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
class ComboBoxItem extends ComboBoxItemMixin(ThemableMixin(DirMixin(PolymerElement))) {
  static get template() {
    return html`
      <style>
        :host {
          display: block;
        }

        :host([hidden]) {
          display: none;
        }
      </style>
      <span part="checkmark" aria-hidden="true"></span>
      <div part="content">
        <slot></slot>
      </div>
    `;
  }
  static get is() {
    return "vaadin-combo-box-item";
  }
}
defineCustomElement(ComboBoxItem);
/**
 * @license
 * Copyright (c) 2015 - 2025 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const ComboBoxOverlayMixin = (superClass) => class ComboBoxOverlayMixin extends PositionMixin(superClass) {
  static get observers() {
    return ["_setOverlayWidth(positionTarget, opened)"];
  }
  constructor() {
    super();
    this.requiredVerticalSpace = 200;
  }
  /** @protected */
  connectedCallback() {
    super.connectedCallback();
    const comboBox2 = this._comboBox;
    const hostDir = comboBox2 && comboBox2.getAttribute("dir");
    if (hostDir) {
      this.setAttribute("dir", hostDir);
    }
  }
  /**
   * Override method inherited from `Overlay`
   * to not close on position target click.
   *
   * @param {Event} event
   * @return {boolean}
   * @protected
   */
  _shouldCloseOnOutsideClick(event) {
    const eventPath = event.composedPath();
    return !eventPath.includes(this.positionTarget) && !eventPath.includes(this);
  }
  /**
   * @protected
   * @override
   */
  _mouseDownListener(event) {
    super._mouseDownListener(event);
    if (this._shouldCloseOnOutsideClick(event) && !isElementFocusable(event.composedPath()[0])) {
      event.preventDefault();
    }
  }
  /** @protected */
  _updateOverlayWidth() {
    const propPrefix = this.localName;
    this.style.setProperty(`--_${propPrefix}-default-width`, `${this.positionTarget.clientWidth}px`);
    const customWidth = getComputedStyle(this._comboBox).getPropertyValue(`--${propPrefix}-width`);
    if (customWidth === "") {
      this.style.removeProperty(`--${propPrefix}-width`);
    } else {
      this.style.setProperty(`--${propPrefix}-width`, customWidth);
    }
  }
  /** @private */
  _setOverlayWidth(positionTarget, opened) {
    if (positionTarget && opened) {
      this._updateOverlayWidth();
      this._updatePosition();
    }
  }
};
/**
 * @license
 * Copyright (c) 2015 - 2025 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const comboBoxOverlayStyles = css`
  #overlay {
    width: var(--vaadin-combo-box-overlay-width, var(--_vaadin-combo-box-overlay-default-width, auto));
  }

  [part='content'] {
    display: flex;
    flex-direction: column;
    height: 100%;
  }
`;
registerStyles$1("vaadin-combo-box-overlay", [overlayStyles, comboBoxOverlayStyles], {
  moduleId: "vaadin-combo-box-overlay-styles"
});
class ComboBoxOverlay extends ComboBoxOverlayMixin(OverlayMixin(DirMixin(ThemableMixin(PolymerElement)))) {
  static get is() {
    return "vaadin-combo-box-overlay";
  }
  static get template() {
    return html`
      <div id="backdrop" part="backdrop" hidden></div>
      <div part="overlay" id="overlay">
        <div part="loader"></div>
        <div part="content" id="content"><slot></slot></div>
      </div>
    `;
  }
}
defineCustomElement(ComboBoxOverlay);
/**
 * @license
 * Copyright (c) 2016 The Polymer Project Authors. All rights reserved.
 * This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
 * The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
 * The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
 * Code distributed by Google as part of the polymer project is also
 * subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
 */
const IOS = navigator.userAgent.match(/iP(?:hone|ad;(?: U;)? CPU) OS (\d+)/u);
const IOS_TOUCH_SCROLLING = IOS && IOS[1] >= 8;
const DEFAULT_PHYSICAL_COUNT = 3;
const ironList = {
  /**
   * The ratio of hidden tiles that should remain in the scroll direction.
   * Recommended value ~0.5, so it will distribute tiles evenly in both
   * directions.
   */
  _ratio: 0.5,
  /**
   * The padding-top value for the list.
   */
  _scrollerPaddingTop: 0,
  /**
   * This value is a cached value of `scrollTop` from the last `scroll` event.
   */
  _scrollPosition: 0,
  /**
   * The sum of the heights of all the tiles in the DOM.
   */
  _physicalSize: 0,
  /**
   * The average `offsetHeight` of the tiles observed till now.
   */
  _physicalAverage: 0,
  /**
   * The number of tiles which `offsetHeight` > 0 observed until now.
   */
  _physicalAverageCount: 0,
  /**
   * The Y position of the item rendered in the `_physicalStart`
   * tile relative to the scrolling list.
   */
  _physicalTop: 0,
  /**
   * The number of items in the list.
   */
  _virtualCount: 0,
  /**
   * The estimated scroll height based on `_physicalAverage`
   */
  _estScrollHeight: 0,
  /**
   * The scroll height of the dom node
   */
  _scrollHeight: 0,
  /**
   * The height of the list. This is referred as the viewport in the context of
   * list.
   */
  _viewportHeight: 0,
  /**
   * The width of the list. This is referred as the viewport in the context of
   * list.
   */
  _viewportWidth: 0,
  /**
   * An array of DOM nodes that are currently in the tree
   * @type {?Array<!HTMLElement>}
   */
  _physicalItems: null,
  /**
   * An array of heights for each item in `_physicalItems`
   * @type {?Array<number>}
   */
  _physicalSizes: null,
  /**
   * A cached value for the first visible index.
   * See `firstVisibleIndex`
   * @type {?number}
   */
  _firstVisibleIndexVal: null,
  /**
   * A cached value for the last visible index.
   * See `lastVisibleIndex`
   * @type {?number}
   */
  _lastVisibleIndexVal: null,
  /**
   * The max number of pages to render. One page is equivalent to the height of
   * the list.
   */
  _maxPages: 2,
  /**
   * The cost of stamping a template in ms.
   */
  _templateCost: 0,
  /**
   * The bottom of the physical content.
   */
  get _physicalBottom() {
    return this._physicalTop + this._physicalSize;
  },
  /**
   * The bottom of the scroll.
   */
  get _scrollBottom() {
    return this._scrollPosition + this._viewportHeight;
  },
  /**
   * The n-th item rendered in the last physical item.
   */
  get _virtualEnd() {
    return this._virtualStart + this._physicalCount - 1;
  },
  /**
   * The height of the physical content that isn't on the screen.
   */
  get _hiddenContentSize() {
    return this._physicalSize - this._viewportHeight;
  },
  /**
   * The maximum scroll top value.
   */
  get _maxScrollTop() {
    return this._estScrollHeight - this._viewportHeight + this._scrollOffset;
  },
  /**
   * The largest n-th value for an item such that it can be rendered in
   * `_physicalStart`.
   */
  get _maxVirtualStart() {
    const virtualCount = this._virtualCount;
    return Math.max(0, virtualCount - this._physicalCount);
  },
  get _virtualStart() {
    return this._virtualStartVal || 0;
  },
  set _virtualStart(val) {
    val = this._clamp(val, 0, this._maxVirtualStart);
    this._virtualStartVal = val;
  },
  get _physicalStart() {
    return this._physicalStartVal || 0;
  },
  /**
   * The k-th tile that is at the top of the scrolling list.
   */
  set _physicalStart(val) {
    val %= this._physicalCount;
    if (val < 0) {
      val = this._physicalCount + val;
    }
    this._physicalStartVal = val;
  },
  /**
   * The k-th tile that is at the bottom of the scrolling list.
   */
  get _physicalEnd() {
    return (this._physicalStart + this._physicalCount - 1) % this._physicalCount;
  },
  get _physicalCount() {
    return this._physicalCountVal || 0;
  },
  set _physicalCount(val) {
    this._physicalCountVal = val;
  },
  /**
   * An optimal physical size such that we will have enough physical items
   * to fill up the viewport and recycle when the user scrolls.
   *
   * This default value assumes that we will at least have the equivalent
   * to a viewport of physical items above and below the user's viewport.
   */
  get _optPhysicalSize() {
    return this._viewportHeight === 0 ? Infinity : this._viewportHeight * this._maxPages;
  },
  /**
   * True if the current list is visible.
   */
  get _isVisible() {
    return Boolean(this.offsetWidth || this.offsetHeight);
  },
  /**
   * Gets the index of the first visible item in the viewport.
   *
   * @type {number}
   */
  get firstVisibleIndex() {
    let idx = this._firstVisibleIndexVal;
    if (idx == null) {
      let physicalOffset = this._physicalTop + this._scrollOffset;
      idx = this._iterateItems((pidx, vidx) => {
        physicalOffset += this._getPhysicalSizeIncrement(pidx);
        if (physicalOffset > this._scrollPosition) {
          return vidx;
        }
      }) || 0;
      this._firstVisibleIndexVal = idx;
    }
    return idx;
  },
  /**
   * Gets the index of the last visible item in the viewport.
   *
   * @type {number}
   */
  get lastVisibleIndex() {
    let idx = this._lastVisibleIndexVal;
    if (idx == null) {
      let physicalOffset = this._physicalTop + this._scrollOffset;
      this._iterateItems((pidx, vidx) => {
        if (physicalOffset < this._scrollBottom) {
          idx = vidx;
        }
        physicalOffset += this._getPhysicalSizeIncrement(pidx);
      });
      this._lastVisibleIndexVal = idx;
    }
    return idx;
  },
  get _scrollOffset() {
    return this._scrollerPaddingTop + this.scrollOffset;
  },
  /**
   * Recycles the physical items when needed.
   */
  _scrollHandler() {
    const scrollTop = Math.max(0, Math.min(this._maxScrollTop, this._scrollTop));
    let delta = scrollTop - this._scrollPosition;
    const isScrollingDown = delta >= 0;
    this._scrollPosition = scrollTop;
    this._firstVisibleIndexVal = null;
    this._lastVisibleIndexVal = null;
    if (Math.abs(delta) > this._physicalSize && this._physicalSize > 0) {
      delta -= this._scrollOffset;
      const idxAdjustment = Math.round(delta / this._physicalAverage);
      this._virtualStart += idxAdjustment;
      this._physicalStart += idxAdjustment;
      this._physicalTop = Math.min(Math.floor(this._virtualStart) * this._physicalAverage, this._scrollPosition);
      this._update();
    } else if (this._physicalCount > 0) {
      const reusables = this._getReusables(isScrollingDown);
      if (isScrollingDown) {
        this._physicalTop = reusables.physicalTop;
        this._virtualStart += reusables.indexes.length;
        this._physicalStart += reusables.indexes.length;
      } else {
        this._virtualStart -= reusables.indexes.length;
        this._physicalStart -= reusables.indexes.length;
      }
      this._update(reusables.indexes, isScrollingDown ? null : reusables.indexes);
      this._debounce("_increasePoolIfNeeded", this._increasePoolIfNeeded.bind(this, 0), microTask$1);
    }
  },
  /**
   * Returns an object that contains the indexes of the physical items
   * that might be reused and the physicalTop.
   *
   * @param {boolean} fromTop If the potential reusable items are above the scrolling region.
   */
  _getReusables(fromTop) {
    let ith, offsetContent, physicalItemHeight;
    const idxs = [];
    const protectedOffsetContent = this._hiddenContentSize * this._ratio;
    const virtualStart = this._virtualStart;
    const virtualEnd = this._virtualEnd;
    const physicalCount = this._physicalCount;
    let top = this._physicalTop + this._scrollOffset;
    const bottom = this._physicalBottom + this._scrollOffset;
    const scrollTop = this._scrollPosition;
    const scrollBottom = this._scrollBottom;
    if (fromTop) {
      ith = this._physicalStart;
      offsetContent = scrollTop - top;
    } else {
      ith = this._physicalEnd;
      offsetContent = bottom - scrollBottom;
    }
    while (true) {
      physicalItemHeight = this._getPhysicalSizeIncrement(ith);
      offsetContent -= physicalItemHeight;
      if (idxs.length >= physicalCount || offsetContent <= protectedOffsetContent) {
        break;
      }
      if (fromTop) {
        if (virtualEnd + idxs.length + 1 >= this._virtualCount) {
          break;
        }
        if (top + physicalItemHeight >= scrollTop - this._scrollOffset) {
          break;
        }
        idxs.push(ith);
        top += physicalItemHeight;
        ith = (ith + 1) % physicalCount;
      } else {
        if (virtualStart - idxs.length <= 0) {
          break;
        }
        if (top + this._physicalSize - physicalItemHeight <= scrollBottom) {
          break;
        }
        idxs.push(ith);
        top -= physicalItemHeight;
        ith = ith === 0 ? physicalCount - 1 : ith - 1;
      }
    }
    return { indexes: idxs, physicalTop: top - this._scrollOffset };
  },
  /**
   * Update the list of items, starting from the `_virtualStart` item.
   * @param {!Array<number>=} itemSet
   * @param {!Array<number>=} movingUp
   */
  _update(itemSet, movingUp) {
    if (itemSet && itemSet.length === 0 || this._physicalCount === 0) {
      return;
    }
    this._assignModels(itemSet);
    this._updateMetrics(itemSet);
    if (movingUp) {
      while (movingUp.length) {
        const idx = movingUp.pop();
        this._physicalTop -= this._getPhysicalSizeIncrement(idx);
      }
    }
    this._positionItems();
    this._updateScrollerSize();
  },
  _isClientFull() {
    return this._scrollBottom !== 0 && this._physicalBottom - 1 >= this._scrollBottom && this._physicalTop <= this._scrollPosition;
  },
  /**
   * Increases the pool size.
   */
  _increasePoolIfNeeded(count) {
    const nextPhysicalCount = this._clamp(
      this._physicalCount + count,
      DEFAULT_PHYSICAL_COUNT,
      this._virtualCount - this._virtualStart
    );
    const delta = nextPhysicalCount - this._physicalCount;
    let nextIncrease = Math.round(this._physicalCount * 0.5);
    if (delta < 0) {
      return;
    }
    if (delta > 0) {
      const ts = window.performance.now();
      [].push.apply(this._physicalItems, this._createPool(delta));
      for (let i2 = 0; i2 < delta; i2++) {
        this._physicalSizes.push(0);
      }
      this._physicalCount += delta;
      if (this._physicalStart > this._physicalEnd && this._isIndexRendered(this._focusedVirtualIndex) && this._getPhysicalIndex(this._focusedVirtualIndex) < this._physicalEnd) {
        this._physicalStart += delta;
      }
      this._update();
      this._templateCost = (window.performance.now() - ts) / delta;
      nextIncrease = Math.round(this._physicalCount * 0.5);
    }
    if (this._virtualEnd >= this._virtualCount - 1 || nextIncrease === 0) ;
    else if (!this._isClientFull()) {
      this._debounce("_increasePoolIfNeeded", this._increasePoolIfNeeded.bind(this, nextIncrease), microTask$1);
    } else if (this._physicalSize < this._optPhysicalSize) {
      this._debounce(
        "_increasePoolIfNeeded",
        this._increasePoolIfNeeded.bind(this, this._clamp(Math.round(50 / this._templateCost), 1, nextIncrease)),
        idlePeriod$1
      );
    }
  },
  /**
   * Renders the a new list.
   */
  _render() {
    if (!this.isAttached || !this._isVisible) {
      return;
    }
    if (this._physicalCount !== 0) {
      const reusables = this._getReusables(true);
      this._physicalTop = reusables.physicalTop;
      this._virtualStart += reusables.indexes.length;
      this._physicalStart += reusables.indexes.length;
      this._update(reusables.indexes);
      this._update();
      this._increasePoolIfNeeded(0);
    } else if (this._virtualCount > 0) {
      this.updateViewportBoundaries();
      this._increasePoolIfNeeded(DEFAULT_PHYSICAL_COUNT);
    }
  },
  /**
   * Called when the items have changed. That is, reassignments
   * to `items`, splices or updates to a single item.
   */
  _itemsChanged(change) {
    if (change.path === "items") {
      this._virtualStart = 0;
      this._physicalTop = 0;
      this._virtualCount = this.items ? this.items.length : 0;
      this._physicalIndexForKey = {};
      this._firstVisibleIndexVal = null;
      this._lastVisibleIndexVal = null;
      if (!this._physicalItems) {
        this._physicalItems = [];
      }
      if (!this._physicalSizes) {
        this._physicalSizes = [];
      }
      this._physicalStart = 0;
      if (this._scrollTop > this._scrollOffset) {
        this._resetScrollPosition(0);
      }
      this._debounce("_render", this._render, animationFrame$1);
    }
  },
  /**
   * Executes a provided function per every physical index in `itemSet`
   * `itemSet` default value is equivalent to the entire set of physical
   * indexes.
   *
   * @param {!function(number, number)} fn
   * @param {!Array<number>=} itemSet
   */
  _iterateItems(fn, itemSet) {
    let pidx, vidx, rtn, i2;
    if (arguments.length === 2 && itemSet) {
      for (i2 = 0; i2 < itemSet.length; i2++) {
        pidx = itemSet[i2];
        vidx = this._computeVidx(pidx);
        if ((rtn = fn.call(this, pidx, vidx)) != null) {
          return rtn;
        }
      }
    } else {
      pidx = this._physicalStart;
      vidx = this._virtualStart;
      for (; pidx < this._physicalCount; pidx++, vidx++) {
        if ((rtn = fn.call(this, pidx, vidx)) != null) {
          return rtn;
        }
      }
      for (pidx = 0; pidx < this._physicalStart; pidx++, vidx++) {
        if ((rtn = fn.call(this, pidx, vidx)) != null) {
          return rtn;
        }
      }
    }
  },
  /**
   * Returns the virtual index for a given physical index
   *
   * @param {number} pidx Physical index
   * @return {number}
   */
  _computeVidx(pidx) {
    if (pidx >= this._physicalStart) {
      return this._virtualStart + (pidx - this._physicalStart);
    }
    return this._virtualStart + (this._physicalCount - this._physicalStart) + pidx;
  },
  /**
   * Updates the position of the physical items.
   */
  _positionItems() {
    this._adjustScrollPosition();
    let y3 = this._physicalTop;
    this._iterateItems((pidx) => {
      this.translate3d(0, `${y3}px`, 0, this._physicalItems[pidx]);
      y3 += this._physicalSizes[pidx];
    });
  },
  _getPhysicalSizeIncrement(pidx) {
    return this._physicalSizes[pidx];
  },
  /**
   * Adjusts the scroll position when it was overestimated.
   */
  _adjustScrollPosition() {
    const deltaHeight = this._virtualStart === 0 ? this._physicalTop : Math.min(this._scrollPosition + this._physicalTop, 0);
    if (deltaHeight !== 0) {
      this._physicalTop -= deltaHeight;
      const scrollTop = this._scrollPosition;
      if (!IOS_TOUCH_SCROLLING && scrollTop > 0) {
        this._resetScrollPosition(scrollTop - deltaHeight);
      }
    }
  },
  /**
   * Sets the position of the scroll.
   */
  _resetScrollPosition(pos) {
    if (this.scrollTarget && pos >= 0) {
      this._scrollTop = pos;
      this._scrollPosition = this._scrollTop;
    }
  },
  /**
   * Sets the scroll height, that's the height of the content,
   *
   * @param {boolean=} forceUpdate If true, updates the height no matter what.
   */
  _updateScrollerSize(forceUpdate) {
    const estScrollHeight = this._physicalBottom + Math.max(this._virtualCount - this._physicalCount - this._virtualStart, 0) * this._physicalAverage;
    this._estScrollHeight = estScrollHeight;
    if (forceUpdate || this._scrollHeight === 0 || this._scrollPosition >= estScrollHeight - this._physicalSize || Math.abs(estScrollHeight - this._scrollHeight) >= this._viewportHeight) {
      this.$.items.style.height = `${estScrollHeight}px`;
      this._scrollHeight = estScrollHeight;
    }
  },
  /**
   * Scroll to a specific index in the virtual list regardless
   * of the physical items in the DOM tree.
   *
   * @method scrollToIndex
   * @param {number} idx The index of the item
   */
  scrollToIndex(idx) {
    if (typeof idx !== "number" || idx < 0 || idx > this.items.length - 1) {
      return;
    }
    flush$1();
    if (this._physicalCount === 0) {
      return;
    }
    idx = this._clamp(idx, 0, this._virtualCount - 1);
    if (!this._isIndexRendered(idx) || idx >= this._maxVirtualStart) {
      this._virtualStart = idx - 1;
    }
    this._assignModels();
    this._updateMetrics();
    this._physicalTop = this._virtualStart * this._physicalAverage;
    let currentTopItem = this._physicalStart;
    let currentVirtualItem = this._virtualStart;
    let targetOffsetTop = 0;
    const hiddenContentSize = this._hiddenContentSize;
    while (currentVirtualItem < idx && targetOffsetTop <= hiddenContentSize) {
      targetOffsetTop += this._getPhysicalSizeIncrement(currentTopItem);
      currentTopItem = (currentTopItem + 1) % this._physicalCount;
      currentVirtualItem += 1;
    }
    this._updateScrollerSize(true);
    this._positionItems();
    this._resetScrollPosition(this._physicalTop + this._scrollOffset + targetOffsetTop);
    this._increasePoolIfNeeded(0);
    this._firstVisibleIndexVal = null;
    this._lastVisibleIndexVal = null;
  },
  /**
   * Reset the physical average and the average count.
   */
  _resetAverage() {
    this._physicalAverage = 0;
    this._physicalAverageCount = 0;
  },
  /**
   * A handler for the `iron-resize` event triggered by `IronResizableBehavior`
   * when the element is resized.
   */
  _resizeHandler() {
    this._debounce(
      "_render",
      () => {
        this._firstVisibleIndexVal = null;
        this._lastVisibleIndexVal = null;
        if (this._isVisible) {
          this.updateViewportBoundaries();
          this.toggleScrollListener(true);
          this._resetAverage();
          this._render();
        } else {
          this.toggleScrollListener(false);
        }
      },
      animationFrame$1
    );
  },
  _isIndexRendered(idx) {
    return idx >= this._virtualStart && idx <= this._virtualEnd;
  },
  _getPhysicalIndex(vidx) {
    return (this._physicalStart + (vidx - this._virtualStart)) % this._physicalCount;
  },
  _clamp(v, min, max) {
    return Math.min(max, Math.max(min, v));
  },
  _debounce(name, cb, asyncModule) {
    if (!this._debouncers) {
      this._debouncers = {};
    }
    this._debouncers[name] = Debouncer$1.debounce(this._debouncers[name], asyncModule, cb.bind(this));
    enqueueDebouncer$1(this._debouncers[name]);
  }
};
/**
 * @license
 * Copyright (c) 2021 - 2025 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const MAX_VIRTUAL_COUNT = 1e5;
const OFFSET_ADJUST_MIN_THRESHOLD = 1e3;
class IronListAdapter {
  constructor({ createElements, updateElement, scrollTarget, scrollContainer, elementsContainer, reorderElements }) {
    this.isAttached = true;
    this._vidxOffset = 0;
    this.createElements = createElements;
    this.updateElement = updateElement;
    this.scrollTarget = scrollTarget;
    this.scrollContainer = scrollContainer;
    this.elementsContainer = elementsContainer || scrollContainer;
    this.reorderElements = reorderElements;
    this._maxPages = 1.3;
    this.__placeholderHeight = 200;
    this.__elementHeightQueue = Array(10);
    this.timeouts = {
      SCROLL_REORDER: 500,
      IGNORE_WHEEL: 500,
      FIX_INVALID_ITEM_POSITIONING: 100
    };
    this.__resizeObserver = new ResizeObserver(() => this._resizeHandler());
    if (getComputedStyle(this.scrollTarget).overflow === "visible") {
      this.scrollTarget.style.overflow = "auto";
    }
    if (getComputedStyle(this.scrollContainer).position === "static") {
      this.scrollContainer.style.position = "relative";
    }
    this.__resizeObserver.observe(this.scrollTarget);
    this.scrollTarget.addEventListener("scroll", () => this._scrollHandler());
    const attachObserver = new ResizeObserver(([{ contentRect }]) => {
      const isHidden = contentRect.width === 0 && contentRect.height === 0;
      if (!isHidden && this.__scrollTargetHidden && this.scrollTarget.scrollTop !== this._scrollPosition) {
        this.scrollTarget.scrollTop = this._scrollPosition;
      }
      this.__scrollTargetHidden = isHidden;
    });
    attachObserver.observe(this.scrollTarget);
    this._scrollLineHeight = this._getScrollLineHeight();
    this.scrollTarget.addEventListener("wheel", (e2) => this.__onWheel(e2));
    this.scrollTarget.addEventListener("virtualizer-element-focused", (e2) => this.__onElementFocused(e2));
    this.elementsContainer.addEventListener("focusin", () => {
      this.scrollTarget.dispatchEvent(
        new CustomEvent("virtualizer-element-focused", { detail: { element: this.__getFocusedElement() } })
      );
    });
    if (this.reorderElements) {
      this.scrollTarget.addEventListener("mousedown", () => {
        this.__mouseDown = true;
      });
      this.scrollTarget.addEventListener("mouseup", () => {
        this.__mouseDown = false;
        if (this.__pendingReorder) {
          this.__reorderElements();
        }
      });
    }
  }
  get scrollOffset() {
    return 0;
  }
  get adjustedFirstVisibleIndex() {
    return this.firstVisibleIndex + this._vidxOffset;
  }
  get adjustedLastVisibleIndex() {
    return this.lastVisibleIndex + this._vidxOffset;
  }
  get _maxVirtualIndexOffset() {
    return this.size - this._virtualCount;
  }
  __hasPlaceholders() {
    return this.__getVisibleElements().some((el) => el.__virtualizerPlaceholder);
  }
  scrollToIndex(index) {
    if (typeof index !== "number" || isNaN(index) || this.size === 0 || !this.scrollTarget.offsetHeight) {
      return;
    }
    delete this.__pendingScrollToIndex;
    if (this._physicalCount <= 3) {
      this.flush();
    }
    index = this._clamp(index, 0, this.size - 1);
    const visibleElementCount = this.__getVisibleElements().length;
    let targetVirtualIndex = Math.floor(index / this.size * this._virtualCount);
    if (this._virtualCount - targetVirtualIndex < visibleElementCount) {
      targetVirtualIndex = this._virtualCount - (this.size - index);
      this._vidxOffset = this._maxVirtualIndexOffset;
    } else if (targetVirtualIndex < visibleElementCount) {
      if (index < OFFSET_ADJUST_MIN_THRESHOLD) {
        targetVirtualIndex = index;
        this._vidxOffset = 0;
      } else {
        targetVirtualIndex = OFFSET_ADJUST_MIN_THRESHOLD;
        this._vidxOffset = index - targetVirtualIndex;
      }
    } else {
      this._vidxOffset = index - targetVirtualIndex;
    }
    this.__skipNextVirtualIndexAdjust = true;
    super.scrollToIndex(targetVirtualIndex);
    if (this.adjustedFirstVisibleIndex !== index && this._scrollTop < this._maxScrollTop && !this.grid) {
      this._scrollTop -= this.__getIndexScrollOffset(index) || 0;
    }
    this._scrollHandler();
    if (this.__hasPlaceholders()) {
      this.__pendingScrollToIndex = index;
    }
  }
  flush() {
    if (this.scrollTarget.offsetHeight === 0) {
      return;
    }
    this._resizeHandler();
    flush$1();
    this._scrollHandler();
    if (this.__fixInvalidItemPositioningDebouncer) {
      this.__fixInvalidItemPositioningDebouncer.flush();
    }
    if (this.__scrollReorderDebouncer) {
      this.__scrollReorderDebouncer.flush();
    }
    if (this.__debouncerWheelAnimationFrame) {
      this.__debouncerWheelAnimationFrame.flush();
    }
  }
  hostConnected() {
    if (this.scrollTarget.offsetParent && this.scrollTarget.scrollTop !== this._scrollPosition) {
      this.scrollTarget.scrollTop = this._scrollPosition;
    }
  }
  update(startIndex = 0, endIndex = this.size - 1) {
    const updatedElements = [];
    this.__getVisibleElements().forEach((el) => {
      if (el.__virtualIndex >= startIndex && el.__virtualIndex <= endIndex) {
        this.__updateElement(el, el.__virtualIndex, true);
        updatedElements.push(el);
      }
    });
    this.__afterElementsUpdated(updatedElements);
  }
  /**
   * Updates the height for a given set of items.
   *
   * @param {!Array<number>=} itemSet
   */
  _updateMetrics(itemSet) {
    flush$1();
    let newPhysicalSize = 0;
    let oldPhysicalSize = 0;
    const prevAvgCount = this._physicalAverageCount;
    const prevPhysicalAvg = this._physicalAverage;
    this._iterateItems((pidx, vidx) => {
      oldPhysicalSize += this._physicalSizes[pidx];
      this._physicalSizes[pidx] = Math.ceil(this.__getBorderBoxHeight(this._physicalItems[pidx]));
      newPhysicalSize += this._physicalSizes[pidx];
      this._physicalAverageCount += this._physicalSizes[pidx] ? 1 : 0;
    }, itemSet);
    this._physicalSize = this._physicalSize + newPhysicalSize - oldPhysicalSize;
    if (this._physicalAverageCount !== prevAvgCount) {
      this._physicalAverage = Math.round(
        (prevPhysicalAvg * prevAvgCount + newPhysicalSize) / this._physicalAverageCount
      );
    }
  }
  __getBorderBoxHeight(el) {
    const style = getComputedStyle(el);
    const itemHeight = parseFloat(style.height) || 0;
    if (style.boxSizing === "border-box") {
      return itemHeight;
    }
    const paddingBottom = parseFloat(style.paddingBottom) || 0;
    const paddingTop = parseFloat(style.paddingTop) || 0;
    const borderBottomWidth = parseFloat(style.borderBottomWidth) || 0;
    const borderTopWidth = parseFloat(style.borderTopWidth) || 0;
    return itemHeight + paddingBottom + paddingTop + borderBottomWidth + borderTopWidth;
  }
  __updateElement(el, index, forceSameIndexUpdates) {
    if (el.__virtualizerPlaceholder) {
      el.style.paddingTop = "";
      el.style.opacity = "";
      el.__virtualizerPlaceholder = false;
    }
    if (!this.__preventElementUpdates && (el.__lastUpdatedIndex !== index || forceSameIndexUpdates)) {
      this.updateElement(el, index);
      el.__lastUpdatedIndex = index;
    }
  }
  /**
   * Called synchronously right after elements have been updated.
   * This is a good place to do any post-update work.
   *
   * @param {!Array<!HTMLElement>} updatedElements
   */
  __afterElementsUpdated(updatedElements) {
    updatedElements.forEach((el) => {
      const elementHeight = el.offsetHeight;
      if (elementHeight === 0) {
        el.style.paddingTop = `${this.__placeholderHeight}px`;
        el.style.opacity = "0";
        el.__virtualizerPlaceholder = true;
        this.__placeholderClearDebouncer = Debouncer$1.debounce(
          this.__placeholderClearDebouncer,
          animationFrame$1,
          () => this._resizeHandler()
        );
      } else {
        this.__elementHeightQueue.push(elementHeight);
        this.__elementHeightQueue.shift();
        const filteredHeights = this.__elementHeightQueue.filter((h3) => h3 !== void 0);
        this.__placeholderHeight = Math.round(filteredHeights.reduce((a3, b2) => a3 + b2, 0) / filteredHeights.length);
      }
    });
    if (this.__pendingScrollToIndex !== void 0 && !this.__hasPlaceholders()) {
      this.scrollToIndex(this.__pendingScrollToIndex);
    }
  }
  __getIndexScrollOffset(index) {
    const element = this.__getVisibleElements().find((el) => el.__virtualIndex === index);
    return element ? this.scrollTarget.getBoundingClientRect().top - element.getBoundingClientRect().top : void 0;
  }
  get size() {
    return this.__size;
  }
  set size(size) {
    if (size === this.size) {
      return;
    }
    if (this.__fixInvalidItemPositioningDebouncer) {
      this.__fixInvalidItemPositioningDebouncer.cancel();
    }
    if (this._debouncers && this._debouncers._increasePoolIfNeeded) {
      this._debouncers._increasePoolIfNeeded.cancel();
    }
    this.__preventElementUpdates = true;
    let fvi;
    let fviOffsetBefore;
    if (size > 0) {
      fvi = this.adjustedFirstVisibleIndex;
      fviOffsetBefore = this.__getIndexScrollOffset(fvi);
    }
    this.__size = size;
    this._itemsChanged({
      path: "items"
    });
    flush$1();
    if (size > 0) {
      fvi = Math.min(fvi, size - 1);
      this.scrollToIndex(fvi);
      const fviOffsetAfter = this.__getIndexScrollOffset(fvi);
      if (fviOffsetBefore !== void 0 && fviOffsetAfter !== void 0) {
        this._scrollTop += fviOffsetBefore - fviOffsetAfter;
      }
    }
    this.__preventElementUpdates = false;
    if (!this._isVisible) {
      this._assignModels();
    }
    if (!this.elementsContainer.children.length) {
      requestAnimationFrame(() => this._resizeHandler());
    }
    this._resizeHandler();
    flush$1();
    this._debounce("_update", this._update, microTask$1);
  }
  /** @private */
  get _scrollTop() {
    return this.scrollTarget.scrollTop;
  }
  /** @private */
  set _scrollTop(top) {
    this.scrollTarget.scrollTop = top;
  }
  /** @private */
  get items() {
    return {
      length: Math.min(this.size, MAX_VIRTUAL_COUNT)
    };
  }
  /** @private */
  get offsetHeight() {
    return this.scrollTarget.offsetHeight;
  }
  /** @private */
  get $() {
    return {
      items: this.scrollContainer
    };
  }
  /** @private */
  updateViewportBoundaries() {
    const styles2 = window.getComputedStyle(this.scrollTarget);
    this._scrollerPaddingTop = this.scrollTarget === this ? 0 : parseInt(styles2["padding-top"], 10);
    this._isRTL = Boolean(styles2.direction === "rtl");
    this._viewportWidth = this.elementsContainer.offsetWidth;
    this._viewportHeight = this.scrollTarget.offsetHeight;
    this._scrollPageHeight = this._viewportHeight - this._scrollLineHeight;
    if (this.grid) {
      this._updateGridMetrics();
    }
  }
  /** @private */
  setAttribute() {
  }
  /** @private */
  _createPool(size) {
    const physicalItems = this.createElements(size);
    const fragment = document.createDocumentFragment();
    physicalItems.forEach((el) => {
      el.style.position = "absolute";
      fragment.appendChild(el);
      this.__resizeObserver.observe(el);
    });
    this.elementsContainer.appendChild(fragment);
    return physicalItems;
  }
  /** @private */
  _assignModels(itemSet) {
    const updatedElements = [];
    this._iterateItems((pidx, vidx) => {
      const el = this._physicalItems[pidx];
      el.hidden = vidx >= this.size;
      if (!el.hidden) {
        el.__virtualIndex = vidx + (this._vidxOffset || 0);
        this.__updateElement(el, el.__virtualIndex);
        updatedElements.push(el);
      } else {
        delete el.__lastUpdatedIndex;
      }
    }, itemSet);
    this.__afterElementsUpdated(updatedElements);
  }
  /** @private */
  _isClientFull() {
    setTimeout(() => {
      this.__clientFull = true;
    });
    return this.__clientFull || super._isClientFull();
  }
  /** @private */
  translate3d(_x, y3, _z, el) {
    el.style.transform = `translateY(${y3})`;
  }
  /** @private */
  toggleScrollListener() {
  }
  /** @private */
  __getFocusedElement(visibleElements = this.__getVisibleElements()) {
    return visibleElements.find(
      (element) => element.contains(this.elementsContainer.getRootNode().activeElement) || element.contains(this.scrollTarget.getRootNode().activeElement)
    );
  }
  /** @private */
  __nextFocusableSiblingMissing(focusedElement, visibleElements) {
    return (
      // Check if focused element is the last visible DOM element
      visibleElements.indexOf(focusedElement) === visibleElements.length - 1 && // ...while there are more items available
      this.size > focusedElement.__virtualIndex + 1
    );
  }
  /** @private */
  __previousFocusableSiblingMissing(focusedElement, visibleElements) {
    return (
      // Check if focused element is the first visible DOM element
      visibleElements.indexOf(focusedElement) === 0 && // ...while there are preceding items available
      focusedElement.__virtualIndex > 0
    );
  }
  /** @private */
  __onElementFocused(e2) {
    if (!this.reorderElements) {
      return;
    }
    const focusedElement = e2.detail.element;
    if (!focusedElement) {
      return;
    }
    const visibleElements = this.__getVisibleElements();
    if (this.__previousFocusableSiblingMissing(focusedElement, visibleElements) || this.__nextFocusableSiblingMissing(focusedElement, visibleElements)) {
      this.flush();
    }
    const reorderedVisibleElements = this.__getVisibleElements();
    if (this.__nextFocusableSiblingMissing(focusedElement, reorderedVisibleElements)) {
      this._scrollTop += Math.ceil(focusedElement.getBoundingClientRect().bottom) - Math.floor(this.scrollTarget.getBoundingClientRect().bottom - 1);
      this.flush();
    } else if (this.__previousFocusableSiblingMissing(focusedElement, reorderedVisibleElements)) {
      this._scrollTop -= Math.ceil(this.scrollTarget.getBoundingClientRect().top + 1) - Math.floor(focusedElement.getBoundingClientRect().top);
      this.flush();
    }
  }
  _scrollHandler() {
    if (this.scrollTarget.offsetHeight === 0) {
      return;
    }
    this._adjustVirtualIndexOffset(this._scrollTop - (this.__previousScrollTop || 0));
    const delta = this.scrollTarget.scrollTop - this._scrollPosition;
    super._scrollHandler();
    if (this._physicalCount !== 0) {
      const isScrollingDown = delta >= 0;
      const reusables = this._getReusables(!isScrollingDown);
      if (reusables.indexes.length) {
        this._physicalTop = reusables.physicalTop;
        if (isScrollingDown) {
          this._virtualStart -= reusables.indexes.length;
          this._physicalStart -= reusables.indexes.length;
        } else {
          this._virtualStart += reusables.indexes.length;
          this._physicalStart += reusables.indexes.length;
        }
        this._resizeHandler();
      }
    }
    if (delta) {
      this.__fixInvalidItemPositioningDebouncer = Debouncer$1.debounce(
        this.__fixInvalidItemPositioningDebouncer,
        timeOut$1.after(this.timeouts.FIX_INVALID_ITEM_POSITIONING),
        () => this.__fixInvalidItemPositioning()
      );
    }
    if (this.reorderElements) {
      this.__scrollReorderDebouncer = Debouncer$1.debounce(
        this.__scrollReorderDebouncer,
        timeOut$1.after(this.timeouts.SCROLL_REORDER),
        () => this.__reorderElements()
      );
    }
    this.__previousScrollTop = this._scrollTop;
    if (this._scrollTop === 0 && this.firstVisibleIndex !== 0 && Math.abs(delta) > 0) {
      this.scrollToIndex(0);
    }
  }
  /** @override */
  _resizeHandler() {
    super._resizeHandler();
    const lastIndexVisible = this.adjustedLastVisibleIndex === this.size - 1;
    const emptySpace = this._physicalTop - this._scrollPosition;
    if (lastIndexVisible && emptySpace > 0) {
      const idxAdjustment = Math.ceil(emptySpace / this._physicalAverage);
      this._virtualStart = Math.max(0, this._virtualStart - idxAdjustment);
      this._physicalStart = Math.max(0, this._physicalStart - idxAdjustment);
      super.scrollToIndex(this._virtualCount - 1);
      this.scrollTarget.scrollTop = this.scrollTarget.scrollHeight - this.scrollTarget.clientHeight;
    }
  }
  /**
   * Work around an iron-list issue with invalid item positioning.
   * See https://github.com/vaadin/flow-components/issues/4306
   * @private
   */
  __fixInvalidItemPositioning() {
    if (!this.scrollTarget.isConnected) {
      return;
    }
    const physicalTopBelowTop = this._physicalTop > this._scrollTop;
    const physicalBottomAboveBottom = this._physicalBottom < this._scrollBottom;
    const firstIndexVisible = this.adjustedFirstVisibleIndex === 0;
    const lastIndexVisible = this.adjustedLastVisibleIndex === this.size - 1;
    if (physicalTopBelowTop && !firstIndexVisible || physicalBottomAboveBottom && !lastIndexVisible) {
      const isScrollingDown = physicalBottomAboveBottom;
      const originalRatio = this._ratio;
      this._ratio = 0;
      this._scrollPosition = this._scrollTop + (isScrollingDown ? -1 : 1);
      this._scrollHandler();
      this._ratio = originalRatio;
    }
  }
  /** @private */
  __onWheel(e2) {
    if (e2.ctrlKey || this._hasScrolledAncestor(e2.target, e2.deltaX, e2.deltaY)) {
      return;
    }
    let deltaY = e2.deltaY;
    if (e2.deltaMode === WheelEvent.DOM_DELTA_LINE) {
      deltaY *= this._scrollLineHeight;
    } else if (e2.deltaMode === WheelEvent.DOM_DELTA_PAGE) {
      deltaY *= this._scrollPageHeight;
    }
    if (!this._deltaYAcc) {
      this._deltaYAcc = 0;
    }
    if (this._wheelAnimationFrame) {
      this._deltaYAcc += deltaY;
      e2.preventDefault();
      return;
    }
    deltaY += this._deltaYAcc;
    this._deltaYAcc = 0;
    this._wheelAnimationFrame = true;
    this.__debouncerWheelAnimationFrame = Debouncer$1.debounce(
      this.__debouncerWheelAnimationFrame,
      animationFrame$1,
      () => {
        this._wheelAnimationFrame = false;
      }
    );
    const momentum = Math.abs(e2.deltaX) + Math.abs(deltaY);
    if (this._canScroll(this.scrollTarget, e2.deltaX, deltaY)) {
      e2.preventDefault();
      this.scrollTarget.scrollTop += deltaY;
      this.scrollTarget.scrollLeft += e2.deltaX;
      this._hasResidualMomentum = true;
      this._ignoreNewWheel = true;
      this._debouncerIgnoreNewWheel = Debouncer$1.debounce(
        this._debouncerIgnoreNewWheel,
        timeOut$1.after(this.timeouts.IGNORE_WHEEL),
        () => {
          this._ignoreNewWheel = false;
        }
      );
    } else if (this._hasResidualMomentum && momentum <= this._previousMomentum || this._ignoreNewWheel) {
      e2.preventDefault();
    } else if (momentum > this._previousMomentum) {
      this._hasResidualMomentum = false;
    }
    this._previousMomentum = momentum;
  }
  /**
   * Determines if the element has an ancestor that handles the scroll delta prior to this
   *
   * @private
   */
  _hasScrolledAncestor(el, deltaX, deltaY) {
    if (el === this.scrollTarget || el === this.scrollTarget.getRootNode().host) {
      return false;
    } else if (this._canScroll(el, deltaX, deltaY) && ["auto", "scroll"].indexOf(getComputedStyle(el).overflow) !== -1) {
      return true;
    } else if (el !== this && el.parentElement) {
      return this._hasScrolledAncestor(el.parentElement, deltaX, deltaY);
    }
  }
  _canScroll(el, deltaX, deltaY) {
    return deltaY > 0 && el.scrollTop < el.scrollHeight - el.offsetHeight || deltaY < 0 && el.scrollTop > 0 || deltaX > 0 && el.scrollLeft < el.scrollWidth - el.offsetWidth || deltaX < 0 && el.scrollLeft > 0;
  }
  /**
   * Increases the pool size.
   * @override
   */
  _increasePoolIfNeeded(count) {
    if (this._physicalCount > 2 && count) {
      const totalItemCount = Math.ceil(this._optPhysicalSize / this._physicalAverage);
      const missingItemCount = totalItemCount - this._physicalCount;
      super._increasePoolIfNeeded(Math.max(count, Math.min(100, missingItemCount)));
    } else {
      super._increasePoolIfNeeded(count);
    }
  }
  /**
   * An optimal physical size such that we will have enough physical items
   * to fill up the viewport and recycle when the user scrolls.
   *
   * This default value assumes that we will at least have the equivalent
   * to a viewport of physical items above and below the user's viewport.
   * @override
   */
  get _optPhysicalSize() {
    const optPhysicalSize = super._optPhysicalSize;
    if (optPhysicalSize <= 0 || this.__hasPlaceholders()) {
      return optPhysicalSize;
    }
    return optPhysicalSize + this.__getItemHeightBuffer();
  }
  /**
   * Extra item height buffer used when calculating optimal physical size.
   *
   * The iron list core uses the optimal physical size when determining whether to increase the item pool.
   * For the cases where some items are much larger than the average, the iron list core might not increase item pool.
   * This can lead to the large item not being rendered.
   *
   * @returns {Number} - Extra item height buffer
   * @private
   */
  __getItemHeightBuffer() {
    if (this._physicalCount === 0) {
      return 0;
    }
    const bufferZoneHeight = Math.ceil(this._viewportHeight * (this._maxPages - 1) / 2);
    const maxItemHeight = Math.max(...this._physicalSizes);
    if (maxItemHeight > Math.min(...this._physicalSizes)) {
      return Math.max(0, maxItemHeight - bufferZoneHeight);
    }
    return 0;
  }
  /**
   * @returns {Number|undefined} - The browser's default font-size in pixels
   * @private
   */
  _getScrollLineHeight() {
    const el = document.createElement("div");
    el.style.fontSize = "initial";
    el.style.display = "none";
    document.body.appendChild(el);
    const fontSize = window.getComputedStyle(el).fontSize;
    document.body.removeChild(el);
    return fontSize ? window.parseInt(fontSize) : void 0;
  }
  __getVisibleElements() {
    return Array.from(this.elementsContainer.children).filter((element) => !element.hidden);
  }
  /** @private */
  __reorderElements() {
    if (this.__mouseDown) {
      this.__pendingReorder = true;
      return;
    }
    this.__pendingReorder = false;
    const adjustedVirtualStart = this._virtualStart + (this._vidxOffset || 0);
    const visibleElements = this.__getVisibleElements();
    const targetElement = this.__getFocusedElement(visibleElements) || visibleElements[0];
    if (!targetElement) {
      return;
    }
    const targetPhysicalIndex = targetElement.__virtualIndex - adjustedVirtualStart;
    const delta = visibleElements.indexOf(targetElement) - targetPhysicalIndex;
    if (delta > 0) {
      for (let i2 = 0; i2 < delta; i2++) {
        this.elementsContainer.appendChild(visibleElements[i2]);
      }
    } else if (delta < 0) {
      for (let i2 = visibleElements.length + delta; i2 < visibleElements.length; i2++) {
        this.elementsContainer.insertBefore(visibleElements[i2], visibleElements[0]);
      }
    }
    if (isSafari) {
      const { transform } = this.scrollTarget.style;
      this.scrollTarget.style.transform = "translateZ(0)";
      setTimeout(() => {
        this.scrollTarget.style.transform = transform;
      });
    }
  }
  /** @private */
  _adjustVirtualIndexOffset(delta) {
    const maxOffset = this._maxVirtualIndexOffset;
    if (this._virtualCount >= this.size) {
      this._vidxOffset = 0;
    } else if (this.__skipNextVirtualIndexAdjust) {
      this.__skipNextVirtualIndexAdjust = false;
    } else if (Math.abs(delta) > 1e4) {
      const scale = this._scrollTop / (this.scrollTarget.scrollHeight - this.scrollTarget.clientHeight);
      this._vidxOffset = Math.round(scale * maxOffset);
    } else {
      const oldOffset = this._vidxOffset;
      const threshold = OFFSET_ADJUST_MIN_THRESHOLD;
      const maxShift = 100;
      if (this._scrollTop === 0) {
        this._vidxOffset = 0;
        if (oldOffset !== this._vidxOffset) {
          super.scrollToIndex(0);
        }
      } else if (this.firstVisibleIndex < threshold && this._vidxOffset > 0) {
        this._vidxOffset -= Math.min(this._vidxOffset, maxShift);
        super.scrollToIndex(this.firstVisibleIndex + (oldOffset - this._vidxOffset));
      }
      if (this._scrollTop >= this._maxScrollTop && this._maxScrollTop > 0) {
        this._vidxOffset = maxOffset;
        if (oldOffset !== this._vidxOffset) {
          super.scrollToIndex(this._virtualCount - 1);
        }
      } else if (this.firstVisibleIndex > this._virtualCount - threshold && this._vidxOffset < maxOffset) {
        this._vidxOffset += Math.min(maxOffset - this._vidxOffset, maxShift);
        super.scrollToIndex(this.firstVisibleIndex - (this._vidxOffset - oldOffset));
      }
    }
  }
}
Object.setPrototypeOf(IronListAdapter.prototype, ironList);
class Virtualizer {
  /**
   * @typedef {Object} VirtualizerConfig
   * @property {Function} createElements Function that returns the given number of new elements
   * @property {Function} updateElement Function that updates the element at a specific index
   * @property {HTMLElement} scrollTarget Reference to the scrolling element
   * @property {HTMLElement} scrollContainer Reference to a wrapper for the item elements (or a slot) inside the scrollTarget
   * @property {HTMLElement | undefined} elementsContainer Reference to the container in which the item elements are placed, defaults to scrollContainer
   * @property {boolean | undefined} reorderElements Determines whether the physical item elements should be kept in order in the DOM
   * @param {VirtualizerConfig} config Configuration for the virtualizer
   */
  constructor(config) {
    this.__adapter = new IronListAdapter(config);
  }
  /**
   * Gets the index of the first visible item in the viewport.
   *
   * @return {number}
   */
  get firstVisibleIndex() {
    return this.__adapter.adjustedFirstVisibleIndex;
  }
  /**
   * Gets the index of the last visible item in the viewport.
   *
   * @return {number}
   */
  get lastVisibleIndex() {
    return this.__adapter.adjustedLastVisibleIndex;
  }
  /**
   * The size of the virtualizer
   * @return {number | undefined} The size of the virtualizer
   */
  get size() {
    return this.__adapter.size;
  }
  /**
   * The size of the virtualizer
   * @param {number} size The size of the virtualizer
   */
  set size(size) {
    this.__adapter.size = size;
  }
  /**
   * Scroll to a specific index in the virtual list
   *
   * @method scrollToIndex
   * @param {number} index The index of the item
   */
  scrollToIndex(index) {
    this.__adapter.scrollToIndex(index);
  }
  /**
   * Requests the virtualizer to re-render the item elements on an index range, if currently in the DOM
   *
   * @method update
   * @param {number | undefined} startIndex The start index of the range
   * @param {number | undefined} endIndex The end index of the range
   */
  update(startIndex = 0, endIndex = this.size - 1) {
    this.__adapter.update(startIndex, endIndex);
  }
  /**
   * Flushes active asynchronous tasks so that the component and the DOM end up in a stable state
   *
   * @method update
   * @param {number | undefined} startIndex The start index of the range
   * @param {number | undefined} endIndex The end index of the range
   */
  flush() {
    this.__adapter.flush();
  }
  /**
   * Notifies the virtualizer about its host element connected to the DOM.
   *
   * @method hostConnected
   */
  hostConnected() {
    this.__adapter.hostConnected();
  }
}
/**
 * @license
 * Copyright (c) 2015 - 2025 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const ComboBoxPlaceholder = class ComboBoxPlaceholder2 {
  toString() {
    return "";
  }
};
/**
 * @license
 * Copyright (c) 2015 - 2025 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const ComboBoxScrollerMixin = (superClass) => class ComboBoxScrollerMixin extends superClass {
  static get properties() {
    return {
      /**
       * A full set of items to filter the visible options from.
       * Set to an empty array when combo-box is not opened.
       */
      items: {
        type: Array,
        sync: true,
        observer: "__itemsChanged"
      },
      /**
       * Index of an item that has focus outline and is scrolled into view.
       * The actual focus still remains in the input field.
       */
      focusedIndex: {
        type: Number,
        sync: true,
        observer: "__focusedIndexChanged"
      },
      /**
       * Set to true while combo-box fetches new page from the data provider.
       */
      loading: {
        type: Boolean,
        sync: true,
        observer: "__loadingChanged"
      },
      /**
       * Whether the combo-box is currently opened or not. If set to false,
       * calling `scrollIntoView` does not have any effect.
       */
      opened: {
        type: Boolean,
        sync: true,
        observer: "__openedChanged"
      },
      /**
       * The selected item from the `items` array.
       */
      selectedItem: {
        type: Object,
        sync: true,
        observer: "__selectedItemChanged"
      },
      /**
       * A function used to generate CSS class names for dropdown
       * items based on the item. The return value should be the
       * generated class name as a string, or multiple class names
       * separated by whitespace characters.
       */
      itemClassNameGenerator: {
        type: Object,
        observer: "__itemClassNameGeneratorChanged"
      },
      /**
       * Path for the id of the item, used to detect whether the item is selected.
       */
      itemIdPath: {
        type: String
      },
      /**
       * Reference to the owner (combo-box owner), used by the item elements.
       */
      owner: {
        type: Object
      },
      /**
       * Function used to set a label for every combo-box item.
       */
      getItemLabel: {
        type: Object
      },
      /**
       * Function used to render the content of every combo-box item.
       */
      renderer: {
        type: Object,
        sync: true,
        observer: "__rendererChanged"
      },
      /**
       * Used to propagate the `theme` attribute from the host element.
       */
      theme: {
        type: String
      }
    };
  }
  constructor() {
    super();
    this.__boundOnItemClick = this.__onItemClick.bind(this);
  }
  /** @private */
  get _viewportTotalPaddingBottom() {
    if (this._cachedViewportTotalPaddingBottom === void 0) {
      const itemsStyle = window.getComputedStyle(this.$.selector);
      this._cachedViewportTotalPaddingBottom = [itemsStyle.paddingBottom, itemsStyle.borderBottomWidth].map((v) => {
        return parseInt(v, 10);
      }).reduce((sum, v) => {
        return sum + v;
      });
    }
    return this._cachedViewportTotalPaddingBottom;
  }
  /** @protected */
  ready() {
    super.ready();
    this.setAttribute("role", "listbox");
    this.id = `${this.localName}-${generateUniqueId()}`;
    this.__hostTagName = this.constructor.is.replace("-scroller", "");
    this.addEventListener("click", (e2) => e2.stopPropagation());
    this.__patchWheelOverScrolling();
  }
  /**
   * Updates the virtualizer's size and items.
   */
  requestContentUpdate() {
    if (!this.__virtualizer) {
      return;
    }
    if (this.items) {
      this.__virtualizer.size = this.items.length;
    }
    if (this.opened) {
      this.__virtualizer.update();
    }
  }
  /**
   * Scrolls an item at given index into view and adjusts `scrollTop`
   * so that the element gets fully visible on Arrow Down key press.
   * @param {number} index
   */
  scrollIntoView(index) {
    if (!this.__virtualizer || !(this.opened && index >= 0)) {
      return;
    }
    const visibleItemsCount = this._visibleItemsCount();
    let targetIndex = index;
    if (index > this.__virtualizer.lastVisibleIndex - 1) {
      this.__virtualizer.scrollToIndex(index);
      targetIndex = index - visibleItemsCount + 1;
    } else if (index > this.__virtualizer.firstVisibleIndex) {
      targetIndex = this.__virtualizer.firstVisibleIndex;
    }
    this.__virtualizer.scrollToIndex(Math.max(0, targetIndex));
    const lastPhysicalItem = [...this.children].find(
      (el) => !el.hidden && el.index === this.__virtualizer.lastVisibleIndex
    );
    if (!lastPhysicalItem || index !== lastPhysicalItem.index) {
      return;
    }
    const lastPhysicalItemRect = lastPhysicalItem.getBoundingClientRect();
    const scrollerRect = this.getBoundingClientRect();
    const scrollTopAdjust = lastPhysicalItemRect.bottom - scrollerRect.bottom + this._viewportTotalPaddingBottom;
    if (scrollTopAdjust > 0) {
      this.scrollTop += scrollTopAdjust;
    }
  }
  /**
   * @param {string | object} item
   * @param {string | object} selectedItem
   * @param {string} itemIdPath
   * @protected
   */
  _isItemSelected(item2, selectedItem, itemIdPath) {
    if (item2 instanceof ComboBoxPlaceholder) {
      return false;
    } else if (itemIdPath && item2 !== void 0 && selectedItem !== void 0) {
      return get$2(itemIdPath, item2) === get$2(itemIdPath, selectedItem);
    }
    return item2 === selectedItem;
  }
  /** @private */
  __initVirtualizer() {
    this.__virtualizer = new Virtualizer({
      createElements: this.__createElements.bind(this),
      updateElement: this._updateElement.bind(this),
      elementsContainer: this,
      scrollTarget: this,
      scrollContainer: this.$.selector,
      reorderElements: true
    });
  }
  /** @private */
  __itemsChanged(items) {
    if (items && this.__virtualizer) {
      this.requestContentUpdate();
    }
  }
  /** @private */
  __loadingChanged() {
    this.requestContentUpdate();
  }
  /** @private */
  __openedChanged(opened) {
    if (opened) {
      if (!this.__virtualizer) {
        this.__initVirtualizer();
      }
      this.requestContentUpdate();
    }
  }
  /** @private */
  __selectedItemChanged() {
    this.requestContentUpdate();
  }
  /** @private */
  __itemClassNameGeneratorChanged(generator, oldGenerator) {
    if (generator || oldGenerator) {
      this.requestContentUpdate();
    }
  }
  /** @private */
  __focusedIndexChanged(index, oldIndex) {
    if (index !== oldIndex) {
      this.requestContentUpdate();
    }
    if (index >= 0 && !this.loading) {
      this.scrollIntoView(index);
    }
  }
  /** @private */
  __rendererChanged(renderer, oldRenderer) {
    if (renderer || oldRenderer) {
      this.requestContentUpdate();
    }
  }
  /** @private */
  __createElements(count) {
    return [...Array(count)].map(() => {
      const item2 = document.createElement(`${this.__hostTagName}-item`);
      item2.addEventListener("click", this.__boundOnItemClick);
      item2.tabIndex = "-1";
      item2.style.width = "100%";
      return item2;
    });
  }
  /**
   * @param {HTMLElement} el
   * @param {number} index
   * @protected
   */
  _updateElement(el, index) {
    const item2 = this.items[index];
    const focusedIndex = this.focusedIndex;
    const selected = this._isItemSelected(item2, this.selectedItem, this.itemIdPath);
    el.setProperties({
      item: item2,
      index,
      label: this.getItemLabel(item2),
      selected,
      renderer: this.renderer,
      focused: !this.loading && focusedIndex === index
    });
    if (typeof this.itemClassNameGenerator === "function") {
      el.className = this.itemClassNameGenerator(item2);
    } else if (el.className !== "") {
      el.className = "";
    }
    el.id = `${this.__hostTagName}-item-${index}`;
    el.setAttribute("role", index !== void 0 ? "option" : false);
    el.setAttribute("aria-selected", selected.toString());
    el.setAttribute("aria-posinset", index + 1);
    el.setAttribute("aria-setsize", this.items.length);
    if (this.theme) {
      el.setAttribute("theme", this.theme);
    } else {
      el.removeAttribute("theme");
    }
    if (item2 instanceof ComboBoxPlaceholder) {
      this.__requestItemByIndex(index);
    }
  }
  /** @private */
  __onItemClick(e2) {
    this.dispatchEvent(new CustomEvent("selection-changed", { detail: { item: e2.currentTarget.item } }));
  }
  /**
   * We want to prevent the kinetic scrolling energy from being transferred from the overlay contents over to the parent.
   * Further improvement ideas: after the contents have been scrolled to the top or bottom and scrolling has stopped, it could allow
   * scrolling the parent similarly to touch scrolling.
   * @private
   */
  __patchWheelOverScrolling() {
    this.$.selector.addEventListener("wheel", (e2) => {
      const scrolledToTop = this.scrollTop === 0;
      const scrolledToBottom = this.scrollHeight - this.scrollTop - this.clientHeight <= 1;
      if (scrolledToTop && e2.deltaY < 0) {
        e2.preventDefault();
      } else if (scrolledToBottom && e2.deltaY > 0) {
        e2.preventDefault();
      }
    });
  }
  /**
   * Dispatches an `index-requested` event for the given index to notify
   * the data provider that it should start loading the page containing the requested index.
   *
   * The event is dispatched asynchronously to prevent an immediate page request and therefore
   * a possible infinite recursion in case the data provider implements page request cancelation logic
   * by invoking data provider page callbacks with an empty array.
   * The infinite recursion may occur otherwise since invoking a data provider page callback with an empty array
   * triggers a synchronous scroller update and, if the callback corresponds to the currently visible page,
   * the scroller will synchronously request the page again which may lead to looping in the end.
   * That was the case for the Flow counterpart:
   * https://github.com/vaadin/flow-components/issues/3553#issuecomment-1239344828
   * @private
   */
  __requestItemByIndex(index) {
    requestAnimationFrame(() => {
      this.dispatchEvent(
        new CustomEvent("index-requested", {
          detail: {
            index
          }
        })
      );
    });
  }
  /** @private */
  _visibleItemsCount() {
    this.__virtualizer.scrollToIndex(this.__virtualizer.firstVisibleIndex);
    const hasItems = this.__virtualizer.size > 0;
    return hasItems ? this.__virtualizer.lastVisibleIndex - this.__virtualizer.firstVisibleIndex + 1 : 0;
  }
};
/**
 * @license
 * Copyright (c) 2015 - 2025 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
class ComboBoxScroller extends ComboBoxScrollerMixin(PolymerElement) {
  static get is() {
    return "vaadin-combo-box-scroller";
  }
  static get template() {
    return html`
      <style>
        :host {
          display: block;
          min-height: 1px;
          overflow: auto;

          /* Fixes item background from getting on top of scrollbars on Safari */
          transform: translate3d(0, 0, 0);

          /* Enable momentum scrolling on iOS */
          -webkit-overflow-scrolling: touch;

          /* Fixes scrollbar disappearing when 'Show scroll bars: Always' enabled in Safari */
          box-shadow: 0 0 0 white;
        }

        #selector {
          border-width: var(--_vaadin-combo-box-items-container-border-width);
          border-style: var(--_vaadin-combo-box-items-container-border-style);
          border-color: var(--_vaadin-combo-box-items-container-border-color, transparent);
          position: relative;
        }
      </style>
      <div id="selector">
        <slot></slot>
      </div>
    `;
  }
}
defineCustomElement(ComboBoxScroller);
/**
 * @license
 * Copyright (c) 2021 - 2025 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const ClearButtonMixin = (superclass) => class ClearButtonMixinClass extends InputMixin(KeyboardMixin(superclass)) {
  static get properties() {
    return {
      /**
       * Set to true to display the clear icon which clears the input.
       *
       * It is up to the component to choose where to place the clear icon:
       * in the Shadow DOM or in the light DOM. In any way, a reference to
       * the clear icon element should be provided via the `clearElement` getter.
       *
       * @attr {boolean} clear-button-visible
       */
      clearButtonVisible: {
        type: Boolean,
        reflectToAttribute: true,
        value: false
      }
    };
  }
  /**
   * Any element extending this mixin is required to implement this getter.
   * It returns the reference to the clear button element.
   *
   * @protected
   * @return {Element | null | undefined}
   */
  get clearElement() {
    console.warn(`Please implement the 'clearElement' property in <${this.localName}>`);
    return null;
  }
  /** @protected */
  ready() {
    super.ready();
    if (this.clearElement) {
      this.clearElement.addEventListener("mousedown", (event) => this._onClearButtonMouseDown(event));
      this.clearElement.addEventListener("click", (event) => this._onClearButtonClick(event));
    }
  }
  /**
   * @param {Event} event
   * @protected
   */
  _onClearButtonClick(event) {
    event.preventDefault();
    this._onClearAction();
  }
  /**
   * @param {MouseEvent} event
   * @protected
   */
  _onClearButtonMouseDown(event) {
    event.preventDefault();
    if (!isTouch) {
      this.inputElement.focus();
    }
  }
  /**
   * Override an event listener inherited from `KeydownMixin` to clear on Esc.
   * Components that extend this mixin can prevent this behavior by overriding
   * this method without calling `super._onEscape` to provide custom logic.
   *
   * @param {KeyboardEvent} event
   * @protected
   * @override
   */
  _onEscape(event) {
    super._onEscape(event);
    if (this.clearButtonVisible && !!this.value && !this.readonly) {
      event.stopPropagation();
      this._onClearAction();
    }
  }
  /**
   * Clears the value and dispatches `input` and `change` events
   * on the input element. This method should be called
   * when the clear action originates from the user.
   *
   * @protected
   */
  _onClearAction() {
    this._inputElementValue = "";
    this.inputElement.dispatchEvent(new Event("input", { bubbles: true, composed: true }));
    this.inputElement.dispatchEvent(new Event("change", { bubbles: true }));
  }
};
/**
 * @license
 * Copyright (c) 2021 - 2025 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const InputConstraintsMixin = dedupingMixin(
  (superclass) => class InputConstraintsMixinClass extends DelegateStateMixin(ValidateMixin(InputMixin(superclass))) {
    /**
     * An array of attributes which participate in the input validation.
     * Changing these attributes will cause the input to re-validate.
     *
     * IMPORTANT: The attributes should be properly delegated to the input element
     * from the host using `delegateAttrs` getter (see `DelegateStateMixin`).
     * The `required` attribute is already delegated.
     */
    static get constraints() {
      return ["required"];
    }
    static get delegateAttrs() {
      return [...super.delegateAttrs, "required"];
    }
    /** @protected */
    ready() {
      super.ready();
      this._createConstraintsObserver();
    }
    /**
     * Returns true if the current input value satisfies all constraints (if any).
     * @return {boolean}
     */
    checkValidity() {
      if (this.inputElement && this._hasValidConstraints(this.constructor.constraints.map((c2) => this[c2]))) {
        return this.inputElement.checkValidity();
      }
      return !this.invalid;
    }
    /**
     * Returns true if some of the provided set of constraints are valid.
     * @param {Array} constraints
     * @return {boolean}
     * @protected
     */
    _hasValidConstraints(constraints) {
      return constraints.some((c2) => this.__isValidConstraint(c2));
    }
    /**
     * Override this method to customize setting up constraints observer.
     * @protected
     */
    _createConstraintsObserver() {
      this._createMethodObserver(`_constraintsChanged(stateTarget, ${this.constructor.constraints.join(", ")})`);
    }
    /**
     * Override this method to implement custom validation constraints.
     * @param {HTMLElement | undefined} stateTarget
     * @param {unknown[]} constraints
     * @protected
     */
    _constraintsChanged(stateTarget, ...constraints) {
      if (!stateTarget) {
        return;
      }
      const hasConstraints = this._hasValidConstraints(constraints);
      const isLastConstraintRemoved = this.__previousHasConstraints && !hasConstraints;
      if ((this._hasValue || this.invalid) && hasConstraints) {
        this._requestValidation();
      } else if (isLastConstraintRemoved && !this.manualValidation) {
        this._setInvalid(false);
      }
      this.__previousHasConstraints = hasConstraints;
    }
    /**
     * Override an event listener inherited from `InputMixin`
     * to capture native `change` event and make sure that
     * a new one is dispatched after validation runs.
     * @param {Event} event
     * @protected
     * @override
     */
    _onChange(event) {
      event.stopPropagation();
      this._requestValidation();
      this.dispatchEvent(
        new CustomEvent("change", {
          detail: {
            sourceEvent: event
          },
          bubbles: event.bubbles,
          cancelable: event.cancelable
        })
      );
    }
    /** @private */
    __isValidConstraint(constraint) {
      return Boolean(constraint) || constraint === 0;
    }
  }
);
/**
 * @license
 * Copyright (c) 2021 - 2025 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const InputControlMixin = (superclass) => class InputControlMixinClass extends SlotStylesMixin(
  DelegateFocusMixin(InputConstraintsMixin(FieldMixin(ClearButtonMixin(KeyboardMixin(superclass)))))
) {
  static get properties() {
    return {
      /**
       * A pattern matched against individual characters the user inputs.
       *
       * When set, the field will prevent:
       * - `keydown` events if the entered key doesn't match `/^allowedCharPattern$/`
       * - `paste` events if the pasted text doesn't match `/^allowedCharPattern*$/`
       * - `drop` events if the dropped text doesn't match `/^allowedCharPattern*$/`
       *
       * For example, to allow entering only numbers and minus signs, use:
       * `allowedCharPattern = "[\\d-]"`
       * @attr {string} allowed-char-pattern
       */
      allowedCharPattern: {
        type: String,
        observer: "_allowedCharPatternChanged"
      },
      /**
       * If true, the input text gets fully selected when the field is focused using click or touch / tap.
       */
      autoselect: {
        type: Boolean,
        value: false
      },
      /**
       * The name of this field.
       */
      name: {
        type: String,
        reflectToAttribute: true
      },
      /**
       * A hint to the user of what can be entered in the field.
       */
      placeholder: {
        type: String,
        reflectToAttribute: true
      },
      /**
       * When present, it specifies that the field is read-only.
       */
      readonly: {
        type: Boolean,
        value: false,
        reflectToAttribute: true
      },
      /**
       * The text usually displayed in a tooltip popup when the mouse is over the field.
       */
      title: {
        type: String,
        reflectToAttribute: true
      }
    };
  }
  static get delegateAttrs() {
    return [...super.delegateAttrs, "name", "type", "placeholder", "readonly", "invalid", "title"];
  }
  constructor() {
    super();
    this._boundOnPaste = this._onPaste.bind(this);
    this._boundOnDrop = this._onDrop.bind(this);
    this._boundOnBeforeInput = this._onBeforeInput.bind(this);
  }
  /** @protected */
  get slotStyles() {
    return [
      `
          :is(input[slot='input'], textarea[slot='textarea'])::placeholder {
            font: inherit;
            color: inherit;
          }
        `
    ];
  }
  /**
   * Override an event listener from `DelegateFocusMixin`.
   * @param {FocusEvent} event
   * @protected
   * @override
   */
  _onFocus(event) {
    super._onFocus(event);
    if (this.autoselect && this.inputElement) {
      this.inputElement.select();
    }
  }
  /**
   * Override a method from `InputMixin`.
   * @param {!HTMLElement} input
   * @protected
   * @override
   */
  _addInputListeners(input) {
    super._addInputListeners(input);
    input.addEventListener("paste", this._boundOnPaste);
    input.addEventListener("drop", this._boundOnDrop);
    input.addEventListener("beforeinput", this._boundOnBeforeInput);
  }
  /**
   * Override a method from `InputMixin`.
   * @param {!HTMLElement} input
   * @protected
   * @override
   */
  _removeInputListeners(input) {
    super._removeInputListeners(input);
    input.removeEventListener("paste", this._boundOnPaste);
    input.removeEventListener("drop", this._boundOnDrop);
    input.removeEventListener("beforeinput", this._boundOnBeforeInput);
  }
  /**
   * Override an event listener from `KeyboardMixin`.
   * @param {!KeyboardEvent} event
   * @protected
   * @override
   */
  _onKeyDown(event) {
    super._onKeyDown(event);
    if (this.allowedCharPattern && !this.__shouldAcceptKey(event) && event.target === this.inputElement) {
      event.preventDefault();
      this._markInputPrevented();
    }
  }
  /** @protected */
  _markInputPrevented() {
    this.setAttribute("input-prevented", "");
    this._preventInputDebouncer = Debouncer$1.debounce(this._preventInputDebouncer, timeOut$1.after(200), () => {
      this.removeAttribute("input-prevented");
    });
  }
  /** @private */
  __shouldAcceptKey(event) {
    return event.metaKey || event.ctrlKey || !event.key || // Allow typing anything if event.key is not supported
    event.key.length !== 1 || // Allow "Backspace", "ArrowLeft" etc.
    this.__allowedCharRegExp.test(event.key);
  }
  /** @private */
  _onPaste(e2) {
    if (this.allowedCharPattern) {
      const pastedText = e2.clipboardData.getData("text");
      if (!this.__allowedTextRegExp.test(pastedText)) {
        e2.preventDefault();
        this._markInputPrevented();
      }
    }
  }
  /** @private */
  _onDrop(e2) {
    if (this.allowedCharPattern) {
      const draggedText = e2.dataTransfer.getData("text");
      if (!this.__allowedTextRegExp.test(draggedText)) {
        e2.preventDefault();
        this._markInputPrevented();
      }
    }
  }
  /** @private */
  _onBeforeInput(e2) {
    if (this.allowedCharPattern && e2.data && !this.__allowedTextRegExp.test(e2.data)) {
      e2.preventDefault();
      this._markInputPrevented();
    }
  }
  /** @private */
  _allowedCharPatternChanged(charPattern) {
    if (charPattern) {
      try {
        this.__allowedCharRegExp = new RegExp(`^${charPattern}$`, "u");
        this.__allowedTextRegExp = new RegExp(`^${charPattern}*$`, "u");
      } catch (e2) {
        console.error(e2);
      }
    }
  }
  /**
   * Fired when the user commits a value change.
   *
   * @event change
   */
  /**
   * Fired when the value is changed by the user: on every typing keystroke,
   * and the value is cleared using the clear button.
   *
   * @event input
   */
};
/**
 * @license
 * Copyright (c) 2021 - 2025 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const PatternMixin = (superclass) => class PatternMixinClass extends InputConstraintsMixin(superclass) {
  static get properties() {
    return {
      /**
       * A regular expression that the value is checked against.
       * The pattern must match the entire value, not just some subset.
       */
      pattern: {
        type: String
      }
    };
  }
  static get delegateAttrs() {
    return [...super.delegateAttrs, "pattern"];
  }
  static get constraints() {
    return [...super.constraints, "pattern"];
  }
};
/**
 * @license
 * Copyright (c) 2021 - 2025 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const clearButton = css`
  [part='clear-button'] {
    display: none;
    cursor: default;
  }

  [part='clear-button']::before {
    content: '\\2715';
  }

  :host([clear-button-visible][has-value]:not([disabled]):not([readonly])) [part='clear-button'] {
    display: block;
  }
`;
/**
 * @license
 * Copyright (c) 2021 - 2025 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const fieldShared = css`
  :host {
    display: inline-flex;
    outline: none;
  }

  :host::before {
    content: '\\2003';
    width: 0;
    display: inline-block;
    /* Size and position this element on the same vertical position as the input-field element
          to make vertical align for the host element work as expected */
  }

  :host([hidden]) {
    display: none !important;
  }

  :host(:not([has-label])) [part='label'] {
    display: none;
  }

  @media (forced-colors: active) {
    :host(:not([readonly])) [part='input-field'] {
      outline: 1px solid;
      outline-offset: -1px;
    }
    :host([focused]) [part='input-field'] {
      outline-width: 2px;
    }
    :host([disabled]) [part='input-field'] {
      outline-color: GrayText;
    }
  }
`;
/**
 * @license
 * Copyright (c) 2021 - 2025 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const inputFieldContainer = css`
  [class$='container'] {
    display: flex;
    flex-direction: column;
    min-width: 100%;
    max-width: 100%;
    width: var(--vaadin-field-default-width, 12em);
  }
`;
/**
 * @license
 * Copyright (c) 2021 - 2025 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const inputFieldShared = [fieldShared, inputFieldContainer, clearButton];
/**
 * @license
 * Copyright (c) 2021 - 2025 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
function getFlatIndexContext(cache, flatIndex, level = 0) {
  let levelIndex = flatIndex;
  for (const subCache of cache.subCaches) {
    const index = subCache.parentCacheIndex;
    if (levelIndex <= index) {
      break;
    } else if (levelIndex <= index + subCache.flatSize) {
      return getFlatIndexContext(subCache, levelIndex - index - 1, level + 1);
    }
    levelIndex -= subCache.flatSize;
  }
  return {
    cache,
    item: cache.items[levelIndex],
    index: levelIndex,
    page: Math.floor(levelIndex / cache.pageSize),
    level
  };
}
function getItemContext({ getItemId }, cache, targetItem, level = 0, levelFlatIndex = 0) {
  for (let index = 0; index < cache.items.length; index++) {
    const item2 = cache.items[index];
    if (!!item2 && getItemId(item2) === getItemId(targetItem)) {
      return {
        cache,
        level,
        item: item2,
        index,
        page: Math.floor(index / cache.pageSize),
        subCache: cache.getSubCache(index),
        flatIndex: levelFlatIndex + cache.getFlatIndex(index)
      };
    }
  }
  for (const subCache of cache.subCaches) {
    const parentItemFlatIndex = levelFlatIndex + cache.getFlatIndex(subCache.parentCacheIndex);
    const result = getItemContext({ getItemId }, subCache, targetItem, level + 1, parentItemFlatIndex + 1);
    if (result) {
      return result;
    }
  }
}
function getFlatIndexByPath(cache, [levelIndex, ...subIndexes], flatIndex = 0) {
  if (levelIndex === Infinity) {
    levelIndex = cache.size - 1;
  }
  const flatIndexOnLevel = cache.getFlatIndex(levelIndex);
  const subCache = cache.getSubCache(levelIndex);
  if (subCache && subCache.flatSize > 0 && subIndexes.length) {
    return getFlatIndexByPath(subCache, subIndexes, flatIndex + flatIndexOnLevel + 1);
  }
  return flatIndex + flatIndexOnLevel;
}
/**
 * @license
 * Copyright (c) 2021 - 2025 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
class Cache {
  /**
   * A context object.
   *
   * @type {{ isExpanded: (item: unknown) => boolean }}
   */
  context;
  /**
   * The number of items to display per page.
   *
   * @type {number}
   */
  pageSize;
  /**
   * An array of cached items.
   *
   * @type {object[]}
   */
  items = [];
  /**
   * A map where the key is a requested page and the value is a callback
   * that will be called with data once the request is complete.
   *
   * @type {Record<number, Function>}
   */
  pendingRequests = {};
  /**
   * A map where the key is the index of an item in the `items` array
   * and the value is a sub-cache associated with that item.
   *
   * Note, it's intentionally defined as an object instead of a Map
   * to ensure that Object.entries() returns an array with keys sorted
   * in alphabetical order, rather than the order they were added.
   *
   * @type {Record<number, Cache>}
   * @private
   */
  __subCacheByIndex = {};
  /**
   * The number of items.
   *
   * @type {number}
   * @private
   */
  __size = 0;
  /**
   * The total number of items, including items from expanded sub-caches.
   *
   * @type {number}
   * @private
   */
  __flatSize = 0;
  /**
   * @param {Cache['context']} context
   * @param {number} pageSize
   * @param {number | undefined} size
   * @param {Cache | undefined} parentCache
   * @param {number | undefined} parentCacheIndex
   */
  constructor(context, pageSize, size, parentCache, parentCacheIndex) {
    this.context = context;
    this.pageSize = pageSize;
    this.size = size;
    this.parentCache = parentCache;
    this.parentCacheIndex = parentCacheIndex;
    this.__flatSize = size || 0;
  }
  /**
   * An item in the parent cache that the current cache is associated with.
   *
   * @return {object | undefined}
   */
  get parentItem() {
    return this.parentCache && this.parentCache.items[this.parentCacheIndex];
  }
  /**
   * An array of sub-caches sorted in the same order as their associated items
   * appear in the `items` array.
   *
   * @return {Cache[]}
   */
  get subCaches() {
    return Object.values(this.__subCacheByIndex);
  }
  /**
   * Whether the cache or any of its descendant caches have pending requests.
   *
   * @return {boolean}
   */
  get isLoading() {
    if (Object.keys(this.pendingRequests).length > 0) {
      return true;
    }
    return this.subCaches.some((subCache) => subCache.isLoading);
  }
  /**
   * The total number of items, including items from expanded sub-caches.
   *
   * @return {number}
   */
  get flatSize() {
    return this.__flatSize;
  }
  /**
   * The total number of items, including items from expanded sub-caches.
   *
   * @protected
   * @deprecated since 24.3 and will be removed in Vaadin 25.
   */
  get effectiveSize() {
    console.warn(
      "<vaadin-grid> The `effectiveSize` property of ItemCache is deprecated and will be removed in Vaadin 25."
    );
    return this.flatSize;
  }
  /**
   * The number of items.
   *
   * @return {number}
   */
  get size() {
    return this.__size;
  }
  /**
   * Sets the number of items.
   *
   * @param {number} size
   */
  set size(size) {
    const oldSize = this.__size;
    if (oldSize === size) {
      return;
    }
    this.__size = size;
    if (this.context.placeholder !== void 0) {
      this.items.length = size || 0;
      for (let i2 = 0; i2 < size || 0; i2++) {
        this.items[i2] ||= this.context.placeholder;
      }
    }
    Object.keys(this.pendingRequests).forEach((page) => {
      const startIndex = parseInt(page) * this.pageSize;
      if (startIndex >= this.size || 0) {
        delete this.pendingRequests[page];
      }
    });
  }
  /**
   * Recalculates the flattened size for the cache and its descendant caches recursively.
   */
  recalculateFlatSize() {
    this.__flatSize = !this.parentItem || this.context.isExpanded(this.parentItem) ? this.size + this.subCaches.reduce((total, subCache) => {
      subCache.recalculateFlatSize();
      return total + subCache.flatSize;
    }, 0) : 0;
  }
  /**
   * Adds an array of items corresponding to the given page
   * to the `items` array.
   *
   * @param {number} page
   * @param {object[]} items
   */
  setPage(page, items) {
    const startIndex = page * this.pageSize;
    items.forEach((item2, i2) => {
      const itemIndex = startIndex + i2;
      if (this.size === void 0 || itemIndex < this.size) {
        this.items[itemIndex] = item2;
      }
    });
  }
  /**
   * Retrieves the sub-cache associated with the item at the given index
   * in the `items` array.
   *
   * @param {number} index
   * @return {Cache | undefined}
   */
  getSubCache(index) {
    return this.__subCacheByIndex[index];
  }
  /**
   * Removes the sub-cache associated with the item at the given index
   * in the `items` array.
   *
   * @param {number} index
   */
  removeSubCache(index) {
    delete this.__subCacheByIndex[index];
  }
  /**
   * Removes all sub-caches.
   */
  removeSubCaches() {
    this.__subCacheByIndex = {};
  }
  /**
   * Creates and associates a sub-cache for the item at the given index
   * in the `items` array.
   *
   * @param {number} index
   * @return {Cache}
   */
  createSubCache(index) {
    const subCache = new Cache(this.context, this.pageSize, 0, this, index);
    this.__subCacheByIndex[index] = subCache;
    return subCache;
  }
  /**
   * Retrieves the flattened index corresponding to the given index
   * of an item in the `items` array.
   *
   * @param {number} index
   * @return {number}
   */
  getFlatIndex(index) {
    const clampedIndex = Math.max(0, Math.min(this.size - 1, index));
    return this.subCaches.reduce((prev, subCache) => {
      const index2 = subCache.parentCacheIndex;
      return clampedIndex > index2 ? prev + subCache.flatSize : prev;
    }, clampedIndex);
  }
  /**
   * @deprecated since 24.3 and will be removed in Vaadin 25.
   */
  getItemForIndex(index) {
    console.warn(
      "<vaadin-grid> The `getItemForIndex` method of ItemCache is deprecated and will be removed in Vaadin 25."
    );
    const { item: item2 } = getFlatIndexContext(this, index);
    return item2;
  }
  /**
   * @deprecated since 24.3 and will be removed in Vaadin 25.
   */
  getCacheAndIndex(index) {
    console.warn(
      "<vaadin-grid> The `getCacheAndIndex` method of ItemCache is deprecated and will be removed in Vaadin 25."
    );
    const { cache, index: scaledIndex } = getFlatIndexContext(this, index);
    return { cache, scaledIndex };
  }
  /**
   * @deprecated since 24.3 and will be removed in Vaadin 25.
   */
  updateSize() {
    console.warn("<vaadin-grid> The `updateSize` method of ItemCache is deprecated and will be removed in Vaadin 25.");
    this.recalculateFlatSize();
  }
  /**
   * @deprecated since 24.3 and will be removed in Vaadin 25.
   */
  ensureSubCacheForScaledIndex(scaledIndex) {
    console.warn(
      "<vaadin-grid> The `ensureSubCacheForScaledIndex` method of ItemCache is deprecated and will be removed in Vaadin 25."
    );
    if (!this.getSubCache(scaledIndex)) {
      const subCache = this.createSubCache(scaledIndex);
      this.context.__controller.__loadCachePage(subCache, 0);
    }
  }
  /**
   * @deprecated since 24.3 and will be removed in Vaadin 25.
   */
  get grid() {
    console.warn("<vaadin-grid> The `grid` property of ItemCache is deprecated and will be removed in Vaadin 25.");
    return this.context.__controller.host;
  }
  /**
   * @deprecated since 24.3 and will be removed in Vaadin 25.
   */
  get itemCaches() {
    console.warn(
      "<vaadin-grid> The `itemCaches` property of ItemCache is deprecated and will be removed in Vaadin 25."
    );
    return this.__subCacheByIndex;
  }
}
/**
 * @license
 * Copyright (c) 2021 - 2025 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
class DataProviderController extends EventTarget {
  /**
   * The controller host element.
   *
   * @param {HTMLElement}
   */
  host;
  /**
   * A callback that returns data based on the passed params such as
   * `page`, `pageSize`, `parentItem`, etc.
   */
  dataProvider;
  /**
   * A callback that returns additional params that need to be passed
   * to the data provider callback with every request.
   */
  dataProviderParams;
  /**
   * A number of items to display per page.
   *
   * @type {number}
   */
  pageSize;
  /**
   * A callback that returns whether the given item is expanded.
   *
   * @type {(item: unknown) => boolean}
   */
  isExpanded;
  /**
   * A callback that returns the id for the given item and that
   * is used when checking object items for equality.
   *
   * @type { (item: unknown) => unknown}
   */
  getItemId;
  /**
   * A reference to the root cache instance.
   *
   * @param {Cache}
   */
  rootCache;
  /**
   * A placeholder item that is used to indicate that the item is not loaded yet.
   *
   * @type {unknown}
   */
  placeholder;
  /**
   * A callback that returns whether the given item is a placeholder.
   *
   * @type {(item: unknown) => boolean}
   */
  isPlaceholder;
  constructor(host, { size, pageSize, isExpanded, getItemId, isPlaceholder, placeholder, dataProvider, dataProviderParams }) {
    super();
    this.host = host;
    this.pageSize = pageSize;
    this.getItemId = getItemId;
    this.isExpanded = isExpanded;
    this.placeholder = placeholder;
    this.isPlaceholder = isPlaceholder;
    this.dataProvider = dataProvider;
    this.dataProviderParams = dataProviderParams;
    this.rootCache = this.__createRootCache(size);
  }
  /**
   * The total number of items, including items from expanded sub-caches.
   */
  get flatSize() {
    return this.rootCache.flatSize;
  }
  /** @private */
  get __cacheContext() {
    return {
      isExpanded: this.isExpanded,
      placeholder: this.placeholder,
      // The controller instance is needed to ensure deprecated cache methods work.
      __controller: this
    };
  }
  /**
   * Whether the root cache or any of its decendant caches have pending requests.
   *
   * @return {boolean}
   */
  isLoading() {
    return this.rootCache.isLoading;
  }
  /**
   * Sets the page size and clears the cache.
   *
   * @param {number} pageSize
   */
  setPageSize(pageSize) {
    this.pageSize = pageSize;
    this.clearCache();
  }
  /**
   * Sets the data provider callback and clears the cache.
   *
   * @type {Function}
   */
  setDataProvider(dataProvider) {
    this.dataProvider = dataProvider;
    this.clearCache();
  }
  /**
   * Recalculates the flattened size.
   */
  recalculateFlatSize() {
    this.rootCache.recalculateFlatSize();
  }
  /**
   * Clears the cache.
   */
  clearCache() {
    this.rootCache = this.__createRootCache(this.rootCache.size);
  }
  /**
   * Returns context for the given flattened index, including:
   * - the corresponding cache
   * - the cache level
   * - the corresponding item (if loaded)
   * - the item's index in the cache's items array
   * - the page containing the item
   *
   * @param {number} flatIndex
   */
  getFlatIndexContext(flatIndex) {
    return getFlatIndexContext(this.rootCache, flatIndex);
  }
  /**
   * Returns context for the given item, including:
   * - the cache containing the item
   * - the cache level
   * - the item
   * - the item's index in the cache's items array
   * - the item's flattened index
   * - the item's sub-cache (if exists)
   * - the page containing the item
   *
   * If the item isn't found, the method returns undefined.
   */
  getItemContext(item2) {
    return getItemContext({ getItemId: this.getItemId }, this.rootCache, item2);
  }
  /**
   * Returns the flattened index for the item that the given indexes point to.
   * Each index in the path array points to a sub-item of the previous index.
   * Using `Infinity` as an index will point to the last item on the level.
   *
   * @param {number[]} path
   * @return {number}
   */
  getFlatIndexByPath(path) {
    return getFlatIndexByPath(this.rootCache, path);
  }
  /**
   * Requests the data provider to load the page with the item corresponding
   * to the given flattened index. If the item is already loaded, the method
   * returns immediatelly.
   *
   * @param {number} flatIndex
   */
  ensureFlatIndexLoaded(flatIndex) {
    const { cache, page, item: item2 } = this.getFlatIndexContext(flatIndex);
    if (!this.__isItemLoaded(item2)) {
      this.__loadCachePage(cache, page);
    }
  }
  /**
   * Creates a sub-cache for the item corresponding to the given flattened index and
   * requests the data provider to load the first page into the created sub-cache.
   * If the sub-cache already exists, the method returns immediatelly.
   *
   * @param {number} flatIndex
   */
  ensureFlatIndexHierarchy(flatIndex) {
    const { cache, item: item2, index } = this.getFlatIndexContext(flatIndex);
    if (this.__isItemLoaded(item2) && this.isExpanded(item2) && !cache.getSubCache(index)) {
      const subCache = cache.createSubCache(index);
      this.__loadCachePage(subCache, 0);
    }
  }
  /**
   * Loads the first page into the root cache.
   */
  loadFirstPage() {
    this.__loadCachePage(this.rootCache, 0);
  }
  /** @private */
  __createRootCache(size) {
    return new Cache(this.__cacheContext, this.pageSize, size);
  }
  /** @private */
  __loadCachePage(cache, page) {
    if (!this.dataProvider || cache.pendingRequests[page]) {
      return;
    }
    let params = {
      page,
      pageSize: this.pageSize,
      parentItem: cache.parentItem
    };
    if (this.dataProviderParams) {
      params = { ...params, ...this.dataProviderParams() };
    }
    const callback = (items, size) => {
      if (cache.pendingRequests[page] !== callback) {
        return;
      }
      if (size !== void 0) {
        cache.size = size;
      } else if (params.parentItem) {
        cache.size = items.length;
      }
      cache.setPage(page, items);
      this.recalculateFlatSize();
      this.dispatchEvent(new CustomEvent("page-received"));
      delete cache.pendingRequests[page];
      this.dispatchEvent(new CustomEvent("page-loaded"));
    };
    cache.pendingRequests[page] = callback;
    this.dispatchEvent(new CustomEvent("page-requested"));
    this.dataProvider(params, callback);
  }
  /** @private */
  __isItemLoaded(item2) {
    if (this.isPlaceholder) {
      return !this.isPlaceholder(item2);
    } else if (this.placeholder) {
      return item2 !== this.placeholder;
    }
    return !!item2;
  }
}
/**
 * @license
 * Copyright (c) 2015 - 2025 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const ComboBoxDataProviderMixin = (superClass) => class DataProviderMixin extends superClass {
  static get properties() {
    return {
      /**
       * Number of items fetched at a time from the dataprovider.
       * @attr {number} page-size
       * @type {number}
       */
      pageSize: {
        type: Number,
        value: 50,
        observer: "_pageSizeChanged",
        sync: true
      },
      /**
       * Total number of items.
       * @type {number | undefined}
       */
      size: {
        type: Number,
        observer: "_sizeChanged",
        sync: true
      },
      /**
       * Function that provides items lazily. Receives arguments `params`, `callback`
       *
       * `params.page` Requested page index
       *
       * `params.pageSize` Current page size
       *
       * `params.filter` Currently applied filter
       *
       * `callback(items, size)` Callback function with arguments:
       *   - `items` Current page of items
       *   - `size` Total number of items.
       * @type {ComboBoxDataProvider | undefined}
       */
      dataProvider: {
        type: Object,
        observer: "_dataProviderChanged",
        sync: true
      },
      /** @private */
      __dataProviderInitialized: {
        type: Boolean,
        value: false
      },
      /** @private */
      __previousDataProviderFilter: {
        type: String
      }
    };
  }
  static get observers() {
    return [
      "_dataProviderFilterChanged(filter)",
      "_warnDataProviderValue(dataProvider, value)",
      "_ensureFirstPage(opened)"
    ];
  }
  constructor() {
    super();
    this.__dataProviderController = new DataProviderController(this, {
      placeholder: new ComboBoxPlaceholder(),
      isPlaceholder: (item2) => item2 instanceof ComboBoxPlaceholder,
      dataProviderParams: () => ({ filter: this.filter })
    });
    this.__dataProviderController.addEventListener("page-requested", this.__onDataProviderPageRequested.bind(this));
    this.__dataProviderController.addEventListener("page-loaded", this.__onDataProviderPageLoaded.bind(this));
  }
  /** @protected */
  ready() {
    super.ready();
    this._scroller.addEventListener("index-requested", (e2) => {
      if (!this._shouldFetchData()) {
        return;
      }
      const index = e2.detail.index;
      if (index !== void 0) {
        this.__dataProviderController.ensureFlatIndexLoaded(index);
      }
    });
    this.__dataProviderInitialized = true;
    if (this.dataProvider) {
      this.__synchronizeControllerState();
    }
  }
  /** @private */
  _dataProviderFilterChanged(filter2) {
    if (this.__previousDataProviderFilter === void 0 && filter2 === "") {
      this.__previousDataProviderFilter = filter2;
      return;
    }
    if (this.__previousDataProviderFilter !== filter2) {
      this.__previousDataProviderFilter = filter2;
      this.__keepOverlayOpened = true;
      this.size = void 0;
      this.clearCache();
      this.__keepOverlayOpened = false;
    }
  }
  /** @protected */
  _shouldFetchData() {
    if (!this.dataProvider) {
      return false;
    }
    return this.opened || this.filter && this.filter.length;
  }
  /** @private */
  _ensureFirstPage(opened) {
    if (!this._shouldFetchData() || !opened) {
      return;
    }
    if (this._forceNextRequest || this.size === void 0) {
      this._forceNextRequest = false;
      this.__dataProviderController.loadFirstPage();
    } else if (this.size > 0) {
      this.__dataProviderController.ensureFlatIndexLoaded(0);
    }
  }
  /** @private */
  __onDataProviderPageRequested() {
    this.loading = true;
  }
  /** @private */
  __onDataProviderPageLoaded() {
    const { rootCache } = this.__dataProviderController;
    rootCache.items = [...rootCache.items];
    this.__synchronizeControllerState();
    if (!this.opened && !this._isInputFocused()) {
      this._commitValue();
    }
  }
  /**
   * Clears the cached pages and reloads data from dataprovider when needed.
   */
  clearCache() {
    if (!this.dataProvider) {
      return;
    }
    this.__dataProviderController.clearCache();
    this.__synchronizeControllerState();
    if (this._shouldFetchData()) {
      this._forceNextRequest = false;
      this.__dataProviderController.loadFirstPage();
    } else {
      this._forceNextRequest = true;
    }
  }
  /**
   * When the size change originates externally, synchronizes the new size with
   * the controller and request a content update to re-render the scroller.
   *
   * @private
   */
  _sizeChanged(size) {
    const { rootCache } = this.__dataProviderController;
    if (rootCache.size !== size) {
      rootCache.size = size;
      rootCache.items = [...rootCache.items];
      this.__synchronizeControllerState();
    }
  }
  /**
   * When the items change originates externally, synchronizes the new items with
   * the controller and requests a content update to re-render the scroller.
   *
   * @private
   * @override
   */
  _filteredItemsChanged(items) {
    super._filteredItemsChanged(items);
    if (this.dataProvider && items) {
      const { rootCache } = this.__dataProviderController;
      if (rootCache.items !== items) {
        rootCache.items = items;
        this.__synchronizeControllerState();
      }
    }
  }
  /**
   * Synchronizes the controller's state with the component, which can be
   * out of sync after the controller receives new data from the data provider
   * or if the state in the controller is directly manipulated.
   *
   * @private
   */
  __synchronizeControllerState() {
    if (this.__dataProviderInitialized && this.dataProvider) {
      const { rootCache } = this.__dataProviderController;
      this.size = rootCache.size;
      this.filteredItems = rootCache.items;
      this.loading = this.__dataProviderController.isLoading();
    }
  }
  /** @private */
  _pageSizeChanged(pageSize, oldPageSize) {
    if (Math.floor(pageSize) !== pageSize || pageSize < 1) {
      this.pageSize = oldPageSize;
      throw new Error("`pageSize` value must be an integer > 0");
    }
    this.__dataProviderController.setPageSize(pageSize);
    this.clearCache();
  }
  /** @private */
  _dataProviderChanged(dataProvider, oldDataProvider) {
    this._ensureItemsOrDataProvider(() => {
      this.dataProvider = oldDataProvider;
    });
    this.__dataProviderController.setDataProvider(dataProvider);
    this.clearCache();
  }
  /** @private */
  _ensureItemsOrDataProvider(restoreOldValueCallback) {
    if (this.items !== void 0 && this.dataProvider !== void 0) {
      restoreOldValueCallback();
      throw new Error("Using `items` and `dataProvider` together is not supported");
    }
  }
  /** @private */
  _warnDataProviderValue(dataProvider, value) {
    if (dataProvider && value !== "" && (this.selectedItem === void 0 || this.selectedItem === null)) {
      const valueIndex = this.__getItemIndexByValue(this.filteredItems, value);
      if (valueIndex < 0 || !this._getItemLabel(this.filteredItems[valueIndex])) {
        console.warn(
          "Warning: unable to determine the label for the provided `value`. Nothing to display in the text field. This usually happens when setting an initial `value` before any items are returned from the `dataProvider` callback. Consider setting `selectedItem` instead of `value`"
        );
      }
    }
  }
};
/**
 * @license
 * Copyright (c) 2021 - 2025 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
function processTemplates(component) {
  if (window.Vaadin && window.Vaadin.templateRendererCallback) {
    window.Vaadin.templateRendererCallback(component);
    return;
  }
  if (component.querySelector("template")) {
    console.warn(
      `WARNING: <template> inside <${component.localName}> is no longer supported. Import @vaadin/polymer-legacy-adapter/template-renderer.js to enable compatibility.`
    );
  }
}
/**
 * @license
 * Copyright (c) 2021 - 2025 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
class VirtualKeyboardController {
  /**
   * @param {{ inputElement?: HTMLElement; opened: boolean } & HTMLElement} host
   */
  constructor(host) {
    this.host = host;
    host.addEventListener("opened-changed", () => {
      if (!host.opened) {
        this.__setVirtualKeyboardEnabled(false);
      }
    });
    host.addEventListener("blur", () => this.__setVirtualKeyboardEnabled(true));
    host.addEventListener("touchstart", () => this.__setVirtualKeyboardEnabled(true));
  }
  /** @private */
  __setVirtualKeyboardEnabled(value) {
    if (this.host.inputElement) {
      this.host.inputElement.inputMode = value ? "" : "none";
    }
  }
}
/**
 * @license
 * Copyright (c) 2015 - 2025 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
function isValidValue(value) {
  return value !== void 0 && value !== null;
}
function findItemIndex(items, callback) {
  return items.findIndex((item2) => {
    if (item2 instanceof ComboBoxPlaceholder) {
      return false;
    }
    return callback(item2);
  });
}
const ComboBoxMixin = (subclass) => class ComboBoxMixinClass extends OverlayClassMixin(
  ControllerMixin(ValidateMixin(FocusMixin(KeyboardMixin(InputMixin(DisabledMixin(subclass))))))
) {
  static get properties() {
    return {
      /**
       * True if the dropdown is open, false otherwise.
       * @type {boolean}
       */
      opened: {
        type: Boolean,
        notify: true,
        value: false,
        reflectToAttribute: true,
        sync: true,
        observer: "_openedChanged"
      },
      /**
       * Set true to prevent the overlay from opening automatically.
       * @attr {boolean} auto-open-disabled
       */
      autoOpenDisabled: {
        type: Boolean,
        sync: true
      },
      /**
       * When present, it specifies that the field is read-only.
       * @type {boolean}
       */
      readonly: {
        type: Boolean,
        value: false,
        reflectToAttribute: true
      },
      /**
       * Custom function for rendering the content of every item.
       * Receives three arguments:
       *
       * - `root` The `<vaadin-combo-box-item>` internal container DOM element.
       * - `comboBox` The reference to the `<vaadin-combo-box>` element.
       * - `model` The object with the properties related with the rendered
       *   item, contains:
       *   - `model.index` The index of the rendered item.
       *   - `model.item` The item.
       * @type {ComboBoxRenderer | undefined}
       */
      renderer: {
        type: Object,
        sync: true
      },
      /**
       * A full set of items to filter the visible options from.
       * The items can be of either `String` or `Object` type.
       * @type {!Array<!ComboBoxItem | string> | undefined}
       */
      items: {
        type: Array,
        sync: true,
        observer: "_itemsChanged"
      },
      /**
       * If `true`, the user can input a value that is not present in the items list.
       * `value` property will be set to the input value in this case.
       * Also, when `value` is set programmatically, the input value will be set
       * to reflect that value.
       * @attr {boolean} allow-custom-value
       * @type {boolean}
       */
      allowCustomValue: {
        type: Boolean,
        value: false
      },
      /**
       * A subset of items, filtered based on the user input. Filtered items
       * can be assigned directly to omit the internal filtering functionality.
       * The items can be of either `String` or `Object` type.
       * @type {!Array<!ComboBoxItem | string> | undefined}
       */
      filteredItems: {
        type: Array,
        observer: "_filteredItemsChanged",
        sync: true
      },
      /**
       * Used to detect user value changes and fire `change` events.
       * @private
       */
      _lastCommittedValue: String,
      /**
       * When set to `true`, "loading" attribute is added to host and the overlay element.
       * @type {boolean}
       */
      loading: {
        type: Boolean,
        value: false,
        reflectToAttribute: true,
        sync: true
      },
      /**
       * @type {number}
       * @protected
       */
      _focusedIndex: {
        type: Number,
        observer: "_focusedIndexChanged",
        value: -1,
        sync: true
      },
      /**
       * Filtering string the user has typed into the input field.
       * @type {string}
       */
      filter: {
        type: String,
        value: "",
        notify: true,
        sync: true
      },
      /**
       * The selected item from the `items` array.
       * @type {ComboBoxItem | string | undefined}
       */
      selectedItem: {
        type: Object,
        notify: true,
        sync: true
      },
      /**
       * A function used to generate CSS class names for dropdown
       * items based on the item. The return value should be the
       * generated class name as a string, or multiple class names
       * separated by whitespace characters.
       */
      itemClassNameGenerator: {
        type: Object
      },
      /**
       * Path for label of the item. If `items` is an array of objects, the
       * `itemLabelPath` is used to fetch the displayed string label for each
       * item.
       *
       * The item label is also used for matching items when processing user
       * input, i.e., for filtering and selecting items.
       * @attr {string} item-label-path
       * @type {string}
       */
      itemLabelPath: {
        type: String,
        value: "label",
        observer: "_itemLabelPathChanged",
        sync: true
      },
      /**
       * Path for the value of the item. If `items` is an array of objects, the
       * `itemValuePath:` is used to fetch the string value for the selected
       * item.
       *
       * The item value is used in the `value` property of the combo box,
       * to provide the form value.
       * @attr {string} item-value-path
       * @type {string}
       */
      itemValuePath: {
        type: String,
        value: "value",
        sync: true
      },
      /**
       * Path for the id of the item. If `items` is an array of objects,
       * the `itemIdPath` is used to compare and identify the same item
       * in `selectedItem` and `filteredItems` (items given by the
       * `dataProvider` callback).
       * @attr {string} item-id-path
       */
      itemIdPath: {
        type: String,
        sync: true
      },
      /**
       * @type {!HTMLElement | undefined}
       * @protected
       */
      _toggleElement: {
        type: Object,
        observer: "_toggleElementChanged"
      },
      /**
       * Set of items to be rendered in the dropdown.
       * @protected
       */
      _dropdownItems: {
        type: Array,
        sync: true
      },
      /** @private */
      _closeOnBlurIsPrevented: Boolean,
      /** @private */
      _scroller: {
        type: Object,
        sync: true
      },
      /** @private */
      _overlayOpened: {
        type: Boolean,
        sync: true,
        observer: "_overlayOpenedChanged"
      },
      /** @private */
      __keepOverlayOpened: {
        type: Boolean,
        sync: true
      }
    };
  }
  static get observers() {
    return [
      "_selectedItemChanged(selectedItem, itemValuePath, itemLabelPath)",
      "_openedOrItemsChanged(opened, _dropdownItems, loading, __keepOverlayOpened)",
      "_updateScroller(_scroller, _dropdownItems, opened, loading, selectedItem, itemIdPath, _focusedIndex, renderer, _theme, itemClassNameGenerator)"
    ];
  }
  constructor() {
    super();
    this._boundOverlaySelectedItemChanged = this._overlaySelectedItemChanged.bind(this);
    this._boundOnClearButtonMouseDown = this.__onClearButtonMouseDown.bind(this);
    this._boundOnClick = this._onClick.bind(this);
    this._boundOnOverlayTouchAction = this._onOverlayTouchAction.bind(this);
    this._boundOnTouchend = this._onTouchend.bind(this);
  }
  /**
   * Tag name prefix used by scroller and items.
   * @protected
   * @return {string}
   */
  get _tagNamePrefix() {
    return "vaadin-combo-box";
  }
  /**
   * Get a reference to the native `<input>` element.
   * Override to provide a custom input.
   * @protected
   * @return {HTMLInputElement | undefined}
   */
  get _nativeInput() {
    return this.inputElement;
  }
  /**
   * Override method inherited from `InputMixin`
   * to customize the input element.
   * @protected
   * @override
   */
  _inputElementChanged(inputElement) {
    super._inputElementChanged(inputElement);
    const input = this._nativeInput;
    if (input) {
      input.autocomplete = "off";
      input.autocapitalize = "off";
      input.setAttribute("role", "combobox");
      input.setAttribute("aria-autocomplete", "list");
      input.setAttribute("aria-expanded", !!this.opened);
      input.setAttribute("spellcheck", "false");
      input.setAttribute("autocorrect", "off");
      this._revertInputValueToValue();
      if (this.clearElement) {
        this.clearElement.addEventListener("mousedown", this._boundOnClearButtonMouseDown);
      }
    }
  }
  /** @protected */
  ready() {
    super.ready();
    this._initOverlay();
    this._initScroller();
    this._lastCommittedValue = this.value;
    this.addEventListener("click", this._boundOnClick);
    this.addEventListener("touchend", this._boundOnTouchend);
    const bringToFrontListener = () => {
      requestAnimationFrame(() => {
        this._overlayElement.bringToFront();
      });
    };
    this.addEventListener("mousedown", bringToFrontListener);
    this.addEventListener("touchstart", bringToFrontListener);
    processTemplates(this);
    this.addController(new VirtualKeyboardController(this));
  }
  /** @protected */
  disconnectedCallback() {
    super.disconnectedCallback();
    this.close();
  }
  /**
   * Requests an update for the content of items.
   * While performing the update, it invokes the renderer (passed in the `renderer` property) once an item.
   *
   * It is not guaranteed that the update happens immediately (synchronously) after it is requested.
   */
  requestContentUpdate() {
    if (!this._scroller) {
      return;
    }
    this._scroller.requestContentUpdate();
    this._getItemElements().forEach((item2) => {
      item2.requestContentUpdate();
    });
  }
  /**
   * Opens the dropdown list.
   */
  open() {
    if (!this.disabled && !this.readonly) {
      this.opened = true;
    }
  }
  /**
   * Closes the dropdown list.
   */
  close() {
    this.opened = false;
  }
  /**
   * Override Polymer lifecycle callback to handle `filter` property change after
   * the observer for `opened` property is triggered. This is needed when opening
   * combo-box on user input to ensure the focused index is set correctly.
   *
   * @param {!Object} currentProps Current accessor values
   * @param {?Object} changedProps Properties changed since the last call
   * @param {?Object} oldProps Previous values for each changed property
   * @protected
   * @override
   */
  _propertiesChanged(currentProps, changedProps, oldProps) {
    super._propertiesChanged(currentProps, changedProps, oldProps);
    if (changedProps.filter !== void 0) {
      this._filterChanged(changedProps.filter);
    }
  }
  /**
   * Override LitElement lifecycle callback to handle filter property change.
   * @param {Object} props
   * @protected
   */
  updated(props) {
    super.updated(props);
    if (props.has("filter")) {
      this._filterChanged(this.filter);
    }
  }
  /** @private */
  _initOverlay() {
    const overlay2 = this.$.overlay;
    overlay2._comboBox = this;
    overlay2.addEventListener("touchend", this._boundOnOverlayTouchAction);
    overlay2.addEventListener("touchmove", this._boundOnOverlayTouchAction);
    overlay2.addEventListener("mousedown", (e2) => e2.preventDefault());
    overlay2.addEventListener("opened-changed", (e2) => {
      this._overlayOpened = e2.detail.value;
    });
    this._overlayElement = overlay2;
  }
  /**
   * Create and initialize the scroller element.
   * Override to provide custom host reference.
   *
   * @protected
   */
  _initScroller(host) {
    const scroller2 = document.createElement(`${this._tagNamePrefix}-scroller`);
    scroller2.owner = host || this;
    scroller2.getItemLabel = this._getItemLabel.bind(this);
    scroller2.addEventListener("selection-changed", this._boundOverlaySelectedItemChanged);
    const overlay2 = this._overlayElement;
    overlay2.renderer = (root2) => {
      if (!root2.innerHTML) {
        root2.appendChild(scroller2);
      }
    };
    overlay2.requestContentUpdate();
    this._scroller = scroller2;
  }
  /** @private */
  // eslint-disable-next-line @typescript-eslint/max-params
  _updateScroller(scroller2, items, opened, loading, selectedItem, itemIdPath, focusedIndex, renderer, theme, itemClassNameGenerator) {
    if (scroller2) {
      if (opened) {
        scroller2.style.maxHeight = getComputedStyle(this).getPropertyValue(`--${this._tagNamePrefix}-overlay-max-height`) || "65vh";
      }
      scroller2.setProperties({
        items: opened ? items : [],
        opened,
        loading,
        selectedItem,
        itemIdPath,
        focusedIndex,
        renderer,
        theme,
        itemClassNameGenerator
      });
    }
  }
  /** @private */
  _openedOrItemsChanged(opened, items, loading, keepOverlayOpened) {
    this._overlayOpened = opened && (keepOverlayOpened || loading || !!(items && items.length));
  }
  /** @private */
  _overlayOpenedChanged(opened, wasOpened) {
    if (opened) {
      this.dispatchEvent(new CustomEvent("vaadin-combo-box-dropdown-opened", { bubbles: true, composed: true }));
      this._onOpened();
    } else if (wasOpened && this._dropdownItems && this._dropdownItems.length) {
      this.close();
      this.dispatchEvent(new CustomEvent("vaadin-combo-box-dropdown-closed", { bubbles: true, composed: true }));
    }
  }
  /** @private */
  _focusedIndexChanged(index, oldIndex) {
    if (oldIndex === void 0) {
      return;
    }
    this._updateActiveDescendant(index);
  }
  /** @protected */
  _isInputFocused() {
    return this.inputElement && isElementFocused(this.inputElement);
  }
  /** @private */
  _updateActiveDescendant(index) {
    const input = this._nativeInput;
    if (!input) {
      return;
    }
    const item2 = this._getItemElements().find((el) => el.index === index);
    if (item2) {
      input.setAttribute("aria-activedescendant", item2.id);
    } else {
      input.removeAttribute("aria-activedescendant");
    }
  }
  /** @private */
  _openedChanged(opened, wasOpened) {
    if (wasOpened === void 0) {
      return;
    }
    if (opened) {
      if (!this._isInputFocused() && !isTouch) {
        if (this.inputElement) {
          this.inputElement.focus();
        }
      }
    } else {
      this._onClosed();
    }
    const input = this._nativeInput;
    if (input) {
      input.setAttribute("aria-expanded", !!opened);
      if (opened) {
        input.setAttribute("aria-controls", this._scroller.id);
      } else {
        input.removeAttribute("aria-controls");
      }
    }
  }
  /** @private */
  _onOverlayTouchAction() {
    this._closeOnBlurIsPrevented = true;
    this.inputElement.blur();
    this._closeOnBlurIsPrevented = false;
  }
  /** @protected */
  _isClearButton(event) {
    return event.composedPath()[0] === this.clearElement;
  }
  /** @private */
  __onClearButtonMouseDown(event) {
    event.preventDefault();
    this.inputElement.focus();
  }
  /**
   * @param {Event} event
   * @protected
   */
  _onClearButtonClick(event) {
    event.preventDefault();
    this._onClearAction();
    if (this.opened) {
      this.requestContentUpdate();
    }
  }
  /**
   * @param {Event} event
   * @private
   */
  _onToggleButtonClick(event) {
    event.preventDefault();
    if (this.opened) {
      this.close();
    } else {
      this.open();
    }
  }
  /**
   * @param {Event} event
   * @protected
   */
  _onHostClick(event) {
    if (!this.autoOpenDisabled) {
      event.preventDefault();
      this.open();
    }
  }
  /** @private */
  _onClick(event) {
    if (this._isClearButton(event)) {
      this._onClearButtonClick(event);
    } else if (event.composedPath().includes(this._toggleElement)) {
      this._onToggleButtonClick(event);
    } else {
      this._onHostClick(event);
    }
  }
  /**
   * Override an event listener from `KeyboardMixin`.
   *
   * @param {KeyboardEvent} e
   * @protected
   * @override
   */
  _onKeyDown(e2) {
    super._onKeyDown(e2);
    if (e2.key === "ArrowDown") {
      this._onArrowDown();
      e2.preventDefault();
    } else if (e2.key === "ArrowUp") {
      this._onArrowUp();
      e2.preventDefault();
    }
  }
  /** @private */
  _getItemLabel(item2) {
    let label = item2 && this.itemLabelPath ? get$2(this.itemLabelPath, item2) : void 0;
    if (label === void 0 || label === null) {
      label = item2 ? item2.toString() : "";
    }
    return label;
  }
  /** @private */
  _getItemValue(item2) {
    let value = item2 && this.itemValuePath ? get$2(this.itemValuePath, item2) : void 0;
    if (value === void 0) {
      value = item2 ? item2.toString() : "";
    }
    return value;
  }
  /** @private */
  _onArrowDown() {
    if (this.opened) {
      const items = this._dropdownItems;
      if (items) {
        this._focusedIndex = Math.min(items.length - 1, this._focusedIndex + 1);
        this._prefillFocusedItemLabel();
      }
    } else {
      this.open();
    }
  }
  /** @private */
  _onArrowUp() {
    if (this.opened) {
      if (this._focusedIndex > -1) {
        this._focusedIndex = Math.max(0, this._focusedIndex - 1);
      } else {
        const items = this._dropdownItems;
        if (items) {
          this._focusedIndex = items.length - 1;
        }
      }
      this._prefillFocusedItemLabel();
    } else {
      this.open();
    }
  }
  /** @private */
  _prefillFocusedItemLabel() {
    if (this._focusedIndex > -1) {
      const focusedItem = this._dropdownItems[this._focusedIndex];
      this._inputElementValue = this._getItemLabel(focusedItem);
      this._markAllSelectionRange();
    }
  }
  /** @private */
  _setSelectionRange(start, end) {
    if (this._isInputFocused() && this.inputElement.setSelectionRange) {
      this.inputElement.setSelectionRange(start, end);
    }
  }
  /** @private */
  _markAllSelectionRange() {
    if (this._inputElementValue !== void 0) {
      this._setSelectionRange(0, this._inputElementValue.length);
    }
  }
  /** @private */
  _clearSelectionRange() {
    if (this._inputElementValue !== void 0) {
      const pos = this._inputElementValue ? this._inputElementValue.length : 0;
      this._setSelectionRange(pos, pos);
    }
  }
  /** @private */
  _closeOrCommit() {
    if (!this.opened && !this.loading) {
      this._commitValue();
    } else {
      this.close();
    }
  }
  /**
   * Override an event listener from `KeyboardMixin`.
   *
   * @param {KeyboardEvent} e
   * @protected
   * @override
   */
  _onEnter(e2) {
    if (!this._hasValidInputValue()) {
      e2.preventDefault();
      e2.stopPropagation();
      return;
    }
    if (this.opened) {
      e2.preventDefault();
      e2.stopPropagation();
    }
    this._closeOrCommit();
  }
  /**
   * @protected
   */
  _hasValidInputValue() {
    const hasInvalidOption = this._focusedIndex < 0 && this._inputElementValue !== "" && this._getItemLabel(this.selectedItem) !== this._inputElementValue;
    return this.allowCustomValue || !hasInvalidOption;
  }
  /**
   * Override an event listener from `KeyboardMixin`.
   * Do not call `super` in order to override clear
   * button logic defined in `InputControlMixin`.
   *
   * @param {!KeyboardEvent} e
   * @protected
   * @override
   */
  _onEscape(e2) {
    if (this.autoOpenDisabled && (this.opened || this.value !== this._inputElementValue && this._inputElementValue.length > 0)) {
      e2.stopPropagation();
      this._focusedIndex = -1;
      this.cancel();
    } else if (this.opened) {
      e2.stopPropagation();
      if (this._focusedIndex > -1) {
        this._focusedIndex = -1;
        this._revertInputValue();
      } else {
        this.cancel();
      }
    } else if (this.clearButtonVisible && !!this.value && !this.readonly) {
      e2.stopPropagation();
      this._onClearAction();
    }
  }
  /** @private */
  _toggleElementChanged(toggleElement) {
    if (toggleElement) {
      toggleElement.addEventListener("mousedown", (e2) => e2.preventDefault());
      toggleElement.addEventListener("click", () => {
        if (isTouch && !this._isInputFocused()) {
          document.activeElement.blur();
        }
      });
    }
  }
  /**
   * Clears the current value.
   * @protected
   */
  _onClearAction() {
    this.selectedItem = null;
    if (this.allowCustomValue) {
      this.value = "";
    }
    this._detectAndDispatchChange();
  }
  /**
   * Clears the current filter. Should be used instead of setting the property
   * directly in order to allow overriding this in multi-select combo box.
   * @protected
   */
  _clearFilter() {
    this.filter = "";
  }
  /**
   * Reverts back to original value.
   */
  cancel() {
    this._revertInputValueToValue();
    this._lastCommittedValue = this.value;
    this._closeOrCommit();
  }
  /** @private */
  _onOpened() {
    this._lastCommittedValue = this.value;
  }
  /** @private */
  _onClosed() {
    if (!this.loading || this.allowCustomValue) {
      this._commitValue();
    }
  }
  /** @private */
  _commitValue() {
    if (this._focusedIndex > -1) {
      const focusedItem = this._dropdownItems[this._focusedIndex];
      if (this.selectedItem !== focusedItem) {
        this.selectedItem = focusedItem;
      }
      this._inputElementValue = this._getItemLabel(this.selectedItem);
      this._focusedIndex = -1;
    } else if (this._inputElementValue === "" || this._inputElementValue === void 0) {
      this.selectedItem = null;
      if (this.allowCustomValue) {
        this.value = "";
      }
    } else {
      const items = [this.selectedItem, ...this._dropdownItems || []];
      const itemMatchingInputValue = items[this.__getItemIndexByLabel(items, this._inputElementValue)];
      if (this.allowCustomValue && // To prevent a repetitive input value being saved after pressing ESC and Tab.
      !itemMatchingInputValue) {
        const customValue = this._inputElementValue;
        this._lastCustomValue = customValue;
        const e2 = new CustomEvent("custom-value-set", {
          detail: customValue,
          composed: true,
          cancelable: true,
          bubbles: true
        });
        this.dispatchEvent(e2);
        if (!e2.defaultPrevented) {
          this.value = customValue;
        }
      } else if (!this.allowCustomValue && !this.opened && itemMatchingInputValue) {
        this.value = this._getItemValue(itemMatchingInputValue);
      } else {
        this._revertInputValueToValue();
      }
    }
    this._detectAndDispatchChange();
    this._clearSelectionRange();
    this._clearFilter();
  }
  /**
   * Override an event listener from `InputMixin`.
   * @param {!Event} event
   * @protected
   * @override
   */
  _onInput(event) {
    const filter2 = this._inputElementValue;
    const props = {};
    if (this.filter === filter2) {
      this._filterChanged(this.filter);
    } else {
      props.filter = filter2;
    }
    if (!this.opened && !this._isClearButton(event) && !this.autoOpenDisabled) {
      props.opened = true;
    }
    this.setProperties(props);
  }
  /**
   * Override an event listener from `InputMixin`.
   * @param {!Event} event
   * @protected
   * @override
   */
  _onChange(event) {
    event.stopPropagation();
  }
  /** @private */
  _itemLabelPathChanged(itemLabelPath) {
    if (typeof itemLabelPath !== "string") {
      console.error("You should set itemLabelPath to a valid string");
    }
  }
  /** @private */
  _filterChanged(filter2) {
    this._scrollIntoView(0);
    this._focusedIndex = -1;
    if (this.items) {
      this.filteredItems = this._filterItems(this.items, filter2);
    } else {
      this._filteredItemsChanged(this.filteredItems);
    }
  }
  /** @protected */
  _revertInputValue() {
    if (this.filter !== "") {
      this._inputElementValue = this.filter;
    } else {
      this._revertInputValueToValue();
    }
    this._clearSelectionRange();
  }
  /** @private */
  _revertInputValueToValue() {
    if (this.allowCustomValue && !this.selectedItem) {
      this._inputElementValue = this.value;
    } else {
      this._inputElementValue = this._getItemLabel(this.selectedItem);
    }
  }
  /** @private */
  _selectedItemChanged(selectedItem) {
    if (selectedItem === null || selectedItem === void 0) {
      if (this.filteredItems) {
        if (!this.allowCustomValue) {
          this.value = "";
        }
        this._toggleHasValue(this._hasValue);
        this._inputElementValue = this.value;
      }
    } else {
      const value = this._getItemValue(selectedItem);
      if (this.value !== value) {
        this.value = value;
        if (this.value !== value) {
          return;
        }
      }
      this._toggleHasValue(true);
      this._inputElementValue = this._getItemLabel(selectedItem);
    }
  }
  /**
   * Override an observer from `InputMixin`.
   * @protected
   * @override
   */
  _valueChanged(value, oldVal) {
    if (value === "" && oldVal === void 0) {
      return;
    }
    if (isValidValue(value)) {
      if (this._getItemValue(this.selectedItem) !== value) {
        this._selectItemForValue(value);
      }
      if (!this.selectedItem && this.allowCustomValue) {
        this._inputElementValue = value;
      }
      this._toggleHasValue(this._hasValue);
    } else {
      this.selectedItem = null;
    }
    this._clearFilter();
    this._lastCommittedValue = void 0;
  }
  /** @private */
  _detectAndDispatchChange() {
    if (document.hasFocus()) {
      this._requestValidation();
    }
    if (this.value !== this._lastCommittedValue) {
      this.dispatchEvent(new CustomEvent("change", { bubbles: true }));
      this._lastCommittedValue = this.value;
    }
  }
  /** @private */
  _itemsChanged(items, oldItems) {
    this._ensureItemsOrDataProvider(() => {
      this.items = oldItems;
    });
    if (items) {
      this.filteredItems = items.slice(0);
    } else if (oldItems) {
      this.filteredItems = null;
    }
  }
  /** @private */
  _filteredItemsChanged(filteredItems) {
    this._setDropdownItems(filteredItems);
  }
  /** @private */
  _filterItems(arr, filter2) {
    if (!arr) {
      return arr;
    }
    const filteredItems = arr.filter((item2) => {
      filter2 = filter2 ? filter2.toString().toLowerCase() : "";
      return this._getItemLabel(item2).toString().toLowerCase().indexOf(filter2) > -1;
    });
    return filteredItems;
  }
  /** @private */
  _selectItemForValue(value) {
    const valueIndex = this.__getItemIndexByValue(this.filteredItems, value);
    const previouslySelectedItem = this.selectedItem;
    if (valueIndex >= 0) {
      this.selectedItem = this.filteredItems[valueIndex];
    } else if (this.dataProvider && this.selectedItem === void 0) {
      this.selectedItem = void 0;
    } else {
      this.selectedItem = null;
    }
    if (this.selectedItem === null && previouslySelectedItem === null) {
      this._selectedItemChanged(this.selectedItem);
    }
  }
  /**
   * Provide items to be rendered in the dropdown.
   * Override this method to show custom items.
   *
   * @protected
   */
  _setDropdownItems(newItems) {
    const oldItems = this._dropdownItems;
    this._dropdownItems = newItems;
    const focusedItem = oldItems ? oldItems[this._focusedIndex] : null;
    const valueIndex = this.__getItemIndexByValue(newItems, this.value);
    if ((this.selectedItem === null || this.selectedItem === void 0) && valueIndex >= 0) {
      this.selectedItem = newItems[valueIndex];
    }
    const focusedItemIndex = this.__getItemIndexByValue(newItems, this._getItemValue(focusedItem));
    if (focusedItemIndex > -1) {
      this._focusedIndex = focusedItemIndex;
    } else {
      this._focusedIndex = this.__getItemIndexByLabel(newItems, this.filter);
    }
  }
  /** @private */
  _getItemElements() {
    return Array.from(this._scroller.querySelectorAll(`${this._tagNamePrefix}-item`));
  }
  /** @private */
  _scrollIntoView(index) {
    if (!this._scroller) {
      return;
    }
    this._scroller.scrollIntoView(index);
  }
  /**
   * Returns the first item that matches the provided value.
   *
   * @private
   */
  __getItemIndexByValue(items, value) {
    if (!items || !isValidValue(value)) {
      return -1;
    }
    return findItemIndex(items, (item2) => {
      return this._getItemValue(item2) === value;
    });
  }
  /**
   * Returns the first item that matches the provided label.
   * Labels are matched against each other case insensitively.
   *
   * @private
   */
  __getItemIndexByLabel(items, label) {
    if (!items || !label) {
      return -1;
    }
    return findItemIndex(items, (item2) => {
      return this._getItemLabel(item2).toString().toLowerCase() === label.toString().toLowerCase();
    });
  }
  /** @private */
  _overlaySelectedItemChanged(e2) {
    e2.stopPropagation();
    if (e2.detail.item instanceof ComboBoxPlaceholder) {
      return;
    }
    if (this.opened) {
      this._focusedIndex = this.filteredItems.indexOf(e2.detail.item);
      this.close();
    }
  }
  /**
   * Override method inherited from `FocusMixin`
   * to close the overlay on blur and commit the value.
   *
   * @param {boolean} focused
   * @protected
   * @override
   */
  _setFocused(focused) {
    super._setFocused(focused);
    if (!focused && !this.readonly && !this._closeOnBlurIsPrevented) {
      if (!this.opened && this.allowCustomValue && this._inputElementValue === this._lastCustomValue) {
        delete this._lastCustomValue;
        return;
      }
      if (isKeyboardActive()) {
        this._closeOrCommit();
        return;
      }
      if (!this.opened) {
        this._commitValue();
      } else if (!this._overlayOpened) {
        this.close();
      }
    }
  }
  /**
   * Override method inherited from `FocusMixin` to not remove focused
   * state when focus moves to the overlay.
   *
   * @param {FocusEvent} event
   * @return {boolean}
   * @protected
   * @override
   */
  _shouldRemoveFocus(event) {
    if (event.relatedTarget && event.relatedTarget.localName === `${this._tagNamePrefix}-item`) {
      return false;
    }
    if (event.relatedTarget === this._overlayElement) {
      event.composedPath()[0].focus();
      return false;
    }
    return true;
  }
  /** @private */
  _onTouchend(event) {
    if (!this.clearElement || event.composedPath()[0] !== this.clearElement) {
      return;
    }
    event.preventDefault();
    this._onClearAction();
  }
  /**
   * Fired when the value changes.
   *
   * @event value-changed
   * @param {Object} detail
   * @param {String} detail.value the combobox value
   */
  /**
   * Fired when selected item changes.
   *
   * @event selected-item-changed
   * @param {Object} detail
   * @param {Object|String} detail.value the selected item. Type is the same as the type of `items`.
   */
  /**
   * Fired when the user sets a custom value.
   * @event custom-value-set
   * @param {String} detail the custom value
   */
  /**
   * Fired when the user commits a value change.
   * @event change
   */
  /**
   * Fired after the `vaadin-combo-box-overlay` opens.
   *
   * @event vaadin-combo-box-dropdown-opened
   */
  /**
   * Fired after the `vaadin-combo-box-overlay` closes.
   *
   * @event vaadin-combo-box-dropdown-closed
   */
};
/**
 * @license
 * Copyright (c) 2015 - 2025 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
registerStyles$1("vaadin-combo-box", inputFieldShared, { moduleId: "vaadin-combo-box-styles" });
class ComboBox extends ComboBoxDataProviderMixin(
  ComboBoxMixin(PatternMixin(InputControlMixin(ThemableMixin(ElementMixin(PolymerElement)))))
) {
  static get is() {
    return "vaadin-combo-box";
  }
  static get template() {
    return html`
      <style>
        :host([opened]) {
          pointer-events: auto;
        }
      </style>

      <div class="vaadin-combo-box-container">
        <div part="label">
          <slot name="label"></slot>
          <span part="required-indicator" aria-hidden="true" on-click="focus"></span>
        </div>

        <vaadin-input-container
          part="input-field"
          readonly="[[readonly]]"
          disabled="[[disabled]]"
          invalid="[[invalid]]"
          theme$="[[_theme]]"
        >
          <slot name="prefix" slot="prefix"></slot>
          <slot name="input"></slot>
          <div id="clearButton" part="clear-button" slot="suffix" aria-hidden="true"></div>
          <div id="toggleButton" part="toggle-button" slot="suffix" aria-hidden="true"></div>
        </vaadin-input-container>

        <div part="helper-text">
          <slot name="helper"></slot>
        </div>

        <div part="error-message">
          <slot name="error-message"></slot>
        </div>
      </div>

      <vaadin-combo-box-overlay
        id="overlay"
        opened="[[_overlayOpened]]"
        loading$="[[loading]]"
        theme$="[[_theme]]"
        position-target="[[_positionTarget]]"
        no-vertical-overlap
      ></vaadin-combo-box-overlay>

      <slot name="tooltip"></slot>
    `;
  }
  static get properties() {
    return {
      /**
       * @protected
       */
      _positionTarget: {
        type: Object
      }
    };
  }
  /**
   * Used by `InputControlMixin` as a reference to the clear button element.
   * @protected
   * @return {!HTMLElement}
   */
  get clearElement() {
    return this.$.clearButton;
  }
  /** @protected */
  ready() {
    super.ready();
    this.addController(
      new InputController(this, (input) => {
        this._setInputElement(input);
        this._setFocusElement(input);
        this.stateTarget = input;
        this.ariaTarget = input;
      })
    );
    this.addController(new LabelledInputController(this.inputElement, this._labelController));
    this._tooltipController = new TooltipController(this);
    this.addController(this._tooltipController);
    this._tooltipController.setPosition("top");
    this._tooltipController.setAriaTarget(this.inputElement);
    this._tooltipController.setShouldShow((target) => !target.opened);
    this._positionTarget = this.shadowRoot.querySelector('[part="input-field"]');
    this._toggleElement = this.$.toggleButton;
  }
  /**
   * Override the method from `InputControlMixin`
   * to stop event propagation to prevent `ComboBoxMixin`
   * from handling this click event also on its own.
   *
   * @param {Event} event
   * @protected
   * @override
   */
  _onClearButtonClick(event) {
    event.stopPropagation();
    super._onClearButtonClick(event);
  }
  /**
   * @param {Event} event
   * @protected
   */
  _onHostClick(event) {
    const path = event.composedPath();
    if (path.includes(this._labelNode) || path.includes(this._positionTarget)) {
      super._onHostClick(event);
    }
  }
}
defineCustomElement(ComboBox);
/**
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/
class Debouncer2 {
  constructor() {
    this._asyncModule = null;
    this._callback = null;
    this._timer = null;
  }
  /**
   * Sets the scheduler; that is, a module with the Async interface,
   * a callback and optional arguments to be passed to the run function
   * from the async module.
   *
   * @param {!AsyncInterface} asyncModule Object with Async interface.
   * @param {function()} callback Callback to run.
   * @return {void}
   */
  setConfig(asyncModule, callback) {
    this._asyncModule = asyncModule;
    this._callback = callback;
    this._timer = this._asyncModule.run(() => {
      this._timer = null;
      debouncerQueue.delete(this);
      this._callback();
    });
  }
  /**
   * Cancels an active debouncer and returns a reference to itself.
   *
   * @return {void}
   */
  cancel() {
    if (this.isActive()) {
      this._cancelAsync();
      debouncerQueue.delete(this);
    }
  }
  /**
   * Cancels a debouncer's async callback.
   *
   * @return {void}
   */
  _cancelAsync() {
    if (this.isActive()) {
      this._asyncModule.cancel(
        /** @type {number} */
        this._timer
      );
      this._timer = null;
    }
  }
  /**
   * Flushes an active debouncer and returns a reference to itself.
   *
   * @return {void}
   */
  flush() {
    if (this.isActive()) {
      this.cancel();
      this._callback();
    }
  }
  /**
   * Returns true if the debouncer is active.
   *
   * @return {boolean} True if active.
   */
  isActive() {
    return this._timer != null;
  }
  /**
   * Creates a debouncer if no debouncer is passed as a parameter
   * or it cancels an active debouncer otherwise. The following
   * example shows how a debouncer can be called multiple times within a
   * microtask and "debounced" such that the provided callback function is
   * called once. Add this method to a custom element:
   *
   * ```js
   * import {microTask} from '@polymer/polymer/lib/utils/async.js';
   * import {Debouncer} from '@polymer/polymer/lib/utils/debounce.js';
   * // ...
   *
   * _debounceWork() {
   *   this._debounceJob = Debouncer.debounce(this._debounceJob,
   *       microTask, () => this._doWork());
   * }
   * ```
   *
   * If the `_debounceWork` method is called multiple times within the same
   * microtask, the `_doWork` function will be called only once at the next
   * microtask checkpoint.
   *
   * Note: In testing it is often convenient to avoid asynchrony. To accomplish
   * this with a debouncer, you can use `enqueueDebouncer` and
   * `flush`. For example, extend the above example by adding
   * `enqueueDebouncer(this._debounceJob)` at the end of the
   * `_debounceWork` method. Then in a test, call `flush` to ensure
   * the debouncer has completed.
   *
   * @param {Debouncer?} debouncer Debouncer object.
   * @param {!AsyncInterface} asyncModule Object with Async interface
   * @param {function()} callback Callback to run.
   * @return {!Debouncer} Returns a debouncer object.
   */
  static debounce(debouncer, asyncModule, callback) {
    if (debouncer instanceof Debouncer2) {
      debouncer._cancelAsync();
    } else {
      debouncer = new Debouncer2();
    }
    debouncer.setConfig(asyncModule, callback);
    return debouncer;
  }
}
let debouncerQueue = /* @__PURE__ */ new Set();
const enqueueDebouncer = function(debouncer) {
  debouncerQueue.add(debouncer);
};
const flushDebouncers = function() {
  const didFlush = Boolean(debouncerQueue.size);
  debouncerQueue.forEach((debouncer) => {
    try {
      debouncer.flush();
    } catch (e2) {
      setTimeout(() => {
        throw e2;
      });
    }
  });
  return didFlush;
};
/**
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/
const flush = function() {
  let shadyDOM, debouncers;
  do {
    shadyDOM = window.ShadyDOM && ShadyDOM.flush();
    if (window.ShadyCSS && window.ShadyCSS.ScopingShim) {
      window.ShadyCSS.ScopingShim.flush();
    }
    debouncers = flushDebouncers();
  } while (shadyDOM || debouncers);
};
/**
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/
let elementsHidden = false;
function hideElementsGlobally() {
  if (legacyOptimizations && !useShadow) {
    if (!elementsHidden) {
      elementsHidden = true;
      const style = document.createElement("style");
      style.textContent = "dom-bind,dom-if,dom-repeat{display:none;}";
      document.head.appendChild(style);
    }
    return true;
  }
  return false;
}
/**
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/
function mutablePropertyChange(inst, property, value, old, mutableData) {
  let isObject;
  if (mutableData) {
    isObject = typeof value === "object" && value !== null;
    if (isObject) {
      old = inst.__dataTemp[property];
    }
  }
  let shouldChange = old !== value && (old === old || value === value);
  if (isObject && shouldChange) {
    inst.__dataTemp[property] = value;
  }
  return shouldChange;
}
const MutableData = dedupingMixin((superClass) => {
  class MutableData2 extends superClass {
    /**
     * Overrides `PropertyEffects` to provide option for skipping
     * strict equality checking for Objects and Arrays.
     *
     * This method pulls the value to dirty check against from the `__dataTemp`
     * cache (rather than the normal `__data` cache) for Objects.  Since the temp
     * cache is cleared at the end of a turn, this implementation allows
     * side-effects of deep object changes to be processed by re-setting the
     * same object (using the temp cache as an in-turn backstop to prevent
     * cycles due to 2-way notification).
     *
     * @param {string} property Property name
     * @param {*} value New property value
     * @param {*} old Previous property value
     * @return {boolean} Whether the property should be considered a change
     * @protected
     */
    _shouldPropertyChange(property, value, old) {
      return mutablePropertyChange(this, property, value, old, true);
    }
  }
  return MutableData2;
});
const OptionalMutableData = dedupingMixin((superClass) => {
  class OptionalMutableData2 extends superClass {
    /** @nocollapse */
    static get properties() {
      return {
        /**
         * Instance-level flag for configuring the dirty-checking strategy
         * for this element.  When true, Objects and Arrays will skip dirty
         * checking, otherwise strict equality checking will be used.
         */
        mutableData: Boolean
      };
    }
    /**
     * Overrides `PropertyEffects` to provide option for skipping
     * strict equality checking for Objects and Arrays.
     *
     * When `this.mutableData` is true on this instance, this method
     * pulls the value to dirty check against from the `__dataTemp` cache
     * (rather than the normal `__data` cache) for Objects.  Since the temp
     * cache is cleared at the end of a turn, this implementation allows
     * side-effects of deep object changes to be processed by re-setting the
     * same object (using the temp cache as an in-turn backstop to prevent
     * cycles due to 2-way notification).
     *
     * @param {string} property Property name
     * @param {*} value New property value
     * @param {*} old Previous property value
     * @return {boolean} Whether the property should be considered a change
     * @protected
     */
    _shouldPropertyChange(property, value, old) {
      return mutablePropertyChange(this, property, value, old, this.mutableData);
    }
  }
  return OptionalMutableData2;
});
MutableData._mutablePropertyChange = mutablePropertyChange;
/**
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/
let newInstance = null;
function HTMLTemplateElementExtension() {
  return newInstance;
}
HTMLTemplateElementExtension.prototype = Object.create(HTMLTemplateElement.prototype, {
  constructor: {
    value: HTMLTemplateElementExtension,
    writable: true
  }
});
const DataTemplate = PropertyEffects(HTMLTemplateElementExtension);
const MutableDataTemplate = MutableData(DataTemplate);
function upgradeTemplate(template2, constructor) {
  newInstance = template2;
  Object.setPrototypeOf(template2, constructor.prototype);
  new constructor();
  newInstance = null;
}
const templateInstanceBase = PropertyEffects(class {
});
function showHideChildren(hide, children) {
  for (let i2 = 0; i2 < children.length; i2++) {
    let n = children[i2];
    if (Boolean(hide) != Boolean(n.__hideTemplateChildren__)) {
      if (n.nodeType === Node.TEXT_NODE) {
        if (hide) {
          n.__polymerTextContent__ = n.textContent;
          n.textContent = "";
        } else {
          n.textContent = n.__polymerTextContent__;
        }
      } else if (n.localName === "slot") {
        if (hide) {
          n.__polymerReplaced__ = document.createComment("hidden-slot");
          wrap$1(wrap$1(n).parentNode).replaceChild(n.__polymerReplaced__, n);
        } else {
          const replace = n.__polymerReplaced__;
          if (replace) {
            wrap$1(wrap$1(replace).parentNode).replaceChild(n, replace);
          }
        }
      } else if (n.style) {
        if (hide) {
          n.__polymerDisplay__ = n.style.display;
          n.style.display = "none";
        } else {
          n.style.display = n.__polymerDisplay__;
        }
      }
    }
    n.__hideTemplateChildren__ = hide;
    if (n._showHideChildren) {
      n._showHideChildren(hide);
    }
  }
}
class TemplateInstanceBase extends templateInstanceBase {
  constructor(props) {
    super();
    this._configureProperties(props);
    this.root = this._stampTemplate(this.__dataHost);
    let children = [];
    this.children = /** @type {!NodeList} */
    children;
    for (let n = this.root.firstChild; n; n = n.nextSibling) {
      children.push(n);
      n.__templatizeInstance = this;
    }
    if (this.__templatizeOwner && this.__templatizeOwner.__hideTemplateChildren__) {
      this._showHideChildren(true);
    }
    let options = this.__templatizeOptions;
    if (props && options.instanceProps || !options.instanceProps) {
      this._enableProperties();
    }
  }
  /**
   * Configure the given `props` by calling `_setPendingProperty`. Also
   * sets any properties stored in `__hostProps`.
   * @private
   * @param {Object} props Object of property name-value pairs to set.
   * @return {void}
   */
  _configureProperties(props) {
    let options = this.__templatizeOptions;
    if (options.forwardHostProp) {
      for (let hprop in this.__hostProps) {
        this._setPendingProperty(hprop, this.__dataHost["_host_" + hprop]);
      }
    }
    for (let iprop in props) {
      this._setPendingProperty(iprop, props[iprop]);
    }
  }
  /**
   * Forwards a host property to this instance.  This method should be
   * called on instances from the `options.forwardHostProp` callback
   * to propagate changes of host properties to each instance.
   *
   * Note this method enqueues the change, which are flushed as a batch.
   *
   * @param {string} prop Property or path name
   * @param {*} value Value of the property to forward
   * @return {void}
   */
  forwardHostProp(prop, value) {
    if (this._setPendingPropertyOrPath(prop, value, false, true)) {
      this.__dataHost._enqueueClient(this);
    }
  }
  /**
   * Override point for adding custom or simulated event handling.
   *
   * @override
   * @param {!Node} node Node to add event listener to
   * @param {string} eventName Name of event
   * @param {function(!Event):void} handler Listener function to add
   * @return {void}
   */
  _addEventListenerToNode(node, eventName, handler) {
    if (this._methodHost && this.__templatizeOptions.parentModel) {
      this._methodHost._addEventListenerToNode(node, eventName, (e2) => {
        e2.model = this;
        handler(e2);
      });
    } else {
      let templateHost = this.__dataHost.__dataHost;
      if (templateHost) {
        templateHost._addEventListenerToNode(node, eventName, handler);
      }
    }
  }
  /**
   * Shows or hides the template instance top level child elements. For
   * text nodes, `textContent` is removed while "hidden" and replaced when
   * "shown."
   * @param {boolean} hide Set to true to hide the children;
   * set to false to show them.
   * @return {void}
   * @protected
   */
  _showHideChildren(hide) {
    showHideChildren(hide, this.children);
  }
  /**
   * Overrides default property-effects implementation to intercept
   * textContent bindings while children are "hidden" and cache in
   * private storage for later retrieval.
   *
   * @override
   * @param {!Node} node The node to set a property on
   * @param {string} prop The property to set
   * @param {*} value The value to set
   * @return {void}
   * @protected
   */
  _setUnmanagedPropertyToNode(node, prop, value) {
    if (node.__hideTemplateChildren__ && node.nodeType == Node.TEXT_NODE && prop == "textContent") {
      node.__polymerTextContent__ = value;
    } else {
      super._setUnmanagedPropertyToNode(node, prop, value);
    }
  }
  /**
   * Find the parent model of this template instance.  The parent model
   * is either another templatize instance that had option `parentModel: true`,
   * or else the host element.
   *
   * @return {!Polymer_PropertyEffects} The parent model of this instance
   */
  get parentModel() {
    let model = this.__parentModel;
    if (!model) {
      let options;
      model = this;
      do {
        model = model.__dataHost.__dataHost;
      } while ((options = model.__templatizeOptions) && !options.parentModel);
      this.__parentModel = model;
    }
    return model;
  }
  /**
   * Stub of HTMLElement's `dispatchEvent`, so that effects that may
   * dispatch events safely no-op.
   *
   * @param {Event} event Event to dispatch
   * @return {boolean} Always true.
   * @override
   */
  dispatchEvent(event) {
    return true;
  }
}
TemplateInstanceBase.prototype.__dataHost;
TemplateInstanceBase.prototype.__templatizeOptions;
TemplateInstanceBase.prototype._methodHost;
TemplateInstanceBase.prototype.__templatizeOwner;
TemplateInstanceBase.prototype.__hostProps;
const MutableTemplateInstanceBase = MutableData(
  // This cast shouldn't be neccessary, but Closure doesn't understand that
  // TemplateInstanceBase is a constructor function.
  /** @type {function(new:TemplateInstanceBase)} */
  TemplateInstanceBase
);
function findMethodHost(template2) {
  let templateHost = template2.__dataHost;
  return templateHost && templateHost._methodHost || templateHost;
}
function createTemplatizerClass(template2, templateInfo, options) {
  let templatizerBase = options.mutableData ? MutableTemplateInstanceBase : TemplateInstanceBase;
  if (templatize.mixin) {
    templatizerBase = templatize.mixin(templatizerBase);
  }
  let klass = class extends templatizerBase {
  };
  klass.prototype.__templatizeOptions = options;
  klass.prototype._bindTemplate(template2);
  addNotifyEffects(klass, template2, templateInfo, options);
  return klass;
}
function addPropagateEffects(target, templateInfo, options, methodHost) {
  let userForwardHostProp = options.forwardHostProp;
  if (userForwardHostProp && templateInfo.hasHostProps) {
    const isTemplate = target.localName == "template";
    let klass = templateInfo.templatizeTemplateClass;
    if (!klass) {
      if (isTemplate) {
        let templatizedBase = options.mutableData ? MutableDataTemplate : DataTemplate;
        class TemplatizedTemplate extends templatizedBase {
        }
        klass = templateInfo.templatizeTemplateClass = TemplatizedTemplate;
      } else {
        const templatizedBase = target.constructor;
        class TemplatizedTemplateExtension extends templatizedBase {
        }
        klass = templateInfo.templatizeTemplateClass = TemplatizedTemplateExtension;
      }
      let hostProps = templateInfo.hostProps;
      for (let prop in hostProps) {
        klass.prototype._addPropertyEffect(
          "_host_" + prop,
          klass.prototype.PROPERTY_EFFECT_TYPES.PROPAGATE,
          { fn: createForwardHostPropEffect(prop, userForwardHostProp) }
        );
        klass.prototype._createNotifyingProperty("_host_" + prop);
      }
      if (legacyWarnings && methodHost) {
        warnOnUndeclaredProperties(templateInfo, options, methodHost);
      }
    }
    if (target.__dataProto) {
      Object.assign(target.__data, target.__dataProto);
    }
    if (isTemplate) {
      upgradeTemplate(target, klass);
      target.__dataTemp = {};
      target.__dataPending = null;
      target.__dataOld = null;
      target._enableProperties();
    } else {
      Object.setPrototypeOf(target, klass.prototype);
      const hostProps = templateInfo.hostProps;
      for (let prop in hostProps) {
        prop = "_host_" + prop;
        if (prop in target) {
          const val = target[prop];
          delete target[prop];
          target.__data[prop] = val;
        }
      }
    }
  }
}
function createForwardHostPropEffect(hostProp, userForwardHostProp) {
  return function forwardHostProp(template2, prop, props) {
    userForwardHostProp.call(
      template2.__templatizeOwner,
      prop.substring("_host_".length),
      props[prop]
    );
  };
}
function addNotifyEffects(klass, template2, templateInfo, options) {
  let hostProps = templateInfo.hostProps || {};
  for (let iprop in options.instanceProps) {
    delete hostProps[iprop];
    let userNotifyInstanceProp = options.notifyInstanceProp;
    if (userNotifyInstanceProp) {
      klass.prototype._addPropertyEffect(
        iprop,
        klass.prototype.PROPERTY_EFFECT_TYPES.NOTIFY,
        { fn: createNotifyInstancePropEffect(iprop, userNotifyInstanceProp) }
      );
    }
  }
  if (options.forwardHostProp && template2.__dataHost) {
    for (let hprop in hostProps) {
      if (!templateInfo.hasHostProps) {
        templateInfo.hasHostProps = true;
      }
      klass.prototype._addPropertyEffect(
        hprop,
        klass.prototype.PROPERTY_EFFECT_TYPES.NOTIFY,
        { fn: createNotifyHostPropEffect() }
      );
    }
  }
}
function createNotifyInstancePropEffect(instProp, userNotifyInstanceProp) {
  return function notifyInstanceProp(inst, prop, props) {
    userNotifyInstanceProp.call(
      inst.__templatizeOwner,
      inst,
      prop,
      props[prop]
    );
  };
}
function createNotifyHostPropEffect() {
  return function notifyHostProp(inst, prop, props) {
    inst.__dataHost._setPendingPropertyOrPath("_host_" + prop, props[prop], true, true);
  };
}
function templatize(template2, owner, options) {
  if (strictTemplatePolicy && !findMethodHost(template2)) {
    throw new Error("strictTemplatePolicy: template owner not trusted");
  }
  options = /** @type {!TemplatizeOptions} */
  options || {};
  if (template2.__templatizeOwner) {
    throw new Error("A <template> can only be templatized once");
  }
  template2.__templatizeOwner = owner;
  const ctor = owner ? owner.constructor : TemplateInstanceBase;
  let templateInfo = ctor._parseTemplate(template2);
  let baseClass = templateInfo.templatizeInstanceClass;
  if (!baseClass) {
    baseClass = createTemplatizerClass(template2, templateInfo, options);
    templateInfo.templatizeInstanceClass = baseClass;
  }
  const methodHost = findMethodHost(template2);
  addPropagateEffects(template2, templateInfo, options, methodHost);
  let klass = class TemplateInstance extends baseClass {
  };
  klass.prototype._methodHost = methodHost;
  klass.prototype.__dataHost = /** @type {!DataTemplate} */
  template2;
  klass.prototype.__templatizeOwner = /** @type {!Object} */
  owner;
  klass.prototype.__hostProps = templateInfo.hostProps;
  klass = /** @type {function(new:TemplateInstanceBase)} */
  klass;
  return klass;
}
function warnOnUndeclaredProperties(templateInfo, options, methodHost) {
  const declaredProps = methodHost.constructor._properties;
  const { propertyEffects } = templateInfo;
  const { instanceProps } = options;
  for (let prop in propertyEffects) {
    if (!declaredProps[prop] && !(instanceProps && instanceProps[prop])) {
      const effects = propertyEffects[prop];
      for (let i2 = 0; i2 < effects.length; i2++) {
        const { part } = effects[i2].info;
        if (!(part.signature && part.signature.static)) {
          console.warn(`Property '${prop}' used in template but not declared in 'properties'; attribute will not be observed.`);
          break;
        }
      }
    }
  }
}
function modelForElement(template2, node) {
  let model;
  while (node) {
    if (model = node.__dataHost ? node : node.__templatizeInstance) {
      if (model.__dataHost != template2) {
        node = model.__dataHost;
      } else {
        return model;
      }
    } else {
      node = wrap$1(node).parentNode;
    }
  }
  return null;
}
/**
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/
class DomIfBase extends PolymerElement {
  // Not needed to find template; can be removed once the analyzer
  // can find the tag name from customElements.define call
  static get is() {
    return "dom-if";
  }
  static get template() {
    return null;
  }
  static get properties() {
    return {
      /**
       * Fired whenever DOM is added or removed/hidden by this template (by
       * default, rendering occurs lazily).  To force immediate rendering, call
       * `render`.
       *
       * @event dom-change
       */
      /**
       * A boolean indicating whether this template should stamp.
       */
      if: {
        type: Boolean,
        observer: "__debounceRender"
      },
      /**
       * When true, elements will be removed from DOM and discarded when `if`
       * becomes false and re-created and added back to the DOM when `if`
       * becomes true.  By default, stamped elements will be hidden but left
       * in the DOM when `if` becomes false, which is generally results
       * in better performance.
       */
      restamp: {
        type: Boolean,
        observer: "__debounceRender"
      },
      /**
       * When the global `suppressTemplateNotifications` setting is used, setting
       * `notifyDomChange: true` will enable firing `dom-change` events on this
       * element.
       */
      notifyDomChange: {
        type: Boolean
      }
    };
  }
  constructor() {
    super();
    this.__renderDebouncer = null;
    this._lastIf = false;
    this.__hideTemplateChildren__ = false;
    this.__template;
    this._templateInfo;
  }
  __debounceRender() {
    this.__renderDebouncer = Debouncer2.debounce(
      this.__renderDebouncer,
      microTask,
      () => this.__render()
    );
    enqueueDebouncer(this.__renderDebouncer);
  }
  /**
   * @override
   * @return {void}
   */
  disconnectedCallback() {
    super.disconnectedCallback();
    const parent = wrap$1(this).parentNode;
    if (!parent || parent.nodeType == Node.DOCUMENT_FRAGMENT_NODE && !wrap$1(parent).host) {
      this.__teardownInstance();
    }
  }
  /**
   * @override
   * @return {void}
   */
  connectedCallback() {
    super.connectedCallback();
    if (!hideElementsGlobally()) {
      this.style.display = "none";
    }
    if (this.if) {
      this.__debounceRender();
    }
  }
  /**
   * Ensures a template has been assigned to `this.__template`.  If it has not
   * yet been, it querySelectors for it in its children and if it does not yet
   * exist (e.g. in parser-generated case), opens a mutation observer and
   * waits for it to appear (returns false if it has not yet been found,
   * otherwise true).  In the `removeNestedTemplates` case, the "template" will
   * be the `dom-if` element itself.
   *
   * @return {boolean} True when a template has been found, false otherwise
   */
  __ensureTemplate() {
    if (!this.__template) {
      const thisAsTemplate = (
        /** @type {!HTMLTemplateElement} */
        /** @type {!HTMLElement} */
        this
      );
      let template2 = thisAsTemplate._templateInfo ? thisAsTemplate : (
        /** @type {!HTMLTemplateElement} */
        wrap$1(thisAsTemplate).querySelector("template")
      );
      if (!template2) {
        let observer2 = new MutationObserver(() => {
          if (wrap$1(this).querySelector("template")) {
            observer2.disconnect();
            this.__render();
          } else {
            throw new Error("dom-if requires a <template> child");
          }
        });
        observer2.observe(this, { childList: true });
        return false;
      }
      this.__template = template2;
    }
    return true;
  }
  /**
   * Ensures a an instance of the template has been created and inserted. This
   * method may return false if the template has not yet been found or if
   * there is no `parentNode` to insert the template into (in either case,
   * connection or the template-finding mutation observer firing will queue
   * another render, causing this method to be called again at a more
   * appropriate time).
   *
   * Subclasses should implement the following methods called here:
   * - `__hasInstance`
   * - `__createAndInsertInstance`
   * - `__getInstanceNodes`
   *
   * @return {boolean} True if the instance was created, false otherwise.
   */
  __ensureInstance() {
    let parentNode = wrap$1(this).parentNode;
    if (!this.__hasInstance()) {
      if (!parentNode) {
        return false;
      }
      if (!this.__ensureTemplate()) {
        return false;
      }
      this.__createAndInsertInstance(parentNode);
    } else {
      let children = this.__getInstanceNodes();
      if (children && children.length) {
        let lastChild = wrap$1(this).previousSibling;
        if (lastChild !== children[children.length - 1]) {
          for (let i2 = 0, n; i2 < children.length && (n = children[i2]); i2++) {
            wrap$1(parentNode).insertBefore(n, this);
          }
        }
      }
    }
    return true;
  }
  /**
   * Forces the element to render its content. Normally rendering is
   * asynchronous to a provoking change. This is done for efficiency so
   * that multiple changes trigger only a single render. The render method
   * should be called if, for example, template rendering is required to
   * validate application state.
   *
   * @return {void}
   */
  render() {
    flush();
  }
  /**
   * Performs the key rendering steps:
   * 1. Ensure a template instance has been stamped (when true)
   * 2. Remove the template instance (when false and restamp:true)
   * 3. Sync the hidden state of the instance nodes with the if/restamp state
   * 4. Fires the `dom-change` event when necessary
   *
   * @return {void}
   */
  __render() {
    if (this.if) {
      if (!this.__ensureInstance()) {
        return;
      }
    } else if (this.restamp) {
      this.__teardownInstance();
    }
    this._showHideChildren();
    if ((!suppressTemplateNotifications || this.notifyDomChange) && this.if != this._lastIf) {
      this.dispatchEvent(new CustomEvent("dom-change", {
        bubbles: true,
        composed: true
      }));
      this._lastIf = this.if;
    }
  }
  // Ideally these would be annotated as abstract methods in an abstract class,
  // but closure compiler is finnicky
  /* eslint-disable valid-jsdoc */
  /**
   * Abstract API to be implemented by subclass: Returns true if a template
   * instance has been created and inserted.
   *
   * @protected
   * @return {boolean} True when an instance has been created.
   */
  __hasInstance() {
  }
  /**
   * Abstract API to be implemented by subclass: Returns the child nodes stamped
   * from a template instance.
   *
   * @protected
   * @return {Array<Node>} Array of child nodes stamped from the template
   * instance.
   */
  __getInstanceNodes() {
  }
  /**
   * Abstract API to be implemented by subclass: Creates an instance of the
   * template and inserts it into the given parent node.
   *
   * @protected
   * @param {Node} parentNode The parent node to insert the instance into
   * @return {void}
   */
  __createAndInsertInstance(parentNode) {
  }
  // eslint-disable-line no-unused-vars
  /**
   * Abstract API to be implemented by subclass: Removes nodes created by an
   * instance of a template and any associated cleanup.
   *
   * @protected
   * @return {void}
   */
  __teardownInstance() {
  }
  /**
   * Abstract API to be implemented by subclass: Shows or hides any template
   * instance childNodes based on the `if` state of the element and its
   * `__hideTemplateChildren__` property.
   *
   * @protected
   * @return {void}
   */
  _showHideChildren() {
  }
  /* eslint-enable valid-jsdoc */
}
class DomIfFast extends DomIfBase {
  constructor() {
    super();
    this.__instance = null;
    this.__syncInfo = null;
  }
  /**
   * Implementation of abstract API needed by DomIfBase.
   *
   * @override
   * @return {boolean} True when an instance has been created.
   */
  __hasInstance() {
    return Boolean(this.__instance);
  }
  /**
   * Implementation of abstract API needed by DomIfBase.
   *
   * @override
   * @return {Array<Node>} Array of child nodes stamped from the template
   * instance.
   */
  __getInstanceNodes() {
    return this.__instance.templateInfo.childNodes;
  }
  /**
   * Implementation of abstract API needed by DomIfBase.
   *
   * Stamps the template by calling `_stampTemplate` on the `__dataHost` of this
   * element and then inserts the resulting nodes into the given `parentNode`.
   *
   * @override
   * @param {Node} parentNode The parent node to insert the instance into
   * @return {void}
   */
  __createAndInsertInstance(parentNode) {
    const host = this.__dataHost || this;
    if (strictTemplatePolicy) {
      if (!this.__dataHost) {
        throw new Error("strictTemplatePolicy: template owner not trusted");
      }
    }
    const templateInfo = host._bindTemplate(
      /** @type {!HTMLTemplateElement} */
      this.__template,
      true
    );
    templateInfo.runEffects = (runEffects2, changedProps, hasPaths) => {
      let syncInfo = this.__syncInfo;
      if (this.if) {
        if (syncInfo) {
          this.__syncInfo = null;
          this._showHideChildren();
          changedProps = Object.assign(syncInfo.changedProps, changedProps);
        }
        runEffects2(changedProps, hasPaths);
      } else {
        if (this.__instance) {
          if (!syncInfo) {
            syncInfo = this.__syncInfo = { runEffects: runEffects2, changedProps: {} };
          }
          if (hasPaths) {
            for (const p in changedProps) {
              const rootProp = root(p);
              syncInfo.changedProps[rootProp] = this.__dataHost[rootProp];
            }
          } else {
            Object.assign(syncInfo.changedProps, changedProps);
          }
        }
      }
    };
    this.__instance = host._stampTemplate(
      /** @type {!HTMLTemplateElement} */
      this.__template,
      templateInfo
    );
    wrap$1(parentNode).insertBefore(this.__instance, this);
  }
  /**
   * Run effects for any properties that changed while the `if` was false.
   *
   * @return {void}
   */
  __syncHostProperties() {
    const syncInfo = this.__syncInfo;
    if (syncInfo) {
      this.__syncInfo = null;
      syncInfo.runEffects(syncInfo.changedProps, false);
    }
  }
  /**
   * Implementation of abstract API needed by DomIfBase.
   *
   * Remove the instance and any nodes it created.  Uses the `__dataHost`'s
   * runtime `_removeBoundDom` method.
   *
   * @override
   * @return {void}
   */
  __teardownInstance() {
    const host = this.__dataHost || this;
    if (this.__instance) {
      host._removeBoundDom(this.__instance);
      this.__instance = null;
      this.__syncInfo = null;
    }
  }
  /**
   * Implementation of abstract API needed by DomIfBase.
   *
   * Shows or hides the template instance top level child nodes. For
   * text nodes, `textContent` is removed while "hidden" and replaced when
   * "shown."
   *
   * @override
   * @return {void}
   * @protected
   * @suppress {visibility}
   */
  _showHideChildren() {
    const hidden = this.__hideTemplateChildren__ || !this.if;
    if (this.__instance && Boolean(this.__instance.__hidden) !== hidden) {
      this.__instance.__hidden = hidden;
      showHideChildren(hidden, this.__instance.templateInfo.childNodes);
    }
    if (!hidden) {
      this.__syncHostProperties();
    }
  }
}
class DomIfLegacy extends DomIfBase {
  constructor() {
    super();
    this.__ctor = null;
    this.__instance = null;
    this.__invalidProps = null;
  }
  /**
   * Implementation of abstract API needed by DomIfBase.
   *
   * @override
   * @return {boolean} True when an instance has been created.
   */
  __hasInstance() {
    return Boolean(this.__instance);
  }
  /**
   * Implementation of abstract API needed by DomIfBase.
   *
   * @override
   * @return {Array<Node>} Array of child nodes stamped from the template
   * instance.
   */
  __getInstanceNodes() {
    return this.__instance.children;
  }
  /**
   * Implementation of abstract API needed by DomIfBase.
   *
   * Stamps the template by creating a new instance of the templatized
   * constructor (which is created lazily if it does not yet exist), and then
   * inserts its resulting `root` doc fragment into the given `parentNode`.
   *
   * @override
   * @param {Node} parentNode The parent node to insert the instance into
   * @return {void}
   */
  __createAndInsertInstance(parentNode) {
    if (!this.__ctor) {
      this.__ctor = templatize(
        /** @type {!HTMLTemplateElement} */
        this.__template,
        this,
        {
          // dom-if templatizer instances require `mutable: true`, as
          // `__syncHostProperties` relies on that behavior to sync objects
          mutableData: true,
          /**
           * @param {string} prop Property to forward
           * @param {*} value Value of property
           * @this {DomIfLegacy}
           */
          forwardHostProp: function(prop, value) {
            if (this.__instance) {
              if (this.if) {
                this.__instance.forwardHostProp(prop, value);
              } else {
                this.__invalidProps = this.__invalidProps || /* @__PURE__ */ Object.create(null);
                this.__invalidProps[root(prop)] = true;
              }
            }
          }
        }
      );
    }
    this.__instance = new this.__ctor();
    wrap$1(parentNode).insertBefore(this.__instance.root, this);
  }
  /**
   * Implementation of abstract API needed by DomIfBase.
   *
   * Removes the instance and any nodes it created.
   *
   * @override
   * @return {void}
   */
  __teardownInstance() {
    if (this.__instance) {
      let c$ = this.__instance.children;
      if (c$ && c$.length) {
        let parent = wrap$1(c$[0]).parentNode;
        if (parent) {
          parent = wrap$1(parent);
          for (let i2 = 0, n; i2 < c$.length && (n = c$[i2]); i2++) {
            parent.removeChild(n);
          }
        }
      }
      this.__invalidProps = null;
      this.__instance = null;
    }
  }
  /**
   * Forwards any properties that changed while the `if` was false into the
   * template instance and flushes it.
   *
   * @return {void}
   */
  __syncHostProperties() {
    let props = this.__invalidProps;
    if (props) {
      this.__invalidProps = null;
      for (let prop in props) {
        this.__instance._setPendingProperty(prop, this.__dataHost[prop]);
      }
      this.__instance._flushProperties();
    }
  }
  /**
   * Implementation of abstract API needed by DomIfBase.
   *
   * Shows or hides the template instance top level child elements. For
   * text nodes, `textContent` is removed while "hidden" and replaced when
   * "shown."
   *
   * @override
   * @protected
   * @return {void}
   * @suppress {visibility}
   */
  _showHideChildren() {
    const hidden = this.__hideTemplateChildren__ || !this.if;
    if (this.__instance && Boolean(this.__instance.__hidden) !== hidden) {
      this.__instance.__hidden = hidden;
      this.__instance._showHideChildren(hidden);
    }
    if (!hidden) {
      this.__syncHostProperties();
    }
  }
}
const DomIf = fastDomIf ? DomIfFast : DomIfLegacy;
customElements.define(DomIf.is, DomIf);
/**
 * @license
 * Copyright 2020 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
window.ShadyDOM?.inUse && window.ShadyDOM?.noPatch === true ? window.ShadyDOM.wrap : (node) => node;
const TemplateResultType = {
  SVG: 2
};
const isTemplateResult = (value, type) => type === void 0 ? (
  // This property needs to remain unminified.
  value?.["_$litType$"] !== void 0
) : value?.["_$litType$"] === type;
const isSingleExpression = (part) => part.strings === void 0;
const RESET_VALUE = {};
const setCommittedValue = (part, value = RESET_VALUE) => part._$committedValue = value;
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const notifyChildrenConnectedChanged = (parent, isConnected) => {
  const children = parent._$disconnectableChildren;
  if (children === void 0) {
    return false;
  }
  for (const obj of children) {
    obj["_$notifyDirectiveConnectionChanged"]?.(isConnected, false);
    notifyChildrenConnectedChanged(obj, isConnected);
  }
  return true;
};
const removeDisconnectableFromParent = (obj) => {
  let parent, children;
  do {
    if ((parent = obj._$parent) === void 0) {
      break;
    }
    children = parent._$disconnectableChildren;
    children.delete(obj);
    obj = parent;
  } while (children?.size === 0);
};
const addDisconnectableToParent = (obj) => {
  for (let parent; parent = obj._$parent; obj = parent) {
    let children = parent._$disconnectableChildren;
    if (children === void 0) {
      parent._$disconnectableChildren = children = /* @__PURE__ */ new Set();
    } else if (children.has(obj)) {
      break;
    }
    children.add(obj);
    installDisconnectAPI(parent);
  }
};
function reparentDisconnectables(newParent) {
  if (this._$disconnectableChildren !== void 0) {
    removeDisconnectableFromParent(this);
    this._$parent = newParent;
    addDisconnectableToParent(this);
  } else {
    this._$parent = newParent;
  }
}
function notifyChildPartConnectedChanged(isConnected, isClearingValue = false, fromPartIndex = 0) {
  const value = this._$committedValue;
  const children = this._$disconnectableChildren;
  if (children === void 0 || children.size === 0) {
    return;
  }
  if (isClearingValue) {
    if (Array.isArray(value)) {
      for (let i2 = fromPartIndex; i2 < value.length; i2++) {
        notifyChildrenConnectedChanged(value[i2], false);
        removeDisconnectableFromParent(value[i2]);
      }
    } else if (value != null) {
      notifyChildrenConnectedChanged(value, false);
      removeDisconnectableFromParent(value);
    }
  } else {
    notifyChildrenConnectedChanged(this, isConnected);
  }
}
const installDisconnectAPI = (obj) => {
  if (obj.type == PartType.CHILD) {
    obj._$notifyConnectionChanged ??= notifyChildPartConnectedChanged;
    obj._$reparentDisconnectables ??= reparentDisconnectables;
  }
};
class AsyncDirective extends Directive {
  constructor() {
    super(...arguments);
    this._$disconnectableChildren = void 0;
  }
  /**
   * Initialize the part with internal fields
   * @param part
   * @param parent
   * @param attributeIndex
   */
  _$initialize(part, parent, attributeIndex) {
    super._$initialize(part, parent, attributeIndex);
    addDisconnectableToParent(this);
    this.isConnected = part._$isConnected;
  }
  // This property needs to remain unminified.
  /**
   * Called from the core code when a directive is going away from a part (in
   * which case `shouldRemoveFromParent` should be true), and from the
   * `setChildrenConnected` helper function when recursively changing the
   * connection state of a tree (in which case `shouldRemoveFromParent` should
   * be false).
   *
   * @param isConnected
   * @param isClearingDirective - True when the directive itself is being
   *     removed; false when the tree is being disconnected
   * @internal
   */
  ["_$notifyDirectiveConnectionChanged"](isConnected, isClearingDirective = true) {
    if (isConnected !== this.isConnected) {
      this.isConnected = isConnected;
      if (isConnected) {
        this.reconnected?.();
      } else {
        this.disconnected?.();
      }
    }
    if (isClearingDirective) {
      notifyChildrenConnectedChanged(this, isConnected);
      removeDisconnectableFromParent(this);
    }
  }
  /**
   * Sets the value of the directive's Part outside the normal `update`/`render`
   * lifecycle of a directive.
   *
   * This method should not be called synchronously from a directive's `update`
   * or `render`.
   *
   * @param directive The directive to update
   * @param value The value to set
   */
  setValue(value) {
    if (isSingleExpression(this.__part)) {
      this.__part._$setValue(value, this);
    } else {
      if (this.__attributeIndex === void 0) {
        throw new Error(`Expected this.__attributeIndex to be a number`);
      }
      const newValues = [...this.__part._$committedValue];
      newValues[this.__attributeIndex] = value;
      this.__part._$setValue(newValues, this, 0);
    }
  }
  /**
   * User callbacks for implementing logic to release any resources/subscriptions
   * that may have been retained by this directive. Since directives may also be
   * re-connected, `reconnected` should also be implemented to restore the
   * working state of the directive prior to the next render.
   */
  disconnected() {
  }
  reconnected() {
  }
}
class FlowComponentDirective extends AsyncDirective {
  constructor(partInfo) {
    super(partInfo);
    if (partInfo.type !== PartType.CHILD) {
      throw new Error(`${this.constructor.directiveName}() can only be used in child bindings`);
    }
  }
  update(part, [appid, nodeid]) {
    this.updateContent(part, appid, nodeid);
    return noChange;
  }
  updateContent(part, appid, nodeid) {
    const { parentNode, startNode } = part;
    this.__parentNode = parentNode;
    const hasNewNodeId = nodeid !== void 0 && nodeid !== null;
    const newNode = hasNewNodeId ? this.getNewNode(appid, nodeid) : null;
    const oldNode = this.getOldNode(part);
    clearTimeout(this.__parentNode.__nodeRetryTimeout);
    if (hasNewNodeId && !newNode) {
      this.__parentNode.__nodeRetryTimeout = setTimeout(() => this.updateContent(part, appid, nodeid));
    } else if (oldNode === newNode) {
      return;
    } else if (oldNode && newNode) {
      parentNode.replaceChild(newNode, oldNode);
    } else if (oldNode) {
      parentNode.removeChild(oldNode);
    } else if (newNode) {
      startNode.after(newNode);
    }
  }
  getNewNode(appid, nodeid) {
    return window.Vaadin.Flow.clients[appid].getByNodeId(nodeid);
  }
  getOldNode(part) {
    const { startNode, endNode } = part;
    if (startNode.nextSibling === endNode) {
      return;
    }
    return startNode.nextSibling;
  }
  disconnected() {
    clearTimeout(this.__parentNode.__nodeRetryTimeout);
  }
}
const flowComponentDirective = directive(FlowComponentDirective);
function getNode(appid, nodeid) {
  return flowComponentDirective(appid, nodeid);
}
function setChildNodes(appid, nodeIds, root2) {
  render(html$1`${nodeIds.map((id) => flowComponentDirective(appid, id))}`, root2);
}
function patchVirtualContainer(container) {
  const originalInsertBefore = container.insertBefore;
  container.insertBefore = function(newNode, referenceNode) {
    if (referenceNode && referenceNode.parentNode === this) {
      return originalInsertBefore.call(this, newNode, referenceNode);
    } else {
      return originalInsertBefore.call(this, newNode, null);
    }
  };
}
window.Vaadin ||= {};
window.Vaadin.FlowComponentHost ||= { patchVirtualContainer, getNode, setChildNodes };
class FlowComponentRenderer extends PolymerElement {
  static get template() {
    return html`
      <style>
        :host {
          animation: 1ms flow-component-renderer-appear;
        }

        @keyframes flow-component-renderer-appear {
          to {
            opacity: 1;
          }
        }
      </style>
      <slot></slot>
    `;
  }
  static get is() {
    return "flow-component-renderer";
  }
  static get properties() {
    return {
      nodeid: Number,
      appid: String
    };
  }
  static get observers() {
    return ["_attachRenderedComponentIfAble(appid, nodeid)"];
  }
  ready() {
    super.ready();
    this.addEventListener("click", function(event) {
      if (this.firstChild && typeof this.firstChild.click === "function" && event.target === this) {
        event.stopPropagation();
        this.firstChild.click();
      }
    });
    this.addEventListener("animationend", this._onAnimationEnd);
  }
  _asyncAttachRenderedComponentIfAble() {
    this._debouncer = Debouncer2.debounce(this._debouncer, idlePeriod, () => this._attachRenderedComponentIfAble());
  }
  _attachRenderedComponentIfAble() {
    if (this.appid == null) {
      return;
    }
    if (this.nodeid == null) {
      if (this.firstChild) {
        this.removeChild(this.firstChild);
      }
      return;
    }
    const renderedComponent = this._getRenderedComponent();
    if (this.firstChild) {
      if (!renderedComponent) {
        this._asyncAttachRenderedComponentIfAble();
      } else if (this.firstChild !== renderedComponent) {
        this.replaceChild(renderedComponent, this.firstChild);
        this._defineFocusTarget();
        this.onComponentRendered();
      } else {
        this._defineFocusTarget();
        this.onComponentRendered();
      }
    } else {
      if (renderedComponent) {
        this.appendChild(renderedComponent);
        this._defineFocusTarget();
        this.onComponentRendered();
      } else {
        this._asyncAttachRenderedComponentIfAble();
      }
    }
  }
  _getRenderedComponent() {
    try {
      return window.Vaadin.Flow.clients[this.appid].getByNodeId(this.nodeid);
    } catch (error) {
      console.error("Could not get node %s from app %s", this.nodeid, this.appid);
      console.error(error);
    }
    return null;
  }
  onComponentRendered() {
  }
  /* Setting the `focus-target` attribute to the first focusable descendant
  starting from the firstChild necessary for the focus to be delegated
  within the flow-component-renderer when used inside a vaadin-grid cell  */
  _defineFocusTarget() {
    var focusable = this._getFirstFocusableDescendant(this.firstChild);
    if (focusable !== null) {
      focusable.setAttribute("focus-target", "true");
    }
  }
  _getFirstFocusableDescendant(node) {
    if (this._isFocusable(node)) {
      return node;
    }
    if (node.hasAttribute && (node.hasAttribute("disabled") || node.hasAttribute("hidden"))) {
      return null;
    }
    if (!node.children) {
      return null;
    }
    for (var i2 = 0; i2 < node.children.length; i2++) {
      var focusable = this._getFirstFocusableDescendant(node.children[i2]);
      if (focusable !== null) {
        return focusable;
      }
    }
    return null;
  }
  _isFocusable(node) {
    if (node.hasAttribute && typeof node.hasAttribute === "function" && (node.hasAttribute("disabled") || node.hasAttribute("hidden"))) {
      return false;
    }
    return node.tabIndex === 0;
  }
  _onAnimationEnd(e2) {
    if (e2.animationName.indexOf("flow-component-renderer-appear") === 0) {
      this._attachRenderedComponentIfAble();
    }
  }
}
window.customElements.define(FlowComponentRenderer.is, FlowComponentRenderer);
window.Vaadin.Flow.comboBoxConnector = {};
window.Vaadin.Flow.comboBoxConnector.initLazy = (comboBox2) => {
  if (comboBox2.$connector) {
    return;
  }
  comboBox2.$connector = {};
  const pageCallbacks = {};
  let cache = {};
  let lastFilter = "";
  const placeHolder = new window.Vaadin.ComboBoxPlaceholder();
  const serverFacade = /* @__PURE__ */ (() => {
    let lastFilterSentToServer = "";
    let dataCommunicatorResetNeeded = false;
    const needsDataCommunicatorReset = () => dataCommunicatorResetNeeded = true;
    const getLastFilterSentToServer = () => lastFilterSentToServer;
    const requestData = (startIndex, endIndex, params) => {
      const count = endIndex - startIndex;
      const filter2 = params.filter;
      comboBox2.$server.setRequestedRange(startIndex, count, filter2);
      lastFilterSentToServer = filter2;
      if (dataCommunicatorResetNeeded) {
        comboBox2.$server.resetDataCommunicator();
        dataCommunicatorResetNeeded = false;
      }
    };
    return {
      needsDataCommunicatorReset,
      getLastFilterSentToServer,
      requestData
    };
  })();
  const clearPageCallbacks = (pages = Object.keys(pageCallbacks)) => {
    pages.forEach((page) => {
      pageCallbacks[page]([], comboBox2.size);
      delete pageCallbacks[page];
      const pageStart = parseInt(page) * comboBox2.pageSize;
      const pageEnd = pageStart + comboBox2.pageSize;
      const end = Math.min(pageEnd, comboBox2.filteredItems.length);
      for (let i2 = pageStart; i2 < end; i2++) {
        comboBox2.filteredItems[i2] = placeHolder;
      }
    });
  };
  comboBox2.dataProvider = function(params, callback) {
    if (params.pageSize != comboBox2.pageSize) {
      throw "Invalid pageSize";
    }
    if (comboBox2._clientSideFilter) {
      if (cache[0]) {
        performClientSideFilter(cache[0], params.filter, callback);
        return;
      } else {
        params.filter = "";
      }
    }
    const filterChanged = params.filter !== lastFilter;
    if (filterChanged) {
      cache = {};
      lastFilter = params.filter;
      this._filterDebouncer = Debouncer2.debounce(this._filterDebouncer, timeOut.after(500), () => {
        if (serverFacade.getLastFilterSentToServer() === params.filter) {
          serverFacade.needsDataCommunicatorReset();
        }
        if (params.filter !== lastFilter) {
          throw new Error("Expected params.filter to be '" + lastFilter + "' but was '" + params.filter + "'");
        }
        this._filterDebouncer = void 0;
        clearPageCallbacks();
        comboBox2.dataProvider(params, callback);
      });
      return;
    }
    if (this._filterDebouncer) {
      pageCallbacks[params.page] = callback;
      return;
    }
    if (cache[params.page]) {
      commitPage(params.page, callback);
    } else {
      pageCallbacks[params.page] = callback;
      const maxRangeCount = Math.max(params.pageSize * 2, 500);
      const activePages = Object.keys(pageCallbacks).map((page) => parseInt(page));
      const rangeMin = Math.min(...activePages);
      const rangeMax = Math.max(...activePages);
      if (activePages.length * params.pageSize > maxRangeCount) {
        if (params.page === rangeMin) {
          clearPageCallbacks([String(rangeMax)]);
        } else {
          clearPageCallbacks([String(rangeMin)]);
        }
        comboBox2.dataProvider(params, callback);
      } else if (rangeMax - rangeMin + 1 !== activePages.length) {
        clearPageCallbacks();
      } else {
        const startIndex = params.pageSize * rangeMin;
        const endIndex = params.pageSize * (rangeMax + 1);
        serverFacade.requestData(startIndex, endIndex, params);
      }
    }
  };
  comboBox2.$connector.clear = (start, length) => {
    const firstPageToClear = Math.floor(start / comboBox2.pageSize);
    const numberOfPagesToClear = Math.ceil(length / comboBox2.pageSize);
    for (let i2 = firstPageToClear; i2 < firstPageToClear + numberOfPagesToClear; i2++) {
      delete cache[i2];
    }
  };
  comboBox2.$connector.filter = (item2, filter2) => {
    filter2 = filter2 ? filter2.toString().toLowerCase() : "";
    return comboBox2._getItemLabel(item2, comboBox2.itemLabelPath).toString().toLowerCase().indexOf(filter2) > -1;
  };
  comboBox2.$connector.set = (index, items, filter2) => {
    if (filter2 != serverFacade.getLastFilterSentToServer()) {
      return;
    }
    if (index % comboBox2.pageSize != 0) {
      throw "Got new data to index " + index + " which is not aligned with the page size of " + comboBox2.pageSize;
    }
    if (index === 0 && items.length === 0 && pageCallbacks[0]) {
      cache[0] = [];
      return;
    }
    const firstPageToSet = index / comboBox2.pageSize;
    const updatedPageCount = Math.ceil(items.length / comboBox2.pageSize);
    for (let i2 = 0; i2 < updatedPageCount; i2++) {
      let page = firstPageToSet + i2;
      let slice = items.slice(i2 * comboBox2.pageSize, (i2 + 1) * comboBox2.pageSize);
      cache[page] = slice;
    }
  };
  comboBox2.$connector.updateData = (items) => {
    const itemsMap = new Map(items.map((item2) => [item2.key, item2]));
    comboBox2.filteredItems = comboBox2.filteredItems.map((item2) => {
      return itemsMap.get(item2.key) || item2;
    });
  };
  comboBox2.$connector.updateSize = function(newSize) {
    if (!comboBox2._clientSideFilter) {
      comboBox2.size = newSize;
    }
  };
  comboBox2.$connector.reset = function() {
    clearPageCallbacks();
    cache = {};
    comboBox2.clearCache();
  };
  comboBox2.$connector.confirm = function(id, filter2) {
    if (filter2 != serverFacade.getLastFilterSentToServer()) {
      return;
    }
    let activePages = Object.getOwnPropertyNames(pageCallbacks);
    for (let i2 = 0; i2 < activePages.length; i2++) {
      let page = activePages[i2];
      if (cache[page]) {
        commitPage(page, pageCallbacks[page]);
      }
    }
    comboBox2.$server.confirmUpdate(id);
  };
  const commitPage = function(page, callback) {
    let data = cache[page];
    if (comboBox2._clientSideFilter) {
      performClientSideFilter(data, comboBox2.filter, callback);
    } else {
      delete cache[page];
      callback(data, comboBox2.size);
    }
  };
  const performClientSideFilter = function(page, filter2, callback) {
    let filteredItems = page;
    if (filter2) {
      filteredItems = page.filter((item2) => comboBox2.$connector.filter(item2, filter2));
    }
    callback(filteredItems, filteredItems.length);
  };
  comboBox2.addEventListener("custom-value-set", (e2) => e2.preventDefault());
  comboBox2.itemClassNameGenerator = function(item2) {
    return item2.className || "";
  };
};
window.Vaadin.ComboBoxPlaceholder = ComboBoxPlaceholder;
/**
 * @license
 * Copyright (c) 2021 - 2025 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const chip = css`
  :host {
    font-size: var(--lumo-font-size-xxs);
    line-height: 1;
    color: var(--lumo-body-text-color);
    border-radius: var(--lumo-border-radius-s);
    background-color: var(--lumo-contrast-20pct);
    cursor: var(--lumo-clickable-cursor);
    -webkit-font-smoothing: antialiased;
    -moz-osx-font-smoothing: grayscale;
  }

  :host([disabled]) {
    background-color: var(--lumo-contrast-10pct);
  }

  :host([focused]) [part='remove-button'] {
    color: inherit;
  }

  :host([slot='overflow']) {
    position: relative;
    min-width: var(--lumo-size-xxs);
    margin-inline-start: var(--lumo-space-s);
  }

  :host([slot='overflow'])::before,
  :host([slot='overflow'])::after {
    position: absolute;
    content: '';
    width: 100%;
    height: 100%;
    border-left: calc(var(--lumo-space-s) / 4) solid;
    border-radius: var(--lumo-border-radius-s);
    border-color: var(--lumo-contrast-30pct);
  }

  :host([slot='overflow'])::before {
    left: calc(-1 * var(--lumo-space-s) / 2);
  }

  :host([slot='overflow'])::after {
    left: calc(-1 * var(--lumo-space-s));
  }

  :host([count='2']) {
    margin-inline-start: calc(var(--lumo-space-s) / 2);
  }

  :host([count='2'])::after {
    display: none;
  }

  :host([count='1']) {
    margin-inline-start: 0;
  }

  :host([count='1'])::before,
  :host([count='1'])::after {
    display: none;
  }

  [part='label'] {
    font-weight: 500;
    line-height: 1.25;
  }

  [part='remove-button'] {
    display: flex;
    align-items: center;
    justify-content: center;
    margin-top: -0.3125em;
    margin-bottom: -0.3125em;
    margin-inline-start: auto;
    width: 1.25em;
    height: 1.25em;
    font-size: 1.5em;
    transition: none;
  }

  [part='remove-button']::before {
    content: var(--lumo-icons-cross);
  }

  :host([disabled]) [part='label'] {
    color: var(--lumo-disabled-text-color);
    -webkit-text-fill-color: var(--lumo-disabled-text-color);
    pointer-events: none;
  }
`;
registerStyles$1("vaadin-multi-select-combo-box-chip", [fieldButton, chip], {
  moduleId: "lumo-multi-select-combo-box-chip"
});
/**
 * @license
 * Copyright (c) 2021 - 2025 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const multiSelectComboBoxItem = css`
  @media (any-hover: hover) {
    :host(:hover[readonly]) {
      background-color: transparent;
      cursor: default;
    }
  }
`;
registerStyles$1("vaadin-multi-select-combo-box-item", [item, comboBoxItem, multiSelectComboBoxItem], {
  moduleId: "lumo-multi-select-combo-box-item"
});
registerStyles$1(
  "vaadin-multi-select-combo-box-overlay",
  [
    overlay,
    menuOverlayCore,
    comboBoxOverlay,
    loader,
    comboBoxLoader,
    css`
      :host {
        --_vaadin-multi-select-combo-box-items-container-border-width: var(--lumo-space-xs);
        --_vaadin-multi-select-combo-box-items-container-border-style: solid;
      }
    `
  ],
  { moduleId: "lumo-multi-select-combo-box-overlay" }
);
registerStyles$1(
  "vaadin-multi-select-combo-box-container",
  css`
    :host([auto-expand-vertically]) {
      padding-block: var(--lumo-space-xs);
    }
  `,
  { moduleId: "lumo-multi-select-combo-box-container" }
);
const multiSelectComboBox$1 = css`
  :host([has-value]) {
    padding-inline-start: 0;
  }

  :host([has-value]) ::slotted(input:placeholder-shown) {
    caret-color: var(--lumo-body-text-color) !important;
  }

  [part='label'] {
    flex-shrink: 0;
  }

  /* Override input-container styles */
  [part='input-field'] ::slotted([slot='chip']),
  [part='input-field'] ::slotted([slot='overflow']) {
    min-height: auto;
    padding: 0.3125em calc(0.5em + var(--lumo-border-radius-s) / 4);
    color: var(--lumo-body-text-color);
    -webkit-mask-image: none;
    mask-image: none;
  }

  :host([auto-expand-vertically]) ::slotted([slot='chip']) {
    margin-block: calc(var(--lumo-space-xs) / 2);
  }

  ::slotted([slot='chip']:not([readonly]):not([disabled])) {
    padding-inline-end: 0;
  }

  :host([auto-expand-vertically]) ::slotted([slot='input']) {
    min-height: calc(var(--lumo-text-field-size, var(--lumo-size-m)) - 2 * var(--lumo-space-xs));
  }

  ::slotted([slot='chip']:not(:last-of-type)),
  ::slotted([slot='overflow']:not(:last-of-type)) {
    margin-inline-end: var(--lumo-space-xs);
  }

  ::slotted([slot='chip'][focused]) {
    background-color: var(--vaadin-selection-color, var(--lumo-primary-color));
    color: var(--lumo-primary-contrast-color);
  }

  [part='toggle-button']::before {
    content: var(--lumo-icons-dropdown);
  }

  :host([readonly][has-value]) [part='toggle-button'] {
    color: var(--lumo-contrast-60pct);
    cursor: var(--lumo-clickable-cursor);
  }
`;
registerStyles$1("vaadin-multi-select-combo-box", [inputFieldShared$1, multiSelectComboBox$1], {
  moduleId: "lumo-multi-select-combo-box"
});
/**
 * @license
 * Copyright (c) 2021 - 2025 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const multiSelectComboBox = css`
  :host {
    max-width: 100%;
    --input-min-width: var(--vaadin-multi-select-combo-box-input-min-width, 4em);
    --_chip-min-width: var(--vaadin-multi-select-combo-box-chip-min-width, 50px);
  }

  #chips {
    display: flex;
    align-items: center;
  }

  ::slotted(input) {
    box-sizing: border-box;
    flex: 1 0 var(--input-min-width);
  }

  ::slotted([slot='chip']),
  ::slotted([slot='overflow']) {
    flex: 0 1 auto;
  }

  ::slotted([slot='chip']) {
    overflow: hidden;
  }

  :host(:is([readonly], [disabled])) ::slotted(input) {
    flex-grow: 0;
    flex-basis: 0;
    padding: 0;
  }

  :host([auto-expand-vertically]) #chips {
    display: contents;
  }

  :host([auto-expand-horizontally]) [class$='container'] {
    width: auto;
  }
`;
const multiSelectComboBoxChip = css`
  :host {
    display: inline-flex;
    align-items: center;
    align-self: center;
    white-space: nowrap;
    box-sizing: border-box;
  }

  [part='label'] {
    overflow: hidden;
    text-overflow: ellipsis;
  }

  :host([hidden]),
  :host(:is([readonly], [disabled], [slot='overflow'])) [part='remove-button'] {
    display: none !important;
  }

  @media (forced-colors: active) {
    :host {
      outline: 1px solid;
      outline-offset: -1px;
    }
  }
`;
/**
 * @license
 * Copyright (c) 2021 - 2025 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
registerStyles$1("vaadin-multi-select-combo-box-chip", multiSelectComboBoxChip, {
  moduleId: "vaadin-multi-select-combo-box-chip"
});
class MultiSelectComboBoxChip extends ThemableMixin(PolymerElement) {
  static get is() {
    return "vaadin-multi-select-combo-box-chip";
  }
  static get properties() {
    return {
      disabled: {
        type: Boolean,
        reflectToAttribute: true
      },
      readonly: {
        type: Boolean,
        reflectToAttribute: true
      },
      label: {
        type: String
      },
      item: {
        type: Object
      }
    };
  }
  static get template() {
    return html`
      <div part="label">[[label]]</div>
      <div part="remove-button" on-click="_onRemoveClick"></div>
    `;
  }
  /** @private */
  _onRemoveClick(event) {
    event.stopPropagation();
    this.dispatchEvent(
      new CustomEvent("item-removed", {
        detail: {
          item: this.item
        },
        bubbles: true,
        composed: true
      })
    );
  }
}
defineCustomElement(MultiSelectComboBoxChip);
/**
 * @license
 * Copyright (c) 2021 - 2025 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
registerStyles$1(
  "vaadin-multi-select-combo-box-container",
  css`
    #wrapper {
      display: flex;
      width: 100%;
      min-width: 0;
    }

    :host([auto-expand-vertically]) #wrapper {
      flex-wrap: wrap;
    }
  `,
  {
    moduleId: "vaadin-multi-select-combo-box-container-styles"
  }
);
let memoizedTemplate$2;
class MultiSelectComboBoxContainer extends InputContainer {
  static get is() {
    return "vaadin-multi-select-combo-box-container";
  }
  static get template() {
    if (!memoizedTemplate$2) {
      memoizedTemplate$2 = super.template.cloneNode(true);
      const content = memoizedTemplate$2.content;
      const slots = content.querySelectorAll("slot");
      const wrapper = document.createElement("div");
      wrapper.setAttribute("id", "wrapper");
      content.insertBefore(wrapper, slots[2]);
      wrapper.appendChild(slots[0]);
      wrapper.appendChild(slots[1]);
    }
    return memoizedTemplate$2;
  }
  static get properties() {
    return {
      /**
       * Set to true to not collapse selected items chips into the overflow
       * chip and instead always expand vertically, causing input field to
       * wrap into multiple lines when width is limited.
       * @attr {boolean} auto-expand-vertically
       */
      autoExpandVertically: {
        type: Boolean,
        reflectToAttribute: true
      }
    };
  }
}
defineCustomElement(MultiSelectComboBoxContainer);
/**
 * @license
 * Copyright (c) 2021 - 2025 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
class MultiSelectComboBoxItem extends ComboBoxItemMixin(ThemableMixin(DirMixin(PolymerElement))) {
  static get is() {
    return "vaadin-multi-select-combo-box-item";
  }
  static get template() {
    return html`
      <style>
        :host {
          display: block;
        }

        :host([hidden]) {
          display: none !important;
        }
      </style>
      <span part="checkmark" aria-hidden="true"></span>
      <div part="content">
        <slot></slot>
      </div>
    `;
  }
}
defineCustomElement(MultiSelectComboBoxItem);
/**
 * @license
 * Copyright (c) 2021 - 2025 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const multiSelectComboBoxOverlayStyles = css`
  #overlay {
    width: var(
      --vaadin-multi-select-combo-box-overlay-width,
      var(--_vaadin-multi-select-combo-box-overlay-default-width, auto)
    );
  }

  [part='content'] {
    display: flex;
    flex-direction: column;
    height: 100%;
  }
`;
registerStyles$1("vaadin-multi-select-combo-box-overlay", [overlayStyles, multiSelectComboBoxOverlayStyles], {
  moduleId: "vaadin-multi-select-combo-box-overlay-styles"
});
class MultiSelectComboBoxOverlay extends ComboBoxOverlayMixin(OverlayMixin(DirMixin(ThemableMixin(PolymerElement)))) {
  static get is() {
    return "vaadin-multi-select-combo-box-overlay";
  }
  static get template() {
    return html`
      <div id="backdrop" part="backdrop" hidden></div>
      <div part="overlay" id="overlay">
        <div part="loader"></div>
        <div part="content" id="content"><slot></slot></div>
      </div>
    `;
  }
}
defineCustomElement(MultiSelectComboBoxOverlay);
/**
 * @license
 * Copyright (c) 2021 - 2025 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
class MultiSelectComboBoxScroller extends ComboBoxScrollerMixin(PolymerElement) {
  static get is() {
    return "vaadin-multi-select-combo-box-scroller";
  }
  static get template() {
    return html`
      <style>
        :host {
          display: block;
          min-height: 1px;
          overflow: auto;

          /* Fixes item background from getting on top of scrollbars on Safari */
          transform: translate3d(0, 0, 0);

          /* Enable momentum scrolling on iOS */
          -webkit-overflow-scrolling: touch;

          /* Fixes scrollbar disappearing when 'Show scroll bars: Always' enabled in Safari */
          box-shadow: 0 0 0 white;
        }

        #selector {
          border-width: var(--_vaadin-multi-select-combo-box-items-container-border-width);
          border-style: var(--_vaadin-multi-select-combo-box-items-container-border-style);
          border-color: var(--_vaadin-multi-select-combo-box-items-container-border-color, transparent);
          position: relative;
        }
      </style>
      <div id="selector">
        <slot></slot>
      </div>
    `;
  }
  /** @protected */
  ready() {
    super.ready();
    this.setAttribute("aria-multiselectable", "true");
  }
  /**
   * @protected
   * @override
   */
  _isItemSelected(item2, _selectedItem, itemIdPath) {
    if (item2 instanceof ComboBoxPlaceholder) {
      return false;
    }
    if (this.owner.readonly) {
      return false;
    }
    return this.owner._findIndex(item2, this.owner.selectedItems, itemIdPath) > -1;
  }
  /**
   * @param {HTMLElement} el
   * @param {number} index
   * @protected
   * @override
   */
  _updateElement(el, index) {
    super._updateElement(el, index);
    el.toggleAttribute("readonly", this.owner.readonly);
  }
}
defineCustomElement(MultiSelectComboBoxScroller);
/**
 * @license
 * Copyright (c) 2021 - 2025 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const MultiSelectComboBoxInternalMixin = (superClass) => class MultiSelectComboBoxInternalMixinClass extends ComboBoxDataProviderMixin(ComboBoxMixin(superClass)) {
  static get properties() {
    return {
      /**
       * A subset of items, filtered based on the user input.
       */
      filteredItems: {
        type: Array,
        notify: true,
        sync: true
      },
      /**
       * When true, filter string isn't cleared after selecting an item.
       */
      keepFilter: {
        type: Boolean,
        value: false
      },
      /**
       * When set to `true`, "loading" attribute is set
       * on the host and the overlay element.
       * @type {boolean}
       */
      loading: {
        type: Boolean,
        notify: true,
        sync: true
      },
      /**
       * Total number of items.
       * @type {number | undefined}
       */
      size: {
        type: Number,
        notify: true,
        observer: "_sizeChanged",
        sync: true
      },
      /**
       * Selected items to render in the dropdown
       * when the component is read-only.
       */
      selectedItems: {
        type: Array,
        value: () => []
      },
      /**
       * Set to true to group selected items at the top of the overlay.
       * @attr {boolean} selected-items-on-top
       */
      selectedItemsOnTop: {
        type: Boolean,
        value: false,
        sync: true
      },
      /**
       * Last input value entered by the user before value is updated.
       * Used to store `filter` property value before clearing it.
       */
      lastFilter: {
        type: String,
        notify: true,
        sync: true
      },
      /**
       * A subset of items to be shown at the top of the overlay.
       */
      topGroup: {
        type: Array,
        observer: "_topGroupChanged",
        sync: true
      },
      _target: {
        type: Object
      }
    };
  }
  static get observers() {
    return ["_readonlyChanged(readonly)"];
  }
  /**
   * Reference to the clear button element.
   * @protected
   * @return {!HTMLElement}
   */
  get clearElement() {
    return this.querySelector('[part="clear-button"]');
  }
  /**
   * Tag name prefix used by scroller and items.
   * @protected
   * @return {string}
   */
  get _tagNamePrefix() {
    return "vaadin-multi-select-combo-box";
  }
  constructor() {
    super();
    this.addEventListener("custom-value-set", this.__onCustomValueSet.bind(this));
  }
  /**
   * Override method inherited from the combo-box
   * to allow opening dropdown when readonly.
   * @override
   */
  open() {
    if (!this.disabled && !(this.readonly && this.selectedItems.length === 0)) {
      this.opened = true;
    }
  }
  /** @protected */
  ready() {
    super.ready();
    this._target = this;
    this._toggleElement = this.querySelector(".toggle-button");
  }
  /** @protected */
  _updateOverlayWidth() {
    this.$.overlay._updateOverlayWidth();
  }
  /** @private */
  _readonlyChanged() {
    this._setDropdownItems(this.filteredItems);
  }
  /**
   * Override combo-box method to group selected
   * items at the top of the overlay.
   *
   * @protected
   * @override
   */
  _setDropdownItems(items) {
    if (this.readonly) {
      super._setDropdownItems(this.selectedItems);
      return;
    }
    if (this.filter || !this.selectedItemsOnTop) {
      super._setDropdownItems(items);
      return;
    }
    if (items && items.length && this.topGroup && this.topGroup.length) {
      const filteredItems = items.filter(
        (item2) => this._comboBox._findIndex(item2, this.topGroup, this.itemIdPath) === -1
      );
      super._setDropdownItems(this.topGroup.concat(filteredItems));
      return;
    }
    super._setDropdownItems(items);
  }
  /** @private */
  _topGroupChanged(topGroup) {
    if (topGroup) {
      this._setDropdownItems(this.filteredItems);
    }
  }
  /**
   * Override combo-box method to set correct owner for using by item renderers.
   * This needs to be done before the scroller gets added to the DOM to ensure
   * Lit directive works in case when combo-box is opened using attribute.
   *
   * @protected
   * @override
   */
  _initScroller() {
    const comboBox2 = this.getRootNode().host;
    this._comboBox = comboBox2;
    super._initScroller(comboBox2);
  }
  /**
   * Override Enter handler to keep overlay open
   * when item is selected or unselected.
   * @param {!Event} event
   * @protected
   * @override
   */
  _onEnter(event) {
    if (this.opened) {
      event.preventDefault();
      event.stopPropagation();
      if (this.readonly) {
        this.close();
      } else if (this._hasValidInputValue()) {
        const focusedItem = this._dropdownItems[this._focusedIndex];
        this._commitValue();
        this._focusedIndex = this._dropdownItems.indexOf(focusedItem);
      }
      return;
    }
    super._onEnter(event);
  }
  /**
   * Override Escape handler to not clear
   * selected items when readonly.
   * @param {!Event} event
   * @protected
   * @override
   */
  _onEscape(event) {
    if (this.readonly) {
      event.stopPropagation();
      if (this.opened) {
        this.close();
      }
      return;
    }
    super._onEscape(event);
  }
  /**
   * Override from combo-box to ignore requests to clear the filter if the
   * keepFilter option is enabled. Exceptions are when the dropdown is closed,
   * so the filter is still cleared on cancel and focus out.
   * @protected
   * @override
   */
  _clearFilter() {
    if (!this.keepFilter || !this.opened) {
      super._clearFilter();
    }
  }
  /**
   * Override method from combo-box to always clear the filter when reverting
   * the input value, regardless of the keepFilter option.
   * @override
   * @protected
   */
  _revertInputValueToValue() {
    super._revertInputValueToValue();
    this.filter = "";
  }
  /**
   * @protected
   * @override
   */
  _commitValue() {
    this.lastFilter = this.filter;
    super._commitValue();
  }
  /**
   * Override method inherited from the combo-box
   * to not update focused item when readonly.
   * @protected
   * @override
   */
  _onArrowDown() {
    if (!this.readonly) {
      super._onArrowDown();
    } else if (!this.opened) {
      this.open();
    }
  }
  /**
   * Override method inherited from the combo-box
   * to not update focused item when readonly.
   * @protected
   * @override
   */
  _onArrowUp() {
    if (!this.readonly) {
      super._onArrowUp();
    } else if (!this.opened) {
      this.open();
    }
  }
  /**
   * Override method inherited from the combo-box
   * to close dropdown on blur when readonly.
   * @param {boolean} focused
   * @protected
   * @override
   */
  _setFocused(focused) {
    if (!focused) {
      this._ignoreCommitValue = true;
    }
    super._setFocused(focused);
    if (!focused && this.readonly && !this._closeOnBlurIsPrevented) {
      this.close();
    }
  }
  /**
   * Override method inherited from the combo-box
   * to not commit an already selected item again
   * after closing overlay on outside click.
   * @protected
   * @override
   */
  _onClosed() {
    this._ignoreCommitValue = true;
    super._onClosed();
  }
  /**
   * Override method inherited from the combo-box
   * to not commit an already selected item again
   * on blur, which would result in un-selecting.
   * @protected
   * @override
   */
  _detectAndDispatchChange() {
    if (this._ignoreCommitValue) {
      this._ignoreCommitValue = false;
      this.clear();
      this._inputElementValue = "";
      return;
    }
    super._detectAndDispatchChange();
  }
  /**
   * @param {CustomEvent} event
   * @protected
   * @override
   */
  _overlaySelectedItemChanged(event) {
    event.stopPropagation();
    if (this.readonly) {
      return;
    }
    if (event.detail.item instanceof ComboBoxPlaceholder) {
      return;
    }
    if (this.opened) {
      this.lastFilter = this.filter;
      this.dispatchEvent(
        new CustomEvent("combo-box-item-selected", {
          detail: {
            item: event.detail.item
          }
        })
      );
    }
  }
  /**
   * Override method inherited from the combo-box
   * to not request data provider when read-only.
   *
   * @protected
   * @override
   */
  _shouldFetchData() {
    if (this.readonly) {
      return false;
    }
    return super._shouldFetchData();
  }
  /**
   * Override method inherited from the combo-box
   * to not clear the data provider cache when read-only.
   *
   * @protected
   * @override
   */
  clearCache() {
    if (this.readonly) {
      return;
    }
    super.clearCache();
  }
  /** @private */
  __onCustomValueSet(event) {
    if (this._ignoreCommitValue) {
      event.stopImmediatePropagation();
    }
  }
};
/**
 * @license
 * Copyright (c) 2021 - 2025 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
class MultiSelectComboBoxInternal extends MultiSelectComboBoxInternalMixin(ThemableMixin(PolymerElement)) {
  static get is() {
    return "vaadin-multi-select-combo-box-internal";
  }
  static get template() {
    return html`
      <style>
        :host([opened]) {
          pointer-events: auto;
        }
      </style>

      <slot></slot>

      <vaadin-multi-select-combo-box-overlay
        id="overlay"
        opened="[[_overlayOpened]]"
        loading$="[[loading]]"
        theme$="[[_theme]]"
        position-target="[[_target]]"
        no-vertical-overlap
        restore-focus-node="[[inputElement]]"
      ></vaadin-multi-select-combo-box-overlay>
    `;
  }
}
defineCustomElement(MultiSelectComboBoxInternal);
/**
 * @license
 * Copyright (c) 2021 - 2025 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const MultiSelectComboBoxMixin = (superClass) => class MultiSelectComboBoxMixinClass extends InputControlMixin(ResizeMixin(superClass)) {
  static get properties() {
    return {
      /**
       * Set to true to auto expand horizontally, causing input field to
       * grow until max width is reached.
       * @attr {boolean} auto-expand-horizontally
       */
      autoExpandHorizontally: {
        type: Boolean,
        value: false,
        reflectToAttribute: true,
        observer: "_autoExpandHorizontallyChanged",
        sync: true
      },
      /**
       * Set to true to not collapse selected items chips into the overflow
       * chip and instead always expand vertically, causing input field to
       * wrap into multiple lines when width is limited.
       * @attr {boolean} auto-expand-vertically
       */
      autoExpandVertically: {
        type: Boolean,
        value: false,
        reflectToAttribute: true,
        observer: "_autoExpandVerticallyChanged",
        sync: true
      },
      /**
       * Set true to prevent the overlay from opening automatically.
       * @attr {boolean} auto-open-disabled
       */
      autoOpenDisabled: {
        type: Boolean,
        sync: true
      },
      /**
       * Set to true to display the clear icon which clears the input.
       * @attr {boolean} clear-button-visible
       */
      clearButtonVisible: {
        type: Boolean,
        reflectToAttribute: true,
        observer: "_clearButtonVisibleChanged",
        value: false,
        sync: true
      },
      /**
       * A full set of items to filter the visible options from.
       * The items can be of either `String` or `Object` type.
       */
      items: {
        type: Array,
        sync: true
      },
      /**
       * A function used to generate CSS class names for dropdown
       * items and selected chips based on the item. The return
       * value should be the generated class name as a string, or
       * multiple class names separated by whitespace characters.
       */
      itemClassNameGenerator: {
        type: Object,
        observer: "__itemClassNameGeneratorChanged",
        sync: true
      },
      /**
       * The item property used for a visual representation of the item.
       * @attr {string} item-label-path
       */
      itemLabelPath: {
        type: String,
        value: "label",
        sync: true
      },
      /**
       * Path for the value of the item. If `items` is an array of objects,
       * this property is used as a string value for the selected item.
       * @attr {string} item-value-path
       */
      itemValuePath: {
        type: String,
        value: "value",
        sync: true
      },
      /**
       * Path for the id of the item, used to detect whether the item is selected.
       * @attr {string} item-id-path
       */
      itemIdPath: {
        type: String,
        sync: true
      },
      /**
       * The object used to localize this component.
       * To change the default localization, replace the entire
       * _i18n_ object or just the property you want to modify.
       *
       * The object has the following JSON structure and default values:
       * ```
       * {
       *   // Screen reader announcement on clear button click.
       *   cleared: 'Selection cleared',
       *   // Screen reader announcement when a chip is focused.
       *   focused: ' focused. Press Backspace to remove',
       *   // Screen reader announcement when item is selected.
       *   selected: 'added to selection',
       *   // Screen reader announcement when item is deselected.
       *   deselected: 'removed from selection',
       *   // Screen reader announcement of the selected items count.
       *   // {count} is replaced with the actual count of items.
       *   total: '{count} items selected',
       * }
       * ```
       * @type {!MultiSelectComboBoxI18n}
       * @default {English/US}
       */
      i18n: {
        type: Object,
        value: () => {
          return {
            cleared: "Selection cleared",
            focused: "focused. Press Backspace to remove",
            selected: "added to selection",
            deselected: "removed from selection",
            total: "{count} items selected"
          };
        }
      },
      /**
       * When true, filter string isn't cleared after selecting an item.
       */
      keepFilter: {
        type: Boolean,
        value: false
      },
      /**
       * True when loading items from the data provider, false otherwise.
       */
      loading: {
        type: Boolean,
        value: false,
        reflectToAttribute: true,
        sync: true
      },
      /**
       * A space-delimited list of CSS class names to set on the overlay element.
       *
       * @attr {string} overlay-class
       */
      overlayClass: {
        type: String,
        sync: true
      },
      /**
       * When present, it specifies that the field is read-only.
       */
      readonly: {
        type: Boolean,
        value: false,
        observer: "_readonlyChanged",
        reflectToAttribute: true,
        sync: true
      },
      /**
       * The list of selected items.
       * Note: modifying the selected items creates a new array each time.
       */
      selectedItems: {
        type: Array,
        value: () => [],
        notify: true,
        sync: true
      },
      /**
       * True if the dropdown is open, false otherwise.
       */
      opened: {
        type: Boolean,
        notify: true,
        value: false,
        reflectToAttribute: true,
        sync: true
      },
      /**
       * Total number of items.
       */
      size: {
        type: Number,
        sync: true
      },
      /**
       * Number of items fetched at a time from the data provider.
       * @attr {number} page-size
       */
      pageSize: {
        type: Number,
        value: 50,
        observer: "_pageSizeChanged",
        sync: true
      },
      /**
       * Function that provides items lazily. Receives two arguments:
       *
       * - `params` - Object with the following properties:
       *   - `params.page` Requested page index
       *   - `params.pageSize` Current page size
       *   - `params.filter` Currently applied filter
       *
       * - `callback(items, size)` - Callback function with arguments:
       *   - `items` Current page of items
       *   - `size` Total number of items.
       */
      dataProvider: {
        type: Object,
        sync: true
      },
      /**
       * When true, the user can input a value that is not present in the items list.
       * @attr {boolean} allow-custom-value
       */
      allowCustomValue: {
        type: Boolean,
        value: false
      },
      /**
       * A hint to the user of what can be entered in the control.
       * The placeholder will be only displayed in the case when
       * there is no item selected.
       */
      placeholder: {
        type: String,
        observer: "_placeholderChanged",
        sync: true
      },
      /**
       * Custom function for rendering the content of every item.
       * Receives three arguments:
       *
       * - `root` The `<vaadin-multi-select-combo-box-item>` internal container DOM element.
       * - `comboBox` The reference to the `<vaadin-multi-select-combo-box>` element.
       * - `model` The object with the properties related with the rendered
       *   item, contains:
       *   - `model.index` The index of the rendered item.
       *   - `model.item` The item.
       */
      renderer: {
        type: Function,
        sync: true
      },
      /**
       * Filtering string the user has typed into the input field.
       */
      filter: {
        type: String,
        value: "",
        notify: true,
        sync: true
      },
      /**
       * A subset of items, filtered based on the user input. Filtered items
       * can be assigned directly to omit the internal filtering functionality.
       * The items can be of either `String` or `Object` type.
       */
      filteredItems: {
        type: Array,
        sync: true
      },
      /**
       * Set to true to group selected items at the top of the overlay.
       * @attr {boolean} selected-items-on-top
       */
      selectedItemsOnTop: {
        type: Boolean,
        value: false,
        sync: true
      },
      /** @private */
      value: {
        type: String
      },
      /** @private */
      _overflowItems: {
        type: Array,
        value: () => [],
        sync: true
      },
      /** @private */
      _focusedChipIndex: {
        type: Number,
        value: -1,
        observer: "_focusedChipIndexChanged"
      },
      /** @private */
      _lastFilter: {
        type: String,
        sync: true
      },
      /** @private */
      _topGroup: {
        type: Array
      }
    };
  }
  static get observers() {
    return [
      "_selectedItemsChanged(selectedItems)",
      "__updateOverflowChip(_overflow, _overflowItems, disabled, readonly)",
      "__updateTopGroup(selectedItemsOnTop, selectedItems, opened)"
    ];
  }
  /** @protected */
  get slotStyles() {
    const tag = this.localName;
    return [
      ...super.slotStyles,
      `
        ${tag}[has-value] input::placeholder {
          color: transparent !important;
          forced-color-adjust: none;
        }
      `
    ];
  }
  /**
   * Used by `InputControlMixin` as a reference to the clear button element.
   * @protected
   * @return {!HTMLElement}
   */
  get clearElement() {
    return this.$.clearButton;
  }
  /** @protected */
  get _chips() {
    return [...this.querySelectorAll('[slot="chip"]')];
  }
  /**
   * Override a getter from `InputMixin` to compute
   * the presence of value based on `selectedItems`.
   *
   * @protected
   * @override
   */
  get _hasValue() {
    return this.selectedItems && this.selectedItems.length > 0;
  }
  /** @protected */
  ready() {
    super.ready();
    this.addController(
      new InputController(this, (input) => {
        this._setInputElement(input);
        this._setFocusElement(input);
        this.stateTarget = input;
        this.ariaTarget = input;
      })
    );
    this.addController(new LabelledInputController(this.inputElement, this._labelController));
    this._tooltipController = new TooltipController(this);
    this.addController(this._tooltipController);
    this._tooltipController.setPosition("top");
    this._tooltipController.setAriaTarget(this.inputElement);
    this._tooltipController.setShouldShow((target) => !target.opened);
    this._inputField = this.shadowRoot.querySelector('[part="input-field"]');
    this._overflowController = new SlotController(this, "overflow", "vaadin-multi-select-combo-box-chip", {
      initializer: (chip2) => {
        chip2.addEventListener("mousedown", (e2) => this._preventBlur(e2));
        this._overflow = chip2;
      }
    });
    this.addController(this._overflowController);
    this.__updateChips();
    processTemplates(this);
  }
  /**
   * Returns true if the current input value satisfies all constraints (if any).
   * @return {boolean}
   */
  checkValidity() {
    return this.required && !this.readonly ? this._hasValue : true;
  }
  /**
   * Clears the selected items.
   */
  clear() {
    this.__updateSelection([]);
    announce(this.i18n.cleared);
  }
  /**
   * Clears the cached pages and reloads data from data provider when needed.
   */
  clearCache() {
    if (this.$ && this.$.comboBox) {
      this.$.comboBox.clearCache();
    }
  }
  /**
   * Requests an update for the content of items.
   * While performing the update, it invokes the renderer (passed in the `renderer` property) once an item.
   *
   * It is not guaranteed that the update happens immediately (synchronously) after it is requested.
   */
  requestContentUpdate() {
    if (this.$ && this.$.comboBox) {
      this.$.comboBox.requestContentUpdate();
    }
  }
  /**
   * Override method inherited from `DisabledMixin` to forward disabled to chips.
   * @protected
   * @override
   */
  _disabledChanged(disabled, oldDisabled) {
    super._disabledChanged(disabled, oldDisabled);
    if (disabled || oldDisabled) {
      this.__updateChips();
    }
  }
  /**
   * Override method inherited from `InputMixin` to forward the input to combo-box.
   * @protected
   * @override
   */
  _inputElementChanged(input) {
    super._inputElementChanged(input);
    if (input) {
      this.$.comboBox._setInputElement(input);
    }
  }
  /**
   * Override method inherited from `FocusMixin` to validate on blur.
   * @param {boolean} focused
   * @protected
   */
  _setFocused(focused) {
    super._setFocused(focused);
    if (!focused && document.hasFocus()) {
      this._focusedChipIndex = -1;
      this._requestValidation();
    }
  }
  /**
   * Implement callback from `ResizeMixin` to update chips.
   * @protected
   * @override
   */
  _onResize() {
    this.__updateChips();
  }
  /**
   * Override method from `DelegateStateMixin` to set required state
   * using `aria-required` attribute instead of `required`, in order
   * to prevent screen readers from announcing "invalid entry".
   * @protected
   * @override
   */
  _delegateAttribute(name, value) {
    if (!this.stateTarget) {
      return;
    }
    if (name === "required") {
      this._delegateAttribute("aria-required", value ? "true" : false);
      return;
    }
    super._delegateAttribute(name, value);
  }
  /** @private */
  _autoExpandHorizontallyChanged(autoExpand, oldAutoExpand) {
    if (autoExpand || oldAutoExpand) {
      this.__updateChips();
    }
  }
  /** @private */
  _autoExpandVerticallyChanged(autoExpand, oldAutoExpand) {
    if (autoExpand || oldAutoExpand) {
      this.__updateChips();
    }
  }
  /**
   * Setting clear button visible reduces total space available
   * for rendering chips, and making it hidden increases it.
   * @private
   */
  _clearButtonVisibleChanged(visible, oldVisible) {
    if (visible || oldVisible) {
      this.__updateChips();
    }
  }
  /**
   * Implement two-way binding for the `filteredItems` property
   * that can be set on the internal combo-box element.
   *
   * @param {CustomEvent} event
   * @private
   */
  _onFilteredItemsChanged(event) {
    const { value } = event.detail;
    if (Array.isArray(value) || value == null) {
      this.filteredItems = value;
    }
  }
  /** @private */
  _readonlyChanged(readonly, oldReadonly) {
    if (readonly || oldReadonly) {
      this.__updateChips();
    }
    if (this.dataProvider) {
      this.clearCache();
    }
  }
  /** @private */
  __itemClassNameGeneratorChanged(generator, oldGenerator) {
    if (generator || oldGenerator) {
      this.__updateChips();
    }
  }
  /** @private */
  _pageSizeChanged(pageSize, oldPageSize) {
    if (Math.floor(pageSize) !== pageSize || pageSize <= 0) {
      this.pageSize = oldPageSize;
      console.error('"pageSize" value must be an integer > 0');
    }
    this.$.comboBox.pageSize = this.pageSize;
  }
  /** @private */
  _placeholderChanged(placeholder) {
    const tmpPlaceholder = this.__tmpA11yPlaceholder;
    if (tmpPlaceholder !== placeholder) {
      this.__savedPlaceholder = placeholder;
      if (tmpPlaceholder) {
        this.placeholder = tmpPlaceholder;
      }
    }
  }
  /** @private */
  _selectedItemsChanged(selectedItems) {
    this._toggleHasValue(this._hasValue);
    if (this._hasValue) {
      const tmpPlaceholder = this._mergeItemLabels(selectedItems);
      if (this.__tmpA11yPlaceholder === void 0) {
        this.__savedPlaceholder = this.placeholder;
      }
      this.__tmpA11yPlaceholder = tmpPlaceholder;
      this.placeholder = tmpPlaceholder;
    } else if (this.__tmpA11yPlaceholder !== void 0) {
      delete this.__tmpA11yPlaceholder;
      this.placeholder = this.__savedPlaceholder;
    }
    this.__updateChips();
    this.requestContentUpdate();
    if (this.opened) {
      this.$.comboBox._updateOverlayWidth();
    }
  }
  /** @private */
  _getItemLabel(item2) {
    return this.$.comboBox._getItemLabel(item2);
  }
  /** @private */
  _mergeItemLabels(items) {
    return items.map((item2) => this._getItemLabel(item2)).join(", ");
  }
  /** @private */
  _findIndex(item2, selectedItems, itemIdPath) {
    if (itemIdPath && item2) {
      for (let index = 0; index < selectedItems.length; index++) {
        if (selectedItems[index] && selectedItems[index][itemIdPath] === item2[itemIdPath]) {
          return index;
        }
      }
      return -1;
    }
    return selectedItems.indexOf(item2);
  }
  /**
   * Clear the internal combo box value and filter. Filter will not be cleared
   * when the `keepFilter` option is enabled. Using `force` can enforce clearing
   * the filter.
   * @param {boolean} force overrides the keepFilter option
   * @private
   */
  __clearInternalValue(force = false) {
    if (!this.keepFilter || force) {
      this.filter = "";
      this.$.comboBox.clear();
    } else {
      this.$.comboBox.clear();
      this._inputElementValue = this.filter;
    }
  }
  /** @private */
  __announceItem(itemLabel, isSelected, itemCount) {
    const state = isSelected ? "selected" : "deselected";
    const total = this.i18n.total.replace("{count}", itemCount || 0);
    announce(`${itemLabel} ${this.i18n[state]} ${total}`);
  }
  /** @private */
  __removeItem(item2) {
    const itemsCopy = [...this.selectedItems];
    itemsCopy.splice(itemsCopy.indexOf(item2), 1);
    this.__updateSelection(itemsCopy);
    const itemLabel = this._getItemLabel(item2);
    this.__announceItem(itemLabel, false, itemsCopy.length);
  }
  /** @private */
  __selectItem(item2) {
    const itemsCopy = [...this.selectedItems];
    const index = this._findIndex(item2, itemsCopy, this.itemIdPath);
    const itemLabel = this._getItemLabel(item2);
    let isSelected = false;
    if (index !== -1) {
      const lastFilter = this._lastFilter;
      if (lastFilter && lastFilter.toLowerCase() === itemLabel.toLowerCase()) {
        this.__clearInternalValue();
        return;
      }
      itemsCopy.splice(index, 1);
    } else {
      itemsCopy.push(item2);
      isSelected = true;
    }
    this.__updateSelection(itemsCopy);
    this.__clearInternalValue();
    this.__announceItem(itemLabel, isSelected, itemsCopy.length);
  }
  /** @private */
  __updateSelection(selectedItems) {
    this.selectedItems = selectedItems;
    this._requestValidation();
    this.dispatchEvent(new CustomEvent("change", { bubbles: true }));
  }
  /** @private */
  __updateTopGroup(selectedItemsOnTop, selectedItems, opened) {
    if (!selectedItemsOnTop) {
      this._topGroup = [];
    } else if (!opened || this.__needToSyncTopGroup()) {
      this._topGroup = [...selectedItems];
    }
  }
  /** @private */
  __needToSyncTopGroup() {
    if (!this.itemIdPath) {
      return false;
    }
    return this._topGroup && this._topGroup.some((item2) => {
      const selectedItem = this.selectedItems[this._findIndex(item2, this.selectedItems, this.itemIdPath)];
      return selectedItem && item2 !== selectedItem;
    });
  }
  /** @private */
  __createChip(item2) {
    const chip2 = document.createElement("vaadin-multi-select-combo-box-chip");
    chip2.setAttribute("slot", "chip");
    chip2.item = item2;
    chip2.disabled = this.disabled;
    chip2.readonly = this.readonly;
    const label = this._getItemLabel(item2);
    chip2.label = label;
    chip2.setAttribute("title", label);
    if (typeof this.itemClassNameGenerator === "function") {
      chip2.className = this.itemClassNameGenerator(item2);
    }
    chip2.addEventListener("item-removed", (e2) => this._onItemRemoved(e2));
    chip2.addEventListener("mousedown", (e2) => this._preventBlur(e2));
    return chip2;
  }
  /** @private */
  __getOverflowWidth() {
    const chip2 = this._overflow;
    chip2.style.visibility = "hidden";
    chip2.removeAttribute("hidden");
    const count = chip2.getAttribute("count");
    chip2.setAttribute("count", "99");
    const overflowStyle = getComputedStyle(chip2);
    const overflowWidth = chip2.clientWidth + parseInt(overflowStyle.marginInlineStart);
    chip2.setAttribute("count", count);
    chip2.setAttribute("hidden", "");
    chip2.style.visibility = "";
    return overflowWidth;
  }
  /** @private */
  __updateChips() {
    if (!this._inputField || !this.inputElement) {
      return;
    }
    this._chips.forEach((chip2) => {
      chip2.remove();
    });
    const items = [...this.selectedItems];
    const totalWidth = this._inputField.$.wrapper.clientWidth;
    const inputWidth = parseInt(getComputedStyle(this.inputElement).flexBasis);
    let remainingWidth = totalWidth - inputWidth;
    if (items.length > 1) {
      remainingWidth -= this.__getOverflowWidth();
    }
    const chipMinWidth = parseInt(getComputedStyle(this).getPropertyValue("--_chip-min-width"));
    if (this.autoExpandHorizontally) {
      const chips = [];
      for (let i2 = items.length - 1, refNode = null; i2 >= 0; i2--) {
        const chip2 = this.__createChip(items[i2]);
        this.insertBefore(chip2, refNode);
        refNode = chip2;
        chips.unshift(chip2);
      }
      const overflowItems = [];
      const availableWidth = this._inputField.$.wrapper.clientWidth - this.$.chips.clientWidth;
      if (!this.autoExpandVertically && availableWidth < inputWidth) {
        while (chips.length > 1) {
          const lastChip = chips.pop();
          lastChip.remove();
          overflowItems.unshift(items.pop());
          const neededWidth = overflowItems.length > 0 ? inputWidth + this.__getOverflowWidth() : inputWidth;
          if (this._inputField.$.wrapper.clientWidth - this.$.chips.clientWidth >= neededWidth) {
            break;
          }
        }
        if (chips.length === 1) {
          chips[0].style.maxWidth = `${Math.max(chipMinWidth, remainingWidth)}px`;
        }
      }
      this._overflowItems = overflowItems;
      return;
    }
    for (let i2 = items.length - 1, refNode = null; i2 >= 0; i2--) {
      const chip2 = this.__createChip(items[i2]);
      this.insertBefore(chip2, refNode);
      if (!this.autoExpandVertically) {
        if (this.$.chips.clientWidth > remainingWidth) {
          if (remainingWidth < chipMinWidth || refNode !== null) {
            chip2.remove();
            break;
          }
        }
        chip2.style.maxWidth = `${remainingWidth}px`;
      }
      items.pop();
      refNode = chip2;
    }
    this._overflowItems = items;
  }
  /** @private */
  __updateOverflowChip(overflow, items, disabled, readonly) {
    if (overflow) {
      const count = items.length;
      overflow.label = `${count}`;
      overflow.setAttribute("count", `${count}`);
      overflow.setAttribute("title", this._mergeItemLabels(items));
      overflow.toggleAttribute("hidden", count === 0);
      overflow.disabled = disabled;
      overflow.readonly = readonly;
    }
  }
  /** @private */
  _onClearButtonTouchend(event) {
    event.preventDefault();
    event.stopPropagation();
    this.clear();
  }
  /**
   * Override method inherited from `InputControlMixin` and clear items.
   * @protected
   * @override
   */
  _onClearButtonClick(event) {
    event.stopPropagation();
    this.clear();
  }
  /**
   * Override an event listener from `InputControlMixin` to
   * stop the change event re-targeted from the input.
   *
   * @param {!Event} event
   * @protected
   * @override
   */
  _onChange(event) {
    event.stopPropagation();
  }
  /**
   * Override an event listener from `KeyboardMixin`.
   * Do not call `super` in order to override clear
   * button logic defined in `InputControlMixin`.
   *
   * @param {!KeyboardEvent} event
   * @protected
   * @override
   */
  _onEscape(event) {
    if (this.clearButtonVisible && this.selectedItems && this.selectedItems.length) {
      event.stopPropagation();
      this.selectedItems = [];
    }
  }
  /**
   * Override an event listener from `KeyboardMixin`.
   * @param {KeyboardEvent} event
   * @protected
   * @override
   */
  _onKeyDown(event) {
    super._onKeyDown(event);
    const chips = this._chips;
    if (!this.readonly && chips.length > 0) {
      switch (event.key) {
        case "Backspace":
          this._onBackSpace(chips);
          break;
        case "ArrowLeft":
          this._onArrowLeft(chips, event);
          break;
        case "ArrowRight":
          this._onArrowRight(chips, event);
          break;
        default:
          this._focusedChipIndex = -1;
          break;
      }
    }
  }
  /** @private */
  _onArrowLeft(chips, event) {
    if (this.inputElement.selectionStart !== 0) {
      return;
    }
    const idx = this._focusedChipIndex;
    if (idx !== -1) {
      event.preventDefault();
    }
    let newIdx;
    if (!this.__isRTL) {
      if (idx === -1) {
        newIdx = chips.length - 1;
      } else if (idx > 0) {
        newIdx = idx - 1;
      }
    } else if (idx === chips.length - 1) {
      newIdx = -1;
    } else if (idx > -1) {
      newIdx = idx + 1;
    }
    if (newIdx !== void 0) {
      this._focusedChipIndex = newIdx;
    }
  }
  /** @private */
  _onArrowRight(chips, event) {
    if (this.inputElement.selectionStart !== 0) {
      return;
    }
    const idx = this._focusedChipIndex;
    if (idx !== -1) {
      event.preventDefault();
    }
    let newIdx;
    if (this.__isRTL) {
      if (idx === -1) {
        newIdx = chips.length - 1;
      } else if (idx > 0) {
        newIdx = idx - 1;
      }
    } else if (idx === chips.length - 1) {
      newIdx = -1;
    } else if (idx > -1) {
      newIdx = idx + 1;
    }
    if (newIdx !== void 0) {
      this._focusedChipIndex = newIdx;
    }
  }
  /** @private */
  _onBackSpace(chips) {
    if (this.inputElement.selectionStart !== 0) {
      return;
    }
    const idx = this._focusedChipIndex;
    if (idx === -1) {
      this._focusedChipIndex = chips.length - 1;
    } else {
      this.__removeItem(chips[idx].item);
      this._focusedChipIndex = -1;
    }
  }
  /** @private */
  _focusedChipIndexChanged(focusedIndex, oldFocusedIndex) {
    if (focusedIndex > -1 || oldFocusedIndex > -1) {
      const chips = this._chips;
      chips.forEach((chip2, index) => {
        chip2.toggleAttribute("focused", index === focusedIndex);
      });
      if (focusedIndex > -1) {
        const item2 = chips[focusedIndex].item;
        const itemLabel = this._getItemLabel(item2);
        announce(`${itemLabel} ${this.i18n.focused}`);
      }
    }
  }
  /** @private */
  _onComboBoxChange() {
    const item2 = this.$.comboBox.selectedItem;
    if (item2) {
      this.__selectItem(item2);
    }
  }
  /** @private */
  _onComboBoxItemSelected(event) {
    this.__selectItem(event.detail.item);
  }
  /** @private */
  _onCustomValueSet(event) {
    event.preventDefault();
    event.stopPropagation();
    this.__clearInternalValue(true);
    this.dispatchEvent(
      new CustomEvent("custom-value-set", {
        detail: event.detail,
        composed: true,
        bubbles: true
      })
    );
  }
  /** @private */
  _onItemRemoved(event) {
    this.__removeItem(event.detail.item);
  }
  /** @private */
  _preventBlur(event) {
    event.preventDefault();
  }
  /**
   * Fired when the user sets a custom value.
   * @event custom-value-set
   * @param {string} detail the custom value
   */
};
/**
 * @license
 * Copyright (c) 2021 - 2025 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
registerStyles$1("vaadin-multi-select-combo-box", [inputFieldShared, multiSelectComboBox], {
  moduleId: "vaadin-multi-select-combo-box-styles"
});
class MultiSelectComboBox extends MultiSelectComboBoxMixin(ThemableMixin(ElementMixin(PolymerElement))) {
  static get is() {
    return "vaadin-multi-select-combo-box";
  }
  static get template() {
    return html`
      <div class="vaadin-multi-select-combo-box-container">
        <div part="label">
          <slot name="label"></slot>
          <span part="required-indicator" aria-hidden="true" on-click="focus"></span>
        </div>

        <vaadin-multi-select-combo-box-internal
          id="comboBox"
          items="[[items]]"
          item-id-path="[[itemIdPath]]"
          item-label-path="[[itemLabelPath]]"
          item-value-path="[[itemValuePath]]"
          disabled="[[disabled]]"
          readonly="[[readonly]]"
          auto-open-disabled="[[autoOpenDisabled]]"
          allow-custom-value="[[allowCustomValue]]"
          overlay-class="[[overlayClass]]"
          data-provider="[[dataProvider]]"
          filter="{{filter}}"
          last-filter="{{_lastFilter}}"
          loading="{{loading}}"
          size="{{size}}"
          filtered-items="[[filteredItems]]"
          selected-items="[[selectedItems]]"
          selected-items-on-top="[[selectedItemsOnTop]]"
          item-class-name-generator="[[itemClassNameGenerator]]"
          top-group="[[_topGroup]]"
          opened="{{opened}}"
          renderer="[[renderer]]"
          keep-filter="[[keepFilter]]"
          theme$="[[_theme]]"
          on-combo-box-item-selected="_onComboBoxItemSelected"
          on-change="_onComboBoxChange"
          on-custom-value-set="_onCustomValueSet"
          on-filtered-items-changed="_onFilteredItemsChanged"
        >
          <vaadin-multi-select-combo-box-container
            part="input-field"
            auto-expand-vertically="[[autoExpandVertically]]"
            readonly="[[readonly]]"
            disabled="[[disabled]]"
            invalid="[[invalid]]"
            theme$="[[_theme]]"
          >
            <slot name="overflow" slot="prefix"></slot>
            <div id="chips" part="chips" slot="prefix">
              <slot name="chip"></slot>
            </div>
            <slot name="input"></slot>
            <div
              id="clearButton"
              part="clear-button"
              slot="suffix"
              on-touchend="_onClearButtonTouchend"
              aria-hidden="true"
            ></div>
            <div id="toggleButton" class="toggle-button" part="toggle-button" slot="suffix" aria-hidden="true"></div>
          </vaadin-multi-select-combo-box-container>
        </vaadin-multi-select-combo-box-internal>

        <div part="helper-text">
          <slot name="helper"></slot>
        </div>

        <div part="error-message">
          <slot name="error-message"></slot>
        </div>
      </div>

      <slot name="tooltip"></slot>
    `;
  }
}
defineCustomElement(MultiSelectComboBox);
const dialogOverlay$1 = css`
  /* Optical centering */
  :host::before,
  :host::after {
    content: '';
    flex-basis: 0;
    flex-grow: 1;
  }

  :host::after {
    flex-grow: 1.1;
  }

  [part='overlay'] {
    border-radius: var(--lumo-border-radius-l);
    box-shadow:
      0 0 0 1px var(--lumo-shade-5pct),
      var(--lumo-box-shadow-xl);
    background-image: none;
    outline: none;
    -webkit-tap-highlight-color: transparent;
  }

  [part='content'] {
    padding: var(--lumo-space-l);
  }

  :host(:is([has-header], [has-title])) [part='header'] + [part='content'] {
    padding-top: 0;
  }

  [part='header'],
  [part='header-content'],
  [part='footer'] {
    gap: var(--lumo-space-xs) var(--lumo-space-s);
    line-height: var(--lumo-line-height-s);
  }

  [part='header'] {
    padding: var(--lumo-space-m);
    background-color: var(--lumo-base-color);
    border-radius: var(--lumo-border-radius-l) var(--lumo-border-radius-l) 0 0; /* Needed for Safari */
  }

  [part='footer'] {
    padding: var(--lumo-space-s) var(--lumo-space-m);
    background-color: var(--lumo-contrast-5pct);
    border-radius: 0 0 var(--lumo-border-radius-l) var(--lumo-border-radius-l); /* Needed for Safari */
  }

  [part='title'] {
    font-size: var(--lumo-font-size-xl);
    font-weight: 600;
    color: var(--lumo-header-text-color);
    margin-inline-start: calc(var(--lumo-space-l) - var(--lumo-space-m));
  }

  /* No padding */
  :host([theme~='no-padding']) [part='content'] {
    padding: 0 !important;
  }

  @media (min-height: 320px) {
    :host([overflow~='top']) [part='header'] {
      box-shadow: 0 1px 0 0 var(--lumo-contrast-10pct);
    }
  }

  /* Animations */

  :host([opening]),
  :host([closing]) {
    animation: 0.25s lumo-overlay-dummy-animation;
  }

  :host([opening]) [part='overlay'] {
    animation: 0.12s 0.05s vaadin-dialog-enter cubic-bezier(0.215, 0.61, 0.355, 1) both;
  }

  @keyframes vaadin-dialog-enter {
    0% {
      opacity: 0;
      transform: scale(0.95);
    }
  }

  :host([closing]) [part='overlay'] {
    animation: 0.1s 0.03s vaadin-dialog-exit cubic-bezier(0.55, 0.055, 0.675, 0.19) both;
  }

  :host([closing]) [part='backdrop'] {
    animation-delay: 0.05s;
  }

  @keyframes vaadin-dialog-exit {
    100% {
      opacity: 0;
      transform: scale(1.02);
    }
  }
`;
registerStyles$1("vaadin-dialog-overlay", [overlay, dialogOverlay$1], { moduleId: "lumo-dialog" });
registerStyles$1(
  "vaadin-confirm-dialog-overlay",
  [
    overlay,
    dialogOverlay$1,
    css`
      [part='header'] ::slotted(h3) {
        margin-top: 0 !important;
        margin-bottom: 0 !important;
        margin-inline-start: calc(var(--lumo-space-l) - var(--lumo-space-m));
      }

      [part='message'] {
        width: 25em;
        min-width: 100%;
        max-width: 100%;
      }

      ::slotted([slot$='button'][theme~='tertiary']) {
        padding-left: var(--lumo-space-s);
        padding-right: var(--lumo-space-s);
      }

      [part='cancel-button'] {
        flex-grow: 1;
      }

      @media (max-width: 360px) {
        [part='footer'] {
          flex-direction: column-reverse;
          align-items: stretch;
          padding: var(--lumo-space-s) var(--lumo-space-l);
          gap: var(--lumo-space-s);
        }

        ::slotted([slot$='button']) {
          width: 100%;
          margin: 0;
        }
      }
    `
  ],
  { moduleId: "lumo-confirm-dialog-overlay" }
);
/**
 * @license
 * Copyright (c) 2017 - 2025 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const DialogBaseMixin = (superClass) => class DialogBaseMixin extends superClass {
  static get properties() {
    return {
      /**
       * True if the overlay is currently displayed.
       * @type {boolean}
       */
      opened: {
        type: Boolean,
        value: false,
        notify: true,
        sync: true
      },
      /**
       * Set to true to disable closing dialog on outside click
       * @attr {boolean} no-close-on-outside-click
       * @type {boolean}
       */
      noCloseOnOutsideClick: {
        type: Boolean,
        value: false
      },
      /**
       * Set to true to disable closing dialog on Escape press
       * @attr {boolean} no-close-on-esc
       * @type {boolean}
       */
      noCloseOnEsc: {
        type: Boolean,
        value: false
      },
      /**
       * Set to true to remove backdrop and allow click events on background elements.
       * @type {boolean}
       */
      modeless: {
        type: Boolean,
        value: false
      },
      /**
       * Set the distance of the overlay from the top of its container.
       * If a unitless number is provided, pixels are assumed.
       *
       * Note that the overlay top edge may not be the same as the viewport
       * top edge (e.g. the Lumo theme defines some spacing to prevent the
       * overlay from stretching all the way to the top of the viewport).
       */
      top: {
        type: String
      },
      /**
       * Set the distance of the overlay from the left of its container.
       * If a unitless number is provided, pixels are assumed.
       *
       * Note that the overlay left edge may not be the same as the viewport
       * left edge (e.g. the Lumo theme defines some spacing to prevent the
       * overlay from stretching all the way to the left of the viewport).
       */
      left: {
        type: String
      },
      /**
       * Set the width of the overlay.
       * If a unitless number is provided, pixels are assumed.
       */
      width: {
        type: String
      },
      /**
       * Set the height of the overlay.
       * If a unitless number is provided, pixels are assumed.
       */
      height: {
        type: String
      },
      /**
       * The `role` attribute value to be set on the overlay. Defaults to "dialog".
       *
       * @attr {string} overlay-role
       */
      overlayRole: {
        type: String,
        value: "dialog"
      }
    };
  }
  static get observers() {
    return ["__positionChanged(top, left)", "__sizeChanged(width, height)"];
  }
  /** @protected */
  ready() {
    super.ready();
    const overlay2 = this.$.overlay;
    overlay2.addEventListener("vaadin-overlay-outside-click", this._handleOutsideClick.bind(this));
    overlay2.addEventListener("vaadin-overlay-escape-press", this._handleEscPress.bind(this));
    overlay2.addEventListener("vaadin-overlay-closed", this.__handleOverlayClosed.bind(this));
    this._overlayElement = overlay2;
  }
  /** @private */
  __handleOverlayClosed() {
    this.dispatchEvent(new CustomEvent("closed"));
  }
  /** @protected */
  connectedCallback() {
    super.connectedCallback();
    if (this.__restoreOpened) {
      this.opened = true;
    }
  }
  /** @protected */
  disconnectedCallback() {
    super.disconnectedCallback();
    setTimeout(() => {
      if (!this.isConnected) {
        this.__restoreOpened = this.opened;
        this.opened = false;
      }
    });
  }
  /** @protected */
  _onOverlayOpened(e2) {
    if (e2.detail.value === false) {
      this.opened = false;
    }
  }
  /**
   * Close the dialog if `noCloseOnOutsideClick` isn't set to true
   * @private
   */
  _handleOutsideClick(e2) {
    if (this.noCloseOnOutsideClick) {
      e2.preventDefault();
    }
  }
  /**
   * Close the dialog if `noCloseOnEsc` isn't set to true
   * @private
   */
  _handleEscPress(e2) {
    if (this.noCloseOnEsc) {
      e2.preventDefault();
    }
  }
  /** @private */
  _bringOverlayToFront() {
    if (this.modeless) {
      this._overlayElement.bringToFront();
    }
  }
  /** @private */
  __positionChanged(top, left) {
    requestAnimationFrame(() => this.$.overlay.setBounds({ top, left }));
  }
  /** @private */
  __sizeChanged(width, height) {
    requestAnimationFrame(() => this.$.overlay.setBounds({ width, height }, false));
  }
  /**
   * Fired when the dialog is closed.
   *
   * @event closed
   */
};
/**
 * @license
 * Copyright (c) 2017 - 2025 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const dialogOverlay = css`
  [part='header'],
  [part='header-content'],
  [part='footer'] {
    display: flex;
    align-items: center;
    flex-wrap: wrap;
    flex: none;
    pointer-events: none;
    z-index: 1;
  }

  [part='header'] {
    flex-wrap: nowrap;
  }

  ::slotted([slot='header-content']),
  ::slotted([slot='title']),
  ::slotted([slot='footer']) {
    display: contents;
    pointer-events: auto;
  }

  ::slotted([slot='title']) {
    font: inherit !important;
    overflow-wrap: anywhere;
  }

  [part='header-content'] {
    flex: 1;
  }

  :host([has-title]) [part='header-content'],
  [part='footer'] {
    justify-content: flex-end;
  }

  :host(:not([has-title]):not([has-header])) [part='header'],
  :host(:not([has-header])) [part='header-content'],
  :host(:not([has-title])) [part='title'],
  :host(:not([has-footer])) [part='footer'] {
    display: none !important;
  }

  :host(:is([has-title], [has-header], [has-footer])) [part='content'] {
    height: auto;
  }

  @media (min-height: 320px) {
    :host(:is([has-title], [has-header], [has-footer])) .resizer-container {
      overflow: hidden;
      display: flex;
      flex-direction: column;
    }

    :host(:is([has-title], [has-header], [has-footer])) [part='content'] {
      flex: 1;
      overflow: auto;
    }
  }

  /*
      NOTE(platosha): Make some min-width to prevent collapsing of the content
      taking the parent width, e. g., <vaadin-grid> and such.
    */
  [part='content'] {
    min-width: 12em; /* matches the default <vaadin-text-field> width */
  }

  :host([has-bounds-set]) [part='overlay'] {
    max-width: none;
  }

  @media (forced-colors: active) {
    [part='overlay'] {
      outline: 3px solid !important;
    }
  }
`;
const resizableOverlay = css`
  [part='overlay'] {
    position: relative;
    overflow: visible;
    max-height: 100%;
    display: flex;
  }

  [part='content'] {
    box-sizing: border-box;
    height: 100%;
  }

  .resizer-container {
    overflow: auto;
    flex-grow: 1;
    border-radius: inherit; /* prevent child elements being drawn outside part=overlay */
  }

  [part='overlay'][style] .resizer-container {
    min-height: 100%;
    width: 100%;
  }

  :host(:not([resizable])) .resizer {
    display: none;
  }

  :host([resizable]) [part='title'] {
    cursor: move;
    -webkit-user-select: none;
    user-select: none;
  }

  .resizer {
    position: absolute;
    height: 16px;
    width: 16px;
  }

  .resizer.edge {
    height: 8px;
    width: 8px;
    inset: -4px;
  }

  .resizer.edge.n {
    width: auto;
    bottom: auto;
    cursor: ns-resize;
  }

  .resizer.ne {
    top: -4px;
    right: -4px;
    cursor: nesw-resize;
  }

  .resizer.edge.e {
    height: auto;
    left: auto;
    cursor: ew-resize;
  }

  .resizer.se {
    bottom: -4px;
    right: -4px;
    cursor: nwse-resize;
  }

  .resizer.edge.s {
    width: auto;
    top: auto;
    cursor: ns-resize;
  }

  .resizer.sw {
    bottom: -4px;
    left: -4px;
    cursor: nesw-resize;
  }

  .resizer.edge.w {
    height: auto;
    right: auto;
    cursor: ew-resize;
  }

  .resizer.nw {
    top: -4px;
    left: -4px;
    cursor: nwse-resize;
  }
`;
/**
 * @license
 * Copyright (c) 2018 - 2025 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const ConfirmDialogBaseMixin = (superClass) => class ConfirmDialogBaseMixinClass extends superClass {
  static get properties() {
    return {
      /**
       * Set the `aria-label` attribute for assistive technologies like
       * screen readers. An empty string value for this property (the
       * default) means that the `aria-label` attribute is not present.
       */
      ariaLabel: {
        type: String,
        value: ""
      },
      /**
       * Height to be set on the overlay content.
       */
      contentHeight: {
        type: String
      },
      /**
       * Width to be set on the overlay content.
       */
      contentWidth: {
        type: String
      }
    };
  }
  static get observers() {
    return [
      "__updateContentHeight(contentHeight, _overlayElement)",
      "__updateContentWidth(contentWidth, _overlayElement)"
    ];
  }
  /** @private */
  __updateDimension(overlay2, dimension, value) {
    const prop = `--_vaadin-confirm-dialog-content-${dimension}`;
    if (value) {
      overlay2.style.setProperty(prop, value);
    } else {
      overlay2.style.removeProperty(prop);
    }
  }
  /** @private */
  __updateContentHeight(height, overlay2) {
    if (overlay2) {
      this.__updateDimension(overlay2, "height", height);
    }
  }
  /** @private */
  __updateContentWidth(width, overlay2) {
    if (overlay2) {
      this.__updateDimension(overlay2, "width", width);
    }
  }
};
/**
 * @license
 * Copyright (c) 2018 - 2025 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const confirmDialogOverlay = css`
  :host {
    --_vaadin-confirm-dialog-content-width: auto;
    --_vaadin-confirm-dialog-content-height: auto;
  }

  [part='overlay'] {
    width: var(--_vaadin-confirm-dialog-content-width);
    height: var(--_vaadin-confirm-dialog-content-height);
  }

  #resizerContainer {
    height: 100%;
  }

  ::slotted([slot='header']) {
    pointer-events: auto;
  }

  /* Make buttons clickable */
  [part='footer'] > * {
    pointer-events: all;
  }
`;
/**
 * @license
 * Copyright (c) 2018 - 2025 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
registerStyles$1("vaadin-confirm-dialog-overlay", [overlayStyles, dialogOverlay, confirmDialogOverlay], {
  moduleId: "vaadin-confirm-dialog-overlay-styles"
});
class ConfirmDialogOverlay extends OverlayMixin(DirMixin(ThemableMixin(PolymerElement))) {
  static get is() {
    return "vaadin-confirm-dialog-overlay";
  }
  static get template() {
    return html`
      <div part="backdrop" id="backdrop" hidden$="[[!withBackdrop]]"></div>
      <div part="overlay" id="overlay" tabindex="0">
        <section id="resizerContainer" class="resizer-container">
          <header part="header"><slot name="header"></slot></header>
          <div part="content" id="content">
            <div part="message"><slot></slot></div>
          </div>
          <footer part="footer" role="toolbar">
            <div part="cancel-button">
              <slot name="cancel-button"></slot>
            </div>
            <div part="reject-button">
              <slot name="reject-button"></slot>
            </div>
            <div part="confirm-button">
              <slot name="confirm-button"></slot>
            </div>
          </footer>
        </section>
      </div>
    `;
  }
  /**
   * @protected
   * @override
   */
  ready() {
    super.ready();
    this.setAttribute("has-header", "");
    this.setAttribute("has-footer", "");
  }
}
defineCustomElement(ConfirmDialogOverlay);
class ConfirmDialogDialog extends ConfirmDialogBaseMixin(
  DialogBaseMixin(OverlayClassMixin(ThemePropertyMixin(PolymerElement)))
) {
  static get is() {
    return "vaadin-confirm-dialog-dialog";
  }
  static get template() {
    return html`
      <style>
        :host {
          display: none;
        }
      </style>

      <vaadin-confirm-dialog-overlay
        id="overlay"
        opened="[[opened]]"
        on-opened-changed="_onOverlayOpened"
        on-mousedown="_bringOverlayToFront"
        on-touchstart="_bringOverlayToFront"
        theme$="[[_theme]]"
        modeless="[[modeless]]"
        with-backdrop="[[!modeless]]"
        resizable$="[[resizable]]"
        aria-label$="[[ariaLabel]]"
        restore-focus-on-close
        focus-trap
      ></vaadin-confirm-dialog-overlay>
    `;
  }
}
defineCustomElement(ConfirmDialogDialog);
/**
 * @license
 * Copyright (c) 2018 - 2025 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const ConfirmDialogMixin = (superClass) => class ConfirmDialogMixinClass extends superClass {
  static get properties() {
    return {
      /**
       * Sets the `aria-describedby` attribute of the overlay element.
       *
       * By default, all elements inside the message area are linked
       * through the `aria-describedby` attribute. However, there are
       * cases where this can confuse screen reader users (e.g. the dialog
       * may present a password confirmation form). For these cases,
       * it's better to associate only the elements that will help describe
       * the confirmation dialog through this API.
       */
      accessibleDescriptionRef: {
        type: String
      },
      /**
       * True if the overlay is currently displayed.
       * @type {boolean}
       */
      opened: {
        type: Boolean,
        value: false,
        notify: true,
        sync: true
      },
      /**
       * Set the confirmation dialog title.
       * @type {string}
       */
      header: {
        type: String,
        value: ""
      },
      /**
       * Set the message or confirmation question.
       */
      message: {
        type: String,
        value: ""
      },
      /**
       * Text displayed on confirm-button.
       * This only affects the default button, custom slotted buttons will not be altered.
       * @attr {string} confirm-text
       * @type {string}
       */
      confirmText: {
        type: String,
        value: "Confirm"
      },
      /**
       * Theme for a confirm-button.
       * This only affects the default button, custom slotted buttons will not be altered.
       * @attr {string} confirm-theme
       * @type {string}
       */
      confirmTheme: {
        type: String,
        value: "primary"
      },
      /**
       * Set to true to disable closing dialog on Escape press
       * @attr {boolean} no-close-on-esc
       * @type {boolean}
       */
      noCloseOnEsc: {
        type: Boolean,
        value: false
      },
      /**
       * Whether to show reject button or not.
       * @attr {boolean} reject-button-visible
       * @type {boolean}
       */
      rejectButtonVisible: {
        type: Boolean,
        reflectToAttribute: true,
        value: false
      },
      /**
       * Text displayed on reject-button.
       * This only affects the default button, custom slotted buttons will not be altered.
       * @attr {string} reject-text
       * @type {string}
       */
      rejectText: {
        type: String,
        value: "Reject"
      },
      /**
       * Theme for a reject-button.
       * This only affects the default button, custom slotted buttons will not be altered.
       * @attr {string} reject-theme
       * @type {string}
       */
      rejectTheme: {
        type: String,
        value: "error tertiary"
      },
      /**
       * Whether to show cancel button or not.
       * @attr {boolean} cancel-button-visible
       * @type {boolean}
       */
      cancelButtonVisible: {
        type: Boolean,
        reflectToAttribute: true,
        value: false
      },
      /**
       * Text displayed on cancel-button.
       * This only affects the default button, custom slotted buttons will not be altered.
       * @attr {string} cancel-text
       * @type {string}
       */
      cancelText: {
        type: String,
        value: "Cancel"
      },
      /**
       * Theme for a cancel-button.
       * This only affects the default button, custom slotted buttons will not be altered.
       * @attr {string} cancel-theme
       * @type {string}
       */
      cancelTheme: {
        type: String,
        value: "tertiary"
      },
      /**
       * A space-delimited list of CSS class names
       * to set on the underlying overlay element.
       *
       * @attr {string} overlay-class
       */
      overlayClass: {
        type: String
      },
      /**
       * A reference to the "Cancel" button which will be teleported to the overlay.
       * @private
       */
      _cancelButton: {
        type: Object
      },
      /**
       * A reference to the "Confirm" button which will be teleported to the overlay.
       * @private
       */
      _confirmButton: {
        type: Object
      },
      /**
       * A reference to the "header" node which will be teleported to the overlay.
       * @private
       */
      _headerNode: {
        type: Object
      },
      /**
       * A list of message nodes which will be placed in the overlay default slot.
       * @private
       */
      _messageNodes: {
        type: Array,
        value: () => []
      },
      /**
       * A reference to the overlay element.
       * @private
       */
      _overlayElement: {
        type: Object,
        sync: true
      },
      /**
       * A reference to the "Reject" button which will be teleported to the overlay.
       * @private
       */
      _rejectButton: {
        type: Object
      },
      /**
       * Height to be set on the overlay content.
       * @protected
       */
      _contentHeight: {
        type: String
      },
      /**
       * Width to be set on the overlay content.
       * @protected
       */
      _contentWidth: {
        type: String
      }
    };
  }
  static get observers() {
    return [
      "__updateConfirmButton(_confirmButton, confirmText, confirmTheme)",
      "__updateCancelButton(_cancelButton, cancelText, cancelTheme, cancelButtonVisible)",
      "__updateHeaderNode(_headerNode, header)",
      "__updateMessageNodes(_messageNodes, message)",
      "__updateRejectButton(_rejectButton, rejectText, rejectTheme, rejectButtonVisible)",
      "__accessibleDescriptionRefChanged(_overlayElement, _messageNodes, accessibleDescriptionRef)"
    ];
  }
  constructor() {
    super();
    this.__cancel = this.__cancel.bind(this);
    this.__confirm = this.__confirm.bind(this);
    this.__reject = this.__reject.bind(this);
  }
  get __slottedNodes() {
    return [this._headerNode, ...this._messageNodes, this._cancelButton, this._confirmButton, this._rejectButton];
  }
  /** @protected */
  ready() {
    super.ready();
    this._headerController = new SlotController(this, "header", "h3", {
      initializer: (node) => {
        this._headerNode = node;
      }
    });
    this.addController(this._headerController);
    this._messageController = new SlotController(this, "", "div", {
      // Allow providing multiple custom nodes in the default slot
      multiple: true,
      observe: false,
      initializer: (node) => {
        const wrapper = document.createElement("div");
        wrapper.style.display = "contents";
        const wrapperId = `confirm-dialog-message-${generateUniqueId()}`;
        wrapper.id = wrapperId;
        this.appendChild(wrapper);
        wrapper.appendChild(node);
        this._messageNodes = [...this._messageNodes, wrapper];
      }
    });
    this.addController(this._messageController);
    this._cancelController = new SlotController(this, "cancel-button", "vaadin-button", {
      initializer: (button2) => {
        this.__setupSlottedButton("cancel", button2);
      }
    });
    this.addController(this._cancelController);
    this._rejectController = new SlotController(this, "reject-button", "vaadin-button", {
      initializer: (button2) => {
        this.__setupSlottedButton("reject", button2);
      }
    });
    this.addController(this._rejectController);
    this._confirmController = new SlotController(this, "confirm-button", "vaadin-button", {
      initializer: (button2) => {
        this.__setupSlottedButton("confirm", button2);
      }
    });
    this.addController(this._confirmController);
    this._overlayElement = this.$.dialog.$.overlay;
    this._initOverlay(this._overlayElement);
  }
  /** @protected */
  _initOverlay(overlay2) {
    overlay2.addEventListener("vaadin-overlay-escape-press", this._escPressed.bind(this));
    overlay2.addEventListener("vaadin-overlay-open", () => this.__onDialogOpened());
    overlay2.addEventListener("vaadin-overlay-closed", () => this.__onDialogClosed());
    overlay2.setAttribute("role", "alertdialog");
  }
  /** @private */
  __onDialogOpened() {
    const overlay2 = this._overlayElement;
    this.__slottedNodes.forEach((node) => {
      overlay2.appendChild(node);
    });
    const confirmButton = overlay2.querySelector('[slot="confirm-button"]');
    if (confirmButton) {
      confirmButton.focus();
    }
  }
  /** @private */
  __onDialogClosed() {
    this.__slottedNodes.forEach((node) => {
      this.appendChild(node);
    });
    this.dispatchEvent(new CustomEvent("closed"));
  }
  /** @private */
  __accessibleDescriptionRefChanged(overlay2, messageNodes, accessibleDescriptionRef) {
    if (!overlay2 || !messageNodes) {
      return;
    }
    if (accessibleDescriptionRef !== void 0) {
      setAriaIDReference(overlay2, "aria-describedby", {
        newId: accessibleDescriptionRef,
        oldId: this.__oldAccessibleDescriptionRef,
        fromUser: true
      });
    } else {
      messageNodes.forEach((node) => {
        setAriaIDReference(overlay2, "aria-describedby", { newId: node.id });
      });
    }
    this.__oldAccessibleDescriptionRef = accessibleDescriptionRef;
  }
  /** @private */
  __setupSlottedButton(type, button2) {
    const property = `_${type}Button`;
    const listener = `__${type}`;
    if (this[property] && this[property] !== button2) {
      this[property].remove();
    }
    button2.addEventListener("click", this[listener]);
    this[property] = button2;
  }
  /** @private */
  __updateCancelButton(button2, cancelText, cancelTheme, showCancel) {
    if (button2) {
      if (button2 === this._cancelController.defaultNode) {
        button2.textContent = cancelText;
        button2.setAttribute("theme", cancelTheme);
      }
      button2.toggleAttribute("hidden", !showCancel);
    }
  }
  /** @private */
  __updateConfirmButton(button2, confirmText, confirmTheme) {
    if (button2 && button2 === this._confirmController.defaultNode) {
      button2.textContent = confirmText;
      button2.setAttribute("theme", confirmTheme);
    }
  }
  /** @private */
  __updateHeaderNode(headerNode, header) {
    if (headerNode && headerNode === this._headerController.defaultNode) {
      headerNode.textContent = header;
    }
  }
  /** @private */
  __updateMessageNodes(nodes, message) {
    if (nodes && nodes.length > 0) {
      const defaultWrapperNode = nodes.find(
        (node) => this._messageController.defaultNode && node === this._messageController.defaultNode.parentElement
      );
      if (defaultWrapperNode) {
        defaultWrapperNode.firstChild.textContent = message;
      }
    }
  }
  /** @private */
  __updateRejectButton(button2, rejectText, rejectTheme, showReject) {
    if (button2) {
      if (button2 === this._rejectController.defaultNode) {
        button2.textContent = rejectText;
        button2.setAttribute("theme", rejectTheme);
      }
      button2.toggleAttribute("hidden", !showReject);
    }
  }
  /** @private */
  _escPressed(event) {
    if (!event.defaultPrevented) {
      this.__cancel();
    }
  }
  /** @private */
  __confirm() {
    this.dispatchEvent(new CustomEvent("confirm"));
    this.opened = false;
  }
  /** @private */
  __cancel() {
    this.dispatchEvent(new CustomEvent("cancel"));
    this.opened = false;
  }
  /** @private */
  __reject() {
    this.dispatchEvent(new CustomEvent("reject"));
    this.opened = false;
  }
  /** @private */
  _getAriaLabel(header) {
    return header || "confirmation";
  }
  /**
   * Fired when the confirm dialog is closed.
   *
   * @event closed
   */
};
/**
 * @license
 * Copyright (c) 2018 - 2025 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
class ConfirmDialog extends ConfirmDialogMixin(ElementMixin(ThemePropertyMixin(ControllerMixin(PolymerElement)))) {
  static get template() {
    return html`
      <style>
        :host,
        [hidden] {
          display: none !important;
        }
      </style>

      <vaadin-confirm-dialog-dialog
        id="dialog"
        opened="{{opened}}"
        overlay-class="[[overlayClass]]"
        aria-label="[[_getAriaLabel(header)]]"
        theme$="[[_theme]]"
        no-close-on-outside-click
        no-close-on-esc="[[noCloseOnEsc]]"
        content-height="[[_contentHeight]]"
        content-width="[[_contentWidth]]"
      ></vaadin-confirm-dialog-dialog>

      <div hidden>
        <slot name="header"></slot>
        <slot></slot>
        <slot name="cancel-button"></slot>
        <slot name="reject-button"></slot>
        <slot name="confirm-button"></slot>
      </div>
    `;
  }
  static get is() {
    return "vaadin-confirm-dialog";
  }
  /**
   * @event confirm
   * fired when Confirm button was pressed.
   */
  /**
   * @event cancel
   * fired when Cancel button or Escape key was pressed.
   */
  /**
   * @event reject
   * fired when Reject button was pressed.
   */
}
defineCustomElement(ConfirmDialog);
const contextMenuItem = css`
  /* :hover needed to workaround https://github.com/vaadin/web-components/issues/3133 */
  :host(:hover) {
    user-select: none;
    -webkit-user-select: none;
  }

  :host([role='menuitem'][menu-item-checked]) [part='checkmark']::before {
    opacity: 1;
  }

  :host([aria-haspopup='true'])::after {
    font-family: lumo-icons;
    font-size: var(--lumo-icon-size-xs);
    content: var(--lumo-icons-angle-right);
    color: var(--lumo-tertiary-text-color);
  }

  :host(:not([dir='rtl'])[aria-haspopup='true'])::after {
    margin-right: calc(var(--lumo-space-m) * -1);
    padding-left: var(--lumo-space-m);
  }

  :host([expanded]) {
    background-color: var(--lumo-primary-color-10pct);
  }

  /* RTL styles */
  :host([dir='rtl'][aria-haspopup='true'])::after {
    content: var(--lumo-icons-angle-left);
    margin-left: calc(var(--lumo-space-m) * -1);
    padding-right: var(--lumo-space-m);
  }
`;
registerStyles$1("vaadin-context-menu-item", [item, contextMenuItem], { moduleId: "lumo-context-menu-item" });
const contextMenuListBox = css`
  :host {
    --_lumo-list-box-item-selected-icon-display: block;
  }

  /* Normal item */
  [part='items'] ::slotted([role='menuitem']) {
    -webkit-tap-highlight-color: var(--lumo-primary-color-10pct);
    cursor: default;
    outline: none;
    border-radius: var(--lumo-border-radius-m);
    padding-left: calc(var(--lumo-border-radius-m) / 4);
    padding-right: calc(var(--lumo-space-l) + var(--lumo-border-radius-m) / 4);
  }

  /* Hovered item */
  /* TODO a workaround until we have "focus-follows-mouse". After that, use the hover style for focus-ring as well */
  [part='items'] ::slotted([role='menuitem']:hover:not([disabled])),
  [part='items'] ::slotted([role='menuitem'][expanded]:not([disabled])) {
    background-color: var(--lumo-primary-color-10pct);
  }

  /* RTL styles */
  :host([dir='rtl']) [part='items'] ::slotted([role='menuitem']) {
    padding-left: calc(var(--lumo-space-l) + var(--lumo-border-radius-m) / 4);
    padding-right: calc(var(--lumo-border-radius-m) / 4);
  }

  /* Focused item */
  @media (pointer: coarse) {
    [part='items'] ::slotted([role='menuitem']:hover:not([expanded]):not([disabled])) {
      background-color: transparent;
    }
  }
`;
registerStyles$1("vaadin-context-menu-list-box", [listBox, contextMenuListBox], {
  moduleId: "lumo-context-menu-list-box"
});
const contextMenuOverlay = css`
  :host([phone]) {
    /* stylelint-disable declaration-block-no-redundant-longhand-properties */
    top: 0 !important;
    right: 0 !important;
    bottom: var(--vaadin-overlay-viewport-bottom) !important;
    left: 0 !important;
    /* stylelint-enable declaration-block-no-redundant-longhand-properties */
    align-items: stretch;
    justify-content: flex-end;
  }

  /* TODO These style overrides should not be needed.
   We should instead offer a way to have non-selectable items inside the context menu. */

  :host {
    --_lumo-list-box-item-selected-icon-display: none;
    --_lumo-list-box-item-padding-left: calc(var(--lumo-space-m) + var(--lumo-border-radius-m) / 4);
  }

  [part='overlay'] {
    outline: none;
  }
`;
registerStyles$1("vaadin-context-menu-overlay", [menuOverlay, contextMenuOverlay], {
  moduleId: "lumo-context-menu-overlay"
});
/**
 * @license
 * Copyright (c) 2016 - 2025 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
register({
  name: "vaadin-contextmenu",
  deps: ["touchstart", "touchmove", "touchend", "contextmenu"],
  flow: {
    start: ["touchstart", "contextmenu"],
    end: ["contextmenu"]
  },
  emits: ["vaadin-contextmenu"],
  info: {
    sourceEvent: null
  },
  reset() {
    this.info.sourceEvent = null;
    this._cancelTimer();
    this.info.touchJob = null;
    this.info.touchStartCoords = null;
  },
  _cancelTimer() {
    if (this._timerId) {
      clearTimeout(this._timerId);
      delete this._fired;
    }
  },
  _setSourceEvent(e2) {
    this.info.sourceEvent = e2;
    const path = e2.composedPath();
    this.info.sourceEvent.__composedPath = path;
  },
  touchstart(e2) {
    this._setSourceEvent(e2);
    this.info.touchStartCoords = {
      x: e2.changedTouches[0].clientX,
      y: e2.changedTouches[0].clientY
    };
    const t2 = e2.composedPath()[0] || e2.target;
    this._timerId = setTimeout(() => {
      const ct = e2.changedTouches[0];
      if (!e2.shiftKey) {
        if (isIOS) {
          this._fired = true;
          this.fire(t2, ct.clientX, ct.clientY);
        }
        prevent("tap");
      }
    }, 500);
  },
  touchmove(e2) {
    const moveThreshold = 15;
    const touchStartCoords = this.info.touchStartCoords;
    if (Math.abs(touchStartCoords.x - e2.changedTouches[0].clientX) > moveThreshold || Math.abs(touchStartCoords.y - e2.changedTouches[0].clientY) > moveThreshold) {
      this._cancelTimer();
    }
  },
  touchend(e2) {
    if (this._fired) {
      e2.preventDefault();
    }
    this._cancelTimer();
  },
  contextmenu(e2) {
    if (!e2.shiftKey) {
      this._setSourceEvent(e2);
      if (isFirefox && isKeyboardActive()) {
        const keyboardTarget = e2.composedPath()[0];
        const targetRect = keyboardTarget.getBoundingClientRect();
        this.fire(keyboardTarget, targetRect.left, targetRect.bottom);
      } else {
        this.fire(e2.target, e2.clientX, e2.clientY);
      }
      prevent("tap");
    }
  },
  fire(target, x2, y3) {
    const sourceEvent = this.info.sourceEvent;
    const ev = new Event("vaadin-contextmenu", { bubbles: true, cancelable: true, composed: true });
    ev.detail = { x: x2, y: y3, sourceEvent };
    target.dispatchEvent(ev);
    if (ev.defaultPrevented && sourceEvent && sourceEvent.preventDefault) {
      sourceEvent.preventDefault();
    }
  }
});
/**
 * @license
 * Copyright (c) 2016 - 2025 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
class ContextMenuItem extends ItemMixin(ThemableMixin(DirMixin(PolymerElement))) {
  static get is() {
    return "vaadin-context-menu-item";
  }
  static get template() {
    return html`
      <style>
        :host {
          display: inline-block;
        }

        :host([hidden]) {
          display: none !important;
        }
      </style>
      <span part="checkmark" aria-hidden="true"></span>
      <div part="content">
        <slot></slot>
      </div>
    `;
  }
  /** @protected */
  ready() {
    super.ready();
    this.setAttribute("role", "menuitem");
  }
}
defineCustomElement(ContextMenuItem);
/**
 * @license
 * Copyright (c) 2016 - 2025 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
class ContextMenuListBox extends ListMixin(ThemableMixin(DirMixin(ControllerMixin(PolymerElement)))) {
  static get is() {
    return "vaadin-context-menu-list-box";
  }
  static get template() {
    return html`
      <style>
        :host {
          display: flex;
        }

        :host([hidden]) {
          display: none !important;
        }

        [part='items'] {
          height: 100%;
          width: 100%;
          overflow-y: auto;
          -webkit-overflow-scrolling: touch;
        }
      </style>
      <div part="items">
        <slot></slot>
      </div>
    `;
  }
  static get properties() {
    return {
      // We don't need to define this property since super default is vertical,
      // but we don't want it to be modified, or be shown in the API docs.
      /** @private */
      orientation: {
        readOnly: true
      }
    };
  }
  /**
   * @return {!HTMLElement}
   * @protected
   * @override
   */
  get _scrollerElement() {
    return this.shadowRoot.querySelector('[part="items"]');
  }
  /** @protected */
  ready() {
    super.ready();
    this.setAttribute("role", "menu");
  }
}
defineCustomElement(ContextMenuListBox);
/**
 * @license
 * Copyright (c) 2016 - 2025 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const MenuOverlayMixin = (superClass) => class MenuOverlayMixin extends OverlayFocusMixin(PositionMixin(superClass)) {
  static get properties() {
    return {
      /**
       * @protected
       */
      parentOverlay: {
        type: Object,
        readOnly: true
      },
      /**
       * @protected
       */
      _theme: {
        type: String,
        readOnly: true,
        sync: true
      }
    };
  }
  static get observers() {
    return ["_themeChanged(_theme)"];
  }
  /** @protected */
  ready() {
    super.ready();
    this.restoreFocusOnClose = true;
    this.addEventListener("keydown", (e2) => {
      if (!e2.defaultPrevented && e2.composedPath()[0] === this.$.overlay && [38, 40].indexOf(e2.keyCode) > -1) {
        const child = this.getFirstChild();
        if (child && Array.isArray(child.items) && child.items.length) {
          e2.preventDefault();
          if (e2.keyCode === 38) {
            child.items[child.items.length - 1].focus();
          } else {
            child.focus();
          }
        }
      }
    });
  }
  /**
   * Returns the first element in the overlay content.
   *
   * @returns {HTMLElement}
   */
  getFirstChild() {
    return this.querySelector(":not(style):not(slot)");
  }
  /** @private */
  _themeChanged() {
    this.close();
  }
  /**
   * Returns the adjusted boundaries of the overlay.
   *
   * @returns {object}
   */
  getBoundaries() {
    const overlayRect = this.getBoundingClientRect();
    const contentRect = this.$.overlay.getBoundingClientRect();
    let yMax = overlayRect.bottom - contentRect.height;
    const parent = this.parentOverlay;
    if (parent && parent.hasAttribute("bottom-aligned")) {
      const parentStyle = getComputedStyle(parent);
      yMax = yMax - parseFloat(parentStyle.bottom) - parseFloat(parentStyle.height);
    }
    return {
      xMax: overlayRect.right - contentRect.width,
      xMin: overlayRect.left + contentRect.width,
      yMax
    };
  }
  /**
   * @protected
   * @override
   */
  _updatePosition() {
    super._updatePosition();
    if (this.positionTarget && this.parentOverlay) {
      const content = this.$.content;
      const style = getComputedStyle(content);
      const isLeftAligned = !!this.style.left;
      if (isLeftAligned) {
        this.style.left = `${parseFloat(this.style.left) + parseFloat(style.paddingLeft)}px`;
      } else {
        this.style.right = `${parseFloat(this.style.right) + parseFloat(style.paddingRight)}px`;
      }
      const isBottomAligned = !!this.style.bottom;
      if (isBottomAligned) {
        this.style.bottom = `${parseFloat(this.style.bottom) - parseFloat(style.paddingBottom)}px`;
      } else {
        this.style.top = `${parseFloat(this.style.top) - parseFloat(style.paddingTop)}px`;
      }
    }
  }
  /**
   * Override method inherited from `OverlayFocusMixin` to disable
   * focus restoration on sub-menu overlay close. Focus should
   * be only restored when the root menu closes.
   *
   * @protected
   * @override
   * @return {boolean}
   */
  _shouldRestoreFocus() {
    if (this.parentOverlay) {
      return false;
    }
    return super._shouldRestoreFocus();
  }
  /**
   * Override method inherited from `OverlayFocusMixin` to return
   * true if the overlay contains the given node, including
   * those within descendant menu overlays.
   *
   * @protected
   * @override
   * @param {Node} node
   * @return {boolean}
   */
  _deepContains(node) {
    let overlay2 = getClosestElement(this.localName, node);
    while (overlay2) {
      if (overlay2 === this) {
        return true;
      }
      overlay2 = overlay2.parentOverlay;
    }
    return false;
  }
};
/**
 * @license
 * Copyright (c) 2016 - 2025 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const styles = css`
  :host {
    align-items: flex-start;
    justify-content: flex-start;
  }

  :host([right-aligned]),
  :host([end-aligned]) {
    align-items: flex-end;
  }

  :host([bottom-aligned]) {
    justify-content: flex-end;
  }

  [part='overlay'] {
    background-color: #fff;
  }

  @media (forced-colors: active) {
    [part='overlay'] {
      outline: 3px solid !important;
    }
  }
`;
/**
 * @license
 * Copyright (c) 2016 - 2025 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
registerStyles$1("vaadin-context-menu-overlay", [overlayStyles, styles], {
  moduleId: "vaadin-context-menu-overlay-styles"
});
class ContextMenuOverlay extends MenuOverlayMixin(OverlayMixin(DirMixin(ThemableMixin(PolymerElement)))) {
  static get is() {
    return "vaadin-context-menu-overlay";
  }
  static get template() {
    return html`
      <div id="backdrop" part="backdrop" hidden$="[[!withBackdrop]]"></div>
      <div part="overlay" id="overlay" tabindex="0">
        <div part="content" id="content">
          <slot></slot>
        </div>
      </div>
    `;
  }
}
defineCustomElement(ContextMenuOverlay);
/**
 * @license
 * Copyright (c) 2021 - 2025 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
class MediaQueryController {
  constructor(query, callback) {
    this.query = query;
    this.callback = callback;
    this._boundQueryHandler = this._queryHandler.bind(this);
  }
  hostConnected() {
    this._removeListener();
    this._mediaQuery = window.matchMedia(this.query);
    this._addListener();
    this._queryHandler(this._mediaQuery);
  }
  hostDisconnected() {
    this._removeListener();
  }
  /** @private */
  _addListener() {
    if (this._mediaQuery) {
      this._mediaQuery.addListener(this._boundQueryHandler);
    }
  }
  /** @private */
  _removeListener() {
    if (this._mediaQuery) {
      this._mediaQuery.removeListener(this._boundQueryHandler);
    }
    this._mediaQuery = null;
  }
  /** @private */
  _queryHandler(mediaQuery) {
    if (typeof this.callback === "function") {
      this.callback(mediaQuery.matches);
    }
  }
}
/**
 * @license
 * Copyright (c) 2016 - 2025 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const ItemsMixin = (superClass) => class ItemsMixin extends superClass {
  static get properties() {
    return {
      /**
       * @typedef ContextMenuItem
       * @type {object}
       * @property {string} text - Text to be set as the menu item component's textContent
       * @property {union: string | object} component - The component to represent the item.
       * Either a tagName or an element instance. Defaults to "vaadin-context-menu-item".
       * @property {boolean} disabled - If true, the item is disabled and cannot be selected
       * @property {boolean} checked - If true, the item shows a checkmark next to it
       * @property {boolean} keepOpen - If true, the menu will not be closed on item selection
       * @property {string} className - A space-delimited list of CSS class names to be set on the menu item component.
       * @property {union: string | string[]} theme - If set, sets the given theme(s) as an attribute to the menu item component, overriding any theme set on the context menu.
       * @property {MenuItem[]} children - Array of child menu items
       */
      /**
       * Defines a (hierarchical) menu structure for the component.
       * If a menu item has a non-empty `children` set, a sub-menu with the child items is opened
       * next to the parent menu on mouseover, tap or a right arrow keypress.
       *
       * The items API can't be used together with a renderer!
       *
       * #### Example
       *
       * ```javascript
       * contextMenu.items = [
       *   { text: 'Menu Item 1', theme: 'primary', className: 'first', children:
       *     [
       *       { text: 'Menu Item 1-1', checked: true, keepOpen: true },
       *       { text: 'Menu Item 1-2' }
       *     ]
       *   },
       *   { component: 'hr' },
       *   { text: 'Menu Item 2', children:
       *     [
       *       { text: 'Menu Item 2-1' },
       *       { text: 'Menu Item 2-2', disabled: true }
       *     ]
       *   },
       *   { text: 'Menu Item 3', disabled: true, className: 'last' }
       * ];
       * ```
       *
       * @type {!Array<!ContextMenuItem> | undefined}
       */
      items: {
        type: Array,
        sync: true
      }
    };
  }
  constructor() {
    super();
    this.__itemsOutsideClickListener = (e2) => {
      if (this._shouldCloseOnOutsideClick(e2)) {
        this.dispatchEvent(new CustomEvent("items-outside-click"));
      }
    };
    this.addEventListener("items-outside-click", () => {
      this.items && this.close();
    });
  }
  /**
   * Tag name prefix used by overlay, list-box and items.
   * @protected
   * @return {string}
   */
  get _tagNamePrefix() {
    return "vaadin-context-menu";
  }
  /** @protected */
  connectedCallback() {
    super.connectedCallback();
    document.documentElement.addEventListener("click", this.__itemsOutsideClickListener);
  }
  /** @protected */
  disconnectedCallback() {
    super.disconnectedCallback();
    document.documentElement.removeEventListener("click", this.__itemsOutsideClickListener);
  }
  /**
   * Whether to close the overlay on outside click or not.
   * Override this method to customize the closing logic.
   *
   * @param {Event} event
   * @return {boolean}
   * @protected
   */
  _shouldCloseOnOutsideClick(event) {
    return !event.composedPath().some((el) => el.localName === `${this._tagNamePrefix}-overlay`);
  }
  /** @protected */
  __forwardFocus() {
    const overlay2 = this._overlayElement;
    const child = overlay2.getFirstChild();
    if (overlay2.parentOverlay) {
      const parent = overlay2.parentOverlay.querySelector("[expanded]");
      if (parent && parent.hasAttribute("focused") && child) {
        child.focus();
      } else {
        overlay2.$.overlay.focus();
      }
    } else if (child) {
      child.focus();
    }
  }
  /** @private */
  __openSubMenu(subMenu, itemElement, overlayClass) {
    subMenu.items = itemElement._item.children;
    subMenu.listenOn = itemElement;
    subMenu.overlayClass = overlayClass;
    const parent = this._overlayElement;
    const subMenuOverlay = subMenu._overlayElement;
    subMenuOverlay.positionTarget = itemElement;
    subMenuOverlay.noHorizontalOverlap = true;
    subMenuOverlay._setParentOverlay(parent);
    if (parent.hasAttribute("theme")) {
      subMenu.setAttribute("theme", parent.getAttribute("theme"));
    } else {
      subMenu.removeAttribute("theme");
    }
    const content = subMenuOverlay.$.content;
    content.style.minWidth = "";
    itemElement.dispatchEvent(
      new CustomEvent("opensubmenu", {
        detail: {
          children: itemElement._item.children
        }
      })
    );
  }
  /**
   * @param {!ContextMenuItem} item
   * @return {HTMLElement}
   * @private
   */
  __createComponent(item2) {
    let component;
    if (item2.component instanceof HTMLElement) {
      component = item2.component;
    } else {
      component = document.createElement(item2.component || `${this._tagNamePrefix}-item`);
    }
    if (component._hasVaadinItemMixin) {
      component.setAttribute("role", "menuitem");
      component.tabIndex = -1;
    }
    if (component.localName === "hr") {
      component.setAttribute("role", "separator");
    } else {
      component.setAttribute("aria-haspopup", "false");
    }
    this._setMenuItemTheme(component, item2, this._theme);
    component._item = item2;
    if (item2.text) {
      component.textContent = item2.text;
    }
    if (item2.className) {
      component.setAttribute("class", item2.className);
    }
    this.__toggleMenuComponentAttribute(component, "menu-item-checked", item2.checked);
    this.__toggleMenuComponentAttribute(component, "disabled", item2.disabled);
    if (item2.children && item2.children.length) {
      this.__updateExpanded(component, false);
      component.setAttribute("aria-haspopup", "true");
    }
    return component;
  }
  /** @private */
  __initListBox() {
    const listBox2 = document.createElement(`${this._tagNamePrefix}-list-box`);
    if (this._theme) {
      listBox2.setAttribute("theme", this._theme);
    }
    listBox2.addEventListener("selected-changed", (event) => {
      const { value } = event.detail;
      if (typeof value === "number") {
        const item2 = listBox2.items[value]._item;
        listBox2.selected = null;
        if (!item2.children) {
          this.dispatchEvent(new CustomEvent("item-selected", { detail: { value: item2 } }));
        }
      }
    });
    return listBox2;
  }
  /** @private */
  __initOverlay() {
    const overlay2 = this._overlayElement;
    overlay2.$.backdrop.addEventListener("click", () => {
      this.close();
    });
    overlay2.addEventListener(isTouch ? "click" : "mouseover", (event) => {
      this.__showSubMenu(event);
    });
    overlay2.addEventListener("keydown", (event) => {
      const { key } = event;
      const isRTL = this.__isRTL;
      const isArrowRight = key === "ArrowRight";
      const isArrowLeft = key === "ArrowLeft";
      if (!isRTL && isArrowRight || isRTL && isArrowLeft || key === "Enter" || key === " ") {
        this.__showSubMenu(event);
      } else if (!isRTL && isArrowLeft || isRTL && isArrowRight || key === "Escape") {
        if (key === "Escape") {
          event.stopPropagation();
        }
        this.close();
        this.listenOn.focus();
      } else if (key === "Tab") {
        this.dispatchEvent(new CustomEvent("close-all-menus"));
      }
    });
  }
  /** @private */
  __initSubMenu() {
    const subMenu = document.createElement(this.constructor.is);
    subMenu._modeless = true;
    subMenu.openOn = "opensubmenu";
    subMenu.setAttribute("hidden", "");
    this.addEventListener("opened-changed", (event) => {
      if (!event.detail.value) {
        this._subMenu.close();
      }
    });
    subMenu.addEventListener("close-all-menus", () => {
      this.dispatchEvent(new CustomEvent("close-all-menus"));
    });
    subMenu.addEventListener("item-selected", (event) => {
      const { detail } = event;
      this.dispatchEvent(new CustomEvent("item-selected", { detail }));
    });
    this.addEventListener("close-all-menus", () => {
      this._overlayElement.close();
    });
    this.addEventListener("item-selected", (e2) => {
      const menu = e2.target;
      const selectedItem = e2.detail.value;
      const index = menu.items.indexOf(selectedItem);
      if (!!selectedItem.keepOpen && index > -1) {
        menu._overlayElement.requestContentUpdate();
        menu._listBox._observer.flush();
        const newItem = menu._listBox.children[index];
        newItem.focus();
      } else if (!selectedItem.keepOpen) {
        this.close();
      }
    });
    subMenu.addEventListener("opened-changed", (event) => {
      if (!event.detail.value) {
        const expandedItem = this._listBox.querySelector("[expanded]");
        if (expandedItem) {
          this.__updateExpanded(expandedItem, false);
        }
      }
    });
    return subMenu;
  }
  /** @private */
  __showSubMenu(event, item2 = event.composedPath().find((node) => node.localName === `${this._tagNamePrefix}-item`)) {
    if (!this.__openListenerActive) {
      return;
    }
    if (this._overlayElement.hasAttribute("opening")) {
      requestAnimationFrame(() => {
        this.__showSubMenu(event, item2);
      });
      return;
    }
    const subMenu = this._subMenu;
    if (item2) {
      const { children } = item2._item;
      const child = subMenu._overlayElement.getFirstChild();
      const isSubmenuFocused = child && child.focused;
      if (subMenu.items !== children) {
        subMenu.close();
      }
      if (!this.opened) {
        return;
      }
      if (children && children.length) {
        this.__updateExpanded(item2, true);
        const { overlayClass } = this;
        this.__openSubMenu(subMenu, item2, overlayClass);
      } else if (isSubmenuFocused) {
        subMenu.listenOn.focus();
      } else if (!this._listBox.focused) {
        this._overlayElement.$.overlay.focus();
      }
    }
  }
  /**
   * @param {!HTMLElement} root
   * @param {!ContextMenu} menu
   * @param {!ContextMenuRendererContext} context
   * @protected
   */
  __itemsRenderer(root2, menu, { detail }) {
    this.__initMenu(root2, menu);
    const subMenu = root2.querySelector(this.constructor.is);
    subMenu.closeOn = menu.closeOn;
    const listBox2 = root2.querySelector(`${this._tagNamePrefix}-list-box`);
    listBox2.innerHTML = "";
    [...detail.children || menu.items].forEach((item2) => {
      const component = this.__createComponent(item2);
      listBox2.appendChild(component);
    });
  }
  /** @protected */
  _setMenuItemTheme(component, item2, hostTheme) {
    let theme = component.getAttribute("theme") || hostTheme;
    if (item2.theme != null) {
      theme = Array.isArray(item2.theme) ? item2.theme.join(" ") : item2.theme;
    }
    this.__updateTheme(component, theme);
  }
  /** @private */
  __toggleMenuComponentAttribute(component, attribute, on) {
    if (on) {
      component.setAttribute(attribute, "");
      component[`__has-${attribute}`] = true;
    } else if (component[`__has-${attribute}`]) {
      component.removeAttribute(attribute);
      component[`__has-${attribute}`] = false;
    }
  }
  /** @private */
  __initMenu(root2, _menu) {
    if (!root2.firstElementChild) {
      this.__initOverlay();
      const listBox2 = this.__initListBox();
      this._listBox = listBox2;
      root2.appendChild(listBox2);
      const subMenu = this.__initSubMenu();
      this._subMenu = subMenu;
      root2.appendChild(subMenu);
      requestAnimationFrame(() => {
        this.__openListenerActive = true;
      });
    } else {
      this.__updateTheme(this._listBox, this._theme);
    }
  }
  /** @private */
  __updateExpanded(component, expanded) {
    component.setAttribute("aria-expanded", expanded.toString());
    component.toggleAttribute("expanded", expanded);
  }
  /** @private */
  __updateTheme(component, theme) {
    if (theme) {
      component.setAttribute("theme", theme);
    } else {
      component.removeAttribute("theme");
    }
  }
};
/**
 * @license
 * Copyright (c) 2016 - 2025 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const ContextMenuMixin = (superClass) => class ContextMenuMixinClass extends ItemsMixin(superClass) {
  static get properties() {
    return {
      /**
       * CSS selector that can be used to target any child element
       * of the context menu to listen for `openOn` events.
       */
      selector: {
        type: String
      },
      /**
       * True if the overlay is currently displayed.
       * @type {boolean}
       */
      opened: {
        type: Boolean,
        value: false,
        notify: true,
        readOnly: true
      },
      /**
       * Event name to listen for opening the context menu.
       * @attr {string} open-on
       * @type {string}
       */
      openOn: {
        type: String,
        value: "vaadin-contextmenu",
        sync: true
      },
      /**
       * The target element that's listened to for context menu opening events.
       * By default the vaadin-context-menu listens to the target's `vaadin-contextmenu`
       * events.
       * @type {!HTMLElement}
       * @default self
       */
      listenOn: {
        type: Object,
        sync: true,
        value() {
          return this;
        }
      },
      /**
       * Event name to listen for closing the context menu.
       * @attr {string} close-on
       * @type {string}
       */
      closeOn: {
        type: String,
        value: "click",
        observer: "_closeOnChanged",
        sync: true
      },
      /**
       * Custom function for rendering the content of the menu overlay.
       * Receives three arguments:
       *
       * - `root` The root container DOM element. Append your content to it.
       * - `contextMenu` The reference to the `<vaadin-context-menu>` element.
       * - `context` The object with the menu context, contains:
       *   - `context.target`  the target of the menu opening event,
       *   - `context.detail` the menu opening event detail.
       * @type {ContextMenuRenderer | undefined}
       */
      renderer: {
        type: Function,
        sync: true
      },
      /**
       * When true, the menu overlay is modeless.
       * @protected
       */
      _modeless: {
        type: Boolean,
        sync: true
      },
      /** @private */
      _context: {
        type: Object,
        sync: true
      },
      /** @private */
      _phone: {
        type: Boolean
      },
      _fullscreen: {
        type: Boolean
      },
      _fullscreenMediaQuery: {
        type: String,
        value: "(max-width: 450px), (max-height: 450px)"
      }
    };
  }
  static get observers() {
    return [
      "_openedChanged(opened)",
      "_targetOrOpenOnChanged(listenOn, openOn)",
      "_rendererChanged(renderer, items)",
      "_fullscreenChanged(_fullscreen)",
      "_overlayContextChanged(_overlayElement, _context)",
      "_overlayModelessChanged(_overlayElement, _modeless)",
      "_overlayPhoneChanged(_overlayElement, _phone)",
      "_overlayThemeChanged(_overlayElement, _theme)"
    ];
  }
  constructor() {
    super();
    this._createOverlay();
    this._boundOpen = this.open.bind(this);
    this._boundClose = this.close.bind(this);
    this._boundPreventDefault = this._preventDefault.bind(this);
    this._boundOnGlobalContextMenu = this._onGlobalContextMenu.bind(this);
  }
  /** @protected */
  connectedCallback() {
    super.connectedCallback();
    this.__boundOnScroll = this.__onScroll.bind(this);
    window.addEventListener("scroll", this.__boundOnScroll, true);
    if (this.__restoreOpened) {
      this._setOpened(true);
    }
  }
  /** @protected */
  disconnectedCallback() {
    super.disconnectedCallback();
    window.removeEventListener("scroll", this.__boundOnScroll, true);
    this.__restoreOpened = this.opened;
    this.close();
  }
  /** @protected */
  ready() {
    super.ready();
    this.addController(
      new MediaQueryController(this._fullscreenMediaQuery, (matches2) => {
        this._fullscreen = matches2;
      })
    );
  }
  /** @private */
  _createOverlay() {
    const overlay2 = document.createElement(`${this._tagNamePrefix}-overlay`);
    overlay2.owner = this;
    overlay2.addEventListener("opened-changed", (e2) => {
      this._onOverlayOpened(e2);
    });
    overlay2.addEventListener("vaadin-overlay-open", (e2) => {
      this._onVaadinOverlayOpen(e2);
    });
    this._overlayElement = overlay2;
  }
  /**
   * Runs before overlay is fully rendered
   * @private
   */
  _onOverlayOpened(e2) {
    const opened = e2.detail.value;
    this._setOpened(opened);
    if (opened) {
      this.__alignOverlayPosition();
    }
  }
  /**
   * Runs after overlay is fully rendered
   * @private
   */
  _onVaadinOverlayOpen() {
    this.__alignOverlayPosition();
    this._overlayElement.style.visibility = "";
    this.__forwardFocus();
  }
  /** @private */
  _overlayContextChanged(overlay2, context) {
    if (overlay2) {
      overlay2.model = context;
    }
  }
  /** @private */
  _overlayModelessChanged(overlay2, modeless) {
    if (overlay2) {
      overlay2.modeless = modeless;
    }
  }
  /** @private */
  _overlayPhoneChanged(overlay2, phone) {
    if (overlay2) {
      overlay2.toggleAttribute("phone", phone);
      overlay2.withBackdrop = phone;
    }
  }
  /** @private */
  _overlayThemeChanged(overlay2, theme) {
    if (overlay2) {
      if (theme) {
        overlay2.setAttribute("theme", theme);
      } else {
        overlay2.removeAttribute("theme");
      }
    }
  }
  /** @private */
  _targetOrOpenOnChanged(listenOn, openOn) {
    if (this._oldListenOn && this._oldOpenOn) {
      this._unlisten(this._oldListenOn, this._oldOpenOn, this._boundOpen);
      this._oldListenOn.style.webkitTouchCallout = "";
      this._oldListenOn.style.webkitUserSelect = "";
      this._oldListenOn.style.userSelect = "";
      this._oldListenOn = null;
      this._oldOpenOn = null;
    }
    if (listenOn && openOn) {
      this._listen(listenOn, openOn, this._boundOpen);
      this._oldListenOn = listenOn;
      this._oldOpenOn = openOn;
    }
  }
  /** @private */
  _fullscreenChanged(fullScreen) {
    this._phone = fullScreen;
  }
  /** @private */
  __setListenOnUserSelect(opened) {
    const value = opened ? "none" : "";
    this.listenOn.style.webkitTouchCallout = value;
    this.listenOn.style.webkitUserSelect = value;
    this.listenOn.style.userSelect = value;
    if (opened) {
      document.getSelection().removeAllRanges();
    }
  }
  /** @private */
  _closeOnChanged(closeOn, oldCloseOn) {
    const evtOverlay = "vaadin-overlay-outside-click";
    const overlay2 = this._overlayElement;
    if (oldCloseOn) {
      this._unlisten(overlay2, oldCloseOn, this._boundClose);
    }
    if (closeOn) {
      this._listen(overlay2, closeOn, this._boundClose);
      overlay2.removeEventListener(evtOverlay, this._boundPreventDefault);
    } else {
      overlay2.addEventListener(evtOverlay, this._boundPreventDefault);
    }
  }
  /** @private */
  _preventDefault(e2) {
    e2.preventDefault();
  }
  /** @private */
  _openedChanged(opened) {
    if (opened) {
      document.documentElement.addEventListener("contextmenu", this._boundOnGlobalContextMenu, true);
    } else {
      document.documentElement.removeEventListener("contextmenu", this._boundOnGlobalContextMenu, true);
    }
    this.__setListenOnUserSelect(opened);
    this._overlayElement.opened = opened;
  }
  /**
   * Requests an update for the content of the menu overlay.
   * While performing the update, it invokes the renderer passed in the `renderer` property.
   *
   * It is not guaranteed that the update happens immediately (synchronously) after it is requested.
   */
  requestContentUpdate() {
    if (!this._overlayElement || !this.renderer) {
      return;
    }
    this._overlayElement.requestContentUpdate();
  }
  /** @private */
  _rendererChanged(renderer, items) {
    if (items) {
      if (renderer) {
        throw new Error("The items API cannot be used together with a renderer");
      }
      if (this.closeOn === "click") {
        this.closeOn = "";
      }
      renderer = this.__itemsRenderer;
    }
    this._overlayElement.renderer = renderer;
  }
  /**
   * Closes the overlay.
   */
  close() {
    this._setOpened(false);
  }
  /** @private */
  _contextTarget(e2) {
    if (this.selector) {
      const targets = this.listenOn.querySelectorAll(this.selector);
      return Array.prototype.filter.call(targets, (el) => {
        return e2.composedPath().indexOf(el) > -1;
      })[0];
    }
    return e2.target;
  }
  /**
   * Opens the overlay.
   * @param {!Event | undefined} e used as the context for the menu. Overlay coordinates are taken from this event.
   */
  open(e2) {
    if (e2 && !this.opened) {
      this._context = {
        detail: e2.detail,
        target: this._contextTarget(e2)
      };
      if (this._context.target) {
        e2.preventDefault();
        e2.stopPropagation();
        this.__x = this._getEventCoordinate(e2, "x");
        this.__pageXOffset = window.pageXOffset;
        this.__y = this._getEventCoordinate(e2, "y");
        this.__pageYOffset = window.pageYOffset;
        this._overlayElement.style.visibility = "hidden";
        this._setOpened(true);
      }
    }
  }
  /** @private */
  __onScroll() {
    if (!this.opened) {
      return;
    }
    const yDiff = window.pageYOffset - this.__pageYOffset;
    const xDiff = window.pageXOffset - this.__pageXOffset;
    this.__adjustPosition("left", -xDiff);
    this.__adjustPosition("right", xDiff);
    this.__adjustPosition("top", -yDiff);
    this.__adjustPosition("bottom", yDiff);
    this.__pageYOffset += yDiff;
    this.__pageXOffset += xDiff;
  }
  /** @private */
  __adjustPosition(coord, diff) {
    const overlay2 = this._overlayElement;
    const style = overlay2.style;
    style[coord] = `${(parseInt(style[coord]) || 0) + diff}px`;
  }
  /** @private */
  __alignOverlayPosition() {
    const overlay2 = this._overlayElement;
    if (overlay2.positionTarget) {
      return;
    }
    const style = overlay2.style;
    ["top", "right", "bottom", "left"].forEach((prop) => style.removeProperty(prop));
    ["right-aligned", "end-aligned", "bottom-aligned"].forEach((attr) => overlay2.removeAttribute(attr));
    const { xMax, xMin, yMax } = overlay2.getBoundaries();
    const x2 = this.__x;
    const y3 = this.__y;
    const wdthVport = document.documentElement.clientWidth;
    const hghtVport = document.documentElement.clientHeight;
    if (!this.__isRTL) {
      if (x2 < wdthVport / 2 || x2 < xMax) {
        style.left = `${x2}px`;
      } else {
        style.right = `${Math.max(0, wdthVport - x2)}px`;
        this._setEndAligned(overlay2);
      }
    } else if (x2 > wdthVport / 2 || x2 > xMin) {
      style.right = `${Math.max(0, wdthVport - x2)}px`;
    } else {
      style.left = `${x2}px`;
      this._setEndAligned(overlay2);
    }
    if (y3 < hghtVport / 2 || y3 < yMax) {
      style.top = `${y3}px`;
    } else {
      style.bottom = `${Math.max(0, hghtVport - y3)}px`;
      overlay2.setAttribute("bottom-aligned", "");
    }
  }
  /** @private */
  _setEndAligned(element) {
    element.setAttribute("end-aligned", "");
    if (!this.__isRTL) {
      element.setAttribute("right-aligned", "");
    }
  }
  /** @private */
  _getEventCoordinate(event, coord) {
    if (event.detail instanceof Object) {
      if (event.detail[coord]) {
        return event.detail[coord];
      } else if (event.detail.sourceEvent) {
        return this._getEventCoordinate(event.detail.sourceEvent, coord);
      }
    } else {
      const prop = `client${coord.toUpperCase()}`;
      const position = event.changedTouches ? event.changedTouches[0][prop] : event[prop];
      if (position === 0) {
        const rect = event.target.getBoundingClientRect();
        return coord === "x" ? rect.left : rect.top + rect.height;
      }
      return position;
    }
  }
  /** @private */
  _listen(node, evType, handler) {
    if (gestures[evType]) {
      addListener(node, evType, handler);
    } else {
      node.addEventListener(evType, handler);
    }
  }
  /** @private */
  _unlisten(node, evType, handler) {
    if (gestures[evType]) {
      removeListener(node, evType, handler);
    } else {
      node.removeEventListener(evType, handler);
    }
  }
  /** @private */
  __createMouseEvent(name, clientX, clientY) {
    return new MouseEvent(name, {
      bubbles: true,
      composed: true,
      cancelable: true,
      clientX,
      clientY
    });
  }
  /** @private */
  __focusClosestFocusable(target) {
    let currentElement = target;
    while (currentElement) {
      if (currentElement instanceof HTMLElement && isElementFocusable(currentElement)) {
        currentElement.focus();
        return;
      }
      currentElement = currentElement.parentNode || currentElement.host;
    }
  }
  /**
   * Executes a synthetic contextmenu event on the target under the coordinates.
   * @private
   */
  __contextMenuAt(x2, y3) {
    const target = deepTargetFind(x2, y3);
    if (target) {
      queueMicrotask(() => {
        target.dispatchEvent(this.__createMouseEvent("mousedown", x2, y3));
        target.dispatchEvent(this.__createMouseEvent("mouseup", x2, y3));
        this.__focusClosestFocusable(target);
        target.dispatchEvent(this.__createMouseEvent("contextmenu", x2, y3));
      });
    }
  }
  /** @private */
  _onGlobalContextMenu(e2) {
    if (!e2.shiftKey) {
      const isTouchDevice = isAndroid || isIOS;
      if (!isTouchDevice) {
        e2.stopPropagation();
        this._overlayElement.__focusRestorationController.focusNode = null;
        this._overlayElement.addEventListener(
          "vaadin-overlay-closed",
          () => this.__contextMenuAt(e2.clientX, e2.clientY),
          {
            once: true
          }
        );
      }
      e2.preventDefault();
      this.close();
    }
  }
};
/**
 * @license
 * Copyright (c) 2016 - 2025 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
class ContextMenu extends ContextMenuMixin(
  OverlayClassMixin(ControllerMixin(ElementMixin(ThemePropertyMixin(PolymerElement))))
) {
  static get template() {
    return html`
      <style>
        :host {
          display: block;
        }

        :host([hidden]) {
          display: none !important;
        }
      </style>

      <slot id="slot"></slot>
    `;
  }
  static get is() {
    return "vaadin-context-menu";
  }
  /** @protected */
  ready() {
    super.ready();
    processTemplates(this);
  }
  /**
   * @param {DocumentFragment} dom
   * @return {null}
   * @protected
   * @override
   */
  _attachDom(dom) {
    const root2 = this.attachShadow({ mode: "open" });
    root2.appendChild(dom);
    root2.appendChild(this._overlayElement);
    return root2;
  }
  /**
   * Fired when an item is selected when the context menu is populated using the `items` API.
   *
   * @event item-selected
   * @param {Object} detail
   * @param {Object} detail.value the selected menu item
   */
}
defineCustomElement(ContextMenu);
function getContainer(appId, nodeId) {
  try {
    return window.Vaadin.Flow.clients[appId].getByNodeId(nodeId);
  } catch (error) {
    console.error("Could not get node %s from app %s", nodeId, appId);
    console.error(error);
  }
}
function initLazy$1(contextMenu, appId) {
  if (contextMenu.$connector) {
    return;
  }
  contextMenu.$connector = {
    /**
     * Generates and assigns the items to the context menu.
     *
     * @param {number} nodeId
     */
    generateItems(nodeId) {
      const items = generateItemsTree(appId, nodeId);
      contextMenu.items = items;
    }
  };
}
function generateItemsTree(appId, nodeId) {
  const container = getContainer(appId, nodeId);
  if (!container) {
    return;
  }
  return Array.from(container.children).map((child) => {
    const item2 = {
      component: child,
      checked: child._checked,
      keepOpen: child._keepOpen,
      className: child.className,
      theme: child.__theme
    };
    if (child._hasVaadinItemMixin && child._containerNodeId) {
      item2.children = generateItemsTree(appId, child._containerNodeId);
    }
    child._item = item2;
    return item2;
  });
}
function setChecked(component, checked) {
  if (component._item) {
    component._item.checked = checked;
    if (component._item.keepOpen) {
      component.toggleAttribute("menu-item-checked", checked);
    }
  }
}
function setKeepOpen(component, keepOpen) {
  if (component._item) {
    component._item.keepOpen = keepOpen;
  }
}
function setTheme(component, theme) {
  if (component._item) {
    component._item.theme = theme;
  }
}
window.Vaadin.Flow.contextMenuConnector = {
  initLazy: initLazy$1,
  generateItemsTree,
  setChecked,
  setKeepOpen,
  setTheme
};
function init(target) {
  if (target.$contextMenuTargetConnector) {
    return;
  }
  target.$contextMenuTargetConnector = {
    openOnHandler(e2) {
      if (target.preventContextMenu && target.preventContextMenu(e2)) {
        return;
      }
      e2.preventDefault();
      e2.stopPropagation();
      this.$contextMenuTargetConnector.openEvent = e2;
      let detail = {};
      if (target.getContextMenuBeforeOpenDetail) {
        detail = target.getContextMenuBeforeOpenDetail(e2);
      }
      target.dispatchEvent(
        new CustomEvent("vaadin-context-menu-before-open", {
          detail
        })
      );
    },
    updateOpenOn(eventType) {
      this.removeListener();
      this.openOnEventType = eventType;
      customElements.whenDefined("vaadin-context-menu").then(() => {
        if (gestures[eventType]) {
          addListener(target, eventType, this.openOnHandler);
        } else {
          target.addEventListener(eventType, this.openOnHandler);
        }
      });
    },
    removeListener() {
      if (this.openOnEventType) {
        if (gestures[this.openOnEventType]) {
          removeListener(target, this.openOnEventType, this.openOnHandler);
        } else {
          target.removeEventListener(this.openOnEventType, this.openOnHandler);
        }
      }
    },
    openMenu(contextMenu) {
      contextMenu.open(this.openEvent);
    },
    removeConnector() {
      this.removeListener();
      target.$contextMenuTargetConnector = void 0;
    }
  };
}
window.Vaadin.Flow.contextMenuTargetConnector = { init };
/**
 * @license
 * Copyright (c) 2019 - 2025 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const customField = css`
  :host {
    --lumo-text-field-size: var(--lumo-size-m);
    color: var(--lumo-body-text-color);
    font-size: var(--lumo-font-size-m);
    /* align with text-field height + vertical paddings */
    line-height: calc(var(--lumo-text-field-size) + 2 * var(--lumo-space-xs));
    font-family: var(--lumo-font-family);
    -webkit-font-smoothing: antialiased;
    -moz-osx-font-smoothing: grayscale;
    -webkit-tap-highlight-color: transparent;
    padding: 0;
  }

  :host::before {
    margin-top: var(--lumo-space-xs);
    height: var(--lumo-text-field-size);
    box-sizing: border-box;
    display: inline-flex;
    align-items: center;
  }

  /* align with text-field label */
  :host([has-label]) [part='label'] {
    padding-bottom: calc(0.5em - var(--lumo-space-xs));
  }

  :host(:not([has-label])) [part='label'],
  :host(:not([has-label]))::before {
    display: none;
  }

  /* align with text-field error message */
  :host([has-error-message]) [part='error-message']::before {
    height: calc(0.4em - var(--lumo-space-xs));
  }

  :host([focused]:not([readonly]):not([disabled])) [part='label'] {
    color: var(--lumo-primary-text-color);
  }

  :host(:hover:not([readonly]):not([disabled]):not([focused])) [part='label'],
  :host(:hover:not([readonly]):not([disabled]):not([focused])) [part='helper-text'] {
    color: var(--lumo-body-text-color);
  }

  /* Touch device adjustment */
  @media (pointer: coarse) {
    :host(:hover:not([readonly]):not([disabled]):not([focused])) [part='label'] {
      color: var(--lumo-secondary-text-color);
    }
  }

  /* Disabled */
  :host([disabled]) [part='label'] {
    color: var(--lumo-disabled-text-color);
    -webkit-text-fill-color: var(--lumo-disabled-text-color);
  }

  /* Small theme */
  :host([theme~='small']) {
    font-size: var(--lumo-font-size-s);
    --lumo-text-field-size: var(--lumo-size-s);
  }

  :host([theme~='small'][has-label]) [part='label'] {
    font-size: var(--lumo-font-size-xs);
  }

  :host([theme~='small'][has-label]) [part='error-message'] {
    font-size: var(--lumo-font-size-xxs);
  }

  /* When custom-field is used with components without outer margin */
  :host([theme~='whitespace'][has-label]) [part='label'] {
    padding-bottom: 0.5em;
  }
`;
registerStyles$1("vaadin-custom-field", [requiredField, helper, customField], {
  moduleId: "lumo-custom-field"
});
/**
 * @license
 * Copyright (c) 2019 - 2025 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const defaultParseValue = (value) => {
  return value.split("	");
};
const defaultFormatValue = (inputValues) => {
  return inputValues.join("	");
};
const CustomFieldMixin = (superClass) => class CustomFieldMixin extends FieldMixin(FocusMixin(KeyboardMixin(superClass))) {
  static get properties() {
    return {
      /**
       * The name of the control, which is submitted with the form data.
       */
      name: String,
      /**
       * The value of the field. When wrapping several inputs, it will contain `\t`
       * (Tab character) as a delimiter indicating parts intended to be used as the
       * corresponding inputs values.
       * Use the [`formatValue`](#/elements/vaadin-custom-field#property-formatValue)
       * and [`parseValue`](#/elements/vaadin-custom-field#property-parseValue)
       * properties to customize this behavior.
       */
      value: {
        type: String,
        observer: "__valueChanged",
        notify: true,
        sync: true
      },
      /**
       * Array of available input nodes
       * @type {!Array<!HTMLElement> | undefined}
       */
      inputs: {
        type: Array,
        readOnly: true,
        observer: "__inputsChanged"
      },
      /**
       * A function to format the values of the individual fields contained by
       * the custom field into a single component value. The function receives
       * an array of all values of the individual fields in the order of their
       * presence in the DOM, and must return a single component value.
       * This function is called each time a value of an internal field is
       * changed.
       *
       * Example:
       * ```js
       * customField.formatValue = (fieldValues) => {
       *   return fieldValues.join("-");
       * }
       * ```
       * @type {!CustomFieldFormatValueFn | undefined}
       */
      formatValue: {
        type: Function
      },
      /**
       * A function to parse the component value into values for the individual
       * fields contained by the custom field. The function receives the
       * component value, and must return an array of values for the individual
       * fields in the order of their presence in the DOM.
       * The function is called each time the value of the component changes.
       *
       * Example:
       * ```js
       * customField.parseValue = (componentValue) => {
       *   return componentValue.split("-");
       * }
       * ```
       * @type {!CustomFieldParseValueFn | undefined}
       */
      parseValue: {
        type: Function
      }
    };
  }
  /** @protected */
  ready() {
    super.ready();
    this.setAttribute("role", "group");
    this.ariaTarget = this;
    this.__childrenObserver = new MutationObserver(() => {
      this.__setInputsFromSlot();
    });
    this.__setInputsFromSlot();
    this.$.slot.addEventListener("slotchange", () => {
      this.__setInputsFromSlot();
      getFlattenedElements(this.$.slot).filter((el) => !this.__isInput(el)).forEach((el) => {
        this.__childrenObserver.observe(el, { childList: true });
      });
    });
    this._tooltipController = new TooltipController(this);
    this.addController(this._tooltipController);
    this._tooltipController.setShouldShow((target) => {
      const inputs = target.inputs || [];
      return !inputs.some((el) => el.opened);
    });
  }
  /** @protected */
  focus() {
    if (this.inputs && this.inputs[0]) {
      this.inputs[0].focus();
    }
  }
  /**
   * Override method inherited from `FocusMixin` to validate on blur.
   * @param {boolean} focused
   * @protected
   */
  _setFocused(focused) {
    super._setFocused(focused);
    if (!focused) {
      this._requestValidation();
    }
  }
  /**
   * Override method inherited from `FocusMixin` to not remove focused
   * state when focus moves to another input in the custom field.
   * @param {FocusEvent} event
   * @return {boolean}
   * @protected
   */
  _shouldRemoveFocus(event) {
    const { relatedTarget } = event;
    return !this.inputs || !this.inputs.some((el) => relatedTarget === (el.focusElement || el));
  }
  /**
   * Returns true if the current inputs values satisfy all constraints (if any).
   *
   * @return {boolean}
   */
  checkValidity() {
    const hasInvalidFields = this.inputs && this.inputs.some((input) => !(input.validate || input.checkValidity).call(input));
    if (hasInvalidFields || this.required && !(this.value && this.value.trim())) {
      return false;
    }
    return true;
  }
  /**
   * Override an observer from `FieldMixin`
   * to validate when required is removed.
   *
   * @protected
   * @override
   */
  _requiredChanged(required) {
    super._requiredChanged(required);
    if (required === false) {
      this._requestValidation();
    }
  }
  /**
   * @param {KeyboardEvent} e
   * @protected
   * @override
   */
  _onKeyDown(e2) {
    if (e2.key === "Tab") {
      const inputs = this.inputs || [];
      if (inputs.indexOf(e2.target) < inputs.length - 1 && !e2.shiftKey || inputs.indexOf(e2.target) > 0 && e2.shiftKey) {
        this.dispatchEvent(new CustomEvent("internal-tab"));
      } else {
        this.__setValue();
      }
    }
  }
  /** @protected */
  _onInputChange(event) {
    event.stopPropagation();
    this.__setValue();
    this._requestValidation();
    this.dispatchEvent(
      new CustomEvent("change", {
        bubbles: true,
        cancelable: false,
        detail: {
          value: this.value
        }
      })
    );
  }
  /** @private */
  __setValue() {
    this.__settingValue = true;
    const formatFn = this.formatValue || defaultFormatValue;
    this.value = formatFn.apply(this, [this.inputs.map((input) => input.value)]);
    this.__settingValue = false;
  }
  /** @private */
  __isInput(node) {
    const isSlottedInput = node.getAttribute("slot") === "input" || node.getAttribute("slot") === "textarea";
    return !isSlottedInput && (node.validate || node.checkValidity);
  }
  /** @private */
  __getInputsFromSlot() {
    return getFlattenedElements(this.$.slot).filter((node) => this.__isInput(node));
  }
  /** @private */
  __setInputsFromSlot() {
    this._setInputs(this.__getInputsFromSlot());
  }
  /** @private */
  __inputsChanged(inputs, oldInputs) {
    if (inputs.length === 0) {
      if (oldInputs && oldInputs.length > 0) {
        this.__setValue();
      }
      return;
    }
    if (this.value && this.value !== "	" && (!oldInputs || oldInputs.length === 0)) {
      this.__applyInputsValue(this.value);
    } else {
      this.__setValue();
    }
  }
  /** @private */
  __toggleHasValue(value) {
    this.toggleAttribute("has-value", value !== null && value.trim() !== "");
  }
  /** @private */
  __valueChanged(value, oldValue) {
    this.__toggleHasValue(value);
    if (this.__settingValue || !this.inputs) {
      return;
    }
    this.__applyInputsValue(value || "	");
    if (oldValue !== void 0) {
      this._requestValidation();
    }
  }
  /** @private */
  __applyInputsValue(value) {
    const parseFn = this.parseValue || defaultParseValue;
    const valuesArray = parseFn.apply(this, [value]);
    if (!valuesArray || valuesArray.length === 0) {
      console.warn("Value parser has not provided values array");
      return;
    }
    this.inputs.forEach((input, idx) => {
      input.value = valuesArray[idx];
    });
  }
};
/**
 * @license
 * Copyright (c) 2019 - 2025 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const customFieldStyles = css`
  :host {
    display: inline-flex;
  }

  :host::before {
    content: '\\2003';
    width: 0;
    display: inline-block;
    /* Size and position this element on the same vertical position as the input-field element
           to make vertical align for the host element work as expected */
  }

  :host([hidden]) {
    display: none !important;
  }

  .vaadin-custom-field-container {
    width: 100%;
    display: flex;
    flex-direction: column;
  }

  .inputs-wrapper {
    flex: none;
  }
`;
/**
 * @license
 * Copyright (c) 2019 - 2025 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
registerStyles$1("vaadin-custom-field", customFieldStyles, { moduleId: "vaadin-custom-field-styles" });
class CustomField extends CustomFieldMixin(ThemableMixin(ElementMixin(PolymerElement))) {
  static get is() {
    return "vaadin-custom-field";
  }
  static get template() {
    return html`
      <div class="vaadin-custom-field-container">
        <div part="label" on-click="focus">
          <slot name="label"></slot>
          <span part="required-indicator" aria-hidden="true"></span>
        </div>

        <div class="inputs-wrapper" part="input-fields" on-change="_onInputChange">
          <slot id="slot"></slot>
        </div>

        <div part="helper-text">
          <slot name="helper"></slot>
        </div>

        <div part="error-message">
          <slot name="error-message"></slot>
        </div>
      </div>

      <slot name="tooltip"></slot>
    `;
  }
  /**
   * Fired when the user commits a value change for any of the internal inputs.
   *
   * @event change
   */
}
defineCustomElement(CustomField);
const datePickerOverlay = css`
  [part='overlay'] {
    /*
  Width:
      date cell widths
    + month calendar side padding
    + year scroller width
  */
    /* prettier-ignore */
    width:
    calc(
        var(--lumo-size-m) * 7
      + var(--lumo-space-xs) * 2
      + 57px
    );
    height: 100%;
    max-height: calc(var(--lumo-size-m) * 14);
    overflow: hidden;
    -webkit-tap-highlight-color: transparent;
    flex-direction: column;
  }

  [part='content'] {
    padding: 0;
    height: 100%;
    overflow: hidden;
    -webkit-mask-image: none;
    mask-image: none;
  }

  :host([top-aligned]) [part~='overlay'] {
    margin-top: var(--lumo-space-xs);
  }

  :host([bottom-aligned]) [part~='overlay'] {
    margin-bottom: var(--lumo-space-xs);
  }

  @media (max-width: 450px), (max-height: 450px) {
    [part='overlay'] {
      width: 100vw;
      height: 70vh;
      max-height: 70vh;
    }
  }
`;
registerStyles$1("vaadin-date-picker-overlay", [menuOverlay, datePickerOverlay], {
  moduleId: "lumo-date-picker-overlay"
});
registerStyles$1(
  "vaadin-date-picker-year",
  css`
    :host([current]) [part='year-number'] {
      color: var(--lumo-primary-text-color);
    }

    :host(:not([current])) [part='year-number'],
    [part='year-separator'] {
      opacity: var(--_lumo-date-picker-year-opacity, 0.7);
      transition: 0.2s opacity;
    }

    [part='year-number'],
    [part='year-separator'] {
      display: flex;
      align-items: center;
      justify-content: center;
      height: 50%;
      transform: translateY(-50%);
    }

    [part='year-separator']::after {
      color: var(--lumo-disabled-text-color);
      content: '\\2022';
    }
  `,
  { moduleId: "lumo-date-picker-year" }
);
registerStyles$1(
  "vaadin-date-picker-overlay-content",
  css`
    :host {
      position: relative;
      /* Background for the year scroller, placed here as we are using a mask image on the actual years part */
      background-image: linear-gradient(var(--lumo-shade-5pct), var(--lumo-shade-5pct));
      background-size: 57px 100%;
      background-position: top right;
      background-repeat: no-repeat;
      cursor: default;
    }

    ::slotted([slot='months']) {
      /* Month calendar height:
              header height + margin-bottom
            + weekdays height + margin-bottom
            + date cell heights
            + small margin between month calendars
        */
      /* prettier-ignore */
      --vaadin-infinite-scroller-item-height:
          calc(
              var(--lumo-font-size-l) + var(--lumo-space-m)
            + var(--lumo-font-size-xs) + var(--lumo-space-s)
            + var(--lumo-size-m) * 6
            + var(--lumo-space-s)
          );
      --vaadin-infinite-scroller-buffer-offset: 10%;
      -webkit-mask-image: linear-gradient(transparent, #000 10%, #000 85%, transparent);
      mask-image: linear-gradient(transparent, #000 10%, #000 85%, transparent);
      position: relative;
      margin-right: 57px;
    }

    ::slotted([slot='years']) {
      /* TODO get rid of fixed magic number */
      --vaadin-infinite-scroller-buffer-width: 97px;
      width: 57px;
      height: auto;
      top: 0;
      bottom: 0;
      font-size: var(--lumo-font-size-s);
      box-shadow: inset 2px 0 4px 0 var(--lumo-shade-5pct);
      -webkit-mask-image: linear-gradient(transparent, #000 35%, #000 65%, transparent);
      mask-image: linear-gradient(transparent, #000 35%, #000 65%, transparent);
      cursor: var(--lumo-clickable-cursor);
    }

    ::slotted([slot='years']:hover) {
      --_lumo-date-picker-year-opacity: 1;
    }

    /* TODO unsupported selector */
    #scrollers {
      position: static;
      display: block;
    }

    /* TODO fix this in vaadin-date-picker that it adapts to the width of the year scroller */
    :host([desktop]) ::slotted([slot='months']) {
      right: auto;
    }

    /* Year scroller position indicator */
    ::slotted([slot='years'])::before {
      border: none;
      width: 1em;
      height: 1em;
      background-color: var(--lumo-base-color);
      background-image: linear-gradient(var(--lumo-tint-5pct), var(--lumo-tint-5pct));
      transform: translate(-75%, -50%) rotate(45deg);
      border-top-right-radius: var(--lumo-border-radius-s);
      box-shadow: 2px -2px 6px 0 var(--lumo-shade-5pct);
      z-index: 1;
    }

    [part='toolbar'] {
      padding: var(--lumo-space-s);
      border-bottom-left-radius: var(--lumo-border-radius-l);
      margin-right: 57px;
    }

    [part='toolbar'] ::slotted(vaadin-button) {
      margin: 0;
    }

    /* Narrow viewport mode (fullscreen) */

    :host([fullscreen]) [part='toolbar'] {
      order: -1;
      background-color: var(--lumo-base-color);
    }

    :host([fullscreen]) [part='overlay-header'] {
      order: -2;
      height: var(--lumo-size-m);
      padding: var(--lumo-space-s);
      position: absolute;
      left: 0;
      right: 0;
      justify-content: center;
    }

    :host([fullscreen]) [part='toggle-button'],
    :host([fullscreen]) [part='clear-button'],
    [part='overlay-header'] [part='label'] {
      display: none;
    }

    /* Very narrow screen (year scroller initially hidden) */

    [part='years-toggle-button'] {
      display: flex;
      align-items: center;
      height: var(--lumo-size-s);
      padding: 0 0.5em;
      border-radius: var(--lumo-border-radius-m);
      z-index: 3;
      color: var(--lumo-primary-text-color);
      font-weight: 500;
      -webkit-font-smoothing: antialiased;
      -moz-osx-font-smoothing: grayscale;
    }

    :host([years-visible]) [part='years-toggle-button'] {
      background-color: var(--lumo-primary-color);
      color: var(--lumo-primary-contrast-color);
    }

    /* TODO magic number (same as used for media-query in vaadin-date-picker-overlay-content) */
    @media screen and (max-width: 374px) {
      :host {
        background-image: none;
      }

      [part='toolbar'],
      ::slotted([slot='months']) {
        margin-right: 0;
      }

      /* TODO make date-picker adapt to the width of the years part */
      ::slotted([slot='years']) {
        --vaadin-infinite-scroller-buffer-width: 90px;
        width: 50px;
        background-color: var(--lumo-shade-5pct);
      }

      :host([years-visible]) ::slotted([slot='months']) {
        padding-left: 50px;
      }
    }
  `,
  { moduleId: "lumo-date-picker-overlay-content" }
);
registerStyles$1(
  "vaadin-month-calendar",
  css`
    :host {
      -webkit-user-select: none;
      -webkit-tap-highlight-color: transparent;
      user-select: none;
      font-size: var(--lumo-font-size-m);
      color: var(--lumo-body-text-color);
      text-align: center;
      padding: 0 var(--lumo-space-xs);
      --_focus-ring-color: var(--vaadin-focus-ring-color, var(--lumo-primary-color-50pct));
      --_focus-ring-width: var(--vaadin-focus-ring-width, 2px);
      --_selection-color: var(--vaadin-selection-color, var(--lumo-primary-color));
      --_selection-color-text: var(--vaadin-selection-color-text, var(--lumo-primary-text-color));
    }

    /* Month header */

    [part='month-header'] {
      color: var(--lumo-header-text-color);
      font-size: var(--lumo-font-size-l);
      line-height: 1;
      font-weight: 500;
      margin-bottom: var(--lumo-space-m);
    }

    /* Week days and numbers */

    [part='weekdays'],
    [part='weekday'],
    [part='week-number'] {
      font-size: var(--lumo-font-size-xxs);
      line-height: 1;
      color: var(--lumo-secondary-text-color);
    }

    [part='weekdays'] {
      margin-bottom: var(--lumo-space-s);
    }

    [part='weekday']:empty,
    [part='week-number'] {
      width: var(--lumo-size-xs);
    }

    /* Date and week number cells */

    [part~='date'],
    [part='week-number'] {
      box-sizing: border-box;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      height: var(--lumo-size-m);
      position: relative;
    }

    [part~='date'] {
      transition: color 0.1s;
    }

    [part~='date']:not(:empty) {
      cursor: var(--lumo-clickable-cursor);
    }

    :host([week-numbers]) [part='weekday']:not(:empty),
    :host([week-numbers]) [part~='date'] {
      width: calc((100% - var(--lumo-size-xs)) / 7);
    }

    /* Today date */

    [part~='date'][part~='today'] {
      color: var(--_selection-color-text);
    }

    /* Focused date */

    [part~='date']::before {
      content: '';
      position: absolute;
      z-index: -1;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      min-width: 2em;
      min-height: 2em;
      width: 80%;
      height: 80%;
      max-height: 100%;
      max-width: 100%;
      border-radius: var(--lumo-border-radius-m);
    }

    [part~='date'][part~='focused']::before {
      box-shadow:
        0 0 0 1px var(--lumo-base-color),
        0 0 0 calc(var(--_focus-ring-width) + 1px) var(--_focus-ring-color);
    }

    :host(:not([focused])) [part~='date'][part~='focused']::before {
      animation: vaadin-date-picker-month-calendar-focus-date 1.4s infinite;
    }

    @keyframes vaadin-date-picker-month-calendar-focus-date {
      50% {
        box-shadow:
          0 0 0 1px var(--lumo-base-color),
          0 0 0 calc(var(--_focus-ring-width) + 1px) transparent;
      }
    }

    [part~='date']:not(:empty):not([part~='disabled']):not([part~='selected']):hover::before {
      background-color: var(--lumo-primary-color-10pct);
    }

    [part~='date'][part~='selected'] {
      color: var(--lumo-primary-contrast-color);
    }

    [part~='date'][part~='selected']::before {
      background-color: var(--_selection-color);
    }

    [part~='date'][part~='disabled'] {
      color: var(--lumo-disabled-text-color);
    }

    @media (pointer: coarse) {
      [part~='date']:hover:not([part~='selected'])::before,
      :host(:not([focus-ring])) [part~='focused']:not([part~='selected'])::before {
        display: none;
      }

      [part~='date']:not(:empty):not([part~='disabled']):active::before {
        display: block;
      }

      :host(:not([focus-ring])) [part~='date'][part~='selected']::before {
        box-shadow: none;
      }
    }
    /* Disabled */

    :host([disabled]) * {
      color: var(--lumo-disabled-text-color) !important;
    }
  `,
  { moduleId: "lumo-month-calendar" }
);
const datePicker = css`
  [part='toggle-button']::before {
    content: var(--lumo-icons-calendar);
  }

  [part='clear-button']::before {
    content: var(--lumo-icons-cross);
  }

  @media (max-width: 450px), (max-height: 450px) {
    [part='overlay-content'] {
      height: 70vh;
    }
  }

  :host([dir='rtl']) [part='input-field'] ::slotted(input) {
    --_lumo-text-field-overflow-mask-image: linear-gradient(to left, transparent, #000 1.25em);
  }

  :host([dir='rtl']) [part='input-field'] ::slotted(input:placeholder-shown) {
    --_lumo-text-field-overflow-mask-image: none;
  }
`;
registerStyles$1("vaadin-date-picker", [inputFieldShared$1, datePicker], { moduleId: "lumo-date-picker" });
/**
 * @license
 * Copyright (c) 2015 - 2025 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const DatePickerOverlayMixin = (superClass) => class DatePickerOverlayMixin extends PositionMixin(OverlayMixin(superClass)) {
  /**
   * Override method inherited from `OverlayMixin` to not close on input click.
   * Needed to ignore date-picker's own input in the mousedown listener below.
   *
   * @param {Event} event
   * @return {boolean}
   * @protected
   */
  _shouldCloseOnOutsideClick(event) {
    const eventPath = event.composedPath();
    return !eventPath.includes(this.positionTarget);
  }
  /**
   * @protected
   * @override
   */
  _mouseDownListener(event) {
    super._mouseDownListener(event);
    if (this._shouldCloseOnOutsideClick(event) && !isElementFocusable(event.composedPath()[0])) {
      event.preventDefault();
    }
  }
};
/**
 * @license
 * Copyright (c) 2016 - 2025 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const datePickerOverlayStyles = css`
  [part='overlay'] {
    display: flex;
    flex: auto;
  }

  [part~='content'] {
    flex: auto;
  }

  @media (forced-colors: active) {
    [part='overlay'] {
      outline: 3px solid;
    }
  }
`;
/**
 * @license
 * Copyright (c) 2016 - 2025 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
registerStyles$1("vaadin-date-picker-overlay", [overlayStyles, datePickerOverlayStyles], {
  moduleId: "vaadin-date-picker-overlay-styles"
});
class DatePickerOverlay extends DatePickerOverlayMixin(DirMixin(ThemableMixin(PolymerElement))) {
  static get is() {
    return "vaadin-date-picker-overlay";
  }
  static get template() {
    return html`
      <div id="backdrop" part="backdrop" hidden$="[[!withBackdrop]]"></div>
      <div part="overlay" id="overlay">
        <div part="content" id="content">
          <slot></slot>
        </div>
      </div>
    `;
  }
}
defineCustomElement(DatePickerOverlay);
/**
 * @license
 * Copyright (c) 2016 - 2025 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
function getISOWeekNumber(date) {
  let dayOfWeek = date.getDay();
  if (dayOfWeek === 0) {
    dayOfWeek = 7;
  }
  const nearestThursdayDiff = 4 - dayOfWeek;
  const nearestThursday = new Date(date.getTime() + nearestThursdayDiff * 24 * 3600 * 1e3);
  const firstOfJanuary = new Date(0, 0);
  firstOfJanuary.setFullYear(nearestThursday.getFullYear());
  const timeDiff = nearestThursday.getTime() - firstOfJanuary.getTime();
  const daysSinceFirstOfJanuary = Math.round(timeDiff / (24 * 3600 * 1e3));
  return Math.floor(daysSinceFirstOfJanuary / 7 + 1);
}
function normalizeDate(date) {
  const normalizedDate = new Date(date);
  normalizedDate.setHours(0, 0, 0, 0);
  return normalizedDate;
}
function normalizeUTCDate(date) {
  return new Date(Date.UTC(date.getUTCFullYear(), date.getUTCMonth(), date.getUTCDate(), 0, 0, 0, 0));
}
function dateEquals(date1, date2, normalizer = normalizeDate) {
  return date1 instanceof Date && date2 instanceof Date && normalizer(date1).getTime() === normalizer(date2).getTime();
}
function extractDateParts(date) {
  return {
    day: date.getDate(),
    month: date.getMonth(),
    year: date.getFullYear()
  };
}
function dateAllowed(date, min, max, isDateDisabled) {
  let dateIsDisabled = false;
  if (typeof isDateDisabled === "function" && !!date) {
    const dateToCheck = extractDateParts(date);
    dateIsDisabled = isDateDisabled(dateToCheck);
  }
  return (!min || date >= min) && (!max || date <= max) && !dateIsDisabled;
}
function getClosestDate(date, dates) {
  return dates.filter((date2) => date2 !== void 0).reduce((closestDate, candidate) => {
    if (!candidate) {
      return closestDate;
    }
    if (!closestDate) {
      return candidate;
    }
    const candidateDiff = Math.abs(date.getTime() - candidate.getTime());
    const closestDateDiff = Math.abs(closestDate.getTime() - date.getTime());
    return candidateDiff < closestDateDiff ? candidate : closestDate;
  });
}
function dateAfterXMonths(months) {
  const today = /* @__PURE__ */ new Date();
  const result = new Date(today);
  result.setDate(1);
  result.setMonth(parseInt(months) + today.getMonth());
  return result;
}
function getAdjustedYear(referenceDate, year, month = 0, day = 1) {
  if (year > 99) {
    throw new Error("The provided year cannot have more than 2 digits.");
  }
  if (year < 0) {
    throw new Error("The provided year cannot be negative.");
  }
  let adjustedYear = year + Math.floor(referenceDate.getFullYear() / 100) * 100;
  if (referenceDate < new Date(adjustedYear - 50, month, day)) {
    adjustedYear -= 100;
  } else if (referenceDate > new Date(adjustedYear + 50, month, day)) {
    adjustedYear += 100;
  }
  return adjustedYear;
}
function parseDate(str) {
  const parts = /^([-+]\d{1}|\d{2,4}|[-+]\d{6})-(\d{1,2})-(\d{1,2})$/u.exec(str);
  if (!parts) {
    return void 0;
  }
  const date = new Date(0, 0);
  date.setFullYear(parseInt(parts[1], 10));
  date.setMonth(parseInt(parts[2], 10) - 1);
  date.setDate(parseInt(parts[3], 10));
  return date;
}
function parseUTCDate(str) {
  const parts = /^([-+]\d{1}|\d{2,4}|[-+]\d{6})-(\d{1,2})-(\d{1,2})$/u.exec(str);
  if (!parts) {
    return void 0;
  }
  const date = new Date(Date.UTC(0, 0));
  date.setUTCFullYear(parseInt(parts[1], 10));
  date.setUTCMonth(parseInt(parts[2], 10) - 1);
  date.setUTCDate(parseInt(parts[3], 10));
  return date;
}
function formatISODateBase(dateParts) {
  const pad = (num, fmt = "00") => (fmt + num).substr((fmt + num).length - fmt.length);
  let yearSign = "";
  let yearFmt = "0000";
  let yearAbs = dateParts.year;
  if (yearAbs < 0) {
    yearAbs = -yearAbs;
    yearSign = "-";
    yearFmt = "000000";
  } else if (dateParts.year >= 1e4) {
    yearSign = "+";
    yearFmt = "000000";
  }
  const year = yearSign + pad(yearAbs, yearFmt);
  const month = pad(dateParts.month + 1);
  const day = pad(dateParts.day);
  return [year, month, day].join("-");
}
function formatISODate(date) {
  if (!(date instanceof Date)) {
    return "";
  }
  return formatISODateBase({
    year: date.getFullYear(),
    month: date.getMonth(),
    day: date.getDate()
  });
}
function formatUTCISODate(date) {
  if (!(date instanceof Date)) {
    return "";
  }
  return formatISODateBase({
    year: date.getUTCFullYear(),
    month: date.getUTCMonth(),
    day: date.getUTCDate()
  });
}
/**
 * @license
 * Copyright (c) 2016 - 2025 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const template$5 = document.createElement("template");
template$5.innerHTML = `
  <style>
    :host {
      display: block;
      overflow: hidden;
      height: 500px;
    }

    #scroller {
      position: relative;
      height: 100%;
      overflow: auto;
      outline: none;
      margin-right: -40px;
      -webkit-overflow-scrolling: touch;
      overflow-x: hidden;
    }

    #scroller.notouchscroll {
      -webkit-overflow-scrolling: auto;
    }

    #scroller::-webkit-scrollbar {
      display: none;
    }

    .buffer {
      position: absolute;
      width: var(--vaadin-infinite-scroller-buffer-width, 100%);
      box-sizing: border-box;
      padding-right: 40px;
      top: var(--vaadin-infinite-scroller-buffer-offset, 0);
      animation: fadein 0.2s;
    }

    @keyframes fadein {
      from {
        opacity: 0;
      }
      to {
        opacity: 1;
      }
    }
  </style>

  <div id="scroller" tabindex="-1">
    <div class="buffer"></div>
    <div class="buffer"></div>
    <div id="fullHeight"></div>
  </div>
`;
class InfiniteScroller extends HTMLElement {
  constructor() {
    super();
    const root2 = this.attachShadow({ mode: "open" });
    root2.appendChild(template$5.content.cloneNode(true));
    this.bufferSize = 20;
    this._initialScroll = 5e5;
    this._initialIndex = 0;
    this._activated = false;
  }
  /**
   * @return {boolean}
   */
  get active() {
    return this._activated;
  }
  set active(active) {
    if (active && !this._activated) {
      this._createPool();
      this._activated = true;
    }
  }
  /**
   * @return {number}
   */
  get bufferOffset() {
    return this._buffers[0].offsetTop;
  }
  /**
   * @return {number}
   */
  get itemHeight() {
    if (!this._itemHeightVal) {
      const itemHeight = getComputedStyle(this).getPropertyValue("--vaadin-infinite-scroller-item-height");
      const tmpStyleProp = "background-position";
      this.$.fullHeight.style.setProperty(tmpStyleProp, itemHeight);
      const itemHeightPx = getComputedStyle(this.$.fullHeight).getPropertyValue(tmpStyleProp);
      this.$.fullHeight.style.removeProperty(tmpStyleProp);
      this._itemHeightVal = parseFloat(itemHeightPx);
    }
    return this._itemHeightVal;
  }
  /** @private */
  get _bufferHeight() {
    return this.itemHeight * this.bufferSize;
  }
  /**
   * @return {number}
   */
  get position() {
    return (this.$.scroller.scrollTop - this._buffers[0].translateY) / this.itemHeight + this._firstIndex;
  }
  /**
   * Current scroller position as index. Can be a fractional number.
   *
   * @type {number}
   */
  set position(index) {
    this._preventScrollEvent = true;
    if (index > this._firstIndex && index < this._firstIndex + this.bufferSize * 2) {
      this.$.scroller.scrollTop = this.itemHeight * (index - this._firstIndex) + this._buffers[0].translateY;
    } else {
      this._initialIndex = ~~index;
      this._reset();
      this._scrollDisabled = true;
      this.$.scroller.scrollTop += index % 1 * this.itemHeight;
      this._scrollDisabled = false;
    }
    if (this._mayHaveMomentum) {
      this.$.scroller.classList.add("notouchscroll");
      this._mayHaveMomentum = false;
      setTimeout(() => {
        this.$.scroller.classList.remove("notouchscroll");
      }, 10);
    }
  }
  /** @protected */
  connectedCallback() {
    if (!this._ready) {
      this._ready = true;
      this.$ = {};
      this.shadowRoot.querySelectorAll("[id]").forEach((node) => {
        this.$[node.id] = node;
      });
      this.$.scroller.addEventListener("scroll", () => this._scroll());
      this._buffers = [...this.shadowRoot.querySelectorAll(".buffer")];
      this.$.fullHeight.style.height = `${this._initialScroll * 2}px`;
    }
  }
  /** @protected */
  disconnectedCallback() {
    if (this._debouncerScrollFinish) {
      this._debouncerScrollFinish.cancel();
    }
    if (this._debouncerUpdateClones) {
      this._debouncerUpdateClones.cancel();
    }
    if (this.__pendingFinishInit) {
      cancelAnimationFrame(this.__pendingFinishInit);
    }
  }
  /**
   * Force the scroller to update clones after a reset, without
   * waiting for the debouncer to resolve.
   */
  forceUpdate() {
    if (this._debouncerScrollFinish) {
      this._debouncerScrollFinish.flush();
    }
    if (this._debouncerUpdateClones) {
      this._buffers[0].updated = this._buffers[1].updated = false;
      this._updateClones();
      this._debouncerUpdateClones.cancel();
    }
    flush();
  }
  /**
   * @protected
   * @override
   */
  _createElement() {
  }
  /**
   * @param {HTMLElement} _element
   * @param {number} _index
   * @protected
   * @override
   */
  _updateElement(_element, _index) {
  }
  /** @private */
  _finishInit() {
    if (!this._initDone) {
      this._buffers.forEach((buffer) => {
        [...buffer.children].forEach((slot) => {
          this._ensureStampedInstance(slot._itemWrapper);
        });
      });
      if (!this._buffers[0].translateY) {
        this._reset();
      }
      this._initDone = true;
      this.dispatchEvent(new CustomEvent("init-done"));
    }
  }
  /** @private */
  _translateBuffer(up) {
    const index = up ? 1 : 0;
    this._buffers[index].translateY = this._buffers[index ? 0 : 1].translateY + this._bufferHeight * (index ? -1 : 1);
    this._buffers[index].style.transform = `translate3d(0, ${this._buffers[index].translateY}px, 0)`;
    this._buffers[index].updated = false;
    this._buffers.reverse();
  }
  /** @private */
  _scroll() {
    if (this._scrollDisabled) {
      return;
    }
    const scrollTop = this.$.scroller.scrollTop;
    if (scrollTop < this._bufferHeight || scrollTop > this._initialScroll * 2 - this._bufferHeight) {
      this._initialIndex = ~~this.position;
      this._reset();
    }
    const offset = this.itemHeight + this.bufferOffset;
    const upperThresholdReached = scrollTop > this._buffers[1].translateY + offset;
    const lowerThresholdReached = scrollTop < this._buffers[0].translateY + offset;
    if (upperThresholdReached || lowerThresholdReached) {
      this._translateBuffer(lowerThresholdReached);
      this._updateClones();
    }
    if (!this._preventScrollEvent) {
      this.dispatchEvent(new CustomEvent("custom-scroll", { bubbles: false, composed: true }));
      this._mayHaveMomentum = true;
    }
    this._preventScrollEvent = false;
    this._debouncerScrollFinish = Debouncer$1.debounce(this._debouncerScrollFinish, timeOut$1.after(200), () => {
      const scrollerRect = this.$.scroller.getBoundingClientRect();
      if (!this._isVisible(this._buffers[0], scrollerRect) && !this._isVisible(this._buffers[1], scrollerRect)) {
        this.position = this.position;
      }
    });
  }
  /** @private */
  _reset() {
    this._scrollDisabled = true;
    this.$.scroller.scrollTop = this._initialScroll;
    this._buffers[0].translateY = this._initialScroll - this._bufferHeight;
    this._buffers[1].translateY = this._initialScroll;
    this._buffers.forEach((buffer) => {
      buffer.style.transform = `translate3d(0, ${buffer.translateY}px, 0)`;
    });
    this._buffers[0].updated = this._buffers[1].updated = false;
    this._updateClones(true);
    this._debouncerUpdateClones = Debouncer$1.debounce(this._debouncerUpdateClones, timeOut$1.after(200), () => {
      this._buffers[0].updated = this._buffers[1].updated = false;
      this._updateClones();
    });
    this._scrollDisabled = false;
  }
  /** @private */
  _createPool() {
    const container = this.getBoundingClientRect();
    this._buffers.forEach((buffer) => {
      for (let i2 = 0; i2 < this.bufferSize; i2++) {
        const itemWrapper = document.createElement("div");
        itemWrapper.style.height = `${this.itemHeight}px`;
        itemWrapper.instance = {};
        const slotName = `vaadin-infinite-scroller-item-content-${generateUniqueId()}`;
        const slot = document.createElement("slot");
        slot.setAttribute("name", slotName);
        slot._itemWrapper = itemWrapper;
        buffer.appendChild(slot);
        itemWrapper.setAttribute("slot", slotName);
        this.appendChild(itemWrapper);
        if (this._isVisible(itemWrapper, container)) {
          this._ensureStampedInstance(itemWrapper);
        }
      }
    });
    this.__pendingFinishInit = requestAnimationFrame(() => {
      this._finishInit();
      this.__pendingFinishInit = null;
    });
  }
  /** @private */
  _ensureStampedInstance(itemWrapper) {
    if (itemWrapper.firstElementChild) {
      return;
    }
    const tmpInstance = itemWrapper.instance;
    itemWrapper.instance = this._createElement();
    itemWrapper.appendChild(itemWrapper.instance);
    Object.keys(tmpInstance).forEach((prop) => {
      itemWrapper.instance[prop] = tmpInstance[prop];
    });
  }
  /** @private */
  _updateClones(viewPortOnly) {
    this._firstIndex = Math.round((this._buffers[0].translateY - this._initialScroll) / this.itemHeight) + this._initialIndex;
    const scrollerRect = viewPortOnly ? this.$.scroller.getBoundingClientRect() : void 0;
    this._buffers.forEach((buffer, bufferIndex) => {
      if (!buffer.updated) {
        const firstIndex = this._firstIndex + this.bufferSize * bufferIndex;
        [...buffer.children].forEach((slot, index) => {
          const itemWrapper = slot._itemWrapper;
          if (!viewPortOnly || this._isVisible(itemWrapper, scrollerRect)) {
            this._updateElement(itemWrapper.instance, firstIndex + index);
          }
        });
        buffer.updated = true;
      }
    });
  }
  /** @private */
  _isVisible(element, container) {
    const rect = element.getBoundingClientRect();
    return rect.bottom > container.top && rect.top < container.bottom;
  }
}
/**
 * @license
 * Copyright (c) 2016 - 2025 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const stylesTemplate$1 = document.createElement("template");
stylesTemplate$1.innerHTML = `
  <style>
    :host {
      --vaadin-infinite-scroller-item-height: 270px;
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      height: 100%;
    }
  </style>
`;
class DatePickerMonthScroller extends InfiniteScroller {
  static get is() {
    return "vaadin-date-picker-month-scroller";
  }
  constructor() {
    super();
    this.bufferSize = 3;
    this.shadowRoot.appendChild(stylesTemplate$1.content.cloneNode(true));
  }
  /**
   * @protected
   * @override
   */
  _createElement() {
    return document.createElement("vaadin-month-calendar");
  }
  /**
   * @param {HTMLElement} element
   * @param {number} index
   * @protected
   * @override
   */
  _updateElement(element, index) {
    element.month = dateAfterXMonths(index);
  }
}
defineCustomElement(DatePickerMonthScroller);
/**
 * @license
 * Copyright (c) 2016 - 2025 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const stylesTemplate = document.createElement("template");
stylesTemplate.innerHTML = `
  <style>
    :host {
      --vaadin-infinite-scroller-item-height: 80px;
      width: 50px;
      display: block;
      height: 100%;
      position: absolute;
      right: 0;
      transform: translateX(100%);
      -webkit-tap-highlight-color: transparent;
      -webkit-user-select: none;
      user-select: none;
      /* Center the year scroller position. */
      --vaadin-infinite-scroller-buffer-offset: 50%;
    }

    :host::before {
      content: '';
      display: block;
      background: transparent;
      width: 0;
      height: 0;
      position: absolute;
      left: 0;
      top: 50%;
      transform: translateY(-50%);
      border-width: 6px;
      border-style: solid;
      border-color: transparent;
      border-left-color: #000;
    }
  </style>
`;
class DatePickerYearScroller extends InfiniteScroller {
  static get is() {
    return "vaadin-date-picker-year-scroller";
  }
  constructor() {
    super();
    this.bufferSize = 12;
    this.shadowRoot.appendChild(stylesTemplate.content.cloneNode(true));
  }
  /**
   * @protected
   * @override
   */
  _createElement() {
    return document.createElement("vaadin-date-picker-year");
  }
  /**
   * @param {HTMLElement} element
   * @param {number} index
   * @protected
   * @override
   */
  _updateElement(element, index) {
    element.year = this._yearAfterXYears(index);
  }
  /** @private */
  _yearAfterXYears(index) {
    const today = /* @__PURE__ */ new Date();
    const result = new Date(today);
    result.setFullYear(parseInt(index) + today.getFullYear());
    return result.getFullYear();
  }
}
defineCustomElement(DatePickerYearScroller);
/**
 * @license
 * Copyright (c) 2016 - 2025 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const DatePickerYearMixin = (superClass) => class DatePickerYearMixin extends superClass {
  static get properties() {
    return {
      year: {
        type: String,
        sync: true
      },
      selectedDate: {
        type: Object,
        sync: true
      }
    };
  }
  static get observers() {
    return ["__updateSelected(year, selectedDate)"];
  }
  /** @private */
  __updateSelected(year, selectedDate) {
    this.toggleAttribute("selected", selectedDate && selectedDate.getFullYear() === year);
    this.toggleAttribute("current", year === (/* @__PURE__ */ new Date()).getFullYear());
  }
};
/**
 * @license
 * Copyright (c) 2016 - 2025 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
class DatePickerYear extends ThemableMixin(DatePickerYearMixin(PolymerElement)) {
  static get is() {
    return "vaadin-date-picker-year";
  }
  static get template() {
    return html`
      <style>
        :host {
          display: block;
          height: 100%;
        }
      </style>
      <div part="year-number">[[year]]</div>
      <div part="year-separator" aria-hidden="true"></div>
    `;
  }
}
defineCustomElement(DatePickerYear);
/**
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/
const domRepeatBase = OptionalMutableData(PolymerElement);
class DomRepeat extends domRepeatBase {
  // Not needed to find template; can be removed once the analyzer
  // can find the tag name from customElements.define call
  static get is() {
    return "dom-repeat";
  }
  static get template() {
    return null;
  }
  static get properties() {
    return {
      /**
       * An array containing items determining how many instances of the template
       * to stamp and that that each template instance should bind to.
       */
      items: {
        type: Array
      },
      /**
       * The name of the variable to add to the binding scope for the array
       * element associated with a given template instance.
       */
      as: {
        type: String,
        value: "item"
      },
      /**
       * The name of the variable to add to the binding scope with the index
       * of the instance in the sorted and filtered list of rendered items.
       * Note, for the index in the `this.items` array, use the value of the
       * `itemsIndexAs` property.
       */
      indexAs: {
        type: String,
        value: "index"
      },
      /**
       * The name of the variable to add to the binding scope with the index
       * of the instance in the `this.items` array. Note, for the index of
       * this instance in the sorted and filtered list of rendered items,
       * use the value of the `indexAs` property.
       */
      itemsIndexAs: {
        type: String,
        value: "itemsIndex"
      },
      /**
       * A function that should determine the sort order of the items.  This
       * property should either be provided as a string, indicating a method
       * name on the element's host, or else be an actual function.  The
       * function should match the sort function passed to `Array.sort`.
       * Using a sort function has no effect on the underlying `items` array.
       */
      sort: {
        type: Function,
        observer: "__sortChanged"
      },
      /**
       * A function that can be used to filter items out of the view.  This
       * property should either be provided as a string, indicating a method
       * name on the element's host, or else be an actual function.  The
       * function should match the sort function passed to `Array.filter`.
       * Using a filter function has no effect on the underlying `items` array.
       */
      filter: {
        type: Function,
        observer: "__filterChanged"
      },
      /**
       * When using a `filter` or `sort` function, the `observe` property
       * should be set to a space-separated list of the names of item
       * sub-fields that should trigger a re-sort or re-filter when changed.
       * These should generally be fields of `item` that the sort or filter
       * function depends on.
       */
      observe: {
        type: String,
        observer: "__observeChanged"
      },
      /**
       * When using a `filter` or `sort` function, the `delay` property
       * determines a debounce time in ms after a change to observed item
       * properties that must pass before the filter or sort is re-run.
       * This is useful in rate-limiting shuffling of the view when
       * item changes may be frequent.
       */
      delay: Number,
      /**
       * Count of currently rendered items after `filter` (if any) has been applied.
       * If "chunking mode" is enabled, `renderedItemCount` is updated each time a
       * set of template instances is rendered.
       *
       */
      renderedItemCount: {
        type: Number,
        notify: !suppressTemplateNotifications,
        readOnly: true
      },
      /**
       * When greater than zero, defines an initial count of template instances
       * to render after setting the `items` array, before the next paint, and
       * puts the `dom-repeat` into "chunking mode".  The remaining items (and
       * any future items as a result of pushing onto the array) will be created
       * and rendered incrementally at each animation frame thereof until all
       * instances have been rendered.
       */
      initialCount: {
        type: Number
      },
      /**
       * When `initialCount` is used, this property defines a frame rate (in
       * fps) to target by throttling the number of instances rendered each
       * frame to not exceed the budget for the target frame rate.  The
       * framerate is effectively the number of `requestAnimationFrame`s that
       * it tries to allow to actually fire in a given second. It does this
       * by measuring the time between `rAF`s and continuously adjusting the
       * number of items created each `rAF` to maintain the target framerate.
       * Setting this to a higher number allows lower latency and higher
       * throughput for event handlers and other tasks, but results in a
       * longer time for the remaining items to complete rendering.
       */
      targetFramerate: {
        type: Number,
        value: 20
      },
      _targetFrameTime: {
        type: Number,
        computed: "__computeFrameTime(targetFramerate)"
      },
      /**
       * When the global `suppressTemplateNotifications` setting is used, setting
       * `notifyDomChange: true` will enable firing `dom-change` events on this
       * element.
       */
      notifyDomChange: {
        type: Boolean
      },
      /**
       * When chunking is enabled via `initialCount` and the `items` array is
       * set to a new array, this flag controls whether the previously rendered
       * instances are reused or not.
       *
       * When `true`, any previously rendered template instances are updated in
       * place to their new item values synchronously in one shot, and then any
       * further items (if any) are chunked out.  When `false`, the list is
       * returned back to its `initialCount` (any instances over the initial
       * count are discarded) and the remainder of the list is chunked back in.
       * Set this to `true` to avoid re-creating the list and losing scroll
       * position, although note that when changing the list to completely
       * different data the render thread will be blocked until all existing
       * instances are updated to their new data.
       */
      reuseChunkedInstances: {
        type: Boolean
      }
    };
  }
  static get observers() {
    return ["__itemsChanged(items.*)"];
  }
  constructor() {
    super();
    this.__instances = [];
    this.__renderDebouncer = null;
    this.__itemsIdxToInstIdx = {};
    this.__chunkCount = null;
    this.__renderStartTime = null;
    this.__itemsArrayChanged = false;
    this.__shouldMeasureChunk = false;
    this.__shouldContinueChunking = false;
    this.__chunkingId = 0;
    this.__sortFn = null;
    this.__filterFn = null;
    this.__observePaths = null;
    this.__ctor = null;
    this.__isDetached = true;
    this.template = null;
    this._templateInfo;
  }
  /**
   * @override
   * @return {void}
   */
  disconnectedCallback() {
    super.disconnectedCallback();
    this.__isDetached = true;
    for (let i2 = 0; i2 < this.__instances.length; i2++) {
      this.__detachInstance(i2);
    }
    if (this.__chunkingId) {
      cancelAnimationFrame(this.__chunkingId);
    }
  }
  /**
   * @override
   * @return {void}
   */
  connectedCallback() {
    super.connectedCallback();
    if (!hideElementsGlobally()) {
      this.style.display = "none";
    }
    if (this.__isDetached) {
      this.__isDetached = false;
      let wrappedParent = wrap$1(wrap$1(this).parentNode);
      for (let i2 = 0; i2 < this.__instances.length; i2++) {
        this.__attachInstance(i2, wrappedParent);
      }
      if (this.__chunkingId) {
        this.__render();
      }
    }
  }
  __ensureTemplatized() {
    if (!this.__ctor) {
      const thisAsTemplate = (
        /** @type {!HTMLTemplateElement} */
        /** @type {!HTMLElement} */
        this
      );
      let template2 = this.template = thisAsTemplate._templateInfo ? thisAsTemplate : (
        /** @type {!HTMLTemplateElement} */
        this.querySelector("template")
      );
      if (!template2) {
        let observer2 = new MutationObserver(() => {
          if (this.querySelector("template")) {
            observer2.disconnect();
            this.__render();
          } else {
            throw new Error("dom-repeat requires a <template> child");
          }
        });
        observer2.observe(this, { childList: true });
        return false;
      }
      let instanceProps = {};
      instanceProps[this.as] = true;
      instanceProps[this.indexAs] = true;
      instanceProps[this.itemsIndexAs] = true;
      this.__ctor = templatize(template2, this, {
        mutableData: this.mutableData,
        parentModel: true,
        instanceProps,
        /**
         * @this {DomRepeat}
         * @param {string} prop Property to set
         * @param {*} value Value to set property to
         */
        forwardHostProp: function(prop, value) {
          let i$ = this.__instances;
          for (let i2 = 0, inst; i2 < i$.length && (inst = i$[i2]); i2++) {
            inst.forwardHostProp(prop, value);
          }
        },
        /**
         * @this {DomRepeat}
         * @param {Object} inst Instance to notify
         * @param {string} prop Property to notify
         * @param {*} value Value to notify
         */
        notifyInstanceProp: function(inst, prop, value) {
          if (matches(this.as, prop)) {
            let idx = inst[this.itemsIndexAs];
            if (prop == this.as) {
              this.items[idx] = value;
            }
            let path = translate(this.as, `${JSCompiler_renameProperty("items", this)}.${idx}`, prop);
            this.notifyPath(path, value);
          }
        }
      });
    }
    return true;
  }
  __getMethodHost() {
    return this.__dataHost._methodHost || this.__dataHost;
  }
  __functionFromPropertyValue(functionOrMethodName) {
    if (typeof functionOrMethodName === "string") {
      let methodName = functionOrMethodName;
      let obj = this.__getMethodHost();
      return function() {
        return obj[methodName].apply(obj, arguments);
      };
    }
    return functionOrMethodName;
  }
  __sortChanged(sort) {
    this.__sortFn = this.__functionFromPropertyValue(sort);
    if (this.items) {
      this.__debounceRender(this.__render);
    }
  }
  __filterChanged(filter2) {
    this.__filterFn = this.__functionFromPropertyValue(filter2);
    if (this.items) {
      this.__debounceRender(this.__render);
    }
  }
  __computeFrameTime(rate) {
    return Math.ceil(1e3 / rate);
  }
  __observeChanged() {
    this.__observePaths = this.observe && this.observe.replace(".*", ".").split(" ");
  }
  __handleObservedPaths(path) {
    if (this.__sortFn || this.__filterFn) {
      if (!path) {
        this.__debounceRender(this.__render, this.delay);
      } else if (this.__observePaths) {
        let paths = this.__observePaths;
        for (let i2 = 0; i2 < paths.length; i2++) {
          if (path.indexOf(paths[i2]) === 0) {
            this.__debounceRender(this.__render, this.delay);
          }
        }
      }
    }
  }
  __itemsChanged(change) {
    if (this.items && !Array.isArray(this.items)) {
      console.warn("dom-repeat expected array for `items`, found", this.items);
    }
    if (!this.__handleItemPath(change.path, change.value)) {
      if (change.path === "items") {
        this.__itemsArrayChanged = true;
      }
      this.__debounceRender(this.__render);
    }
  }
  /**
   * @param {function(this:DomRepeat)} fn Function to debounce.
   * @param {number=} delay Delay in ms to debounce by.
   */
  __debounceRender(fn, delay = 0) {
    this.__renderDebouncer = Debouncer2.debounce(
      this.__renderDebouncer,
      delay > 0 ? timeOut.after(delay) : microTask,
      fn.bind(this)
    );
    enqueueDebouncer(this.__renderDebouncer);
  }
  /**
   * Forces the element to render its content. Normally rendering is
   * asynchronous to a provoking change. This is done for efficiency so
   * that multiple changes trigger only a single render. The render method
   * should be called if, for example, template rendering is required to
   * validate application state.
   * @return {void}
   */
  render() {
    this.__debounceRender(this.__render);
    flush();
  }
  __render() {
    if (!this.__ensureTemplatized()) {
      return;
    }
    let items = this.items || [];
    const isntIdxToItemsIdx = this.__sortAndFilterItems(items);
    const limit = this.__calculateLimit(isntIdxToItemsIdx.length);
    this.__updateInstances(items, limit, isntIdxToItemsIdx);
    if (this.initialCount && (this.__shouldMeasureChunk || this.__shouldContinueChunking)) {
      cancelAnimationFrame(this.__chunkingId);
      this.__chunkingId = requestAnimationFrame(() => {
        this.__chunkingId = null;
        this.__continueChunking();
      });
    }
    this._setRenderedItemCount(this.__instances.length);
    if (!suppressTemplateNotifications || this.notifyDomChange) {
      this.dispatchEvent(new CustomEvent("dom-change", {
        bubbles: true,
        composed: true
      }));
    }
  }
  __sortAndFilterItems(items) {
    let isntIdxToItemsIdx = new Array(items.length);
    for (let i2 = 0; i2 < items.length; i2++) {
      isntIdxToItemsIdx[i2] = i2;
    }
    if (this.__filterFn) {
      isntIdxToItemsIdx = isntIdxToItemsIdx.filter((i2, idx, array) => this.__filterFn(items[i2], idx, array));
    }
    if (this.__sortFn) {
      isntIdxToItemsIdx.sort((a3, b2) => this.__sortFn(items[a3], items[b2]));
    }
    return isntIdxToItemsIdx;
  }
  __calculateLimit(filteredItemCount) {
    let limit = filteredItemCount;
    const currentCount = this.__instances.length;
    if (this.initialCount) {
      let newCount;
      if (!this.__chunkCount || this.__itemsArrayChanged && !this.reuseChunkedInstances) {
        limit = Math.min(filteredItemCount, this.initialCount);
        newCount = Math.max(limit - currentCount, 0);
        this.__chunkCount = newCount || 1;
      } else {
        newCount = Math.min(
          Math.max(filteredItemCount - currentCount, 0),
          this.__chunkCount
        );
        limit = Math.min(currentCount + newCount, filteredItemCount);
      }
      this.__shouldMeasureChunk = newCount === this.__chunkCount;
      this.__shouldContinueChunking = limit < filteredItemCount;
      this.__renderStartTime = performance.now();
    }
    this.__itemsArrayChanged = false;
    return limit;
  }
  __continueChunking() {
    if (this.__shouldMeasureChunk) {
      const renderTime = performance.now() - this.__renderStartTime;
      const ratio = this._targetFrameTime / renderTime;
      this.__chunkCount = Math.round(this.__chunkCount * ratio) || 1;
    }
    if (this.__shouldContinueChunking) {
      this.__debounceRender(this.__render);
    }
  }
  __updateInstances(items, limit, isntIdxToItemsIdx) {
    const itemsIdxToInstIdx = this.__itemsIdxToInstIdx = {};
    let instIdx;
    for (instIdx = 0; instIdx < limit; instIdx++) {
      let inst = this.__instances[instIdx];
      let itemIdx = isntIdxToItemsIdx[instIdx];
      let item2 = items[itemIdx];
      itemsIdxToInstIdx[itemIdx] = instIdx;
      if (inst) {
        inst._setPendingProperty(this.as, item2);
        inst._setPendingProperty(this.indexAs, instIdx);
        inst._setPendingProperty(this.itemsIndexAs, itemIdx);
        inst._flushProperties();
      } else {
        this.__insertInstance(item2, instIdx, itemIdx);
      }
    }
    for (let i2 = this.__instances.length - 1; i2 >= instIdx; i2--) {
      this.__detachAndRemoveInstance(i2);
    }
  }
  __detachInstance(idx) {
    let inst = this.__instances[idx];
    const wrappedRoot = wrap$1(inst.root);
    for (let i2 = 0; i2 < inst.children.length; i2++) {
      let el = inst.children[i2];
      wrappedRoot.appendChild(el);
    }
    return inst;
  }
  __attachInstance(idx, parent) {
    let inst = this.__instances[idx];
    parent.insertBefore(inst.root, this);
  }
  __detachAndRemoveInstance(idx) {
    this.__detachInstance(idx);
    this.__instances.splice(idx, 1);
  }
  __stampInstance(item2, instIdx, itemIdx) {
    let model = {};
    model[this.as] = item2;
    model[this.indexAs] = instIdx;
    model[this.itemsIndexAs] = itemIdx;
    return new this.__ctor(model);
  }
  __insertInstance(item2, instIdx, itemIdx) {
    const inst = this.__stampInstance(item2, instIdx, itemIdx);
    let beforeRow = this.__instances[instIdx + 1];
    let beforeNode = beforeRow ? beforeRow.children[0] : this;
    wrap$1(wrap$1(this).parentNode).insertBefore(inst.root, beforeNode);
    this.__instances[instIdx] = inst;
    return inst;
  }
  // Implements extension point from Templatize mixin
  /**
   * Shows or hides the template instance top level child elements. For
   * text nodes, `textContent` is removed while "hidden" and replaced when
   * "shown."
   * @param {boolean} hidden Set to true to hide the children;
   * set to false to show them.
   * @return {void}
   * @protected
   */
  _showHideChildren(hidden) {
    for (let i2 = 0; i2 < this.__instances.length; i2++) {
      this.__instances[i2]._showHideChildren(hidden);
    }
  }
  // Called as a side effect of a host items.<key>.<path> path change,
  // responsible for notifying item.<path> changes to inst for key
  __handleItemPath(path, value) {
    let itemsPath = path.slice(6);
    let dot = itemsPath.indexOf(".");
    let itemsIdx = dot < 0 ? itemsPath : itemsPath.substring(0, dot);
    if (itemsIdx == parseInt(itemsIdx, 10)) {
      let itemSubPath = dot < 0 ? "" : itemsPath.substring(dot + 1);
      this.__handleObservedPaths(itemSubPath);
      let instIdx = this.__itemsIdxToInstIdx[itemsIdx];
      let inst = this.__instances[instIdx];
      if (inst) {
        let itemPath = this.as + (itemSubPath ? "." + itemSubPath : "");
        inst._setPendingPropertyOrPath(itemPath, value, false, true);
        inst._flushProperties();
      }
      return true;
    }
  }
  /**
   * Returns the item associated with a given element stamped by
   * this `dom-repeat`.
   *
   * Note, to modify sub-properties of the item,
   * `modelForElement(el).set('item.<sub-prop>', value)`
   * should be used.
   *
   * @param {!HTMLElement} el Element for which to return the item.
   * @return {*} Item associated with the element.
   */
  itemForElement(el) {
    let instance = this.modelForElement(el);
    return instance && instance[this.as];
  }
  /**
   * Returns the inst index for a given element stamped by this `dom-repeat`.
   * If `sort` is provided, the index will reflect the sorted order (rather
   * than the original array order).
   *
   * @param {!HTMLElement} el Element for which to return the index.
   * @return {?number} Row index associated with the element (note this may
   *   not correspond to the array index if a user `sort` is applied).
   */
  indexForElement(el) {
    let instance = this.modelForElement(el);
    return instance && instance[this.indexAs];
  }
  /**
   * Returns the template "model" associated with a given element, which
   * serves as the binding scope for the template instance the element is
   * contained in. A template model
   * should be used to manipulate data associated with this template instance.
   *
   * Example:
   *
   *   let model = modelForElement(el);
   *   if (model.index < 10) {
   *     model.set('item.checked', true);
   *   }
   *
   * @param {!HTMLElement} el Element for which to return a template model.
   * @return {TemplateInstanceBase} Model representing the binding scope for
   *   the element.
   */
  modelForElement(el) {
    return modelForElement(this.template, el);
  }
}
customElements.define(DomRepeat.is, DomRepeat);
/**
 * @license
 * Copyright (c) 2016 - 2025 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const MonthCalendarMixin = (superClass) => class MonthCalendarMixinClass extends FocusMixin(superClass) {
  static get properties() {
    return {
      /**
       * A `Date` object defining the month to be displayed. Only year and
       * month properties are actually used.
       */
      month: {
        type: Object,
        value: /* @__PURE__ */ new Date(),
        sync: true
      },
      /**
       * A `Date` object for the currently selected date.
       */
      selectedDate: {
        type: Object,
        notify: true,
        sync: true
      },
      /**
       * A `Date` object for the currently focused date.
       */
      focusedDate: {
        type: Object
      },
      /**
       * Set true to display ISO-8601 week numbers in the calendar. Notice that
       * displaying week numbers is only supported when `i18n.firstDayOfWeek`
       * is 1 (Monday).
       */
      showWeekNumbers: {
        type: Boolean,
        value: false
      },
      i18n: {
        type: Object
      },
      /**
       * Flag stating whether taps on the component should be ignored.
       */
      ignoreTaps: {
        type: Boolean
      },
      /**
       * The earliest date that can be selected. All earlier dates will be disabled.
       */
      minDate: {
        type: Date,
        value: null,
        sync: true
      },
      /**
       * The latest date that can be selected. All later dates will be disabled.
       */
      maxDate: {
        type: Date,
        value: null,
        sync: true
      },
      /**
       * A function to be used to determine whether the user can select a given date.
       * Receives a `DatePickerDate` object of the date to be selected and should return a
       * boolean.
       * @type {Function | undefined}
       */
      isDateDisabled: {
        type: Function,
        value: () => false
      },
      enteredDate: {
        type: Date
      },
      disabled: {
        type: Boolean,
        reflectToAttribute: true,
        computed: "__computeDisabled(month, minDate, maxDate)"
      },
      /** @protected */
      _days: {
        type: Array,
        computed: "__computeDays(month, i18n, minDate, maxDate, isDateDisabled)"
      },
      /** @protected */
      _weeks: {
        type: Array,
        computed: "__computeWeeks(_days)"
      },
      /** @private */
      _notTapping: {
        type: Boolean
      },
      /** @private */
      __hasFocus: {
        type: Boolean
      }
    };
  }
  static get observers() {
    return ["__focusedDateChanged(focusedDate, _days)", "_showWeekNumbersChanged(showWeekNumbers, i18n)"];
  }
  get focusableDateElement() {
    return [...this.shadowRoot.querySelectorAll("[part~=date]")].find((datePart) => {
      return dateEquals(datePart.date, this.focusedDate);
    });
  }
  /** @protected */
  ready() {
    super.ready();
    addListener(this.$.monthGrid, "tap", this._handleTap.bind(this));
  }
  /** @override */
  _setFocused(focused) {
    super._setFocused(focused);
    this.__hasFocus = focused;
  }
  /**
   * Returns true if all the dates in the month are out of the allowed range
   * @protected
   */
  __computeDisabled(month, minDate, maxDate) {
    const firstDate = new Date(0, 0);
    firstDate.setFullYear(month.getFullYear());
    firstDate.setMonth(month.getMonth());
    firstDate.setDate(1);
    const lastDate = new Date(0, 0);
    lastDate.setFullYear(month.getFullYear());
    lastDate.setMonth(month.getMonth() + 1);
    lastDate.setDate(0);
    if (minDate && maxDate && minDate.getMonth() === maxDate.getMonth() && minDate.getMonth() === month.getMonth() && maxDate.getDate() - minDate.getDate() >= 0) {
      return false;
    }
    return !dateAllowed(firstDate, minDate, maxDate) && !dateAllowed(lastDate, minDate, maxDate);
  }
  /** @protected */
  _getTitle(month, i18n) {
    if (month === void 0 || i18n === void 0) {
      return;
    }
    return i18n.formatTitle(i18n.monthNames[month.getMonth()], month.getFullYear());
  }
  /** @protected */
  _onMonthGridTouchStart() {
    this._notTapping = false;
    setTimeout(() => {
      this._notTapping = true;
    }, 300);
  }
  /** @private */
  _dateAdd(date, delta) {
    date.setDate(date.getDate() + delta);
  }
  /** @private */
  _applyFirstDayOfWeek(weekDayNames, firstDayOfWeek) {
    if (weekDayNames === void 0 || firstDayOfWeek === void 0) {
      return;
    }
    return weekDayNames.slice(firstDayOfWeek).concat(weekDayNames.slice(0, firstDayOfWeek));
  }
  /** @protected */
  __computeWeekDayNames(i18n, showWeekNumbers) {
    if (i18n === void 0 || showWeekNumbers === void 0) {
      return [];
    }
    const { weekdays, weekdaysShort, firstDayOfWeek } = i18n;
    const weekDayNamesShort = this._applyFirstDayOfWeek(weekdaysShort, firstDayOfWeek);
    const weekDayNames = this._applyFirstDayOfWeek(weekdays, firstDayOfWeek);
    return weekDayNames.map((day, index) => {
      return {
        weekDay: day,
        weekDayShort: weekDayNamesShort[index]
      };
    }).slice(0, 7);
  }
  /** @private */
  __focusedDateChanged(focusedDate, days) {
    if (Array.isArray(days) && days.some((date) => dateEquals(date, focusedDate))) {
      this.removeAttribute("aria-hidden");
    } else {
      this.setAttribute("aria-hidden", "true");
    }
  }
  /** @protected */
  _getDate(date) {
    return date ? date.getDate() : "";
  }
  /** @protected */
  __computeShowWeekSeparator(showWeekNumbers, i18n) {
    return showWeekNumbers && i18n && i18n.firstDayOfWeek === 1;
  }
  /** @protected */
  _isToday(date) {
    return dateEquals(/* @__PURE__ */ new Date(), date);
  }
  /** @protected */
  __computeDays(month, i18n) {
    if (month === void 0 || i18n === void 0) {
      return [];
    }
    const date = new Date(0, 0);
    date.setFullYear(month.getFullYear());
    date.setMonth(month.getMonth());
    date.setDate(1);
    while (date.getDay() !== i18n.firstDayOfWeek) {
      this._dateAdd(date, -1);
    }
    const days = [];
    const startMonth = date.getMonth();
    const targetMonth = month.getMonth();
    while (date.getMonth() === targetMonth || date.getMonth() === startMonth) {
      days.push(date.getMonth() === targetMonth ? new Date(date.getTime()) : null);
      this._dateAdd(date, 1);
    }
    return days;
  }
  /** @protected */
  __computeWeeks(days) {
    return days.reduce((acc, day, i2) => {
      if (i2 % 7 === 0) {
        acc.push([]);
      }
      acc[acc.length - 1].push(day);
      return acc;
    }, []);
  }
  /** @protected */
  _handleTap(e2) {
    if (!this.ignoreTaps && !this._notTapping && e2.target.date && !e2.target.hasAttribute("disabled")) {
      this.selectedDate = e2.target.date;
      this.dispatchEvent(
        new CustomEvent("date-tap", { detail: { date: e2.target.date }, bubbles: true, composed: true })
      );
    }
  }
  /** @protected */
  _preventDefault(e2) {
    e2.preventDefault();
  }
  /** @protected */
  __computeWeekNumber(days) {
    const date = days.reduce((acc, d3) => {
      return !acc && d3 ? d3 : acc;
    });
    return getISOWeekNumber(date);
  }
  /** @protected */
  __computeDayAriaLabel(date) {
    if (!date) {
      return "";
    }
    let ariaLabel = `${this._getDate(date)} ${this.i18n.monthNames[date.getMonth()]} ${date.getFullYear()}, ${this.i18n.weekdays[date.getDay()]}`;
    if (this._isToday(date)) {
      ariaLabel += `, ${this.i18n.today}`;
    }
    return ariaLabel;
  }
  /** @private */
  _showWeekNumbersChanged(showWeekNumbers, i18n) {
    if (this.__computeShowWeekSeparator(showWeekNumbers, i18n)) {
      this.setAttribute("week-numbers", "");
    } else {
      this.removeAttribute("week-numbers");
    }
  }
  // eslint-disable-next-line @typescript-eslint/max-params
  __computeDatePart(date, focusedDate, selectedDate, minDate, maxDate, isDateDisabled, enteredDate, hasFocus) {
    const result = ["date"];
    if (this.__isDayDisabled(date, minDate, maxDate, isDateDisabled)) {
      result.push("disabled");
    }
    if (dateEquals(date, focusedDate) && (hasFocus || dateEquals(date, enteredDate))) {
      result.push("focused");
    }
    if (this.__isDaySelected(date, selectedDate)) {
      result.push("selected");
    }
    if (this._isToday(date)) {
      result.push("today");
    }
    if (date < normalizeDate(/* @__PURE__ */ new Date())) {
      result.push("past");
    }
    if (date > normalizeDate(/* @__PURE__ */ new Date())) {
      result.push("future");
    }
    return result.join(" ");
  }
  /** @private */
  __isDaySelected(date, selectedDate) {
    return dateEquals(date, selectedDate);
  }
  /** @private */
  __computeDayAriaSelected(date, selectedDate) {
    return String(this.__isDaySelected(date, selectedDate));
  }
  /** @private */
  __isDayDisabled(date, minDate, maxDate, isDateDisabled) {
    return !dateAllowed(date, minDate, maxDate, isDateDisabled);
  }
  /** @private */
  __computeDayAriaDisabled(date, min, max, isDateDisabled) {
    if (date === void 0 || min === void 0 && max === void 0 && isDateDisabled === void 0) {
      return "false";
    }
    return String(this.__isDayDisabled(date, min, max, isDateDisabled));
  }
  /** @private */
  __computeDayTabIndex(date, focusedDate) {
    return dateEquals(date, focusedDate) ? "0" : "-1";
  }
};
/**
 * @license
 * Copyright (c) 2016 - 2025 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const monthCalendarStyles = css`
  :host {
    display: block;
  }

  #monthGrid {
    width: 100%;
    border-collapse: collapse;
  }

  #days-container tr,
  #weekdays-container tr {
    display: flex;
  }

  [part~='date'] {
    outline: none;
  }

  [part~='disabled'] {
    pointer-events: none;
  }

  [part='week-number'][hidden],
  [part='weekday'][hidden] {
    display: none;
  }

  [part='weekday'],
  [part~='date'] {
    width: calc(100% / 7);
    padding: 0;
    font-weight: normal;
  }

  [part='weekday']:empty,
  [part='week-number'] {
    width: 12.5%;
    flex-shrink: 0;
    padding: 0;
  }

  :host([week-numbers]) [part='weekday']:not(:empty),
  :host([week-numbers]) [part~='date'] {
    width: 12.5%;
  }

  @media (forced-colors: active) {
    [part~='date'][part~='focused'] {
      outline: 1px solid;
    }

    [part~='date'][part~='selected'] {
      outline: 3px solid;
    }
  }
`;
/**
 * @license
 * Copyright (c) 2016 - 2025 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
registerStyles$1("vaadin-month-calendar", monthCalendarStyles, {
  moduleId: "vaadin-month-calendar-styles"
});
class MonthCalendar extends MonthCalendarMixin(ThemableMixin(PolymerElement)) {
  static get template() {
    return html`
      <div part="month-header" id="month-header" aria-hidden="true">[[_getTitle(month, i18n)]]</div>
      <table
        id="monthGrid"
        role="grid"
        aria-labelledby="month-header"
        on-touchend="_preventDefault"
        on-touchstart="_onMonthGridTouchStart"
      >
        <thead id="weekdays-container">
          <tr role="row" part="weekdays">
            <th part="weekday" aria-hidden="true" hidden$="[[!__computeShowWeekSeparator(showWeekNumbers, i18n)]]"></th>
            <template is="dom-repeat" items="[[__computeWeekDayNames(i18n, showWeekNumbers)]]">
              <th role="columnheader" part="weekday" scope="col" abbr$="[[item.weekDay]]" aria-hidden="true">
                [[item.weekDayShort]]
              </th>
            </template>
          </tr>
        </thead>
        <tbody id="days-container">
          <template is="dom-repeat" items="[[_weeks]]" as="week">
            <tr role="row">
              <td
                part="week-number"
                aria-hidden="true"
                hidden$="[[!__computeShowWeekSeparator(showWeekNumbers, i18n)]]"
              >
                [[__computeWeekNumber(week)]]
              </td>
              <template is="dom-repeat" items="[[week]]">
                <td
                  role="gridcell"
                  part$="[[__computeDatePart(item, focusedDate, selectedDate, minDate, maxDate, isDateDisabled, enteredDate, __hasFocus)]]"
                  date="[[item]]"
                  tabindex$="[[__computeDayTabIndex(item, focusedDate)]]"
                  disabled$="[[__isDayDisabled(item, minDate, maxDate, isDateDisabled)]]"
                  aria-selected$="[[__computeDayAriaSelected(item, selectedDate)]]"
                  aria-disabled$="[[__computeDayAriaDisabled(item, minDate, maxDate, isDateDisabled)]]"
                  aria-label$="[[__computeDayAriaLabel(item)]]"
                  >[[_getDate(item)]]</td
                >
              </template>
            </tr>
          </template>
        </tbody>
      </table>
    `;
  }
  static get is() {
    return "vaadin-month-calendar";
  }
}
defineCustomElement(MonthCalendar);
/**
 * @license
 * Copyright (c) 2016 - 2025 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const DatePickerOverlayContentMixin = (superClass) => class DatePickerOverlayContentMixin extends superClass {
  static get properties() {
    return {
      scrollDuration: {
        type: Number,
        value: 300
      },
      /**
       * The value for this element.
       */
      selectedDate: {
        type: Object,
        value: null,
        sync: true
      },
      /**
       * Date value which is focused using keyboard.
       */
      focusedDate: {
        type: Object,
        notify: true,
        observer: "_focusedDateChanged",
        sync: true
      },
      _focusedMonthDate: Number,
      /**
       * Date which should be visible when there is no value selected.
       */
      initialPosition: {
        type: Object,
        observer: "_initialPositionChanged",
        sync: true
      },
      _originDate: {
        type: Object,
        value: /* @__PURE__ */ new Date()
      },
      _visibleMonthIndex: Number,
      _desktopMode: {
        type: Boolean,
        observer: "_desktopModeChanged"
      },
      _desktopMediaQuery: {
        type: String,
        value: "(min-width: 375px)"
      },
      _translateX: {
        observer: "_translateXChanged"
      },
      _yearScrollerWidth: {
        value: 50
      },
      i18n: {
        type: Object
      },
      showWeekNumbers: {
        type: Boolean,
        value: false
      },
      _ignoreTaps: Boolean,
      _notTapping: Boolean,
      /**
       * The earliest date that can be selected. All earlier dates will be disabled.
       */
      minDate: {
        type: Object,
        sync: true
      },
      /**
       * The latest date that can be selected. All later dates will be disabled.
       */
      maxDate: {
        type: Object,
        sync: true
      },
      /**
       * A function to be used to determine whether the user can select a given date.
       * Receives a `DatePickerDate` object of the date to be selected and should return a
       * boolean.
       *
       * @type {function(DatePickerDate): boolean | undefined}
       */
      isDateDisabled: {
        type: Function
      },
      enteredDate: {
        type: Date,
        sync: true
      },
      /**
       * Input label
       */
      label: String,
      _cancelButton: {
        type: Object
      },
      _todayButton: {
        type: Object
      },
      calendars: {
        type: Array,
        value: () => []
      },
      years: {
        type: Array,
        value: () => []
      }
    };
  }
  static get observers() {
    return [
      "__updateCalendars(calendars, i18n, minDate, maxDate, selectedDate, focusedDate, showWeekNumbers, _ignoreTaps, _theme, isDateDisabled, enteredDate)",
      "__updateCancelButton(_cancelButton, i18n)",
      "__updateTodayButton(_todayButton, i18n, minDate, maxDate, isDateDisabled)",
      "__updateYears(years, selectedDate, _theme)"
    ];
  }
  /**
   * Whether to scroll to a sub-month position when scrolling to a date.
   * This is active if the month scroller is not large enough to fit a
   * full month. In that case we want to scroll to a position between
   * two months in order to have the focused date in the visible area.
   * @returns {boolean} whether to use sub-month scrolling
   * @private
   */
  get __useSubMonthScrolling() {
    return this._monthScroller.clientHeight < this._monthScroller.itemHeight + this._monthScroller.bufferOffset;
  }
  get focusableDateElement() {
    return this.calendars.map((calendar) => calendar.focusableDateElement).find(Boolean);
  }
  /** @protected */
  _addListeners() {
    setTouchAction(this.$.scrollers, "pan-y");
    addListener(this.$.scrollers, "track", this._track.bind(this));
    addListener(this.shadowRoot.querySelector('[part="clear-button"]'), "tap", this._clear.bind(this));
    addListener(this.shadowRoot.querySelector('[part="toggle-button"]'), "tap", this._cancel.bind(this));
    addListener(
      this.shadowRoot.querySelector('[part="years-toggle-button"]'),
      "tap",
      this._toggleYearScroller.bind(this)
    );
  }
  /** @protected */
  _initControllers() {
    this.addController(
      new MediaQueryController(this._desktopMediaQuery, (matches2) => {
        this._desktopMode = matches2;
      })
    );
    this.addController(
      new SlotController(this, "today-button", "vaadin-button", {
        observe: false,
        initializer: (btn) => {
          btn.setAttribute("theme", "tertiary");
          btn.addEventListener("keydown", (e2) => this.__onTodayButtonKeyDown(e2));
          addListener(btn, "tap", this._onTodayTap.bind(this));
          this._todayButton = btn;
        }
      })
    );
    this.addController(
      new SlotController(this, "cancel-button", "vaadin-button", {
        observe: false,
        initializer: (btn) => {
          btn.setAttribute("theme", "tertiary");
          btn.addEventListener("keydown", (e2) => this.__onCancelButtonKeyDown(e2));
          addListener(btn, "tap", this._cancel.bind(this));
          this._cancelButton = btn;
        }
      })
    );
    this.__initMonthScroller();
    this.__initYearScroller();
  }
  reset() {
    this._closeYearScroller();
    this._toggleAnimateClass(true);
  }
  /**
   * Focuses the cancel button
   */
  focusCancel() {
    this._cancelButton.focus();
  }
  /**
   * Scrolls the list to the given Date.
   */
  scrollToDate(date, animate) {
    const offset = this.__useSubMonthScrolling ? this._calculateWeekScrollOffset(date) : 0;
    this._scrollToPosition(this._differenceInMonths(date, this._originDate) + offset, animate);
    this._monthScroller.forceUpdate();
  }
  /** @private */
  __initMonthScroller() {
    this.addController(
      new SlotController(this, "months", "vaadin-date-picker-month-scroller", {
        observe: false,
        initializer: (scroller2) => {
          scroller2.addEventListener("custom-scroll", () => {
            this._onMonthScroll();
          });
          scroller2.addEventListener("touchstart", () => {
            this._onMonthScrollTouchStart();
          });
          scroller2.addEventListener("keydown", (e2) => {
            this.__onMonthCalendarKeyDown(e2);
          });
          scroller2.addEventListener("init-done", () => {
            const calendars = [...this.querySelectorAll("vaadin-month-calendar")];
            calendars.forEach((calendar) => {
              calendar.addEventListener("selected-date-changed", (e2) => {
                this.selectedDate = e2.detail.value;
              });
            });
            this.calendars = calendars;
          });
          this._monthScroller = scroller2;
        }
      })
    );
  }
  /** @private */
  __initYearScroller() {
    this.addController(
      new SlotController(this, "years", "vaadin-date-picker-year-scroller", {
        observe: false,
        initializer: (scroller2) => {
          scroller2.setAttribute("aria-hidden", "true");
          addListener(scroller2, "tap", (e2) => {
            this._onYearTap(e2);
          });
          scroller2.addEventListener("custom-scroll", () => {
            this._onYearScroll();
          });
          scroller2.addEventListener("touchstart", () => {
            this._onYearScrollTouchStart();
          });
          scroller2.addEventListener("init-done", () => {
            this.years = [...this.querySelectorAll("vaadin-date-picker-year")];
          });
          this._yearScroller = scroller2;
        }
      })
    );
  }
  /** @private */
  __updateCancelButton(cancelButton, i18n) {
    if (cancelButton) {
      cancelButton.textContent = i18n && i18n.cancel;
    }
  }
  /** @private */
  __updateTodayButton(todayButton, i18n, minDate, maxDate, isDateDisabled) {
    if (todayButton) {
      todayButton.textContent = i18n && i18n.today;
      todayButton.disabled = !this._isTodayAllowed(minDate, maxDate, isDateDisabled);
    }
  }
  // eslint-disable-next-line @typescript-eslint/max-params
  __updateCalendars(calendars, i18n, minDate, maxDate, selectedDate, focusedDate, showWeekNumbers, ignoreTaps, theme, isDateDisabled, enteredDate) {
    if (calendars && calendars.length) {
      calendars.forEach((calendar) => {
        calendar.i18n = i18n;
        calendar.minDate = minDate;
        calendar.maxDate = maxDate;
        calendar.isDateDisabled = isDateDisabled;
        calendar.focusedDate = focusedDate;
        calendar.selectedDate = selectedDate;
        calendar.showWeekNumbers = showWeekNumbers;
        calendar.ignoreTaps = ignoreTaps;
        calendar.enteredDate = enteredDate;
        if (theme) {
          calendar.setAttribute("theme", theme);
        } else {
          calendar.removeAttribute("theme");
        }
      });
    }
  }
  /** @private */
  __updateYears(years, selectedDate, theme) {
    if (years && years.length) {
      years.forEach((year) => {
        year.selectedDate = selectedDate;
        if (theme) {
          year.setAttribute("theme", theme);
        } else {
          year.removeAttribute("theme");
        }
      });
    }
  }
  /**
   * Select a date and fire event indicating user interaction.
   * @protected
   */
  _selectDate(dateToSelect) {
    if (!this._dateAllowed(dateToSelect)) {
      return false;
    }
    this.selectedDate = dateToSelect;
    this.dispatchEvent(
      new CustomEvent("date-selected", { detail: { date: dateToSelect }, bubbles: true, composed: true })
    );
    return true;
  }
  /** @private */
  _desktopModeChanged(desktopMode) {
    this.toggleAttribute("desktop", desktopMode);
  }
  /** @private */
  _focusedDateChanged(focusedDate) {
    this.revealDate(focusedDate);
  }
  /**
   * Scrolls the month and year scrollers enough to reveal the given date.
   */
  revealDate(date, animate = true) {
    if (!date) {
      return;
    }
    const diff = this._differenceInMonths(date, this._originDate);
    if (this.__useSubMonthScrolling) {
      const offset = this._calculateWeekScrollOffset(date);
      this._scrollToPosition(diff + offset, animate);
      return;
    }
    const scrolledAboveViewport = this._monthScroller.position > diff;
    const visibleArea = Math.max(
      this._monthScroller.itemHeight,
      this._monthScroller.clientHeight - this._monthScroller.bufferOffset * 2
    );
    const visibleItems = visibleArea / this._monthScroller.itemHeight;
    const scrolledBelowViewport = this._monthScroller.position + visibleItems - 1 < diff;
    if (scrolledAboveViewport) {
      this._scrollToPosition(diff, animate);
    } else if (scrolledBelowViewport) {
      this._scrollToPosition(diff - visibleItems + 1, animate);
    }
  }
  /**
   * Calculates an offset to be added to the month scroll position
   * when using sub-month scrolling, in order ensure that the week
   * that the date is in is visible even for small scroll areas.
   * As the month scroller uses a month as minimal scroll unit
   * (a value of `1` equals one month), we can not exactly identify
   * the position of a specific week. This is a best effort
   * implementation based on manual testing.
   * @param date the date for which to calculate the offset
   * @returns {number} the offset
   * @private
   */
  _calculateWeekScrollOffset(date) {
    const temp = new Date(0, 0);
    temp.setFullYear(date.getFullYear());
    temp.setMonth(date.getMonth());
    temp.setDate(1);
    let week = 0;
    while (temp.getDate() < date.getDate()) {
      temp.setDate(temp.getDate() + 1);
      if (temp.getDay() === this.i18n.firstDayOfWeek) {
        week += 1;
      }
    }
    return week / 6;
  }
  /** @private */
  _initialPositionChanged(initialPosition) {
    if (this._monthScroller && this._yearScroller) {
      this._monthScroller.active = true;
      this._yearScroller.active = true;
    }
    this.scrollToDate(initialPosition);
  }
  /** @private */
  _repositionYearScroller() {
    const monthPosition = this._monthScroller.position;
    this._visibleMonthIndex = Math.floor(monthPosition);
    this._yearScroller.position = (monthPosition + this._originDate.getMonth()) / 12;
  }
  /** @private */
  _repositionMonthScroller() {
    this._monthScroller.position = this._yearScroller.position * 12 - this._originDate.getMonth();
    this._visibleMonthIndex = Math.floor(this._monthScroller.position);
  }
  /** @private */
  _onMonthScroll() {
    this._repositionYearScroller();
    this._doIgnoreTaps();
  }
  /** @private */
  _onYearScroll() {
    this._repositionMonthScroller();
    this._doIgnoreTaps();
  }
  /** @private */
  _onYearScrollTouchStart() {
    this._notTapping = false;
    setTimeout(() => {
      this._notTapping = true;
    }, 300);
    this._repositionMonthScroller();
  }
  /** @private */
  _onMonthScrollTouchStart() {
    this._repositionYearScroller();
  }
  /** @private */
  _doIgnoreTaps() {
    this._ignoreTaps = true;
    this._debouncer = Debouncer$1.debounce(this._debouncer, timeOut$1.after(300), () => {
      this._ignoreTaps = false;
    });
  }
  /** @protected */
  _formatDisplayed(date, i18n, label) {
    if (date && i18n && typeof i18n.formatDate === "function") {
      return i18n.formatDate(extractDateParts(date));
    }
    return label;
  }
  /** @private */
  _onTodayTap() {
    const today = this._getTodayMidnight();
    if (Math.abs(this._monthScroller.position - this._differenceInMonths(today, this._originDate)) < 1e-3) {
      this._selectDate(today);
      this._close();
    } else {
      this._scrollToCurrentMonth();
    }
  }
  /** @private */
  _scrollToCurrentMonth() {
    if (this.focusedDate) {
      this.focusedDate = /* @__PURE__ */ new Date();
    }
    this.scrollToDate(/* @__PURE__ */ new Date(), true);
  }
  /** @private */
  _onYearTap(e2) {
    if (!this._ignoreTaps && !this._notTapping) {
      const scrollDelta = e2.detail.y - (this._yearScroller.getBoundingClientRect().top + this._yearScroller.clientHeight / 2);
      const yearDelta = scrollDelta / this._yearScroller.itemHeight;
      this._scrollToPosition(this._monthScroller.position + yearDelta * 12, true);
    }
  }
  /** @private */
  _scrollToPosition(targetPosition, animate) {
    if (this._targetPosition !== void 0) {
      this._targetPosition = targetPosition;
      return;
    }
    if (!animate) {
      this._monthScroller.position = targetPosition;
      this._monthScroller.forceUpdate();
      this._targetPosition = void 0;
      this._repositionYearScroller();
      this.__tryFocusDate();
      return;
    }
    this._targetPosition = targetPosition;
    let revealResolve;
    this._revealPromise = new Promise((resolve) => {
      revealResolve = resolve;
    });
    const easingFunction = (t2, b2, c2, d3) => {
      t2 /= d3 / 2;
      if (t2 < 1) {
        return c2 / 2 * t2 * t2 + b2;
      }
      t2 -= 1;
      return -c2 / 2 * (t2 * (t2 - 2) - 1) + b2;
    };
    let start = 0;
    const initialPosition = this._monthScroller.position;
    const smoothScroll = (timestamp) => {
      if (!start) {
        start = timestamp;
      }
      const currentTime = timestamp - start;
      if (currentTime < this.scrollDuration) {
        const currentPos = easingFunction(
          currentTime,
          initialPosition,
          this._targetPosition - initialPosition,
          this.scrollDuration
        );
        this._monthScroller.position = currentPos;
        window.requestAnimationFrame(smoothScroll);
      } else {
        this.dispatchEvent(
          new CustomEvent("scroll-animation-finished", {
            bubbles: true,
            composed: true,
            detail: {
              position: this._targetPosition,
              oldPosition: initialPosition
            }
          })
        );
        this._monthScroller.position = this._targetPosition;
        this._monthScroller.forceUpdate();
        this._targetPosition = void 0;
        revealResolve();
        this._revealPromise = void 0;
      }
      setTimeout(this._repositionYearScroller.bind(this), 1);
    };
    window.requestAnimationFrame(smoothScroll);
  }
  /** @private */
  _limit(value, range) {
    return Math.min(range.max, Math.max(range.min, value));
  }
  /** @private */
  _handleTrack(e2) {
    if (Math.abs(e2.detail.dx) < 10 || Math.abs(e2.detail.ddy) > 10) {
      return;
    }
    if (Math.abs(e2.detail.ddx) > this._yearScrollerWidth / 3) {
      this._toggleAnimateClass(true);
    }
    const newTranslateX = this._translateX + e2.detail.ddx;
    this._translateX = this._limit(newTranslateX, {
      min: 0,
      max: this._yearScrollerWidth
    });
  }
  /** @private */
  _track(e2) {
    if (this._desktopMode) {
      return;
    }
    switch (e2.detail.state) {
      case "start":
        this._toggleAnimateClass(false);
        break;
      case "track":
        this._handleTrack(e2);
        break;
      case "end":
        this._toggleAnimateClass(true);
        if (this._translateX >= this._yearScrollerWidth / 2) {
          this._closeYearScroller();
        } else {
          this._openYearScroller();
        }
        break;
    }
  }
  /** @private */
  _toggleAnimateClass(enable) {
    if (enable) {
      this.classList.add("animate");
    } else {
      this.classList.remove("animate");
    }
  }
  /** @private */
  _toggleYearScroller() {
    if (this._isYearScrollerVisible()) {
      this._closeYearScroller();
    } else {
      this._openYearScroller();
    }
  }
  /** @private */
  _openYearScroller() {
    this._translateX = 0;
    this.setAttribute("years-visible", "");
  }
  /** @private */
  _closeYearScroller() {
    this.removeAttribute("years-visible");
    this._translateX = this._yearScrollerWidth;
  }
  /** @private */
  _isYearScrollerVisible() {
    return this._translateX < this._yearScrollerWidth / 2;
  }
  /** @private */
  _translateXChanged(x2) {
    if (!this._desktopMode) {
      this._monthScroller.style.transform = `translateX(${x2 - this._yearScrollerWidth}px)`;
      this._yearScroller.style.transform = `translateX(${x2}px)`;
    }
  }
  /** @private */
  _yearAfterXMonths(months) {
    return dateAfterXMonths(months).getFullYear();
  }
  /** @private */
  _differenceInMonths(date1, date2) {
    const months = (date1.getFullYear() - date2.getFullYear()) * 12;
    return months - date2.getMonth() + date1.getMonth();
  }
  /** @private */
  _clear() {
    this._selectDate("");
  }
  /** @private */
  _close() {
    this.dispatchEvent(new CustomEvent("close", { bubbles: true, composed: true }));
  }
  /** @private */
  _cancel() {
    this.focusedDate = this.selectedDate;
    this._close();
  }
  /** @protected */
  _preventDefault(e2) {
    e2.preventDefault();
  }
  /** @private */
  __toggleDate(date) {
    if (dateEquals(date, this.selectedDate)) {
      this._clear();
      this.focusedDate = date;
    } else {
      this._selectDate(date);
    }
  }
  /** @private */
  __onMonthCalendarKeyDown(event) {
    let handled = false;
    switch (event.key) {
      case "ArrowDown":
        this._moveFocusByDays(7);
        handled = true;
        break;
      case "ArrowUp":
        this._moveFocusByDays(-7);
        handled = true;
        break;
      case "ArrowRight":
        this._moveFocusByDays(this.__isRTL ? -1 : 1);
        handled = true;
        break;
      case "ArrowLeft":
        this._moveFocusByDays(this.__isRTL ? 1 : -1);
        handled = true;
        break;
      case "Enter":
        if (this._selectDate(this.focusedDate)) {
          this._close();
          handled = true;
        }
        break;
      case " ":
        this.__toggleDate(this.focusedDate);
        handled = true;
        break;
      case "Home":
        this._moveFocusInsideMonth(this.focusedDate, "minDate");
        handled = true;
        break;
      case "End":
        this._moveFocusInsideMonth(this.focusedDate, "maxDate");
        handled = true;
        break;
      case "PageDown":
        this._moveFocusByMonths(event.shiftKey ? 12 : 1);
        handled = true;
        break;
      case "PageUp":
        this._moveFocusByMonths(event.shiftKey ? -12 : -1);
        handled = true;
        break;
      case "Tab":
        this._onTabKeyDown(event, "calendar");
        break;
    }
    if (handled) {
      event.preventDefault();
      event.stopPropagation();
    }
  }
  /** @private */
  _onTabKeyDown(event, section) {
    event.stopPropagation();
    switch (section) {
      case "calendar":
        if (event.shiftKey) {
          event.preventDefault();
          if (this.hasAttribute("fullscreen")) {
            this.focusCancel();
          } else {
            this.__focusInput();
          }
        }
        break;
      case "today":
        if (event.shiftKey) {
          event.preventDefault();
          this.focusDateElement();
        }
        break;
      case "cancel":
        if (!event.shiftKey) {
          event.preventDefault();
          if (this.hasAttribute("fullscreen")) {
            this.focusDateElement();
          } else {
            this.__focusInput();
          }
        }
        break;
    }
  }
  /** @private */
  __onTodayButtonKeyDown(event) {
    if (event.key === "Tab") {
      this._onTabKeyDown(event, "today");
    }
  }
  /** @private */
  __onCancelButtonKeyDown(event) {
    if (event.key === "Tab") {
      this._onTabKeyDown(event, "cancel");
    }
  }
  /** @private */
  __focusInput() {
    this.dispatchEvent(new CustomEvent("focus-input", { bubbles: true, composed: true }));
  }
  /** @private */
  __tryFocusDate() {
    const dateToFocus = this.__pendingDateFocus;
    if (dateToFocus) {
      const dateElement = this.focusableDateElement;
      if (dateElement && dateEquals(dateElement.date, this.__pendingDateFocus)) {
        delete this.__pendingDateFocus;
        dateElement.focus();
      }
    }
  }
  async focusDate(date, keepMonth) {
    const dateToFocus = date || this.selectedDate || this.initialPosition || /* @__PURE__ */ new Date();
    this.focusedDate = dateToFocus;
    if (!keepMonth) {
      this._focusedMonthDate = dateToFocus.getDate();
    }
    await this.focusDateElement(false);
  }
  async focusDateElement(reveal = true) {
    this.__pendingDateFocus = this.focusedDate;
    if (!this.calendars.length) {
      await new Promise((resolve) => {
        afterNextRender(this, () => {
          flush();
          resolve();
        });
      });
    }
    if (reveal) {
      this.revealDate(this.focusedDate);
    }
    if (this._revealPromise) {
      await this._revealPromise;
    }
    this.__tryFocusDate();
  }
  /** @private */
  _focusClosestDate(focus) {
    this.focusDate(getClosestDate(focus, [this.minDate, this.maxDate]));
  }
  /** @private */
  _focusAllowedDate(dateToFocus, diff, keepMonth) {
    if (this._dateAllowed(dateToFocus, void 0, void 0, () => false)) {
      this.focusDate(dateToFocus, keepMonth);
    } else if (this._dateAllowed(this.focusedDate)) {
      if (diff > 0) {
        this.focusDate(this.maxDate);
      } else {
        this.focusDate(this.minDate);
      }
    } else {
      this._focusClosestDate(this.focusedDate);
    }
  }
  /** @private */
  _getDateDiff(months, days) {
    const date = new Date(0, 0);
    date.setFullYear(this.focusedDate.getFullYear());
    date.setMonth(this.focusedDate.getMonth() + months);
    if (days) {
      date.setDate(this.focusedDate.getDate() + days);
    }
    return date;
  }
  /** @private */
  _moveFocusByDays(days) {
    const dateToFocus = this._getDateDiff(0, days);
    this._focusAllowedDate(dateToFocus, days, false);
  }
  /** @private */
  _moveFocusByMonths(months) {
    const dateToFocus = this._getDateDiff(months);
    const targetMonth = dateToFocus.getMonth();
    if (!this._focusedMonthDate) {
      this._focusedMonthDate = this.focusedDate.getDate();
    }
    dateToFocus.setDate(this._focusedMonthDate);
    if (dateToFocus.getMonth() !== targetMonth) {
      dateToFocus.setDate(0);
    }
    this._focusAllowedDate(dateToFocus, months, true);
  }
  /** @private */
  _moveFocusInsideMonth(focusedDate, property) {
    const dateToFocus = new Date(0, 0);
    dateToFocus.setFullYear(focusedDate.getFullYear());
    if (property === "minDate") {
      dateToFocus.setMonth(focusedDate.getMonth());
      dateToFocus.setDate(1);
    } else {
      dateToFocus.setMonth(focusedDate.getMonth() + 1);
      dateToFocus.setDate(0);
    }
    if (this._dateAllowed(dateToFocus)) {
      this.focusDate(dateToFocus);
    } else if (this._dateAllowed(focusedDate)) {
      this.focusDate(this[property]);
    } else {
      this._focusClosestDate(focusedDate);
    }
  }
  /** @private */
  _dateAllowed(date, min = this.minDate, max = this.maxDate, isDateDisabled = this.isDateDisabled) {
    return dateAllowed(date, min, max, isDateDisabled);
  }
  /** @private */
  _isTodayAllowed(min, max, isDateDisabled) {
    return this._dateAllowed(this._getTodayMidnight(), min, max, isDateDisabled);
  }
  /** @private */
  _getTodayMidnight() {
    const today = /* @__PURE__ */ new Date();
    const todayMidnight = new Date(0, 0);
    todayMidnight.setFullYear(today.getFullYear());
    todayMidnight.setMonth(today.getMonth());
    todayMidnight.setDate(today.getDate());
    return todayMidnight;
  }
  /**
   * Fired when the scroller reaches the target scrolling position.
   * @event scroll-animation-finished
   * @param {Number} detail.position new position
   * @param {Number} detail.oldPosition old position
   */
};
/**
 * @license
 * Copyright (c) 2016 - 2025 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const overlayContentStyles = css`
  :host {
    display: flex;
    flex-direction: column;
    height: 100%;
    width: 100%;
    outline: none;
  }

  [part='overlay-header'] {
    display: flex;
    flex-shrink: 0;
    flex-wrap: nowrap;
    align-items: center;
  }

  :host(:not([fullscreen])) [part='overlay-header'] {
    display: none;
  }

  [part='label'] {
    flex-grow: 1;
  }

  [hidden] {
    display: none !important;
  }

  [part='years-toggle-button'] {
    display: flex;
  }

  #scrollers {
    display: flex;
    height: 100%;
    width: 100%;
    position: relative;
    overflow: hidden;
  }

  :host([desktop]) ::slotted([slot='months']) {
    right: 50px;
    transform: none !important;
  }

  :host([desktop]) ::slotted([slot='years']) {
    transform: none !important;
  }

  :host(.animate) ::slotted([slot='months']),
  :host(.animate) ::slotted([slot='years']) {
    transition: all 200ms;
  }

  [part='toolbar'] {
    display: flex;
    justify-content: space-between;
    z-index: 2;
    flex-shrink: 0;
  }
`;
/**
 * @license
 * Copyright (c) 2016 - 2025 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
registerStyles$1("vaadin-date-picker-overlay-content", overlayContentStyles, {
  moduleId: "vaadin-date-picker-overlay-content-styles"
});
class DatePickerOverlayContent extends DatePickerOverlayContentMixin(
  ControllerMixin(ThemableMixin(DirMixin(PolymerElement)))
) {
  static get template() {
    return html`
      <div part="overlay-header" on-touchend="_preventDefault" aria-hidden="true">
        <div part="label">[[_formatDisplayed(selectedDate, i18n, label)]]</div>
        <div part="clear-button" hidden$="[[!selectedDate]]"></div>
        <div part="toggle-button"></div>

        <div part="years-toggle-button" hidden$="[[_desktopMode]]" aria-hidden="true">
          [[_yearAfterXMonths(_visibleMonthIndex)]]
        </div>
      </div>

      <div id="scrollers">
        <slot name="months"></slot>
        <slot name="years"></slot>
      </div>

      <div on-touchend="_preventDefault" role="toolbar" part="toolbar">
        <slot name="today-button"></slot>
        <slot name="cancel-button"></slot>
      </div>
    `;
  }
  static get is() {
    return "vaadin-date-picker-overlay-content";
  }
  /** @protected */
  ready() {
    super.ready();
    this.setAttribute("role", "dialog");
    this._addListeners();
    this._initControllers();
  }
}
defineCustomElement(DatePickerOverlayContent);
/**
 * @license
 * Copyright (c) 2016 - 2025 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const datePickerI18nDefaults = Object.freeze({
  monthNames: [
    "January",
    "February",
    "March",
    "April",
    "May",
    "June",
    "July",
    "August",
    "September",
    "October",
    "November",
    "December"
  ],
  weekdays: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
  weekdaysShort: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
  firstDayOfWeek: 0,
  today: "Today",
  cancel: "Cancel",
  referenceDate: "",
  formatDate(d3) {
    const yearStr = String(d3.year).replace(/\d+/u, (y3) => "0000".substr(y3.length) + y3);
    return [d3.month + 1, d3.day, yearStr].join("/");
  },
  parseDate(text) {
    const parts = text.split("/");
    const today = /* @__PURE__ */ new Date();
    let date, month = today.getMonth(), year = today.getFullYear();
    if (parts.length === 3) {
      month = parseInt(parts[0]) - 1;
      date = parseInt(parts[1]);
      year = parseInt(parts[2]);
      if (parts[2].length < 3 && year >= 0) {
        const usedReferenceDate = this.referenceDate ? parseDate(this.referenceDate) : /* @__PURE__ */ new Date();
        year = getAdjustedYear(usedReferenceDate, year, month, date);
      }
    } else if (parts.length === 2) {
      month = parseInt(parts[0]) - 1;
      date = parseInt(parts[1]);
    } else if (parts.length === 1) {
      date = parseInt(parts[0]);
    }
    if (date !== void 0) {
      return { day: date, month, year };
    }
  },
  formatTitle: (monthName, fullYear) => {
    return `${monthName} ${fullYear}`;
  }
});
const DatePickerMixin = (subclass) => class DatePickerMixinClass extends OverlayClassMixin(
  ControllerMixin(DelegateFocusMixin(InputConstraintsMixin(KeyboardMixin(subclass))))
) {
  static get properties() {
    return {
      /**
       * The current selected date.
       * @type {Date | undefined}
       * @protected
       */
      _selectedDate: {
        type: Object,
        sync: true
      },
      /**
       * @type {Date | undefined}
       * @protected
       */
      _focusedDate: {
        type: Object,
        sync: true
      },
      /**
       * Selected date.
       *
       * Supported date formats:
       * - ISO 8601 `"YYYY-MM-DD"` (default)
       * - 6-digit extended ISO 8601 `"+YYYYYY-MM-DD"`, `"-YYYYYY-MM-DD"`
       *
       * @type {string}
       */
      value: {
        type: String,
        notify: true,
        value: "",
        sync: true
      },
      /**
       * Date which should be visible when there is no value selected.
       *
       * The same date formats as for the `value` property are supported.
       * @attr {string} initial-position
       */
      initialPosition: String,
      /**
       * Set true to open the date selector overlay.
       */
      opened: {
        type: Boolean,
        reflectToAttribute: true,
        notify: true,
        observer: "_openedChanged",
        sync: true
      },
      /**
       * Set true to prevent the overlay from opening automatically.
       * @attr {boolean} auto-open-disabled
       */
      autoOpenDisabled: {
        type: Boolean,
        sync: true
      },
      /**
       * Set true to display ISO-8601 week numbers in the calendar. Notice that
       * displaying week numbers is only supported when `i18n.firstDayOfWeek`
       * is 1 (Monday).
       * @attr {boolean} show-week-numbers
       */
      showWeekNumbers: {
        type: Boolean,
        value: false,
        sync: true
      },
      /**
       * @type {boolean}
       * @protected
       */
      _fullscreen: {
        type: Boolean,
        value: false,
        sync: true
      },
      /**
       * @type {string}
       * @protected
       */
      _fullscreenMediaQuery: {
        value: "(max-width: 450px), (max-height: 450px)"
      },
      /**
       * The object used to localize this component.
       * To change the default localization, replace the entire
       * `i18n` object with a custom one.
       *
       * To update individual properties, extend the existing i18n object like so:
       * ```
       * datePicker.i18n = { ...datePicker.i18n, {
       *   formatDate: date => { ... },
       *   parseDate: value => { ... },
       * }};
       * ```
       *
       * The object has the following JSON structure and default values:
       *
       * ```
       * {
       *   // An array with the full names of months starting
       *   // with January.
       *   monthNames: [
       *     'January', 'February', 'March', 'April', 'May',
       *     'June', 'July', 'August', 'September',
       *     'October', 'November', 'December'
       *   ],
       *
       *   // An array of weekday names starting with Sunday. Used
       *   // in screen reader announcements.
       *   weekdays: [
       *     'Sunday', 'Monday', 'Tuesday', 'Wednesday',
       *     'Thursday', 'Friday', 'Saturday'
       *   ],
       *
       *   // An array of short weekday names starting with Sunday.
       *   // Displayed in the calendar.
       *   weekdaysShort: [
       *     'Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'
       *   ],
       *
       *   // An integer indicating the first day of the week
       *   // (0 = Sunday, 1 = Monday, etc.).
       *   firstDayOfWeek: 0,
       *
       *   // Translation of the Today shortcut button text.
       *   today: 'Today',
       *
       *   // Translation of the Cancel button text.
       *   cancel: 'Cancel',
       *
       *   // Used for adjusting the year value when parsing dates with short years.
       *   // The year values between 0 and 99 are evaluated and adjusted.
       *   // Example: for a referenceDate of 1970-10-30;
       *   //   dateToBeParsed: 40-10-30, result: 1940-10-30
       *   //   dateToBeParsed: 80-10-30, result: 1980-10-30
       *   //   dateToBeParsed: 10-10-30, result: 2010-10-30
       *   // Supported date format: ISO 8601 `"YYYY-MM-DD"` (default)
       *   // The default value is the current date.
       *   referenceDate: '',
       *
       *   // A function to format given `Object` as
       *   // date string. Object is in the format `{ day: ..., month: ..., year: ... }`
       *   // Note: The argument month is 0-based. This means that January = 0 and December = 11.
       *   formatDate: d => {
       *     // returns a string representation of the given
       *     // object in 'MM/DD/YYYY' -format
       *   },
       *
       *   // A function to parse the given text to an `Object` in the format `{ day: ..., month: ..., year: ... }`.
       *   // Must properly parse (at least) text formatted by `formatDate`.
       *   // Setting the property to null will disable keyboard input feature.
       *   // Note: The argument month is 0-based. This means that January = 0 and December = 11.
       *   parseDate: text => {
       *     // Parses a string in 'MM/DD/YY', 'MM/DD' or 'DD' -format to
       *     // an `Object` in the format `{ day: ..., month: ..., year: ... }`.
       *   }
       *
       *   // A function to format given `monthName` and
       *   // `fullYear` integer as calendar title string.
       *   formatTitle: (monthName, fullYear) => {
       *     return monthName + ' ' + fullYear;
       *   }
       * }
       * ```
       *
       * @type {!DatePickerI18n}
       * @default {English/US}
       */
      i18n: {
        type: Object,
        sync: true,
        value: () => ({ ...datePickerI18nDefaults })
      },
      /**
       * The earliest date that can be selected. All earlier dates will be disabled.
       *
       * Supported date formats:
       * - ISO 8601 `"YYYY-MM-DD"` (default)
       * - 6-digit extended ISO 8601 `"+YYYYYY-MM-DD"`, `"-YYYYYY-MM-DD"`
       *
       * @type {string | undefined}
       */
      min: {
        type: String,
        sync: true
      },
      /**
       * The latest date that can be selected. All later dates will be disabled.
       *
       * Supported date formats:
       * - ISO 8601 `"YYYY-MM-DD"` (default)
       * - 6-digit extended ISO 8601 `"+YYYYYY-MM-DD"`, `"-YYYYYY-MM-DD"`
       *
       * @type {string | undefined}
       */
      max: {
        type: String,
        sync: true
      },
      /**
       * A function to be used to determine whether the user can select a given date.
       * Receives a `DatePickerDate` object of the date to be selected and should return a
       * boolean.
       *
       * @type {function(DatePickerDate): boolean | undefined}
       */
      isDateDisabled: {
        type: Function
      },
      /**
       * The earliest date that can be selected. All earlier dates will be disabled.
       * @type {Date | undefined}
       * @protected
       */
      _minDate: {
        type: Date,
        computed: "__computeMinOrMaxDate(min)"
      },
      /**
       * The latest date that can be selected. All later dates will be disabled.
       * @type {Date | undefined}
       * @protected
       */
      _maxDate: {
        type: Date,
        computed: "__computeMinOrMaxDate(max)"
      },
      /** @private */
      _noInput: {
        type: Boolean,
        computed: "_isNoInput(inputElement, _fullscreen, _ios, i18n, opened, autoOpenDisabled)"
      },
      /** @private */
      _ios: {
        type: Boolean,
        value: isIOS
      },
      /** @private */
      _focusOverlayOnOpen: Boolean,
      /** @private */
      _overlayContent: {
        type: Object,
        sync: true
      },
      /** @private */
      __enteredDate: {
        type: Date,
        sync: true
      }
    };
  }
  static get observers() {
    return [
      "_selectedDateChanged(_selectedDate, i18n)",
      "_focusedDateChanged(_focusedDate, i18n)",
      "__updateOverlayContent(_overlayContent, i18n, label, _minDate, _maxDate, _focusedDate, _selectedDate, showWeekNumbers, isDateDisabled, __enteredDate)",
      "__updateOverlayContentTheme(_overlayContent, _theme)",
      "__updateOverlayContentFullScreen(_overlayContent, _fullscreen)"
    ];
  }
  static get constraints() {
    return [...super.constraints, "min", "max"];
  }
  constructor() {
    super();
    this._boundOnClick = this._onClick.bind(this);
    this._boundOnScroll = this._onScroll.bind(this);
    this._boundOverlayRenderer = this._overlayRenderer.bind(this);
  }
  /** @override */
  get _inputElementValue() {
    return super._inputElementValue;
  }
  /** @override */
  set _inputElementValue(value) {
    super._inputElementValue = value;
    const parsedDate = this.__parseDate(value);
    this.__setEnteredDate(parsedDate);
  }
  /**
   * Override a getter from `InputControlMixin` to make it optional
   * and to prevent warning when a clear button is missing,
   * for example when using <vaadin-date-picker-light>.
   * @protected
   * @return {Element | null | undefined}
   */
  get clearElement() {
    return null;
  }
  /** @private */
  get _nativeInput() {
    if (this.inputElement) {
      return this.inputElement.focusElement || this.inputElement;
    }
    return null;
  }
  /**
   * The input element's value when it cannot be parsed as a date, and an empty string otherwise.
   *
   * @return {string}
   * @private
   */
  get __unparsableValue() {
    if (!this._inputElementValue || this.__parseDate(this._inputElementValue)) {
      return "";
    }
    return this._inputElementValue;
  }
  /**
   * Override an event listener from `DelegateFocusMixin`
   * @protected
   */
  _onFocus(event) {
    super._onFocus(event);
    if (this._noInput && !isKeyboardActive()) {
      event.target.blur();
    }
  }
  /**
   * Override an event listener from `DelegateFocusMixin`
   * @protected
   */
  _onBlur(event) {
    super._onBlur(event);
    if (!this.opened) {
      this.__commitParsedOrFocusedDate();
      if (document.hasFocus()) {
        this._requestValidation();
      }
    }
  }
  /** @protected */
  ready() {
    super.ready();
    this.addEventListener("click", this._boundOnClick);
    this.addController(
      new MediaQueryController(this._fullscreenMediaQuery, (matches2) => {
        this._fullscreen = matches2;
      })
    );
    this.addController(new VirtualKeyboardController(this));
    const overlay2 = this.$.overlay;
    this._overlayElement = overlay2;
    overlay2.renderer = this._boundOverlayRenderer;
    this.addEventListener("mousedown", () => this.__bringToFront());
    this.addEventListener("touchstart", () => this.__bringToFront());
  }
  /** @protected */
  disconnectedCallback() {
    super.disconnectedCallback();
    this.opened = false;
  }
  /**
   * @protected
   * @override
   */
  focus(options) {
    if (this._noInput && !isKeyboardActive()) {
      this.open();
    } else {
      super.focus(options);
    }
  }
  /**
   * Opens the dropdown.
   */
  open() {
    if (!this.disabled && !this.readonly) {
      this.opened = true;
    }
  }
  /**
   * Closes the dropdown.
   */
  close() {
    this.$.overlay.close();
  }
  /** @private */
  _overlayRenderer(root2) {
    if (root2.firstChild) {
      return;
    }
    const content = document.createElement("vaadin-date-picker-overlay-content");
    root2.appendChild(content);
    this._overlayContent = content;
    content.addEventListener("close", () => {
      this._close();
    });
    content.addEventListener("focus-input", this._focusAndSelect.bind(this));
    content.addEventListener("date-tap", (e2) => {
      this.__commitDate(e2.detail.date);
      this._close();
    });
    content.addEventListener("date-selected", (e2) => {
      this.__commitDate(e2.detail.date);
    });
    content.addEventListener("focusin", () => {
      if (this._keyboardActive) {
        this._setFocused(true);
      }
    });
    content.addEventListener("focusout", (event) => {
      if (this._shouldRemoveFocus(event)) {
        this._setFocused(false);
      }
    });
    content.addEventListener("focused-date-changed", (e2) => {
      this._focusedDate = e2.detail.value;
    });
    content.addEventListener("click", (e2) => e2.stopPropagation());
  }
  /**
   * @param {string} dateString
   * @private
   */
  __parseDate(dateString) {
    if (!this.i18n.parseDate) {
      return;
    }
    let dateObject = this.i18n.parseDate(dateString);
    if (dateObject) {
      dateObject = parseDate(`${dateObject.year}-${dateObject.month + 1}-${dateObject.day}`);
    }
    if (dateObject && !isNaN(dateObject.getTime())) {
      return dateObject;
    }
  }
  /**
   * @param {Date} dateObject
   * @private
   */
  __formatDate(dateObject) {
    if (this.i18n.formatDate) {
      return this.i18n.formatDate(extractDateParts(dateObject));
    }
  }
  /**
   * Returns true if the current input value satisfies all constraints (if any)
   *
   * Override the `checkValidity` method for custom validations.
   *
   * @return {boolean} True if the value is valid
   */
  checkValidity() {
    const inputValue = this._inputElementValue;
    const inputValid = !inputValue || !!this._selectedDate && inputValue === this.__formatDate(this._selectedDate);
    const isDateValid = !this._selectedDate || dateAllowed(this._selectedDate, this._minDate, this._maxDate, this.isDateDisabled);
    let inputValidity = true;
    if (this.inputElement && this.inputElement.checkValidity) {
      inputValidity = this.inputElement.checkValidity();
    }
    return inputValid && isDateValid && inputValidity;
  }
  /**
   * Override method inherited from `FocusMixin`
   * to not call `_setFocused(true)` when focus
   * is restored after closing overlay on click,
   * and to avoid removing `focus-ring` attribute.
   *
   * @param {!FocusEvent} _event
   * @return {boolean}
   * @protected
   * @override
   */
  _shouldSetFocus(_event) {
    return !this._shouldKeepFocusRing;
  }
  /**
   * Override method inherited from `FocusMixin`
   * to prevent removing the `focused` attribute:
   * - when moving focus to the overlay content,
   * - when closing on date click / outside click.
   *
   * @param {FocusEvent} event
   * @return {boolean}
   * @protected
   * @override
   */
  _shouldRemoveFocus(event) {
    const { relatedTarget } = event;
    if (this.opened && relatedTarget !== null && relatedTarget !== document.body && !this.contains(relatedTarget) && !this._overlayContent.contains(relatedTarget)) {
      return true;
    }
    return !this.opened;
  }
  /**
   * Override method inherited from `FocusMixin`
   * to store the `focus-ring` state to restore
   * it later when closing on outside click.
   *
   * @param {boolean} focused
   * @protected
   * @override
   */
  _setFocused(focused) {
    super._setFocused(focused);
    this._shouldKeepFocusRing = focused && this._keyboardActive;
  }
  /**
   * Depending on the nature of the value change that has occurred since
   * the last commit attempt, triggers validation and fires an event:
   *
   * Value change             | Event
   * :------------------------|:------------------
   * empty => parsable        | change
   * empty => unparsable      | unparsable-change
   * parsable => empty        | change
   * parsable => parsable     | change
   * parsable => unparsable   | change
   * unparsable => empty      | unparsable-change
   * unparsable => parsable   | change
   * unparsable => unparsable | unparsable-change
   *
   * @private
   */
  __commitValueChange() {
    const unparsableValue = this.__unparsableValue;
    if (this.__committedValue !== this.value) {
      this._requestValidation();
      this.dispatchEvent(new CustomEvent("change", { bubbles: true }));
    } else if (this.__committedUnparsableValue !== unparsableValue) {
      this._requestValidation();
      this.dispatchEvent(new CustomEvent("unparsable-change"));
    }
    this.__committedValue = this.value;
    this.__committedUnparsableValue = unparsableValue;
  }
  /**
   * Sets the given date as the value and commits it.
   *
   * @param {Date} date
   * @private
   */
  __commitDate(date) {
    this.__keepCommittedValue = true;
    this._selectedDate = date;
    this.__keepCommittedValue = false;
    this.__commitValueChange();
  }
  /** @private */
  _close() {
    this._focus();
    this.close();
  }
  /** @private */
  __bringToFront() {
    requestAnimationFrame(() => {
      this.$.overlay.bringToFront();
    });
  }
  /** @private */
  // eslint-disable-next-line @typescript-eslint/max-params
  _isNoInput(inputElement, fullscreen, ios, i18n, opened, autoOpenDisabled) {
    const noInputOnFullscreenMode = fullscreen && (!autoOpenDisabled || opened);
    const noInputOnIos = ios && opened;
    return !inputElement || noInputOnFullscreenMode || noInputOnIos || !i18n.parseDate;
  }
  /** @private */
  _formatISO(date) {
    return formatISODate(date);
  }
  /** @protected */
  _inputElementChanged(input) {
    super._inputElementChanged(input);
    if (input) {
      input.autocomplete = "off";
      input.setAttribute("role", "combobox");
      input.setAttribute("aria-haspopup", "dialog");
      input.setAttribute("aria-expanded", !!this.opened);
      this._applyInputValue(this._selectedDate);
    }
  }
  /** @protected */
  _openedChanged(opened) {
    if (this.inputElement) {
      this.inputElement.setAttribute("aria-expanded", opened);
    }
  }
  /** @private */
  _selectedDateChanged(selectedDate, i18n) {
    if (selectedDate === void 0 || i18n === void 0) {
      return;
    }
    if (!this.__keepInputValue) {
      this._applyInputValue(selectedDate);
    }
    this.value = this._formatISO(selectedDate);
    this._ignoreFocusedDateChange = true;
    this._focusedDate = selectedDate;
    this._ignoreFocusedDateChange = false;
  }
  /** @private */
  _focusedDateChanged(focusedDate, i18n) {
    if (focusedDate === void 0 || i18n === void 0) {
      return;
    }
    if (!this._ignoreFocusedDateChange && !this._noInput) {
      this._applyInputValue(focusedDate);
    }
  }
  /**
   * Override the value observer from `InputMixin` to implement custom
   * handling of the `value` property. The date-picker doesn't forward
   * the value directly to the input like the default implementation of `InputMixin`.
   * Instead, it parses the value into a date, puts it in `_selectedDate` which
   * is then displayed in the input with respect to the specified date format.
   *
   * @param {string | undefined} value
   * @param {string | undefined} oldValue
   * @protected
   * @override
   */
  _valueChanged(value, oldValue) {
    const newDate = parseDate(value);
    if (value && !newDate) {
      this.value = oldValue;
      return;
    }
    if (value) {
      if (!dateEquals(this._selectedDate, newDate)) {
        this._selectedDate = newDate;
        if (oldValue !== void 0) {
          this._requestValidation();
        }
      }
    } else {
      this._selectedDate = null;
    }
    if (!this.__keepCommittedValue) {
      this.__committedValue = this.value;
      this.__committedUnparsableValue = "";
    }
    this._toggleHasValue(this._hasValue);
  }
  /** @private */
  // eslint-disable-next-line @typescript-eslint/max-params
  __updateOverlayContent(overlayContent, i18n, label, minDate, maxDate, focusedDate, selectedDate, showWeekNumbers, isDateDisabled, enteredDate) {
    if (overlayContent) {
      overlayContent.i18n = i18n;
      overlayContent.label = label;
      overlayContent.minDate = minDate;
      overlayContent.maxDate = maxDate;
      overlayContent.focusedDate = focusedDate;
      overlayContent.selectedDate = selectedDate;
      overlayContent.showWeekNumbers = showWeekNumbers;
      overlayContent.isDateDisabled = isDateDisabled;
      overlayContent.enteredDate = enteredDate;
    }
  }
  /** @private */
  __updateOverlayContentTheme(overlayContent, theme) {
    if (overlayContent) {
      if (theme) {
        overlayContent.setAttribute("theme", theme);
      } else {
        overlayContent.removeAttribute("theme");
      }
    }
  }
  /** @private */
  __updateOverlayContentFullScreen(overlayContent, fullscreen) {
    if (overlayContent) {
      overlayContent.toggleAttribute("fullscreen", fullscreen);
    }
  }
  /** @protected */
  _onOverlayEscapePress() {
    this._focusedDate = this._selectedDate;
    this._closedByEscape = true;
    this._close();
    this._closedByEscape = false;
  }
  /** @protected */
  _onOverlayOpened() {
    const content = this._overlayContent;
    content.reset();
    const initialPosition = this._getInitialPosition();
    content.initialPosition = initialPosition;
    const scrollFocusDate = content.focusedDate || initialPosition;
    content.scrollToDate(scrollFocusDate);
    this._ignoreFocusedDateChange = true;
    content.focusedDate = scrollFocusDate;
    this._ignoreFocusedDateChange = false;
    window.addEventListener("scroll", this._boundOnScroll, true);
    if (this._focusOverlayOnOpen) {
      content.focusDateElement();
      this._focusOverlayOnOpen = false;
    } else {
      this._focus();
    }
    const input = this._nativeInput;
    if (this._noInput && input) {
      input.blur();
      this._overlayContent.focusDateElement();
    }
    const focusables = this._noInput ? content : [input, content];
    this.__showOthers = hideOthers(focusables);
  }
  /** @private */
  _getInitialPosition() {
    const parsedInitialPosition = parseDate(this.initialPosition);
    const initialPosition = this._selectedDate || this._overlayContent.initialPosition || parsedInitialPosition || /* @__PURE__ */ new Date();
    return parsedInitialPosition || dateAllowed(initialPosition, this._minDate, this._maxDate, this.isDateDisabled) ? initialPosition : this._minDate || this._maxDate ? getClosestDate(initialPosition, [this._minDate, this._maxDate]) : /* @__PURE__ */ new Date();
  }
  /**
   * Tries to parse the input element's value as a date. If the input value
   * is parsable, commits the resulting date as the value. Otherwise, commits
   * an empty string as the value. If no i18n parser is provided, commits
   * the focused date as the value.
   *
   * @private
   */
  __commitParsedOrFocusedDate() {
    this._ignoreFocusedDateChange = true;
    if (this.i18n.parseDate) {
      const inputValue = this._inputElementValue || "";
      const parsedDate = this.__parseDate(inputValue);
      if (parsedDate) {
        this.__commitDate(parsedDate);
      } else {
        this.__keepInputValue = true;
        this.__commitDate(null);
        this.__keepInputValue = false;
      }
    } else if (this._focusedDate) {
      this.__commitDate(this._focusedDate);
    }
    this._ignoreFocusedDateChange = false;
  }
  /** @protected */
  _onOverlayClosed() {
    if (this.__showOthers) {
      this.__showOthers();
      this.__showOthers = null;
    }
    window.removeEventListener("scroll", this._boundOnScroll, true);
    if (this._closedByEscape) {
      this._applyInputValue(this._selectedDate);
    }
    this.__commitParsedOrFocusedDate();
    if (this._nativeInput && this._nativeInput.selectionStart) {
      this._nativeInput.selectionStart = this._nativeInput.selectionEnd;
    }
    if (!this.value && !this._keyboardActive) {
      this._requestValidation();
    }
  }
  /** @private */
  _onScroll(e2) {
    if (e2.target === window || !this._overlayContent.contains(e2.target)) {
      this._overlayContent._repositionYearScroller();
    }
  }
  /** @protected */
  _focus() {
    if (!this._noInput) {
      this.inputElement.focus();
    }
  }
  /** @private */
  _focusAndSelect() {
    this._focus();
    this._setSelectionRange(0, this._inputElementValue.length);
  }
  /** @private */
  _applyInputValue(date) {
    this._inputElementValue = date ? this.__formatDate(date) : "";
  }
  /** @private */
  _setSelectionRange(a3, b2) {
    if (this._nativeInput && this._nativeInput.setSelectionRange) {
      this._nativeInput.setSelectionRange(a3, b2);
    }
  }
  /**
   * Override an event listener from `InputConstraintsMixin`
   * to have date-picker fully control when to fire a change event
   * and trigger validation.
   *
   * @protected
   */
  _onChange(event) {
    event.stopPropagation();
  }
  /**
   * @param {Event} event
   * @private
   */
  _onClick(event) {
    if (!this._isClearButton(event)) {
      this._onHostClick(event);
    }
  }
  /**
   * @param {Event} event
   * @private
   */
  _onHostClick(event) {
    if (!this.autoOpenDisabled || this._noInput) {
      event.preventDefault();
      this.open();
    }
  }
  /**
   * Override an event listener from `InputControlMixin`
   * to validate and dispatch change on clear.
   * @protected
   */
  _onClearButtonClick(event) {
    event.preventDefault();
    this.__commitDate(null);
  }
  /**
   * Override an event listener from `KeyboardMixin`.
   * @param {KeyboardEvent} e
   * @protected
   * @override
   */
  _onKeyDown(e2) {
    super._onKeyDown(e2);
    if (this._noInput) {
      const allowedKeys = [
        9
        // Tab
      ];
      if (allowedKeys.indexOf(e2.keyCode) === -1) {
        e2.preventDefault();
      }
    }
    switch (e2.key) {
      case "ArrowDown":
      case "ArrowUp":
        e2.preventDefault();
        if (this.opened) {
          this._overlayContent.focusDateElement();
        } else {
          this._focusOverlayOnOpen = true;
          this.open();
        }
        break;
      case "Tab":
        if (this.opened) {
          e2.preventDefault();
          e2.stopPropagation();
          this._setSelectionRange(0, 0);
          if (e2.shiftKey) {
            this._overlayContent.focusCancel();
          } else {
            this._overlayContent.focusDateElement();
          }
        }
        break;
    }
  }
  /**
   * Override an event listener from `KeyboardMixin`.
   *
   * @param {!KeyboardEvent} _event
   * @protected
   * @override
   */
  _onEnter(_event) {
    if (this.opened) {
      this.close();
    } else {
      this.__commitParsedOrFocusedDate();
    }
  }
  /**
   * Override an event listener from `KeyboardMixin`.
   * Do not call `super` in order to override clear
   * button logic defined in `InputControlMixin`.
   *
   * @param {!KeyboardEvent} event
   * @protected
   * @override
   */
  _onEscape(event) {
    if (this.opened) {
      return;
    }
    if (this.clearButtonVisible && !!this.value && !this.readonly) {
      event.stopPropagation();
      this._onClearButtonClick(event);
      return;
    }
    if (this.inputElement.value === "") {
      this.__commitDate(null);
    } else {
      this._applyInputValue(this._selectedDate);
    }
  }
  /** @protected */
  _isClearButton(event) {
    return event.composedPath()[0] === this.clearElement;
  }
  /**
   * Override an event listener from `InputMixin`
   * @protected
   */
  _onInput() {
    if (!this.opened && this._inputElementValue && !this.autoOpenDisabled) {
      this.open();
    }
    const parsedDate = this.__parseDate(this._inputElementValue || "");
    if (parsedDate) {
      this._ignoreFocusedDateChange = true;
      if (!dateEquals(parsedDate, this._focusedDate)) {
        this._focusedDate = parsedDate;
      }
      this._ignoreFocusedDateChange = false;
    }
    this.__setEnteredDate(parsedDate);
  }
  /**
   * @param {Date} date
   * @private
   */
  __setEnteredDate(date) {
    if (date) {
      if (!dateEquals(this.__enteredDate, date)) {
        this.__enteredDate = date;
      }
    } else {
      this.__enteredDate = null;
    }
  }
  /** @private */
  __computeMinOrMaxDate(dateString) {
    return parseDate(dateString);
  }
  /**
   * Fired when the user commits a value change.
   *
   * @event change
   */
  /**
   * Fired when `value` property value changes.
   *
   * @event value-changed
   */
  /**
   * Fired when `opened` property value changes.
   *
   * @event opened-changed
   */
};
/**
 * @license
 * Copyright (c) 2016 - 2025 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const datePickerStyles = css`
  :host([opened]) {
    pointer-events: auto;
  }

  :host([dir='rtl']) [part='input-field'] {
    direction: ltr;
  }

  :host([dir='rtl']) [part='input-field'] ::slotted(input)::placeholder {
    direction: rtl;
    text-align: left;
  }
`;
/**
 * @license
 * Copyright (c) 2016 - 2025 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
registerStyles$1("vaadin-date-picker", [inputFieldShared, datePickerStyles], { moduleId: "vaadin-date-picker-styles" });
class DatePicker extends DatePickerMixin(InputControlMixin(ThemableMixin(ElementMixin(PolymerElement)))) {
  static get is() {
    return "vaadin-date-picker";
  }
  static get template() {
    return html`
      <div class="vaadin-date-picker-container">
        <div part="label">
          <slot name="label"></slot>
          <span part="required-indicator" aria-hidden="true" on-click="focus"></span>
        </div>

        <vaadin-input-container
          part="input-field"
          readonly="[[readonly]]"
          disabled="[[disabled]]"
          invalid="[[invalid]]"
          theme$="[[_theme]]"
        >
          <slot name="prefix" slot="prefix"></slot>
          <slot name="input"></slot>
          <div id="clearButton" part="clear-button" slot="suffix" aria-hidden="true"></div>
          <div part="toggle-button" slot="suffix" aria-hidden="true" on-click="_toggle"></div>
        </vaadin-input-container>

        <div part="helper-text">
          <slot name="helper"></slot>
        </div>

        <div part="error-message">
          <slot name="error-message"></slot>
        </div>
      </div>

      <vaadin-date-picker-overlay
        id="overlay"
        fullscreen$="[[_fullscreen]]"
        theme$="[[_theme]]"
        opened="{{opened}}"
        on-vaadin-overlay-escape-press="_onOverlayEscapePress"
        on-vaadin-overlay-open="_onOverlayOpened"
        on-vaadin-overlay-closing="_onOverlayClosed"
        restore-focus-on-close
        restore-focus-node="[[inputElement]]"
      ></vaadin-date-picker-overlay>

      <slot name="tooltip"></slot>
    `;
  }
  /**
   * Used by `InputControlMixin` as a reference to the clear button element.
   * @protected
   * @return {!HTMLElement}
   */
  get clearElement() {
    return this.$.clearButton;
  }
  /** @protected */
  ready() {
    super.ready();
    this.addController(
      new InputController(
        this,
        (input) => {
          this._setInputElement(input);
          this._setFocusElement(input);
          this.stateTarget = input;
          this.ariaTarget = input;
        },
        {
          // The "search" word is a trick to prevent Safari from enabling AutoFill,
          // which is causing click issues:
          // https://github.com/vaadin/web-components/issues/6817#issuecomment-2268229567
          uniqueIdPrefix: "search-input"
        }
      )
    );
    this.addController(new LabelledInputController(this.inputElement, this._labelController));
    this._tooltipController = new TooltipController(this);
    this.addController(this._tooltipController);
    this._tooltipController.setPosition("top");
    this._tooltipController.setAriaTarget(this.inputElement);
    this._tooltipController.setShouldShow((target) => !target.opened);
    const toggleButton = this.shadowRoot.querySelector('[part="toggle-button"]');
    toggleButton.addEventListener("mousedown", (e2) => e2.preventDefault());
    this.$.overlay.addEventListener("vaadin-overlay-close", this._onVaadinOverlayClose.bind(this));
  }
  /** @private */
  _onVaadinOverlayClose(e2) {
    if (e2.detail.sourceEvent && e2.detail.sourceEvent.composedPath().includes(this)) {
      e2.preventDefault();
    }
  }
  /** @private */
  _toggle(e2) {
    e2.stopPropagation();
    if (this.$.overlay.opened) {
      this.close();
    } else {
      this.open();
    }
  }
  // Workaround https://github.com/vaadin/web-components/issues/2855
  /** @protected */
  _openedChanged(opened) {
    super._openedChanged(opened);
    this.$.overlay.positionTarget = this.shadowRoot.querySelector('[part="input-field"]');
    this.$.overlay.noVerticalOverlap = true;
  }
}
defineCustomElement(DatePicker);
function requiredArgs(required, args) {
  if (args.length < required) {
    throw new TypeError(required + " argument" + (required > 1 ? "s" : "") + " required, but only " + args.length + " present");
  }
}
function _typeof$y(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof$y = function _typeof2(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof$y = function _typeof2(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof$y(obj);
}
function isDate(value) {
  requiredArgs(1, arguments);
  return value instanceof Date || _typeof$y(value) === "object" && Object.prototype.toString.call(value) === "[object Date]";
}
function _typeof$x(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof$x = function _typeof2(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof$x = function _typeof2(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof$x(obj);
}
function toDate(argument) {
  requiredArgs(1, arguments);
  var argStr = Object.prototype.toString.call(argument);
  if (argument instanceof Date || _typeof$x(argument) === "object" && argStr === "[object Date]") {
    return new Date(argument.getTime());
  } else if (typeof argument === "number" || argStr === "[object Number]") {
    return new Date(argument);
  } else {
    if ((typeof argument === "string" || argStr === "[object String]") && typeof console !== "undefined") {
      console.warn("Starting with v2.0.0-beta.1 date-fns doesn't accept strings as date arguments. Please use `parseISO` to parse strings. See: https://github.com/date-fns/date-fns/blob/master/docs/upgradeGuide.md#string-arguments");
      console.warn(new Error().stack);
    }
    return /* @__PURE__ */ new Date(NaN);
  }
}
function isValid(dirtyDate) {
  requiredArgs(1, arguments);
  if (!isDate(dirtyDate) && typeof dirtyDate !== "number") {
    return false;
  }
  var date = toDate(dirtyDate);
  return !isNaN(Number(date));
}
function toInteger(dirtyNumber) {
  if (dirtyNumber === null || dirtyNumber === true || dirtyNumber === false) {
    return NaN;
  }
  var number = Number(dirtyNumber);
  if (isNaN(number)) {
    return number;
  }
  return number < 0 ? Math.ceil(number) : Math.floor(number);
}
function addMilliseconds(dirtyDate, dirtyAmount) {
  requiredArgs(2, arguments);
  var timestamp = toDate(dirtyDate).getTime();
  var amount = toInteger(dirtyAmount);
  return new Date(timestamp + amount);
}
function subMilliseconds(dirtyDate, dirtyAmount) {
  requiredArgs(2, arguments);
  var amount = toInteger(dirtyAmount);
  return addMilliseconds(dirtyDate, -amount);
}
var MILLISECONDS_IN_DAY = 864e5;
function getUTCDayOfYear(dirtyDate) {
  requiredArgs(1, arguments);
  var date = toDate(dirtyDate);
  var timestamp = date.getTime();
  date.setUTCMonth(0, 1);
  date.setUTCHours(0, 0, 0, 0);
  var startOfYearTimestamp = date.getTime();
  var difference = timestamp - startOfYearTimestamp;
  return Math.floor(difference / MILLISECONDS_IN_DAY) + 1;
}
function startOfUTCISOWeek(dirtyDate) {
  requiredArgs(1, arguments);
  var weekStartsOn = 1;
  var date = toDate(dirtyDate);
  var day = date.getUTCDay();
  var diff = (day < weekStartsOn ? 7 : 0) + day - weekStartsOn;
  date.setUTCDate(date.getUTCDate() - diff);
  date.setUTCHours(0, 0, 0, 0);
  return date;
}
function getUTCISOWeekYear(dirtyDate) {
  requiredArgs(1, arguments);
  var date = toDate(dirtyDate);
  var year = date.getUTCFullYear();
  var fourthOfJanuaryOfNextYear = /* @__PURE__ */ new Date(0);
  fourthOfJanuaryOfNextYear.setUTCFullYear(year + 1, 0, 4);
  fourthOfJanuaryOfNextYear.setUTCHours(0, 0, 0, 0);
  var startOfNextYear = startOfUTCISOWeek(fourthOfJanuaryOfNextYear);
  var fourthOfJanuaryOfThisYear = /* @__PURE__ */ new Date(0);
  fourthOfJanuaryOfThisYear.setUTCFullYear(year, 0, 4);
  fourthOfJanuaryOfThisYear.setUTCHours(0, 0, 0, 0);
  var startOfThisYear = startOfUTCISOWeek(fourthOfJanuaryOfThisYear);
  if (date.getTime() >= startOfNextYear.getTime()) {
    return year + 1;
  } else if (date.getTime() >= startOfThisYear.getTime()) {
    return year;
  } else {
    return year - 1;
  }
}
function startOfUTCISOWeekYear(dirtyDate) {
  requiredArgs(1, arguments);
  var year = getUTCISOWeekYear(dirtyDate);
  var fourthOfJanuary = /* @__PURE__ */ new Date(0);
  fourthOfJanuary.setUTCFullYear(year, 0, 4);
  fourthOfJanuary.setUTCHours(0, 0, 0, 0);
  var date = startOfUTCISOWeek(fourthOfJanuary);
  return date;
}
var MILLISECONDS_IN_WEEK$1 = 6048e5;
function getUTCISOWeek(dirtyDate) {
  requiredArgs(1, arguments);
  var date = toDate(dirtyDate);
  var diff = startOfUTCISOWeek(date).getTime() - startOfUTCISOWeekYear(date).getTime();
  return Math.round(diff / MILLISECONDS_IN_WEEK$1) + 1;
}
var defaultOptions = {};
function getDefaultOptions() {
  return defaultOptions;
}
function startOfUTCWeek(dirtyDate, options) {
  var _ref, _ref2, _ref3, _options$weekStartsOn, _options$locale, _options$locale$optio, _defaultOptions$local, _defaultOptions$local2;
  requiredArgs(1, arguments);
  var defaultOptions2 = getDefaultOptions();
  var weekStartsOn = toInteger((_ref = (_ref2 = (_ref3 = (_options$weekStartsOn = options === null || options === void 0 ? void 0 : options.weekStartsOn) !== null && _options$weekStartsOn !== void 0 ? _options$weekStartsOn : options === null || options === void 0 ? void 0 : (_options$locale = options.locale) === null || _options$locale === void 0 ? void 0 : (_options$locale$optio = _options$locale.options) === null || _options$locale$optio === void 0 ? void 0 : _options$locale$optio.weekStartsOn) !== null && _ref3 !== void 0 ? _ref3 : defaultOptions2.weekStartsOn) !== null && _ref2 !== void 0 ? _ref2 : (_defaultOptions$local = defaultOptions2.locale) === null || _defaultOptions$local === void 0 ? void 0 : (_defaultOptions$local2 = _defaultOptions$local.options) === null || _defaultOptions$local2 === void 0 ? void 0 : _defaultOptions$local2.weekStartsOn) !== null && _ref !== void 0 ? _ref : 0);
  if (!(weekStartsOn >= 0 && weekStartsOn <= 6)) {
    throw new RangeError("weekStartsOn must be between 0 and 6 inclusively");
  }
  var date = toDate(dirtyDate);
  var day = date.getUTCDay();
  var diff = (day < weekStartsOn ? 7 : 0) + day - weekStartsOn;
  date.setUTCDate(date.getUTCDate() - diff);
  date.setUTCHours(0, 0, 0, 0);
  return date;
}
function getUTCWeekYear(dirtyDate, options) {
  var _ref, _ref2, _ref3, _options$firstWeekCon, _options$locale, _options$locale$optio, _defaultOptions$local, _defaultOptions$local2;
  requiredArgs(1, arguments);
  var date = toDate(dirtyDate);
  var year = date.getUTCFullYear();
  var defaultOptions2 = getDefaultOptions();
  var firstWeekContainsDate = toInteger((_ref = (_ref2 = (_ref3 = (_options$firstWeekCon = options === null || options === void 0 ? void 0 : options.firstWeekContainsDate) !== null && _options$firstWeekCon !== void 0 ? _options$firstWeekCon : options === null || options === void 0 ? void 0 : (_options$locale = options.locale) === null || _options$locale === void 0 ? void 0 : (_options$locale$optio = _options$locale.options) === null || _options$locale$optio === void 0 ? void 0 : _options$locale$optio.firstWeekContainsDate) !== null && _ref3 !== void 0 ? _ref3 : defaultOptions2.firstWeekContainsDate) !== null && _ref2 !== void 0 ? _ref2 : (_defaultOptions$local = defaultOptions2.locale) === null || _defaultOptions$local === void 0 ? void 0 : (_defaultOptions$local2 = _defaultOptions$local.options) === null || _defaultOptions$local2 === void 0 ? void 0 : _defaultOptions$local2.firstWeekContainsDate) !== null && _ref !== void 0 ? _ref : 1);
  if (!(firstWeekContainsDate >= 1 && firstWeekContainsDate <= 7)) {
    throw new RangeError("firstWeekContainsDate must be between 1 and 7 inclusively");
  }
  var firstWeekOfNextYear = /* @__PURE__ */ new Date(0);
  firstWeekOfNextYear.setUTCFullYear(year + 1, 0, firstWeekContainsDate);
  firstWeekOfNextYear.setUTCHours(0, 0, 0, 0);
  var startOfNextYear = startOfUTCWeek(firstWeekOfNextYear, options);
  var firstWeekOfThisYear = /* @__PURE__ */ new Date(0);
  firstWeekOfThisYear.setUTCFullYear(year, 0, firstWeekContainsDate);
  firstWeekOfThisYear.setUTCHours(0, 0, 0, 0);
  var startOfThisYear = startOfUTCWeek(firstWeekOfThisYear, options);
  if (date.getTime() >= startOfNextYear.getTime()) {
    return year + 1;
  } else if (date.getTime() >= startOfThisYear.getTime()) {
    return year;
  } else {
    return year - 1;
  }
}
function startOfUTCWeekYear(dirtyDate, options) {
  var _ref, _ref2, _ref3, _options$firstWeekCon, _options$locale, _options$locale$optio, _defaultOptions$local, _defaultOptions$local2;
  requiredArgs(1, arguments);
  var defaultOptions2 = getDefaultOptions();
  var firstWeekContainsDate = toInteger((_ref = (_ref2 = (_ref3 = (_options$firstWeekCon = options === null || options === void 0 ? void 0 : options.firstWeekContainsDate) !== null && _options$firstWeekCon !== void 0 ? _options$firstWeekCon : options === null || options === void 0 ? void 0 : (_options$locale = options.locale) === null || _options$locale === void 0 ? void 0 : (_options$locale$optio = _options$locale.options) === null || _options$locale$optio === void 0 ? void 0 : _options$locale$optio.firstWeekContainsDate) !== null && _ref3 !== void 0 ? _ref3 : defaultOptions2.firstWeekContainsDate) !== null && _ref2 !== void 0 ? _ref2 : (_defaultOptions$local = defaultOptions2.locale) === null || _defaultOptions$local === void 0 ? void 0 : (_defaultOptions$local2 = _defaultOptions$local.options) === null || _defaultOptions$local2 === void 0 ? void 0 : _defaultOptions$local2.firstWeekContainsDate) !== null && _ref !== void 0 ? _ref : 1);
  var year = getUTCWeekYear(dirtyDate, options);
  var firstWeek = /* @__PURE__ */ new Date(0);
  firstWeek.setUTCFullYear(year, 0, firstWeekContainsDate);
  firstWeek.setUTCHours(0, 0, 0, 0);
  var date = startOfUTCWeek(firstWeek, options);
  return date;
}
var MILLISECONDS_IN_WEEK = 6048e5;
function getUTCWeek(dirtyDate, options) {
  requiredArgs(1, arguments);
  var date = toDate(dirtyDate);
  var diff = startOfUTCWeek(date, options).getTime() - startOfUTCWeekYear(date, options).getTime();
  return Math.round(diff / MILLISECONDS_IN_WEEK) + 1;
}
function addLeadingZeros(number, targetLength) {
  var sign = number < 0 ? "-" : "";
  var output = Math.abs(number).toString();
  while (output.length < targetLength) {
    output = "0" + output;
  }
  return sign + output;
}
var formatters$1 = {
  // Year
  y: function y(date, token) {
    var signedYear = date.getUTCFullYear();
    var year = signedYear > 0 ? signedYear : 1 - signedYear;
    return addLeadingZeros(token === "yy" ? year % 100 : year, token.length);
  },
  // Month
  M: function M(date, token) {
    var month = date.getUTCMonth();
    return token === "M" ? String(month + 1) : addLeadingZeros(month + 1, 2);
  },
  // Day of the month
  d: function d(date, token) {
    return addLeadingZeros(date.getUTCDate(), token.length);
  },
  // AM or PM
  a: function a(date, token) {
    var dayPeriodEnumValue = date.getUTCHours() / 12 >= 1 ? "pm" : "am";
    switch (token) {
      case "a":
      case "aa":
        return dayPeriodEnumValue.toUpperCase();
      case "aaa":
        return dayPeriodEnumValue;
      case "aaaaa":
        return dayPeriodEnumValue[0];
      case "aaaa":
      default:
        return dayPeriodEnumValue === "am" ? "a.m." : "p.m.";
    }
  },
  // Hour [1-12]
  h: function h(date, token) {
    return addLeadingZeros(date.getUTCHours() % 12 || 12, token.length);
  },
  // Hour [0-23]
  H: function H(date, token) {
    return addLeadingZeros(date.getUTCHours(), token.length);
  },
  // Minute
  m: function m(date, token) {
    return addLeadingZeros(date.getUTCMinutes(), token.length);
  },
  // Second
  s: function s(date, token) {
    return addLeadingZeros(date.getUTCSeconds(), token.length);
  },
  // Fraction of second
  S: function S(date, token) {
    var numberOfDigits = token.length;
    var milliseconds = date.getUTCMilliseconds();
    var fractionalSeconds = Math.floor(milliseconds * Math.pow(10, numberOfDigits - 3));
    return addLeadingZeros(fractionalSeconds, token.length);
  }
};
var dayPeriodEnum = {
  midnight: "midnight",
  noon: "noon",
  morning: "morning",
  afternoon: "afternoon",
  evening: "evening",
  night: "night"
};
var formatters = {
  // Era
  G: function G(date, token, localize2) {
    var era = date.getUTCFullYear() > 0 ? 1 : 0;
    switch (token) {
      // AD, BC
      case "G":
      case "GG":
      case "GGG":
        return localize2.era(era, {
          width: "abbreviated"
        });
      // A, B
      case "GGGGG":
        return localize2.era(era, {
          width: "narrow"
        });
      // Anno Domini, Before Christ
      case "GGGG":
      default:
        return localize2.era(era, {
          width: "wide"
        });
    }
  },
  // Year
  y: function y2(date, token, localize2) {
    if (token === "yo") {
      var signedYear = date.getUTCFullYear();
      var year = signedYear > 0 ? signedYear : 1 - signedYear;
      return localize2.ordinalNumber(year, {
        unit: "year"
      });
    }
    return formatters$1.y(date, token);
  },
  // Local week-numbering year
  Y: function Y(date, token, localize2, options) {
    var signedWeekYear = getUTCWeekYear(date, options);
    var weekYear = signedWeekYear > 0 ? signedWeekYear : 1 - signedWeekYear;
    if (token === "YY") {
      var twoDigitYear = weekYear % 100;
      return addLeadingZeros(twoDigitYear, 2);
    }
    if (token === "Yo") {
      return localize2.ordinalNumber(weekYear, {
        unit: "year"
      });
    }
    return addLeadingZeros(weekYear, token.length);
  },
  // ISO week-numbering year
  R: function R(date, token) {
    var isoWeekYear = getUTCISOWeekYear(date);
    return addLeadingZeros(isoWeekYear, token.length);
  },
  // Extended year. This is a single number designating the year of this calendar system.
  // The main difference between `y` and `u` localizers are B.C. years:
  // | Year | `y` | `u` |
  // |------|-----|-----|
  // | AC 1 |   1 |   1 |
  // | BC 1 |   1 |   0 |
  // | BC 2 |   2 |  -1 |
  // Also `yy` always returns the last two digits of a year,
  // while `uu` pads single digit years to 2 characters and returns other years unchanged.
  u: function u(date, token) {
    var year = date.getUTCFullYear();
    return addLeadingZeros(year, token.length);
  },
  // Quarter
  Q: function Q(date, token, localize2) {
    var quarter = Math.ceil((date.getUTCMonth() + 1) / 3);
    switch (token) {
      // 1, 2, 3, 4
      case "Q":
        return String(quarter);
      // 01, 02, 03, 04
      case "QQ":
        return addLeadingZeros(quarter, 2);
      // 1st, 2nd, 3rd, 4th
      case "Qo":
        return localize2.ordinalNumber(quarter, {
          unit: "quarter"
        });
      // Q1, Q2, Q3, Q4
      case "QQQ":
        return localize2.quarter(quarter, {
          width: "abbreviated",
          context: "formatting"
        });
      // 1, 2, 3, 4 (narrow quarter; could be not numerical)
      case "QQQQQ":
        return localize2.quarter(quarter, {
          width: "narrow",
          context: "formatting"
        });
      // 1st quarter, 2nd quarter, ...
      case "QQQQ":
      default:
        return localize2.quarter(quarter, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  // Stand-alone quarter
  q: function q(date, token, localize2) {
    var quarter = Math.ceil((date.getUTCMonth() + 1) / 3);
    switch (token) {
      // 1, 2, 3, 4
      case "q":
        return String(quarter);
      // 01, 02, 03, 04
      case "qq":
        return addLeadingZeros(quarter, 2);
      // 1st, 2nd, 3rd, 4th
      case "qo":
        return localize2.ordinalNumber(quarter, {
          unit: "quarter"
        });
      // Q1, Q2, Q3, Q4
      case "qqq":
        return localize2.quarter(quarter, {
          width: "abbreviated",
          context: "standalone"
        });
      // 1, 2, 3, 4 (narrow quarter; could be not numerical)
      case "qqqqq":
        return localize2.quarter(quarter, {
          width: "narrow",
          context: "standalone"
        });
      // 1st quarter, 2nd quarter, ...
      case "qqqq":
      default:
        return localize2.quarter(quarter, {
          width: "wide",
          context: "standalone"
        });
    }
  },
  // Month
  M: function M2(date, token, localize2) {
    var month = date.getUTCMonth();
    switch (token) {
      case "M":
      case "MM":
        return formatters$1.M(date, token);
      // 1st, 2nd, ..., 12th
      case "Mo":
        return localize2.ordinalNumber(month + 1, {
          unit: "month"
        });
      // Jan, Feb, ..., Dec
      case "MMM":
        return localize2.month(month, {
          width: "abbreviated",
          context: "formatting"
        });
      // J, F, ..., D
      case "MMMMM":
        return localize2.month(month, {
          width: "narrow",
          context: "formatting"
        });
      // January, February, ..., December
      case "MMMM":
      default:
        return localize2.month(month, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  // Stand-alone month
  L: function L(date, token, localize2) {
    var month = date.getUTCMonth();
    switch (token) {
      // 1, 2, ..., 12
      case "L":
        return String(month + 1);
      // 01, 02, ..., 12
      case "LL":
        return addLeadingZeros(month + 1, 2);
      // 1st, 2nd, ..., 12th
      case "Lo":
        return localize2.ordinalNumber(month + 1, {
          unit: "month"
        });
      // Jan, Feb, ..., Dec
      case "LLL":
        return localize2.month(month, {
          width: "abbreviated",
          context: "standalone"
        });
      // J, F, ..., D
      case "LLLLL":
        return localize2.month(month, {
          width: "narrow",
          context: "standalone"
        });
      // January, February, ..., December
      case "LLLL":
      default:
        return localize2.month(month, {
          width: "wide",
          context: "standalone"
        });
    }
  },
  // Local week of year
  w: function w(date, token, localize2, options) {
    var week = getUTCWeek(date, options);
    if (token === "wo") {
      return localize2.ordinalNumber(week, {
        unit: "week"
      });
    }
    return addLeadingZeros(week, token.length);
  },
  // ISO week of year
  I: function I(date, token, localize2) {
    var isoWeek = getUTCISOWeek(date);
    if (token === "Io") {
      return localize2.ordinalNumber(isoWeek, {
        unit: "week"
      });
    }
    return addLeadingZeros(isoWeek, token.length);
  },
  // Day of the month
  d: function d2(date, token, localize2) {
    if (token === "do") {
      return localize2.ordinalNumber(date.getUTCDate(), {
        unit: "date"
      });
    }
    return formatters$1.d(date, token);
  },
  // Day of year
  D: function D(date, token, localize2) {
    var dayOfYear = getUTCDayOfYear(date);
    if (token === "Do") {
      return localize2.ordinalNumber(dayOfYear, {
        unit: "dayOfYear"
      });
    }
    return addLeadingZeros(dayOfYear, token.length);
  },
  // Day of week
  E: function E(date, token, localize2) {
    var dayOfWeek = date.getUTCDay();
    switch (token) {
      // Tue
      case "E":
      case "EE":
      case "EEE":
        return localize2.day(dayOfWeek, {
          width: "abbreviated",
          context: "formatting"
        });
      // T
      case "EEEEE":
        return localize2.day(dayOfWeek, {
          width: "narrow",
          context: "formatting"
        });
      // Tu
      case "EEEEEE":
        return localize2.day(dayOfWeek, {
          width: "short",
          context: "formatting"
        });
      // Tuesday
      case "EEEE":
      default:
        return localize2.day(dayOfWeek, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  // Local day of week
  e: function e(date, token, localize2, options) {
    var dayOfWeek = date.getUTCDay();
    var localDayOfWeek = (dayOfWeek - options.weekStartsOn + 8) % 7 || 7;
    switch (token) {
      // Numerical value (Nth day of week with current locale or weekStartsOn)
      case "e":
        return String(localDayOfWeek);
      // Padded numerical value
      case "ee":
        return addLeadingZeros(localDayOfWeek, 2);
      // 1st, 2nd, ..., 7th
      case "eo":
        return localize2.ordinalNumber(localDayOfWeek, {
          unit: "day"
        });
      case "eee":
        return localize2.day(dayOfWeek, {
          width: "abbreviated",
          context: "formatting"
        });
      // T
      case "eeeee":
        return localize2.day(dayOfWeek, {
          width: "narrow",
          context: "formatting"
        });
      // Tu
      case "eeeeee":
        return localize2.day(dayOfWeek, {
          width: "short",
          context: "formatting"
        });
      // Tuesday
      case "eeee":
      default:
        return localize2.day(dayOfWeek, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  // Stand-alone local day of week
  c: function c(date, token, localize2, options) {
    var dayOfWeek = date.getUTCDay();
    var localDayOfWeek = (dayOfWeek - options.weekStartsOn + 8) % 7 || 7;
    switch (token) {
      // Numerical value (same as in `e`)
      case "c":
        return String(localDayOfWeek);
      // Padded numerical value
      case "cc":
        return addLeadingZeros(localDayOfWeek, token.length);
      // 1st, 2nd, ..., 7th
      case "co":
        return localize2.ordinalNumber(localDayOfWeek, {
          unit: "day"
        });
      case "ccc":
        return localize2.day(dayOfWeek, {
          width: "abbreviated",
          context: "standalone"
        });
      // T
      case "ccccc":
        return localize2.day(dayOfWeek, {
          width: "narrow",
          context: "standalone"
        });
      // Tu
      case "cccccc":
        return localize2.day(dayOfWeek, {
          width: "short",
          context: "standalone"
        });
      // Tuesday
      case "cccc":
      default:
        return localize2.day(dayOfWeek, {
          width: "wide",
          context: "standalone"
        });
    }
  },
  // ISO day of week
  i: function i(date, token, localize2) {
    var dayOfWeek = date.getUTCDay();
    var isoDayOfWeek = dayOfWeek === 0 ? 7 : dayOfWeek;
    switch (token) {
      // 2
      case "i":
        return String(isoDayOfWeek);
      // 02
      case "ii":
        return addLeadingZeros(isoDayOfWeek, token.length);
      // 2nd
      case "io":
        return localize2.ordinalNumber(isoDayOfWeek, {
          unit: "day"
        });
      // Tue
      case "iii":
        return localize2.day(dayOfWeek, {
          width: "abbreviated",
          context: "formatting"
        });
      // T
      case "iiiii":
        return localize2.day(dayOfWeek, {
          width: "narrow",
          context: "formatting"
        });
      // Tu
      case "iiiiii":
        return localize2.day(dayOfWeek, {
          width: "short",
          context: "formatting"
        });
      // Tuesday
      case "iiii":
      default:
        return localize2.day(dayOfWeek, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  // AM or PM
  a: function a2(date, token, localize2) {
    var hours = date.getUTCHours();
    var dayPeriodEnumValue = hours / 12 >= 1 ? "pm" : "am";
    switch (token) {
      case "a":
      case "aa":
        return localize2.dayPeriod(dayPeriodEnumValue, {
          width: "abbreviated",
          context: "formatting"
        });
      case "aaa":
        return localize2.dayPeriod(dayPeriodEnumValue, {
          width: "abbreviated",
          context: "formatting"
        }).toLowerCase();
      case "aaaaa":
        return localize2.dayPeriod(dayPeriodEnumValue, {
          width: "narrow",
          context: "formatting"
        });
      case "aaaa":
      default:
        return localize2.dayPeriod(dayPeriodEnumValue, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  // AM, PM, midnight, noon
  b: function b(date, token, localize2) {
    var hours = date.getUTCHours();
    var dayPeriodEnumValue;
    if (hours === 12) {
      dayPeriodEnumValue = dayPeriodEnum.noon;
    } else if (hours === 0) {
      dayPeriodEnumValue = dayPeriodEnum.midnight;
    } else {
      dayPeriodEnumValue = hours / 12 >= 1 ? "pm" : "am";
    }
    switch (token) {
      case "b":
      case "bb":
        return localize2.dayPeriod(dayPeriodEnumValue, {
          width: "abbreviated",
          context: "formatting"
        });
      case "bbb":
        return localize2.dayPeriod(dayPeriodEnumValue, {
          width: "abbreviated",
          context: "formatting"
        }).toLowerCase();
      case "bbbbb":
        return localize2.dayPeriod(dayPeriodEnumValue, {
          width: "narrow",
          context: "formatting"
        });
      case "bbbb":
      default:
        return localize2.dayPeriod(dayPeriodEnumValue, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  // in the morning, in the afternoon, in the evening, at night
  B: function B(date, token, localize2) {
    var hours = date.getUTCHours();
    var dayPeriodEnumValue;
    if (hours >= 17) {
      dayPeriodEnumValue = dayPeriodEnum.evening;
    } else if (hours >= 12) {
      dayPeriodEnumValue = dayPeriodEnum.afternoon;
    } else if (hours >= 4) {
      dayPeriodEnumValue = dayPeriodEnum.morning;
    } else {
      dayPeriodEnumValue = dayPeriodEnum.night;
    }
    switch (token) {
      case "B":
      case "BB":
      case "BBB":
        return localize2.dayPeriod(dayPeriodEnumValue, {
          width: "abbreviated",
          context: "formatting"
        });
      case "BBBBB":
        return localize2.dayPeriod(dayPeriodEnumValue, {
          width: "narrow",
          context: "formatting"
        });
      case "BBBB":
      default:
        return localize2.dayPeriod(dayPeriodEnumValue, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  // Hour [1-12]
  h: function h2(date, token, localize2) {
    if (token === "ho") {
      var hours = date.getUTCHours() % 12;
      if (hours === 0) hours = 12;
      return localize2.ordinalNumber(hours, {
        unit: "hour"
      });
    }
    return formatters$1.h(date, token);
  },
  // Hour [0-23]
  H: function H2(date, token, localize2) {
    if (token === "Ho") {
      return localize2.ordinalNumber(date.getUTCHours(), {
        unit: "hour"
      });
    }
    return formatters$1.H(date, token);
  },
  // Hour [0-11]
  K: function K(date, token, localize2) {
    var hours = date.getUTCHours() % 12;
    if (token === "Ko") {
      return localize2.ordinalNumber(hours, {
        unit: "hour"
      });
    }
    return addLeadingZeros(hours, token.length);
  },
  // Hour [1-24]
  k: function k(date, token, localize2) {
    var hours = date.getUTCHours();
    if (hours === 0) hours = 24;
    if (token === "ko") {
      return localize2.ordinalNumber(hours, {
        unit: "hour"
      });
    }
    return addLeadingZeros(hours, token.length);
  },
  // Minute
  m: function m2(date, token, localize2) {
    if (token === "mo") {
      return localize2.ordinalNumber(date.getUTCMinutes(), {
        unit: "minute"
      });
    }
    return formatters$1.m(date, token);
  },
  // Second
  s: function s2(date, token, localize2) {
    if (token === "so") {
      return localize2.ordinalNumber(date.getUTCSeconds(), {
        unit: "second"
      });
    }
    return formatters$1.s(date, token);
  },
  // Fraction of second
  S: function S2(date, token) {
    return formatters$1.S(date, token);
  },
  // Timezone (ISO-8601. If offset is 0, output is always `'Z'`)
  X: function X(date, token, _localize, options) {
    var originalDate = options._originalDate || date;
    var timezoneOffset = originalDate.getTimezoneOffset();
    if (timezoneOffset === 0) {
      return "Z";
    }
    switch (token) {
      // Hours and optional minutes
      case "X":
        return formatTimezoneWithOptionalMinutes(timezoneOffset);
      // Hours, minutes and optional seconds without `:` delimiter
      // Note: neither ISO-8601 nor JavaScript supports seconds in timezone offsets
      // so this token always has the same output as `XX`
      case "XXXX":
      case "XX":
        return formatTimezone(timezoneOffset);
      // Hours, minutes and optional seconds with `:` delimiter
      // Note: neither ISO-8601 nor JavaScript supports seconds in timezone offsets
      // so this token always has the same output as `XXX`
      case "XXXXX":
      case "XXX":
      // Hours and minutes with `:` delimiter
      default:
        return formatTimezone(timezoneOffset, ":");
    }
  },
  // Timezone (ISO-8601. If offset is 0, output is `'+00:00'` or equivalent)
  x: function x(date, token, _localize, options) {
    var originalDate = options._originalDate || date;
    var timezoneOffset = originalDate.getTimezoneOffset();
    switch (token) {
      // Hours and optional minutes
      case "x":
        return formatTimezoneWithOptionalMinutes(timezoneOffset);
      // Hours, minutes and optional seconds without `:` delimiter
      // Note: neither ISO-8601 nor JavaScript supports seconds in timezone offsets
      // so this token always has the same output as `xx`
      case "xxxx":
      case "xx":
        return formatTimezone(timezoneOffset);
      // Hours, minutes and optional seconds with `:` delimiter
      // Note: neither ISO-8601 nor JavaScript supports seconds in timezone offsets
      // so this token always has the same output as `xxx`
      case "xxxxx":
      case "xxx":
      // Hours and minutes with `:` delimiter
      default:
        return formatTimezone(timezoneOffset, ":");
    }
  },
  // Timezone (GMT)
  O: function O(date, token, _localize, options) {
    var originalDate = options._originalDate || date;
    var timezoneOffset = originalDate.getTimezoneOffset();
    switch (token) {
      // Short
      case "O":
      case "OO":
      case "OOO":
        return "GMT" + formatTimezoneShort(timezoneOffset, ":");
      // Long
      case "OOOO":
      default:
        return "GMT" + formatTimezone(timezoneOffset, ":");
    }
  },
  // Timezone (specific non-location)
  z: function z(date, token, _localize, options) {
    var originalDate = options._originalDate || date;
    var timezoneOffset = originalDate.getTimezoneOffset();
    switch (token) {
      // Short
      case "z":
      case "zz":
      case "zzz":
        return "GMT" + formatTimezoneShort(timezoneOffset, ":");
      // Long
      case "zzzz":
      default:
        return "GMT" + formatTimezone(timezoneOffset, ":");
    }
  },
  // Seconds timestamp
  t: function t(date, token, _localize, options) {
    var originalDate = options._originalDate || date;
    var timestamp = Math.floor(originalDate.getTime() / 1e3);
    return addLeadingZeros(timestamp, token.length);
  },
  // Milliseconds timestamp
  T: function T(date, token, _localize, options) {
    var originalDate = options._originalDate || date;
    var timestamp = originalDate.getTime();
    return addLeadingZeros(timestamp, token.length);
  }
};
function formatTimezoneShort(offset, dirtyDelimiter) {
  var sign = offset > 0 ? "-" : "+";
  var absOffset = Math.abs(offset);
  var hours = Math.floor(absOffset / 60);
  var minutes = absOffset % 60;
  if (minutes === 0) {
    return sign + String(hours);
  }
  var delimiter = dirtyDelimiter;
  return sign + String(hours) + delimiter + addLeadingZeros(minutes, 2);
}
function formatTimezoneWithOptionalMinutes(offset, dirtyDelimiter) {
  if (offset % 60 === 0) {
    var sign = offset > 0 ? "-" : "+";
    return sign + addLeadingZeros(Math.abs(offset) / 60, 2);
  }
  return formatTimezone(offset, dirtyDelimiter);
}
function formatTimezone(offset, dirtyDelimiter) {
  var delimiter = dirtyDelimiter || "";
  var sign = offset > 0 ? "-" : "+";
  var absOffset = Math.abs(offset);
  var hours = addLeadingZeros(Math.floor(absOffset / 60), 2);
  var minutes = addLeadingZeros(absOffset % 60, 2);
  return sign + hours + delimiter + minutes;
}
var dateLongFormatter = function dateLongFormatter2(pattern, formatLong2) {
  switch (pattern) {
    case "P":
      return formatLong2.date({
        width: "short"
      });
    case "PP":
      return formatLong2.date({
        width: "medium"
      });
    case "PPP":
      return formatLong2.date({
        width: "long"
      });
    case "PPPP":
    default:
      return formatLong2.date({
        width: "full"
      });
  }
};
var timeLongFormatter = function timeLongFormatter2(pattern, formatLong2) {
  switch (pattern) {
    case "p":
      return formatLong2.time({
        width: "short"
      });
    case "pp":
      return formatLong2.time({
        width: "medium"
      });
    case "ppp":
      return formatLong2.time({
        width: "long"
      });
    case "pppp":
    default:
      return formatLong2.time({
        width: "full"
      });
  }
};
var dateTimeLongFormatter = function dateTimeLongFormatter2(pattern, formatLong2) {
  var matchResult = pattern.match(/(P+)(p+)?/) || [];
  var datePattern = matchResult[1];
  var timePattern = matchResult[2];
  if (!timePattern) {
    return dateLongFormatter(pattern, formatLong2);
  }
  var dateTimeFormat;
  switch (datePattern) {
    case "P":
      dateTimeFormat = formatLong2.dateTime({
        width: "short"
      });
      break;
    case "PP":
      dateTimeFormat = formatLong2.dateTime({
        width: "medium"
      });
      break;
    case "PPP":
      dateTimeFormat = formatLong2.dateTime({
        width: "long"
      });
      break;
    case "PPPP":
    default:
      dateTimeFormat = formatLong2.dateTime({
        width: "full"
      });
      break;
  }
  return dateTimeFormat.replace("{{date}}", dateLongFormatter(datePattern, formatLong2)).replace("{{time}}", timeLongFormatter(timePattern, formatLong2));
};
var longFormatters = {
  p: timeLongFormatter,
  P: dateTimeLongFormatter
};
function getTimezoneOffsetInMilliseconds(date) {
  var utcDate = new Date(Date.UTC(date.getFullYear(), date.getMonth(), date.getDate(), date.getHours(), date.getMinutes(), date.getSeconds(), date.getMilliseconds()));
  utcDate.setUTCFullYear(date.getFullYear());
  return date.getTime() - utcDate.getTime();
}
var protectedDayOfYearTokens = ["D", "DD"];
var protectedWeekYearTokens = ["YY", "YYYY"];
function isProtectedDayOfYearToken(token) {
  return protectedDayOfYearTokens.indexOf(token) !== -1;
}
function isProtectedWeekYearToken(token) {
  return protectedWeekYearTokens.indexOf(token) !== -1;
}
function throwProtectedError(token, format2, input) {
  if (token === "YYYY") {
    throw new RangeError("Use `yyyy` instead of `YYYY` (in `".concat(format2, "`) for formatting years to the input `").concat(input, "`; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md"));
  } else if (token === "YY") {
    throw new RangeError("Use `yy` instead of `YY` (in `".concat(format2, "`) for formatting years to the input `").concat(input, "`; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md"));
  } else if (token === "D") {
    throw new RangeError("Use `d` instead of `D` (in `".concat(format2, "`) for formatting days of the month to the input `").concat(input, "`; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md"));
  } else if (token === "DD") {
    throw new RangeError("Use `dd` instead of `DD` (in `".concat(format2, "`) for formatting days of the month to the input `").concat(input, "`; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md"));
  }
}
var formatDistanceLocale = {
  lessThanXSeconds: {
    one: "less than a second",
    other: "less than {{count}} seconds"
  },
  xSeconds: {
    one: "1 second",
    other: "{{count}} seconds"
  },
  halfAMinute: "half a minute",
  lessThanXMinutes: {
    one: "less than a minute",
    other: "less than {{count}} minutes"
  },
  xMinutes: {
    one: "1 minute",
    other: "{{count}} minutes"
  },
  aboutXHours: {
    one: "about 1 hour",
    other: "about {{count}} hours"
  },
  xHours: {
    one: "1 hour",
    other: "{{count}} hours"
  },
  xDays: {
    one: "1 day",
    other: "{{count}} days"
  },
  aboutXWeeks: {
    one: "about 1 week",
    other: "about {{count}} weeks"
  },
  xWeeks: {
    one: "1 week",
    other: "{{count}} weeks"
  },
  aboutXMonths: {
    one: "about 1 month",
    other: "about {{count}} months"
  },
  xMonths: {
    one: "1 month",
    other: "{{count}} months"
  },
  aboutXYears: {
    one: "about 1 year",
    other: "about {{count}} years"
  },
  xYears: {
    one: "1 year",
    other: "{{count}} years"
  },
  overXYears: {
    one: "over 1 year",
    other: "over {{count}} years"
  },
  almostXYears: {
    one: "almost 1 year",
    other: "almost {{count}} years"
  }
};
var formatDistance = function formatDistance2(token, count, options) {
  var result;
  var tokenValue = formatDistanceLocale[token];
  if (typeof tokenValue === "string") {
    result = tokenValue;
  } else if (count === 1) {
    result = tokenValue.one;
  } else {
    result = tokenValue.other.replace("{{count}}", count.toString());
  }
  if (options !== null && options !== void 0 && options.addSuffix) {
    if (options.comparison && options.comparison > 0) {
      return "in " + result;
    } else {
      return result + " ago";
    }
  }
  return result;
};
function buildFormatLongFn(args) {
  return function() {
    var options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    var width = options.width ? String(options.width) : args.defaultWidth;
    var format2 = args.formats[width] || args.formats[args.defaultWidth];
    return format2;
  };
}
var dateFormats = {
  full: "EEEE, MMMM do, y",
  long: "MMMM do, y",
  medium: "MMM d, y",
  short: "MM/dd/yyyy"
};
var timeFormats = {
  full: "h:mm:ss a zzzz",
  long: "h:mm:ss a z",
  medium: "h:mm:ss a",
  short: "h:mm a"
};
var dateTimeFormats = {
  full: "{{date}} 'at' {{time}}",
  long: "{{date}} 'at' {{time}}",
  medium: "{{date}}, {{time}}",
  short: "{{date}}, {{time}}"
};
var formatLong = {
  date: buildFormatLongFn({
    formats: dateFormats,
    defaultWidth: "full"
  }),
  time: buildFormatLongFn({
    formats: timeFormats,
    defaultWidth: "full"
  }),
  dateTime: buildFormatLongFn({
    formats: dateTimeFormats,
    defaultWidth: "full"
  })
};
var formatRelativeLocale = {
  lastWeek: "'last' eeee 'at' p",
  yesterday: "'yesterday at' p",
  today: "'today at' p",
  tomorrow: "'tomorrow at' p",
  nextWeek: "eeee 'at' p",
  other: "P"
};
var formatRelative = function formatRelative2(token, _date, _baseDate, _options) {
  return formatRelativeLocale[token];
};
function buildLocalizeFn(args) {
  return function(dirtyIndex, options) {
    var context = options !== null && options !== void 0 && options.context ? String(options.context) : "standalone";
    var valuesArray;
    if (context === "formatting" && args.formattingValues) {
      var defaultWidth = args.defaultFormattingWidth || args.defaultWidth;
      var width = options !== null && options !== void 0 && options.width ? String(options.width) : defaultWidth;
      valuesArray = args.formattingValues[width] || args.formattingValues[defaultWidth];
    } else {
      var _defaultWidth = args.defaultWidth;
      var _width = options !== null && options !== void 0 && options.width ? String(options.width) : args.defaultWidth;
      valuesArray = args.values[_width] || args.values[_defaultWidth];
    }
    var index = args.argumentCallback ? args.argumentCallback(dirtyIndex) : dirtyIndex;
    return valuesArray[index];
  };
}
var eraValues = {
  narrow: ["B", "A"],
  abbreviated: ["BC", "AD"],
  wide: ["Before Christ", "Anno Domini"]
};
var quarterValues = {
  narrow: ["1", "2", "3", "4"],
  abbreviated: ["Q1", "Q2", "Q3", "Q4"],
  wide: ["1st quarter", "2nd quarter", "3rd quarter", "4th quarter"]
};
var monthValues = {
  narrow: ["J", "F", "M", "A", "M", "J", "J", "A", "S", "O", "N", "D"],
  abbreviated: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"],
  wide: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"]
};
var dayValues = {
  narrow: ["S", "M", "T", "W", "T", "F", "S"],
  short: ["Su", "Mo", "Tu", "We", "Th", "Fr", "Sa"],
  abbreviated: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
  wide: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"]
};
var dayPeriodValues = {
  narrow: {
    am: "a",
    pm: "p",
    midnight: "mi",
    noon: "n",
    morning: "morning",
    afternoon: "afternoon",
    evening: "evening",
    night: "night"
  },
  abbreviated: {
    am: "AM",
    pm: "PM",
    midnight: "midnight",
    noon: "noon",
    morning: "morning",
    afternoon: "afternoon",
    evening: "evening",
    night: "night"
  },
  wide: {
    am: "a.m.",
    pm: "p.m.",
    midnight: "midnight",
    noon: "noon",
    morning: "morning",
    afternoon: "afternoon",
    evening: "evening",
    night: "night"
  }
};
var formattingDayPeriodValues = {
  narrow: {
    am: "a",
    pm: "p",
    midnight: "mi",
    noon: "n",
    morning: "in the morning",
    afternoon: "in the afternoon",
    evening: "in the evening",
    night: "at night"
  },
  abbreviated: {
    am: "AM",
    pm: "PM",
    midnight: "midnight",
    noon: "noon",
    morning: "in the morning",
    afternoon: "in the afternoon",
    evening: "in the evening",
    night: "at night"
  },
  wide: {
    am: "a.m.",
    pm: "p.m.",
    midnight: "midnight",
    noon: "noon",
    morning: "in the morning",
    afternoon: "in the afternoon",
    evening: "in the evening",
    night: "at night"
  }
};
var ordinalNumber = function ordinalNumber2(dirtyNumber, _options) {
  var number = Number(dirtyNumber);
  var rem100 = number % 100;
  if (rem100 > 20 || rem100 < 10) {
    switch (rem100 % 10) {
      case 1:
        return number + "st";
      case 2:
        return number + "nd";
      case 3:
        return number + "rd";
    }
  }
  return number + "th";
};
var localize = {
  ordinalNumber,
  era: buildLocalizeFn({
    values: eraValues,
    defaultWidth: "wide"
  }),
  quarter: buildLocalizeFn({
    values: quarterValues,
    defaultWidth: "wide",
    argumentCallback: function argumentCallback(quarter) {
      return quarter - 1;
    }
  }),
  month: buildLocalizeFn({
    values: monthValues,
    defaultWidth: "wide"
  }),
  day: buildLocalizeFn({
    values: dayValues,
    defaultWidth: "wide"
  }),
  dayPeriod: buildLocalizeFn({
    values: dayPeriodValues,
    defaultWidth: "wide",
    formattingValues: formattingDayPeriodValues,
    defaultFormattingWidth: "wide"
  })
};
function buildMatchFn(args) {
  return function(string) {
    var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    var width = options.width;
    var matchPattern = width && args.matchPatterns[width] || args.matchPatterns[args.defaultMatchWidth];
    var matchResult = string.match(matchPattern);
    if (!matchResult) {
      return null;
    }
    var matchedString = matchResult[0];
    var parsePatterns = width && args.parsePatterns[width] || args.parsePatterns[args.defaultParseWidth];
    var key = Array.isArray(parsePatterns) ? findIndex(parsePatterns, function(pattern) {
      return pattern.test(matchedString);
    }) : findKey(parsePatterns, function(pattern) {
      return pattern.test(matchedString);
    });
    var value;
    value = args.valueCallback ? args.valueCallback(key) : key;
    value = options.valueCallback ? options.valueCallback(value) : value;
    var rest = string.slice(matchedString.length);
    return {
      value,
      rest
    };
  };
}
function findKey(object, predicate) {
  for (var key in object) {
    if (object.hasOwnProperty(key) && predicate(object[key])) {
      return key;
    }
  }
  return void 0;
}
function findIndex(array, predicate) {
  for (var key = 0; key < array.length; key++) {
    if (predicate(array[key])) {
      return key;
    }
  }
  return void 0;
}
function buildMatchPatternFn(args) {
  return function(string) {
    var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    var matchResult = string.match(args.matchPattern);
    if (!matchResult) return null;
    var matchedString = matchResult[0];
    var parseResult = string.match(args.parsePattern);
    if (!parseResult) return null;
    var value = args.valueCallback ? args.valueCallback(parseResult[0]) : parseResult[0];
    value = options.valueCallback ? options.valueCallback(value) : value;
    var rest = string.slice(matchedString.length);
    return {
      value,
      rest
    };
  };
}
var matchOrdinalNumberPattern = /^(\d+)(th|st|nd|rd)?/i;
var parseOrdinalNumberPattern = /\d+/i;
var matchEraPatterns = {
  narrow: /^(b|a)/i,
  abbreviated: /^(b\.?\s?c\.?|b\.?\s?c\.?\s?e\.?|a\.?\s?d\.?|c\.?\s?e\.?)/i,
  wide: /^(before christ|before common era|anno domini|common era)/i
};
var parseEraPatterns = {
  any: [/^b/i, /^(a|c)/i]
};
var matchQuarterPatterns = {
  narrow: /^[1234]/i,
  abbreviated: /^q[1234]/i,
  wide: /^[1234](th|st|nd|rd)? quarter/i
};
var parseQuarterPatterns = {
  any: [/1/i, /2/i, /3/i, /4/i]
};
var matchMonthPatterns = {
  narrow: /^[jfmasond]/i,
  abbreviated: /^(jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec)/i,
  wide: /^(january|february|march|april|may|june|july|august|september|october|november|december)/i
};
var parseMonthPatterns = {
  narrow: [/^j/i, /^f/i, /^m/i, /^a/i, /^m/i, /^j/i, /^j/i, /^a/i, /^s/i, /^o/i, /^n/i, /^d/i],
  any: [/^ja/i, /^f/i, /^mar/i, /^ap/i, /^may/i, /^jun/i, /^jul/i, /^au/i, /^s/i, /^o/i, /^n/i, /^d/i]
};
var matchDayPatterns = {
  narrow: /^[smtwf]/i,
  short: /^(su|mo|tu|we|th|fr|sa)/i,
  abbreviated: /^(sun|mon|tue|wed|thu|fri|sat)/i,
  wide: /^(sunday|monday|tuesday|wednesday|thursday|friday|saturday)/i
};
var parseDayPatterns = {
  narrow: [/^s/i, /^m/i, /^t/i, /^w/i, /^t/i, /^f/i, /^s/i],
  any: [/^su/i, /^m/i, /^tu/i, /^w/i, /^th/i, /^f/i, /^sa/i]
};
var matchDayPeriodPatterns = {
  narrow: /^(a|p|mi|n|(in the|at) (morning|afternoon|evening|night))/i,
  any: /^([ap]\.?\s?m\.?|midnight|noon|(in the|at) (morning|afternoon|evening|night))/i
};
var parseDayPeriodPatterns = {
  any: {
    am: /^a/i,
    pm: /^p/i,
    midnight: /^mi/i,
    noon: /^no/i,
    morning: /morning/i,
    afternoon: /afternoon/i,
    evening: /evening/i,
    night: /night/i
  }
};
var match = {
  ordinalNumber: buildMatchPatternFn({
    matchPattern: matchOrdinalNumberPattern,
    parsePattern: parseOrdinalNumberPattern,
    valueCallback: function valueCallback(value) {
      return parseInt(value, 10);
    }
  }),
  era: buildMatchFn({
    matchPatterns: matchEraPatterns,
    defaultMatchWidth: "wide",
    parsePatterns: parseEraPatterns,
    defaultParseWidth: "any"
  }),
  quarter: buildMatchFn({
    matchPatterns: matchQuarterPatterns,
    defaultMatchWidth: "wide",
    parsePatterns: parseQuarterPatterns,
    defaultParseWidth: "any",
    valueCallback: function valueCallback2(index) {
      return index + 1;
    }
  }),
  month: buildMatchFn({
    matchPatterns: matchMonthPatterns,
    defaultMatchWidth: "wide",
    parsePatterns: parseMonthPatterns,
    defaultParseWidth: "any"
  }),
  day: buildMatchFn({
    matchPatterns: matchDayPatterns,
    defaultMatchWidth: "wide",
    parsePatterns: parseDayPatterns,
    defaultParseWidth: "any"
  }),
  dayPeriod: buildMatchFn({
    matchPatterns: matchDayPeriodPatterns,
    defaultMatchWidth: "any",
    parsePatterns: parseDayPeriodPatterns,
    defaultParseWidth: "any"
  })
};
var locale = {
  code: "en-US",
  formatDistance,
  formatLong,
  formatRelative,
  localize,
  match,
  options: {
    weekStartsOn: 0,
    firstWeekContainsDate: 1
  }
};
var formattingTokensRegExp$1 = /[yYQqMLwIdDecihHKkms]o|(\w)\1*|''|'(''|[^'])+('|$)|./g;
var longFormattingTokensRegExp$1 = /P+p+|P+|p+|''|'(''|[^'])+('|$)|./g;
var escapedStringRegExp$1 = /^'([^]*?)'?$/;
var doubleQuoteRegExp$1 = /''/g;
var unescapedLatinCharacterRegExp$1 = /[a-zA-Z]/;
function format(dirtyDate, dirtyFormatStr, options) {
  var _ref, _options$locale, _ref2, _ref3, _ref4, _options$firstWeekCon, _defaultOptions$local, _defaultOptions$local2, _ref5, _ref6, _ref7, _options$weekStartsOn, _defaultOptions$local3, _defaultOptions$local4;
  requiredArgs(2, arguments);
  var formatStr = String(dirtyFormatStr);
  var defaultOptions2 = getDefaultOptions();
  var locale$1 = (_ref = (_options$locale = void 0) !== null && _options$locale !== void 0 ? _options$locale : defaultOptions2.locale) !== null && _ref !== void 0 ? _ref : locale;
  var firstWeekContainsDate = toInteger((_ref2 = (_ref3 = (_ref4 = (_options$firstWeekCon = void 0) !== null && _options$firstWeekCon !== void 0 ? _options$firstWeekCon : void 0) !== null && _ref4 !== void 0 ? _ref4 : defaultOptions2.firstWeekContainsDate) !== null && _ref3 !== void 0 ? _ref3 : (_defaultOptions$local = defaultOptions2.locale) === null || _defaultOptions$local === void 0 ? void 0 : (_defaultOptions$local2 = _defaultOptions$local.options) === null || _defaultOptions$local2 === void 0 ? void 0 : _defaultOptions$local2.firstWeekContainsDate) !== null && _ref2 !== void 0 ? _ref2 : 1);
  if (!(firstWeekContainsDate >= 1 && firstWeekContainsDate <= 7)) {
    throw new RangeError("firstWeekContainsDate must be between 1 and 7 inclusively");
  }
  var weekStartsOn = toInteger((_ref5 = (_ref6 = (_ref7 = (_options$weekStartsOn = void 0) !== null && _options$weekStartsOn !== void 0 ? _options$weekStartsOn : void 0) !== null && _ref7 !== void 0 ? _ref7 : defaultOptions2.weekStartsOn) !== null && _ref6 !== void 0 ? _ref6 : (_defaultOptions$local3 = defaultOptions2.locale) === null || _defaultOptions$local3 === void 0 ? void 0 : (_defaultOptions$local4 = _defaultOptions$local3.options) === null || _defaultOptions$local4 === void 0 ? void 0 : _defaultOptions$local4.weekStartsOn) !== null && _ref5 !== void 0 ? _ref5 : 0);
  if (!(weekStartsOn >= 0 && weekStartsOn <= 6)) {
    throw new RangeError("weekStartsOn must be between 0 and 6 inclusively");
  }
  if (!locale$1.localize) {
    throw new RangeError("locale must contain localize property");
  }
  if (!locale$1.formatLong) {
    throw new RangeError("locale must contain formatLong property");
  }
  var originalDate = toDate(dirtyDate);
  if (!isValid(originalDate)) {
    throw new RangeError("Invalid time value");
  }
  var timezoneOffset = getTimezoneOffsetInMilliseconds(originalDate);
  var utcDate = subMilliseconds(originalDate, timezoneOffset);
  var formatterOptions = {
    firstWeekContainsDate,
    weekStartsOn,
    locale: locale$1,
    _originalDate: originalDate
  };
  var result = formatStr.match(longFormattingTokensRegExp$1).map(function(substring) {
    var firstCharacter = substring[0];
    if (firstCharacter === "p" || firstCharacter === "P") {
      var longFormatter = longFormatters[firstCharacter];
      return longFormatter(substring, locale$1.formatLong);
    }
    return substring;
  }).join("").match(formattingTokensRegExp$1).map(function(substring) {
    if (substring === "''") {
      return "'";
    }
    var firstCharacter = substring[0];
    if (firstCharacter === "'") {
      return cleanEscapedString$1(substring);
    }
    var formatter = formatters[firstCharacter];
    if (formatter) {
      if (isProtectedWeekYearToken(substring)) {
        throwProtectedError(substring, dirtyFormatStr, String(dirtyDate));
      }
      if (isProtectedDayOfYearToken(substring)) {
        throwProtectedError(substring, dirtyFormatStr, String(dirtyDate));
      }
      return formatter(utcDate, substring, locale$1.localize, formatterOptions);
    }
    if (firstCharacter.match(unescapedLatinCharacterRegExp$1)) {
      throw new RangeError("Format string contains an unescaped latin alphabet character `" + firstCharacter + "`");
    }
    return substring;
  }).join("");
  return result;
}
function cleanEscapedString$1(input) {
  var matched = input.match(escapedStringRegExp$1);
  if (!matched) {
    return input;
  }
  return matched[1].replace(doubleQuoteRegExp$1, "'");
}
function assign(target, object) {
  if (target == null) {
    throw new TypeError("assign requires that input parameter not be null or undefined");
  }
  for (var property in object) {
    if (Object.prototype.hasOwnProperty.call(object, property)) {
      target[property] = object[property];
    }
  }
  return target;
}
function _typeof$w(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof$w = function _typeof2(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof$w = function _typeof2(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof$w(obj);
}
function _inherits$v(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
  if (superClass) _setPrototypeOf$v(subClass, superClass);
}
function _setPrototypeOf$v(o, p) {
  _setPrototypeOf$v = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
    o2.__proto__ = p2;
    return o2;
  };
  return _setPrototypeOf$v(o, p);
}
function _createSuper$v(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$v();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$v(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$v(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$v(this, result);
  };
}
function _possibleConstructorReturn$v(self2, call) {
  if (call && (_typeof$w(call) === "object" || typeof call === "function")) {
    return call;
  }
  return _assertThisInitialized$v(self2);
}
function _assertThisInitialized$v(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _isNativeReflectConstruct$v() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e2) {
    return false;
  }
}
function _getPrototypeOf$v(o) {
  _getPrototypeOf$v = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf$v(o);
}
function _classCallCheck$w(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$w(target, props) {
  for (var i2 = 0; i2 < props.length; i2++) {
    var descriptor = props[i2];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$w(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties$w(Constructor.prototype, protoProps);
  return Constructor;
}
function _defineProperty$v(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
var TIMEZONE_UNIT_PRIORITY = 10;
var Setter = /* @__PURE__ */ (function() {
  function Setter2() {
    _classCallCheck$w(this, Setter2);
    _defineProperty$v(this, "subPriority", 0);
  }
  _createClass$w(Setter2, [{
    key: "validate",
    value: function validate(_utcDate, _options) {
      return true;
    }
  }]);
  return Setter2;
})();
var ValueSetter = /* @__PURE__ */ (function(_Setter) {
  _inherits$v(ValueSetter2, _Setter);
  var _super = _createSuper$v(ValueSetter2);
  function ValueSetter2(value, validateValue, setValue, priority, subPriority) {
    var _this;
    _classCallCheck$w(this, ValueSetter2);
    _this = _super.call(this);
    _this.value = value;
    _this.validateValue = validateValue;
    _this.setValue = setValue;
    _this.priority = priority;
    if (subPriority) {
      _this.subPriority = subPriority;
    }
    return _this;
  }
  _createClass$w(ValueSetter2, [{
    key: "validate",
    value: function validate(utcDate, options) {
      return this.validateValue(utcDate, this.value, options);
    }
  }, {
    key: "set",
    value: function set2(utcDate, flags, options) {
      return this.setValue(utcDate, flags, this.value, options);
    }
  }]);
  return ValueSetter2;
})(Setter);
var DateToSystemTimezoneSetter = /* @__PURE__ */ (function(_Setter2) {
  _inherits$v(DateToSystemTimezoneSetter2, _Setter2);
  var _super2 = _createSuper$v(DateToSystemTimezoneSetter2);
  function DateToSystemTimezoneSetter2() {
    var _this2;
    _classCallCheck$w(this, DateToSystemTimezoneSetter2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this2 = _super2.call.apply(_super2, [this].concat(args));
    _defineProperty$v(_assertThisInitialized$v(_this2), "priority", TIMEZONE_UNIT_PRIORITY);
    _defineProperty$v(_assertThisInitialized$v(_this2), "subPriority", -1);
    return _this2;
  }
  _createClass$w(DateToSystemTimezoneSetter2, [{
    key: "set",
    value: function set2(date, flags) {
      if (flags.timestampIsSet) {
        return date;
      }
      var convertedDate = /* @__PURE__ */ new Date(0);
      convertedDate.setFullYear(date.getUTCFullYear(), date.getUTCMonth(), date.getUTCDate());
      convertedDate.setHours(date.getUTCHours(), date.getUTCMinutes(), date.getUTCSeconds(), date.getUTCMilliseconds());
      return convertedDate;
    }
  }]);
  return DateToSystemTimezoneSetter2;
})(Setter);
function _classCallCheck$v(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$v(target, props) {
  for (var i2 = 0; i2 < props.length; i2++) {
    var descriptor = props[i2];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$v(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties$v(Constructor.prototype, protoProps);
  return Constructor;
}
var Parser = /* @__PURE__ */ (function() {
  function Parser2() {
    _classCallCheck$v(this, Parser2);
  }
  _createClass$v(Parser2, [{
    key: "run",
    value: function run(dateString, token, match2, options) {
      var result = this.parse(dateString, token, match2, options);
      if (!result) {
        return null;
      }
      return {
        setter: new ValueSetter(result.value, this.validate, this.set, this.priority, this.subPriority),
        rest: result.rest
      };
    }
  }, {
    key: "validate",
    value: function validate(_utcDate, _value, _options) {
      return true;
    }
  }]);
  return Parser2;
})();
function _typeof$v(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof$v = function _typeof2(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof$v = function _typeof2(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof$v(obj);
}
function _classCallCheck$u(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$u(target, props) {
  for (var i2 = 0; i2 < props.length; i2++) {
    var descriptor = props[i2];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$u(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties$u(Constructor.prototype, protoProps);
  return Constructor;
}
function _inherits$u(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
  if (superClass) _setPrototypeOf$u(subClass, superClass);
}
function _setPrototypeOf$u(o, p) {
  _setPrototypeOf$u = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
    o2.__proto__ = p2;
    return o2;
  };
  return _setPrototypeOf$u(o, p);
}
function _createSuper$u(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$u();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$u(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$u(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$u(this, result);
  };
}
function _possibleConstructorReturn$u(self2, call) {
  if (call && (_typeof$v(call) === "object" || typeof call === "function")) {
    return call;
  }
  return _assertThisInitialized$u(self2);
}
function _assertThisInitialized$u(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _isNativeReflectConstruct$u() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e2) {
    return false;
  }
}
function _getPrototypeOf$u(o) {
  _getPrototypeOf$u = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf$u(o);
}
function _defineProperty$u(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
var EraParser = /* @__PURE__ */ (function(_Parser) {
  _inherits$u(EraParser2, _Parser);
  var _super = _createSuper$u(EraParser2);
  function EraParser2() {
    var _this;
    _classCallCheck$u(this, EraParser2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty$u(_assertThisInitialized$u(_this), "priority", 140);
    _defineProperty$u(_assertThisInitialized$u(_this), "incompatibleTokens", ["R", "u", "t", "T"]);
    return _this;
  }
  _createClass$u(EraParser2, [{
    key: "parse",
    value: function parse2(dateString, token, match2) {
      switch (token) {
        // AD, BC
        case "G":
        case "GG":
        case "GGG":
          return match2.era(dateString, {
            width: "abbreviated"
          }) || match2.era(dateString, {
            width: "narrow"
          });
        // A, B
        case "GGGGG":
          return match2.era(dateString, {
            width: "narrow"
          });
        // Anno Domini, Before Christ
        case "GGGG":
        default:
          return match2.era(dateString, {
            width: "wide"
          }) || match2.era(dateString, {
            width: "abbreviated"
          }) || match2.era(dateString, {
            width: "narrow"
          });
      }
    }
  }, {
    key: "set",
    value: function set2(date, flags, value) {
      flags.era = value;
      date.setUTCFullYear(value, 0, 1);
      date.setUTCHours(0, 0, 0, 0);
      return date;
    }
  }]);
  return EraParser2;
})(Parser);
var millisecondsInMinute = 6e4;
var millisecondsInHour = 36e5;
var millisecondsInSecond = 1e3;
var numericPatterns = {
  month: /^(1[0-2]|0?\d)/,
  // 0 to 12
  date: /^(3[0-1]|[0-2]?\d)/,
  // 0 to 31
  dayOfYear: /^(36[0-6]|3[0-5]\d|[0-2]?\d?\d)/,
  // 0 to 366
  week: /^(5[0-3]|[0-4]?\d)/,
  // 0 to 53
  hour23h: /^(2[0-3]|[0-1]?\d)/,
  // 0 to 23
  hour24h: /^(2[0-4]|[0-1]?\d)/,
  // 0 to 24
  hour11h: /^(1[0-1]|0?\d)/,
  // 0 to 11
  hour12h: /^(1[0-2]|0?\d)/,
  // 0 to 12
  minute: /^[0-5]?\d/,
  // 0 to 59
  second: /^[0-5]?\d/,
  // 0 to 59
  singleDigit: /^\d/,
  // 0 to 9
  twoDigits: /^\d{1,2}/,
  // 0 to 99
  threeDigits: /^\d{1,3}/,
  // 0 to 999
  fourDigits: /^\d{1,4}/,
  // 0 to 9999
  anyDigitsSigned: /^-?\d+/,
  singleDigitSigned: /^-?\d/,
  // 0 to 9, -0 to -9
  twoDigitsSigned: /^-?\d{1,2}/,
  // 0 to 99, -0 to -99
  threeDigitsSigned: /^-?\d{1,3}/,
  // 0 to 999, -0 to -999
  fourDigitsSigned: /^-?\d{1,4}/
  // 0 to 9999, -0 to -9999
};
var timezonePatterns = {
  basicOptionalMinutes: /^([+-])(\d{2})(\d{2})?|Z/,
  basic: /^([+-])(\d{2})(\d{2})|Z/,
  basicOptionalSeconds: /^([+-])(\d{2})(\d{2})((\d{2}))?|Z/,
  extended: /^([+-])(\d{2}):(\d{2})|Z/,
  extendedOptionalSeconds: /^([+-])(\d{2}):(\d{2})(:(\d{2}))?|Z/
};
function mapValue(parseFnResult, mapFn) {
  if (!parseFnResult) {
    return parseFnResult;
  }
  return {
    value: mapFn(parseFnResult.value),
    rest: parseFnResult.rest
  };
}
function parseNumericPattern(pattern, dateString) {
  var matchResult = dateString.match(pattern);
  if (!matchResult) {
    return null;
  }
  return {
    value: parseInt(matchResult[0], 10),
    rest: dateString.slice(matchResult[0].length)
  };
}
function parseTimezonePattern(pattern, dateString) {
  var matchResult = dateString.match(pattern);
  if (!matchResult) {
    return null;
  }
  if (matchResult[0] === "Z") {
    return {
      value: 0,
      rest: dateString.slice(1)
    };
  }
  var sign = matchResult[1] === "+" ? 1 : -1;
  var hours = matchResult[2] ? parseInt(matchResult[2], 10) : 0;
  var minutes = matchResult[3] ? parseInt(matchResult[3], 10) : 0;
  var seconds = matchResult[5] ? parseInt(matchResult[5], 10) : 0;
  return {
    value: sign * (hours * millisecondsInHour + minutes * millisecondsInMinute + seconds * millisecondsInSecond),
    rest: dateString.slice(matchResult[0].length)
  };
}
function parseAnyDigitsSigned(dateString) {
  return parseNumericPattern(numericPatterns.anyDigitsSigned, dateString);
}
function parseNDigits(n, dateString) {
  switch (n) {
    case 1:
      return parseNumericPattern(numericPatterns.singleDigit, dateString);
    case 2:
      return parseNumericPattern(numericPatterns.twoDigits, dateString);
    case 3:
      return parseNumericPattern(numericPatterns.threeDigits, dateString);
    case 4:
      return parseNumericPattern(numericPatterns.fourDigits, dateString);
    default:
      return parseNumericPattern(new RegExp("^\\d{1," + n + "}"), dateString);
  }
}
function parseNDigitsSigned(n, dateString) {
  switch (n) {
    case 1:
      return parseNumericPattern(numericPatterns.singleDigitSigned, dateString);
    case 2:
      return parseNumericPattern(numericPatterns.twoDigitsSigned, dateString);
    case 3:
      return parseNumericPattern(numericPatterns.threeDigitsSigned, dateString);
    case 4:
      return parseNumericPattern(numericPatterns.fourDigitsSigned, dateString);
    default:
      return parseNumericPattern(new RegExp("^-?\\d{1," + n + "}"), dateString);
  }
}
function dayPeriodEnumToHours(dayPeriod) {
  switch (dayPeriod) {
    case "morning":
      return 4;
    case "evening":
      return 17;
    case "pm":
    case "noon":
    case "afternoon":
      return 12;
    case "am":
    case "midnight":
    case "night":
    default:
      return 0;
  }
}
function normalizeTwoDigitYear(twoDigitYear, currentYear) {
  var isCommonEra = currentYear > 0;
  var absCurrentYear = isCommonEra ? currentYear : 1 - currentYear;
  var result;
  if (absCurrentYear <= 50) {
    result = twoDigitYear || 100;
  } else {
    var rangeEnd = absCurrentYear + 50;
    var rangeEndCentury = Math.floor(rangeEnd / 100) * 100;
    var isPreviousCentury = twoDigitYear >= rangeEnd % 100;
    result = twoDigitYear + rangeEndCentury - (isPreviousCentury ? 100 : 0);
  }
  return isCommonEra ? result : 1 - result;
}
function isLeapYearIndex(year) {
  return year % 400 === 0 || year % 4 === 0 && year % 100 !== 0;
}
function _typeof$u(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof$u = function _typeof2(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof$u = function _typeof2(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof$u(obj);
}
function _classCallCheck$t(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$t(target, props) {
  for (var i2 = 0; i2 < props.length; i2++) {
    var descriptor = props[i2];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$t(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties$t(Constructor.prototype, protoProps);
  return Constructor;
}
function _inherits$t(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
  if (superClass) _setPrototypeOf$t(subClass, superClass);
}
function _setPrototypeOf$t(o, p) {
  _setPrototypeOf$t = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
    o2.__proto__ = p2;
    return o2;
  };
  return _setPrototypeOf$t(o, p);
}
function _createSuper$t(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$t();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$t(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$t(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$t(this, result);
  };
}
function _possibleConstructorReturn$t(self2, call) {
  if (call && (_typeof$u(call) === "object" || typeof call === "function")) {
    return call;
  }
  return _assertThisInitialized$t(self2);
}
function _assertThisInitialized$t(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _isNativeReflectConstruct$t() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e2) {
    return false;
  }
}
function _getPrototypeOf$t(o) {
  _getPrototypeOf$t = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf$t(o);
}
function _defineProperty$t(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
var YearParser = /* @__PURE__ */ (function(_Parser) {
  _inherits$t(YearParser2, _Parser);
  var _super = _createSuper$t(YearParser2);
  function YearParser2() {
    var _this;
    _classCallCheck$t(this, YearParser2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty$t(_assertThisInitialized$t(_this), "priority", 130);
    _defineProperty$t(_assertThisInitialized$t(_this), "incompatibleTokens", ["Y", "R", "u", "w", "I", "i", "e", "c", "t", "T"]);
    return _this;
  }
  _createClass$t(YearParser2, [{
    key: "parse",
    value: function parse2(dateString, token, match2) {
      var valueCallback3 = function valueCallback4(year) {
        return {
          year,
          isTwoDigitYear: token === "yy"
        };
      };
      switch (token) {
        case "y":
          return mapValue(parseNDigits(4, dateString), valueCallback3);
        case "yo":
          return mapValue(match2.ordinalNumber(dateString, {
            unit: "year"
          }), valueCallback3);
        default:
          return mapValue(parseNDigits(token.length, dateString), valueCallback3);
      }
    }
  }, {
    key: "validate",
    value: function validate(_date, value) {
      return value.isTwoDigitYear || value.year > 0;
    }
  }, {
    key: "set",
    value: function set2(date, flags, value) {
      var currentYear = date.getUTCFullYear();
      if (value.isTwoDigitYear) {
        var normalizedTwoDigitYear = normalizeTwoDigitYear(value.year, currentYear);
        date.setUTCFullYear(normalizedTwoDigitYear, 0, 1);
        date.setUTCHours(0, 0, 0, 0);
        return date;
      }
      var year = !("era" in flags) || flags.era === 1 ? value.year : 1 - value.year;
      date.setUTCFullYear(year, 0, 1);
      date.setUTCHours(0, 0, 0, 0);
      return date;
    }
  }]);
  return YearParser2;
})(Parser);
function _typeof$t(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof$t = function _typeof2(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof$t = function _typeof2(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof$t(obj);
}
function _classCallCheck$s(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$s(target, props) {
  for (var i2 = 0; i2 < props.length; i2++) {
    var descriptor = props[i2];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$s(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties$s(Constructor.prototype, protoProps);
  return Constructor;
}
function _inherits$s(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
  if (superClass) _setPrototypeOf$s(subClass, superClass);
}
function _setPrototypeOf$s(o, p) {
  _setPrototypeOf$s = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
    o2.__proto__ = p2;
    return o2;
  };
  return _setPrototypeOf$s(o, p);
}
function _createSuper$s(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$s();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$s(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$s(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$s(this, result);
  };
}
function _possibleConstructorReturn$s(self2, call) {
  if (call && (_typeof$t(call) === "object" || typeof call === "function")) {
    return call;
  }
  return _assertThisInitialized$s(self2);
}
function _assertThisInitialized$s(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _isNativeReflectConstruct$s() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e2) {
    return false;
  }
}
function _getPrototypeOf$s(o) {
  _getPrototypeOf$s = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf$s(o);
}
function _defineProperty$s(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
var LocalWeekYearParser = /* @__PURE__ */ (function(_Parser) {
  _inherits$s(LocalWeekYearParser2, _Parser);
  var _super = _createSuper$s(LocalWeekYearParser2);
  function LocalWeekYearParser2() {
    var _this;
    _classCallCheck$s(this, LocalWeekYearParser2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty$s(_assertThisInitialized$s(_this), "priority", 130);
    _defineProperty$s(_assertThisInitialized$s(_this), "incompatibleTokens", ["y", "R", "u", "Q", "q", "M", "L", "I", "d", "D", "i", "t", "T"]);
    return _this;
  }
  _createClass$s(LocalWeekYearParser2, [{
    key: "parse",
    value: function parse2(dateString, token, match2) {
      var valueCallback3 = function valueCallback4(year) {
        return {
          year,
          isTwoDigitYear: token === "YY"
        };
      };
      switch (token) {
        case "Y":
          return mapValue(parseNDigits(4, dateString), valueCallback3);
        case "Yo":
          return mapValue(match2.ordinalNumber(dateString, {
            unit: "year"
          }), valueCallback3);
        default:
          return mapValue(parseNDigits(token.length, dateString), valueCallback3);
      }
    }
  }, {
    key: "validate",
    value: function validate(_date, value) {
      return value.isTwoDigitYear || value.year > 0;
    }
  }, {
    key: "set",
    value: function set2(date, flags, value, options) {
      var currentYear = getUTCWeekYear(date, options);
      if (value.isTwoDigitYear) {
        var normalizedTwoDigitYear = normalizeTwoDigitYear(value.year, currentYear);
        date.setUTCFullYear(normalizedTwoDigitYear, 0, options.firstWeekContainsDate);
        date.setUTCHours(0, 0, 0, 0);
        return startOfUTCWeek(date, options);
      }
      var year = !("era" in flags) || flags.era === 1 ? value.year : 1 - value.year;
      date.setUTCFullYear(year, 0, options.firstWeekContainsDate);
      date.setUTCHours(0, 0, 0, 0);
      return startOfUTCWeek(date, options);
    }
  }]);
  return LocalWeekYearParser2;
})(Parser);
function _typeof$s(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof$s = function _typeof2(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof$s = function _typeof2(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof$s(obj);
}
function _classCallCheck$r(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$r(target, props) {
  for (var i2 = 0; i2 < props.length; i2++) {
    var descriptor = props[i2];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$r(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties$r(Constructor.prototype, protoProps);
  return Constructor;
}
function _inherits$r(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
  if (superClass) _setPrototypeOf$r(subClass, superClass);
}
function _setPrototypeOf$r(o, p) {
  _setPrototypeOf$r = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
    o2.__proto__ = p2;
    return o2;
  };
  return _setPrototypeOf$r(o, p);
}
function _createSuper$r(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$r();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$r(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$r(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$r(this, result);
  };
}
function _possibleConstructorReturn$r(self2, call) {
  if (call && (_typeof$s(call) === "object" || typeof call === "function")) {
    return call;
  }
  return _assertThisInitialized$r(self2);
}
function _assertThisInitialized$r(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _isNativeReflectConstruct$r() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e2) {
    return false;
  }
}
function _getPrototypeOf$r(o) {
  _getPrototypeOf$r = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf$r(o);
}
function _defineProperty$r(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
var ISOWeekYearParser = /* @__PURE__ */ (function(_Parser) {
  _inherits$r(ISOWeekYearParser2, _Parser);
  var _super = _createSuper$r(ISOWeekYearParser2);
  function ISOWeekYearParser2() {
    var _this;
    _classCallCheck$r(this, ISOWeekYearParser2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty$r(_assertThisInitialized$r(_this), "priority", 130);
    _defineProperty$r(_assertThisInitialized$r(_this), "incompatibleTokens", ["G", "y", "Y", "u", "Q", "q", "M", "L", "w", "d", "D", "e", "c", "t", "T"]);
    return _this;
  }
  _createClass$r(ISOWeekYearParser2, [{
    key: "parse",
    value: function parse2(dateString, token) {
      if (token === "R") {
        return parseNDigitsSigned(4, dateString);
      }
      return parseNDigitsSigned(token.length, dateString);
    }
  }, {
    key: "set",
    value: function set2(_date, _flags, value) {
      var firstWeekOfYear = /* @__PURE__ */ new Date(0);
      firstWeekOfYear.setUTCFullYear(value, 0, 4);
      firstWeekOfYear.setUTCHours(0, 0, 0, 0);
      return startOfUTCISOWeek(firstWeekOfYear);
    }
  }]);
  return ISOWeekYearParser2;
})(Parser);
function _typeof$r(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof$r = function _typeof2(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof$r = function _typeof2(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof$r(obj);
}
function _classCallCheck$q(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$q(target, props) {
  for (var i2 = 0; i2 < props.length; i2++) {
    var descriptor = props[i2];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$q(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties$q(Constructor.prototype, protoProps);
  return Constructor;
}
function _inherits$q(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
  if (superClass) _setPrototypeOf$q(subClass, superClass);
}
function _setPrototypeOf$q(o, p) {
  _setPrototypeOf$q = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
    o2.__proto__ = p2;
    return o2;
  };
  return _setPrototypeOf$q(o, p);
}
function _createSuper$q(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$q();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$q(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$q(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$q(this, result);
  };
}
function _possibleConstructorReturn$q(self2, call) {
  if (call && (_typeof$r(call) === "object" || typeof call === "function")) {
    return call;
  }
  return _assertThisInitialized$q(self2);
}
function _assertThisInitialized$q(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _isNativeReflectConstruct$q() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e2) {
    return false;
  }
}
function _getPrototypeOf$q(o) {
  _getPrototypeOf$q = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf$q(o);
}
function _defineProperty$q(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
var ExtendedYearParser = /* @__PURE__ */ (function(_Parser) {
  _inherits$q(ExtendedYearParser2, _Parser);
  var _super = _createSuper$q(ExtendedYearParser2);
  function ExtendedYearParser2() {
    var _this;
    _classCallCheck$q(this, ExtendedYearParser2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty$q(_assertThisInitialized$q(_this), "priority", 130);
    _defineProperty$q(_assertThisInitialized$q(_this), "incompatibleTokens", ["G", "y", "Y", "R", "w", "I", "i", "e", "c", "t", "T"]);
    return _this;
  }
  _createClass$q(ExtendedYearParser2, [{
    key: "parse",
    value: function parse2(dateString, token) {
      if (token === "u") {
        return parseNDigitsSigned(4, dateString);
      }
      return parseNDigitsSigned(token.length, dateString);
    }
  }, {
    key: "set",
    value: function set2(date, _flags, value) {
      date.setUTCFullYear(value, 0, 1);
      date.setUTCHours(0, 0, 0, 0);
      return date;
    }
  }]);
  return ExtendedYearParser2;
})(Parser);
function _typeof$q(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof$q = function _typeof2(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof$q = function _typeof2(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof$q(obj);
}
function _classCallCheck$p(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$p(target, props) {
  for (var i2 = 0; i2 < props.length; i2++) {
    var descriptor = props[i2];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$p(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties$p(Constructor.prototype, protoProps);
  return Constructor;
}
function _inherits$p(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
  if (superClass) _setPrototypeOf$p(subClass, superClass);
}
function _setPrototypeOf$p(o, p) {
  _setPrototypeOf$p = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
    o2.__proto__ = p2;
    return o2;
  };
  return _setPrototypeOf$p(o, p);
}
function _createSuper$p(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$p();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$p(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$p(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$p(this, result);
  };
}
function _possibleConstructorReturn$p(self2, call) {
  if (call && (_typeof$q(call) === "object" || typeof call === "function")) {
    return call;
  }
  return _assertThisInitialized$p(self2);
}
function _assertThisInitialized$p(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _isNativeReflectConstruct$p() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e2) {
    return false;
  }
}
function _getPrototypeOf$p(o) {
  _getPrototypeOf$p = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf$p(o);
}
function _defineProperty$p(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
var QuarterParser = /* @__PURE__ */ (function(_Parser) {
  _inherits$p(QuarterParser2, _Parser);
  var _super = _createSuper$p(QuarterParser2);
  function QuarterParser2() {
    var _this;
    _classCallCheck$p(this, QuarterParser2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty$p(_assertThisInitialized$p(_this), "priority", 120);
    _defineProperty$p(_assertThisInitialized$p(_this), "incompatibleTokens", ["Y", "R", "q", "M", "L", "w", "I", "d", "D", "i", "e", "c", "t", "T"]);
    return _this;
  }
  _createClass$p(QuarterParser2, [{
    key: "parse",
    value: function parse2(dateString, token, match2) {
      switch (token) {
        // 1, 2, 3, 4
        case "Q":
        case "QQ":
          return parseNDigits(token.length, dateString);
        // 1st, 2nd, 3rd, 4th
        case "Qo":
          return match2.ordinalNumber(dateString, {
            unit: "quarter"
          });
        // Q1, Q2, Q3, Q4
        case "QQQ":
          return match2.quarter(dateString, {
            width: "abbreviated",
            context: "formatting"
          }) || match2.quarter(dateString, {
            width: "narrow",
            context: "formatting"
          });
        // 1, 2, 3, 4 (narrow quarter; could be not numerical)
        case "QQQQQ":
          return match2.quarter(dateString, {
            width: "narrow",
            context: "formatting"
          });
        // 1st quarter, 2nd quarter, ...
        case "QQQQ":
        default:
          return match2.quarter(dateString, {
            width: "wide",
            context: "formatting"
          }) || match2.quarter(dateString, {
            width: "abbreviated",
            context: "formatting"
          }) || match2.quarter(dateString, {
            width: "narrow",
            context: "formatting"
          });
      }
    }
  }, {
    key: "validate",
    value: function validate(_date, value) {
      return value >= 1 && value <= 4;
    }
  }, {
    key: "set",
    value: function set2(date, _flags, value) {
      date.setUTCMonth((value - 1) * 3, 1);
      date.setUTCHours(0, 0, 0, 0);
      return date;
    }
  }]);
  return QuarterParser2;
})(Parser);
function _typeof$p(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof$p = function _typeof2(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof$p = function _typeof2(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof$p(obj);
}
function _classCallCheck$o(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$o(target, props) {
  for (var i2 = 0; i2 < props.length; i2++) {
    var descriptor = props[i2];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$o(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties$o(Constructor.prototype, protoProps);
  return Constructor;
}
function _inherits$o(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
  if (superClass) _setPrototypeOf$o(subClass, superClass);
}
function _setPrototypeOf$o(o, p) {
  _setPrototypeOf$o = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
    o2.__proto__ = p2;
    return o2;
  };
  return _setPrototypeOf$o(o, p);
}
function _createSuper$o(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$o();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$o(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$o(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$o(this, result);
  };
}
function _possibleConstructorReturn$o(self2, call) {
  if (call && (_typeof$p(call) === "object" || typeof call === "function")) {
    return call;
  }
  return _assertThisInitialized$o(self2);
}
function _assertThisInitialized$o(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _isNativeReflectConstruct$o() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e2) {
    return false;
  }
}
function _getPrototypeOf$o(o) {
  _getPrototypeOf$o = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf$o(o);
}
function _defineProperty$o(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
var StandAloneQuarterParser = /* @__PURE__ */ (function(_Parser) {
  _inherits$o(StandAloneQuarterParser2, _Parser);
  var _super = _createSuper$o(StandAloneQuarterParser2);
  function StandAloneQuarterParser2() {
    var _this;
    _classCallCheck$o(this, StandAloneQuarterParser2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty$o(_assertThisInitialized$o(_this), "priority", 120);
    _defineProperty$o(_assertThisInitialized$o(_this), "incompatibleTokens", ["Y", "R", "Q", "M", "L", "w", "I", "d", "D", "i", "e", "c", "t", "T"]);
    return _this;
  }
  _createClass$o(StandAloneQuarterParser2, [{
    key: "parse",
    value: function parse2(dateString, token, match2) {
      switch (token) {
        // 1, 2, 3, 4
        case "q":
        case "qq":
          return parseNDigits(token.length, dateString);
        // 1st, 2nd, 3rd, 4th
        case "qo":
          return match2.ordinalNumber(dateString, {
            unit: "quarter"
          });
        // Q1, Q2, Q3, Q4
        case "qqq":
          return match2.quarter(dateString, {
            width: "abbreviated",
            context: "standalone"
          }) || match2.quarter(dateString, {
            width: "narrow",
            context: "standalone"
          });
        // 1, 2, 3, 4 (narrow quarter; could be not numerical)
        case "qqqqq":
          return match2.quarter(dateString, {
            width: "narrow",
            context: "standalone"
          });
        // 1st quarter, 2nd quarter, ...
        case "qqqq":
        default:
          return match2.quarter(dateString, {
            width: "wide",
            context: "standalone"
          }) || match2.quarter(dateString, {
            width: "abbreviated",
            context: "standalone"
          }) || match2.quarter(dateString, {
            width: "narrow",
            context: "standalone"
          });
      }
    }
  }, {
    key: "validate",
    value: function validate(_date, value) {
      return value >= 1 && value <= 4;
    }
  }, {
    key: "set",
    value: function set2(date, _flags, value) {
      date.setUTCMonth((value - 1) * 3, 1);
      date.setUTCHours(0, 0, 0, 0);
      return date;
    }
  }]);
  return StandAloneQuarterParser2;
})(Parser);
function _typeof$o(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof$o = function _typeof2(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof$o = function _typeof2(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof$o(obj);
}
function _classCallCheck$n(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$n(target, props) {
  for (var i2 = 0; i2 < props.length; i2++) {
    var descriptor = props[i2];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$n(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties$n(Constructor.prototype, protoProps);
  return Constructor;
}
function _inherits$n(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
  if (superClass) _setPrototypeOf$n(subClass, superClass);
}
function _setPrototypeOf$n(o, p) {
  _setPrototypeOf$n = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
    o2.__proto__ = p2;
    return o2;
  };
  return _setPrototypeOf$n(o, p);
}
function _createSuper$n(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$n();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$n(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$n(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$n(this, result);
  };
}
function _possibleConstructorReturn$n(self2, call) {
  if (call && (_typeof$o(call) === "object" || typeof call === "function")) {
    return call;
  }
  return _assertThisInitialized$n(self2);
}
function _assertThisInitialized$n(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _isNativeReflectConstruct$n() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e2) {
    return false;
  }
}
function _getPrototypeOf$n(o) {
  _getPrototypeOf$n = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf$n(o);
}
function _defineProperty$n(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
var MonthParser = /* @__PURE__ */ (function(_Parser) {
  _inherits$n(MonthParser2, _Parser);
  var _super = _createSuper$n(MonthParser2);
  function MonthParser2() {
    var _this;
    _classCallCheck$n(this, MonthParser2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty$n(_assertThisInitialized$n(_this), "incompatibleTokens", ["Y", "R", "q", "Q", "L", "w", "I", "D", "i", "e", "c", "t", "T"]);
    _defineProperty$n(_assertThisInitialized$n(_this), "priority", 110);
    return _this;
  }
  _createClass$n(MonthParser2, [{
    key: "parse",
    value: function parse2(dateString, token, match2) {
      var valueCallback3 = function valueCallback4(value) {
        return value - 1;
      };
      switch (token) {
        // 1, 2, ..., 12
        case "M":
          return mapValue(parseNumericPattern(numericPatterns.month, dateString), valueCallback3);
        // 01, 02, ..., 12
        case "MM":
          return mapValue(parseNDigits(2, dateString), valueCallback3);
        // 1st, 2nd, ..., 12th
        case "Mo":
          return mapValue(match2.ordinalNumber(dateString, {
            unit: "month"
          }), valueCallback3);
        // Jan, Feb, ..., Dec
        case "MMM":
          return match2.month(dateString, {
            width: "abbreviated",
            context: "formatting"
          }) || match2.month(dateString, {
            width: "narrow",
            context: "formatting"
          });
        // J, F, ..., D
        case "MMMMM":
          return match2.month(dateString, {
            width: "narrow",
            context: "formatting"
          });
        // January, February, ..., December
        case "MMMM":
        default:
          return match2.month(dateString, {
            width: "wide",
            context: "formatting"
          }) || match2.month(dateString, {
            width: "abbreviated",
            context: "formatting"
          }) || match2.month(dateString, {
            width: "narrow",
            context: "formatting"
          });
      }
    }
  }, {
    key: "validate",
    value: function validate(_date, value) {
      return value >= 0 && value <= 11;
    }
  }, {
    key: "set",
    value: function set2(date, _flags, value) {
      date.setUTCMonth(value, 1);
      date.setUTCHours(0, 0, 0, 0);
      return date;
    }
  }]);
  return MonthParser2;
})(Parser);
function _typeof$n(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof$n = function _typeof2(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof$n = function _typeof2(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof$n(obj);
}
function _classCallCheck$m(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$m(target, props) {
  for (var i2 = 0; i2 < props.length; i2++) {
    var descriptor = props[i2];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$m(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties$m(Constructor.prototype, protoProps);
  return Constructor;
}
function _inherits$m(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
  if (superClass) _setPrototypeOf$m(subClass, superClass);
}
function _setPrototypeOf$m(o, p) {
  _setPrototypeOf$m = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
    o2.__proto__ = p2;
    return o2;
  };
  return _setPrototypeOf$m(o, p);
}
function _createSuper$m(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$m();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$m(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$m(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$m(this, result);
  };
}
function _possibleConstructorReturn$m(self2, call) {
  if (call && (_typeof$n(call) === "object" || typeof call === "function")) {
    return call;
  }
  return _assertThisInitialized$m(self2);
}
function _assertThisInitialized$m(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _isNativeReflectConstruct$m() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e2) {
    return false;
  }
}
function _getPrototypeOf$m(o) {
  _getPrototypeOf$m = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf$m(o);
}
function _defineProperty$m(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
var StandAloneMonthParser = /* @__PURE__ */ (function(_Parser) {
  _inherits$m(StandAloneMonthParser2, _Parser);
  var _super = _createSuper$m(StandAloneMonthParser2);
  function StandAloneMonthParser2() {
    var _this;
    _classCallCheck$m(this, StandAloneMonthParser2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty$m(_assertThisInitialized$m(_this), "priority", 110);
    _defineProperty$m(_assertThisInitialized$m(_this), "incompatibleTokens", ["Y", "R", "q", "Q", "M", "w", "I", "D", "i", "e", "c", "t", "T"]);
    return _this;
  }
  _createClass$m(StandAloneMonthParser2, [{
    key: "parse",
    value: function parse2(dateString, token, match2) {
      var valueCallback3 = function valueCallback4(value) {
        return value - 1;
      };
      switch (token) {
        // 1, 2, ..., 12
        case "L":
          return mapValue(parseNumericPattern(numericPatterns.month, dateString), valueCallback3);
        // 01, 02, ..., 12
        case "LL":
          return mapValue(parseNDigits(2, dateString), valueCallback3);
        // 1st, 2nd, ..., 12th
        case "Lo":
          return mapValue(match2.ordinalNumber(dateString, {
            unit: "month"
          }), valueCallback3);
        // Jan, Feb, ..., Dec
        case "LLL":
          return match2.month(dateString, {
            width: "abbreviated",
            context: "standalone"
          }) || match2.month(dateString, {
            width: "narrow",
            context: "standalone"
          });
        // J, F, ..., D
        case "LLLLL":
          return match2.month(dateString, {
            width: "narrow",
            context: "standalone"
          });
        // January, February, ..., December
        case "LLLL":
        default:
          return match2.month(dateString, {
            width: "wide",
            context: "standalone"
          }) || match2.month(dateString, {
            width: "abbreviated",
            context: "standalone"
          }) || match2.month(dateString, {
            width: "narrow",
            context: "standalone"
          });
      }
    }
  }, {
    key: "validate",
    value: function validate(_date, value) {
      return value >= 0 && value <= 11;
    }
  }, {
    key: "set",
    value: function set2(date, _flags, value) {
      date.setUTCMonth(value, 1);
      date.setUTCHours(0, 0, 0, 0);
      return date;
    }
  }]);
  return StandAloneMonthParser2;
})(Parser);
function setUTCWeek(dirtyDate, dirtyWeek, options) {
  requiredArgs(2, arguments);
  var date = toDate(dirtyDate);
  var week = toInteger(dirtyWeek);
  var diff = getUTCWeek(date, options) - week;
  date.setUTCDate(date.getUTCDate() - diff * 7);
  return date;
}
function _typeof$m(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof$m = function _typeof2(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof$m = function _typeof2(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof$m(obj);
}
function _classCallCheck$l(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$l(target, props) {
  for (var i2 = 0; i2 < props.length; i2++) {
    var descriptor = props[i2];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$l(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties$l(Constructor.prototype, protoProps);
  return Constructor;
}
function _inherits$l(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
  if (superClass) _setPrototypeOf$l(subClass, superClass);
}
function _setPrototypeOf$l(o, p) {
  _setPrototypeOf$l = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
    o2.__proto__ = p2;
    return o2;
  };
  return _setPrototypeOf$l(o, p);
}
function _createSuper$l(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$l();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$l(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$l(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$l(this, result);
  };
}
function _possibleConstructorReturn$l(self2, call) {
  if (call && (_typeof$m(call) === "object" || typeof call === "function")) {
    return call;
  }
  return _assertThisInitialized$l(self2);
}
function _assertThisInitialized$l(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _isNativeReflectConstruct$l() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e2) {
    return false;
  }
}
function _getPrototypeOf$l(o) {
  _getPrototypeOf$l = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf$l(o);
}
function _defineProperty$l(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
var LocalWeekParser = /* @__PURE__ */ (function(_Parser) {
  _inherits$l(LocalWeekParser2, _Parser);
  var _super = _createSuper$l(LocalWeekParser2);
  function LocalWeekParser2() {
    var _this;
    _classCallCheck$l(this, LocalWeekParser2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty$l(_assertThisInitialized$l(_this), "priority", 100);
    _defineProperty$l(_assertThisInitialized$l(_this), "incompatibleTokens", ["y", "R", "u", "q", "Q", "M", "L", "I", "d", "D", "i", "t", "T"]);
    return _this;
  }
  _createClass$l(LocalWeekParser2, [{
    key: "parse",
    value: function parse2(dateString, token, match2) {
      switch (token) {
        case "w":
          return parseNumericPattern(numericPatterns.week, dateString);
        case "wo":
          return match2.ordinalNumber(dateString, {
            unit: "week"
          });
        default:
          return parseNDigits(token.length, dateString);
      }
    }
  }, {
    key: "validate",
    value: function validate(_date, value) {
      return value >= 1 && value <= 53;
    }
  }, {
    key: "set",
    value: function set2(date, _flags, value, options) {
      return startOfUTCWeek(setUTCWeek(date, value, options), options);
    }
  }]);
  return LocalWeekParser2;
})(Parser);
function setUTCISOWeek(dirtyDate, dirtyISOWeek) {
  requiredArgs(2, arguments);
  var date = toDate(dirtyDate);
  var isoWeek = toInteger(dirtyISOWeek);
  var diff = getUTCISOWeek(date) - isoWeek;
  date.setUTCDate(date.getUTCDate() - diff * 7);
  return date;
}
function _typeof$l(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof$l = function _typeof2(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof$l = function _typeof2(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof$l(obj);
}
function _classCallCheck$k(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$k(target, props) {
  for (var i2 = 0; i2 < props.length; i2++) {
    var descriptor = props[i2];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$k(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties$k(Constructor.prototype, protoProps);
  return Constructor;
}
function _inherits$k(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
  if (superClass) _setPrototypeOf$k(subClass, superClass);
}
function _setPrototypeOf$k(o, p) {
  _setPrototypeOf$k = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
    o2.__proto__ = p2;
    return o2;
  };
  return _setPrototypeOf$k(o, p);
}
function _createSuper$k(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$k();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$k(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$k(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$k(this, result);
  };
}
function _possibleConstructorReturn$k(self2, call) {
  if (call && (_typeof$l(call) === "object" || typeof call === "function")) {
    return call;
  }
  return _assertThisInitialized$k(self2);
}
function _assertThisInitialized$k(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _isNativeReflectConstruct$k() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e2) {
    return false;
  }
}
function _getPrototypeOf$k(o) {
  _getPrototypeOf$k = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf$k(o);
}
function _defineProperty$k(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
var ISOWeekParser = /* @__PURE__ */ (function(_Parser) {
  _inherits$k(ISOWeekParser2, _Parser);
  var _super = _createSuper$k(ISOWeekParser2);
  function ISOWeekParser2() {
    var _this;
    _classCallCheck$k(this, ISOWeekParser2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty$k(_assertThisInitialized$k(_this), "priority", 100);
    _defineProperty$k(_assertThisInitialized$k(_this), "incompatibleTokens", ["y", "Y", "u", "q", "Q", "M", "L", "w", "d", "D", "e", "c", "t", "T"]);
    return _this;
  }
  _createClass$k(ISOWeekParser2, [{
    key: "parse",
    value: function parse2(dateString, token, match2) {
      switch (token) {
        case "I":
          return parseNumericPattern(numericPatterns.week, dateString);
        case "Io":
          return match2.ordinalNumber(dateString, {
            unit: "week"
          });
        default:
          return parseNDigits(token.length, dateString);
      }
    }
  }, {
    key: "validate",
    value: function validate(_date, value) {
      return value >= 1 && value <= 53;
    }
  }, {
    key: "set",
    value: function set2(date, _flags, value) {
      return startOfUTCISOWeek(setUTCISOWeek(date, value));
    }
  }]);
  return ISOWeekParser2;
})(Parser);
function _typeof$k(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof$k = function _typeof2(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof$k = function _typeof2(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof$k(obj);
}
function _classCallCheck$j(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$j(target, props) {
  for (var i2 = 0; i2 < props.length; i2++) {
    var descriptor = props[i2];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$j(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties$j(Constructor.prototype, protoProps);
  return Constructor;
}
function _inherits$j(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
  if (superClass) _setPrototypeOf$j(subClass, superClass);
}
function _setPrototypeOf$j(o, p) {
  _setPrototypeOf$j = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
    o2.__proto__ = p2;
    return o2;
  };
  return _setPrototypeOf$j(o, p);
}
function _createSuper$j(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$j();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$j(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$j(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$j(this, result);
  };
}
function _possibleConstructorReturn$j(self2, call) {
  if (call && (_typeof$k(call) === "object" || typeof call === "function")) {
    return call;
  }
  return _assertThisInitialized$j(self2);
}
function _assertThisInitialized$j(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _isNativeReflectConstruct$j() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e2) {
    return false;
  }
}
function _getPrototypeOf$j(o) {
  _getPrototypeOf$j = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf$j(o);
}
function _defineProperty$j(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
var DAYS_IN_MONTH = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
var DAYS_IN_MONTH_LEAP_YEAR = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
var DateParser = /* @__PURE__ */ (function(_Parser) {
  _inherits$j(DateParser2, _Parser);
  var _super = _createSuper$j(DateParser2);
  function DateParser2() {
    var _this;
    _classCallCheck$j(this, DateParser2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty$j(_assertThisInitialized$j(_this), "priority", 90);
    _defineProperty$j(_assertThisInitialized$j(_this), "subPriority", 1);
    _defineProperty$j(_assertThisInitialized$j(_this), "incompatibleTokens", ["Y", "R", "q", "Q", "w", "I", "D", "i", "e", "c", "t", "T"]);
    return _this;
  }
  _createClass$j(DateParser2, [{
    key: "parse",
    value: function parse2(dateString, token, match2) {
      switch (token) {
        case "d":
          return parseNumericPattern(numericPatterns.date, dateString);
        case "do":
          return match2.ordinalNumber(dateString, {
            unit: "date"
          });
        default:
          return parseNDigits(token.length, dateString);
      }
    }
  }, {
    key: "validate",
    value: function validate(date, value) {
      var year = date.getUTCFullYear();
      var isLeapYear = isLeapYearIndex(year);
      var month = date.getUTCMonth();
      if (isLeapYear) {
        return value >= 1 && value <= DAYS_IN_MONTH_LEAP_YEAR[month];
      } else {
        return value >= 1 && value <= DAYS_IN_MONTH[month];
      }
    }
  }, {
    key: "set",
    value: function set2(date, _flags, value) {
      date.setUTCDate(value);
      date.setUTCHours(0, 0, 0, 0);
      return date;
    }
  }]);
  return DateParser2;
})(Parser);
function _typeof$j(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof$j = function _typeof2(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof$j = function _typeof2(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof$j(obj);
}
function _classCallCheck$i(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$i(target, props) {
  for (var i2 = 0; i2 < props.length; i2++) {
    var descriptor = props[i2];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$i(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties$i(Constructor.prototype, protoProps);
  return Constructor;
}
function _inherits$i(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
  if (superClass) _setPrototypeOf$i(subClass, superClass);
}
function _setPrototypeOf$i(o, p) {
  _setPrototypeOf$i = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
    o2.__proto__ = p2;
    return o2;
  };
  return _setPrototypeOf$i(o, p);
}
function _createSuper$i(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$i();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$i(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$i(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$i(this, result);
  };
}
function _possibleConstructorReturn$i(self2, call) {
  if (call && (_typeof$j(call) === "object" || typeof call === "function")) {
    return call;
  }
  return _assertThisInitialized$i(self2);
}
function _assertThisInitialized$i(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _isNativeReflectConstruct$i() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e2) {
    return false;
  }
}
function _getPrototypeOf$i(o) {
  _getPrototypeOf$i = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf$i(o);
}
function _defineProperty$i(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
var DayOfYearParser = /* @__PURE__ */ (function(_Parser) {
  _inherits$i(DayOfYearParser2, _Parser);
  var _super = _createSuper$i(DayOfYearParser2);
  function DayOfYearParser2() {
    var _this;
    _classCallCheck$i(this, DayOfYearParser2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty$i(_assertThisInitialized$i(_this), "priority", 90);
    _defineProperty$i(_assertThisInitialized$i(_this), "subpriority", 1);
    _defineProperty$i(_assertThisInitialized$i(_this), "incompatibleTokens", ["Y", "R", "q", "Q", "M", "L", "w", "I", "d", "E", "i", "e", "c", "t", "T"]);
    return _this;
  }
  _createClass$i(DayOfYearParser2, [{
    key: "parse",
    value: function parse2(dateString, token, match2) {
      switch (token) {
        case "D":
        case "DD":
          return parseNumericPattern(numericPatterns.dayOfYear, dateString);
        case "Do":
          return match2.ordinalNumber(dateString, {
            unit: "date"
          });
        default:
          return parseNDigits(token.length, dateString);
      }
    }
  }, {
    key: "validate",
    value: function validate(date, value) {
      var year = date.getUTCFullYear();
      var isLeapYear = isLeapYearIndex(year);
      if (isLeapYear) {
        return value >= 1 && value <= 366;
      } else {
        return value >= 1 && value <= 365;
      }
    }
  }, {
    key: "set",
    value: function set2(date, _flags, value) {
      date.setUTCMonth(0, value);
      date.setUTCHours(0, 0, 0, 0);
      return date;
    }
  }]);
  return DayOfYearParser2;
})(Parser);
function setUTCDay(dirtyDate, dirtyDay, options) {
  var _ref, _ref2, _ref3, _options$weekStartsOn, _options$locale, _options$locale$optio, _defaultOptions$local, _defaultOptions$local2;
  requiredArgs(2, arguments);
  var defaultOptions2 = getDefaultOptions();
  var weekStartsOn = toInteger((_ref = (_ref2 = (_ref3 = (_options$weekStartsOn = options === null || options === void 0 ? void 0 : options.weekStartsOn) !== null && _options$weekStartsOn !== void 0 ? _options$weekStartsOn : options === null || options === void 0 ? void 0 : (_options$locale = options.locale) === null || _options$locale === void 0 ? void 0 : (_options$locale$optio = _options$locale.options) === null || _options$locale$optio === void 0 ? void 0 : _options$locale$optio.weekStartsOn) !== null && _ref3 !== void 0 ? _ref3 : defaultOptions2.weekStartsOn) !== null && _ref2 !== void 0 ? _ref2 : (_defaultOptions$local = defaultOptions2.locale) === null || _defaultOptions$local === void 0 ? void 0 : (_defaultOptions$local2 = _defaultOptions$local.options) === null || _defaultOptions$local2 === void 0 ? void 0 : _defaultOptions$local2.weekStartsOn) !== null && _ref !== void 0 ? _ref : 0);
  if (!(weekStartsOn >= 0 && weekStartsOn <= 6)) {
    throw new RangeError("weekStartsOn must be between 0 and 6 inclusively");
  }
  var date = toDate(dirtyDate);
  var day = toInteger(dirtyDay);
  var currentDay = date.getUTCDay();
  var remainder = day % 7;
  var dayIndex = (remainder + 7) % 7;
  var diff = (dayIndex < weekStartsOn ? 7 : 0) + day - currentDay;
  date.setUTCDate(date.getUTCDate() + diff);
  return date;
}
function _typeof$i(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof$i = function _typeof2(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof$i = function _typeof2(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof$i(obj);
}
function _classCallCheck$h(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$h(target, props) {
  for (var i2 = 0; i2 < props.length; i2++) {
    var descriptor = props[i2];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$h(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties$h(Constructor.prototype, protoProps);
  return Constructor;
}
function _inherits$h(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
  if (superClass) _setPrototypeOf$h(subClass, superClass);
}
function _setPrototypeOf$h(o, p) {
  _setPrototypeOf$h = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
    o2.__proto__ = p2;
    return o2;
  };
  return _setPrototypeOf$h(o, p);
}
function _createSuper$h(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$h();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$h(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$h(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$h(this, result);
  };
}
function _possibleConstructorReturn$h(self2, call) {
  if (call && (_typeof$i(call) === "object" || typeof call === "function")) {
    return call;
  }
  return _assertThisInitialized$h(self2);
}
function _assertThisInitialized$h(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _isNativeReflectConstruct$h() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e2) {
    return false;
  }
}
function _getPrototypeOf$h(o) {
  _getPrototypeOf$h = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf$h(o);
}
function _defineProperty$h(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
var DayParser = /* @__PURE__ */ (function(_Parser) {
  _inherits$h(DayParser2, _Parser);
  var _super = _createSuper$h(DayParser2);
  function DayParser2() {
    var _this;
    _classCallCheck$h(this, DayParser2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty$h(_assertThisInitialized$h(_this), "priority", 90);
    _defineProperty$h(_assertThisInitialized$h(_this), "incompatibleTokens", ["D", "i", "e", "c", "t", "T"]);
    return _this;
  }
  _createClass$h(DayParser2, [{
    key: "parse",
    value: function parse2(dateString, token, match2) {
      switch (token) {
        // Tue
        case "E":
        case "EE":
        case "EEE":
          return match2.day(dateString, {
            width: "abbreviated",
            context: "formatting"
          }) || match2.day(dateString, {
            width: "short",
            context: "formatting"
          }) || match2.day(dateString, {
            width: "narrow",
            context: "formatting"
          });
        // T
        case "EEEEE":
          return match2.day(dateString, {
            width: "narrow",
            context: "formatting"
          });
        // Tu
        case "EEEEEE":
          return match2.day(dateString, {
            width: "short",
            context: "formatting"
          }) || match2.day(dateString, {
            width: "narrow",
            context: "formatting"
          });
        // Tuesday
        case "EEEE":
        default:
          return match2.day(dateString, {
            width: "wide",
            context: "formatting"
          }) || match2.day(dateString, {
            width: "abbreviated",
            context: "formatting"
          }) || match2.day(dateString, {
            width: "short",
            context: "formatting"
          }) || match2.day(dateString, {
            width: "narrow",
            context: "formatting"
          });
      }
    }
  }, {
    key: "validate",
    value: function validate(_date, value) {
      return value >= 0 && value <= 6;
    }
  }, {
    key: "set",
    value: function set2(date, _flags, value, options) {
      date = setUTCDay(date, value, options);
      date.setUTCHours(0, 0, 0, 0);
      return date;
    }
  }]);
  return DayParser2;
})(Parser);
function _typeof$h(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof$h = function _typeof2(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof$h = function _typeof2(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof$h(obj);
}
function _classCallCheck$g(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$g(target, props) {
  for (var i2 = 0; i2 < props.length; i2++) {
    var descriptor = props[i2];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$g(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties$g(Constructor.prototype, protoProps);
  return Constructor;
}
function _inherits$g(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
  if (superClass) _setPrototypeOf$g(subClass, superClass);
}
function _setPrototypeOf$g(o, p) {
  _setPrototypeOf$g = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
    o2.__proto__ = p2;
    return o2;
  };
  return _setPrototypeOf$g(o, p);
}
function _createSuper$g(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$g();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$g(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$g(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$g(this, result);
  };
}
function _possibleConstructorReturn$g(self2, call) {
  if (call && (_typeof$h(call) === "object" || typeof call === "function")) {
    return call;
  }
  return _assertThisInitialized$g(self2);
}
function _assertThisInitialized$g(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _isNativeReflectConstruct$g() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e2) {
    return false;
  }
}
function _getPrototypeOf$g(o) {
  _getPrototypeOf$g = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf$g(o);
}
function _defineProperty$g(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
var LocalDayParser = /* @__PURE__ */ (function(_Parser) {
  _inherits$g(LocalDayParser2, _Parser);
  var _super = _createSuper$g(LocalDayParser2);
  function LocalDayParser2() {
    var _this;
    _classCallCheck$g(this, LocalDayParser2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty$g(_assertThisInitialized$g(_this), "priority", 90);
    _defineProperty$g(_assertThisInitialized$g(_this), "incompatibleTokens", ["y", "R", "u", "q", "Q", "M", "L", "I", "d", "D", "E", "i", "c", "t", "T"]);
    return _this;
  }
  _createClass$g(LocalDayParser2, [{
    key: "parse",
    value: function parse2(dateString, token, match2, options) {
      var valueCallback3 = function valueCallback4(value) {
        var wholeWeekDays = Math.floor((value - 1) / 7) * 7;
        return (value + options.weekStartsOn + 6) % 7 + wholeWeekDays;
      };
      switch (token) {
        // 3
        case "e":
        case "ee":
          return mapValue(parseNDigits(token.length, dateString), valueCallback3);
        // 3rd
        case "eo":
          return mapValue(match2.ordinalNumber(dateString, {
            unit: "day"
          }), valueCallback3);
        // Tue
        case "eee":
          return match2.day(dateString, {
            width: "abbreviated",
            context: "formatting"
          }) || match2.day(dateString, {
            width: "short",
            context: "formatting"
          }) || match2.day(dateString, {
            width: "narrow",
            context: "formatting"
          });
        // T
        case "eeeee":
          return match2.day(dateString, {
            width: "narrow",
            context: "formatting"
          });
        // Tu
        case "eeeeee":
          return match2.day(dateString, {
            width: "short",
            context: "formatting"
          }) || match2.day(dateString, {
            width: "narrow",
            context: "formatting"
          });
        // Tuesday
        case "eeee":
        default:
          return match2.day(dateString, {
            width: "wide",
            context: "formatting"
          }) || match2.day(dateString, {
            width: "abbreviated",
            context: "formatting"
          }) || match2.day(dateString, {
            width: "short",
            context: "formatting"
          }) || match2.day(dateString, {
            width: "narrow",
            context: "formatting"
          });
      }
    }
  }, {
    key: "validate",
    value: function validate(_date, value) {
      return value >= 0 && value <= 6;
    }
  }, {
    key: "set",
    value: function set2(date, _flags, value, options) {
      date = setUTCDay(date, value, options);
      date.setUTCHours(0, 0, 0, 0);
      return date;
    }
  }]);
  return LocalDayParser2;
})(Parser);
function _typeof$g(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof$g = function _typeof2(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof$g = function _typeof2(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof$g(obj);
}
function _classCallCheck$f(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$f(target, props) {
  for (var i2 = 0; i2 < props.length; i2++) {
    var descriptor = props[i2];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$f(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties$f(Constructor.prototype, protoProps);
  return Constructor;
}
function _inherits$f(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
  if (superClass) _setPrototypeOf$f(subClass, superClass);
}
function _setPrototypeOf$f(o, p) {
  _setPrototypeOf$f = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
    o2.__proto__ = p2;
    return o2;
  };
  return _setPrototypeOf$f(o, p);
}
function _createSuper$f(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$f();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$f(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$f(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$f(this, result);
  };
}
function _possibleConstructorReturn$f(self2, call) {
  if (call && (_typeof$g(call) === "object" || typeof call === "function")) {
    return call;
  }
  return _assertThisInitialized$f(self2);
}
function _assertThisInitialized$f(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _isNativeReflectConstruct$f() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e2) {
    return false;
  }
}
function _getPrototypeOf$f(o) {
  _getPrototypeOf$f = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf$f(o);
}
function _defineProperty$f(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
var StandAloneLocalDayParser = /* @__PURE__ */ (function(_Parser) {
  _inherits$f(StandAloneLocalDayParser2, _Parser);
  var _super = _createSuper$f(StandAloneLocalDayParser2);
  function StandAloneLocalDayParser2() {
    var _this;
    _classCallCheck$f(this, StandAloneLocalDayParser2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty$f(_assertThisInitialized$f(_this), "priority", 90);
    _defineProperty$f(_assertThisInitialized$f(_this), "incompatibleTokens", ["y", "R", "u", "q", "Q", "M", "L", "I", "d", "D", "E", "i", "e", "t", "T"]);
    return _this;
  }
  _createClass$f(StandAloneLocalDayParser2, [{
    key: "parse",
    value: function parse2(dateString, token, match2, options) {
      var valueCallback3 = function valueCallback4(value) {
        var wholeWeekDays = Math.floor((value - 1) / 7) * 7;
        return (value + options.weekStartsOn + 6) % 7 + wholeWeekDays;
      };
      switch (token) {
        // 3
        case "c":
        case "cc":
          return mapValue(parseNDigits(token.length, dateString), valueCallback3);
        // 3rd
        case "co":
          return mapValue(match2.ordinalNumber(dateString, {
            unit: "day"
          }), valueCallback3);
        // Tue
        case "ccc":
          return match2.day(dateString, {
            width: "abbreviated",
            context: "standalone"
          }) || match2.day(dateString, {
            width: "short",
            context: "standalone"
          }) || match2.day(dateString, {
            width: "narrow",
            context: "standalone"
          });
        // T
        case "ccccc":
          return match2.day(dateString, {
            width: "narrow",
            context: "standalone"
          });
        // Tu
        case "cccccc":
          return match2.day(dateString, {
            width: "short",
            context: "standalone"
          }) || match2.day(dateString, {
            width: "narrow",
            context: "standalone"
          });
        // Tuesday
        case "cccc":
        default:
          return match2.day(dateString, {
            width: "wide",
            context: "standalone"
          }) || match2.day(dateString, {
            width: "abbreviated",
            context: "standalone"
          }) || match2.day(dateString, {
            width: "short",
            context: "standalone"
          }) || match2.day(dateString, {
            width: "narrow",
            context: "standalone"
          });
      }
    }
  }, {
    key: "validate",
    value: function validate(_date, value) {
      return value >= 0 && value <= 6;
    }
  }, {
    key: "set",
    value: function set2(date, _flags, value, options) {
      date = setUTCDay(date, value, options);
      date.setUTCHours(0, 0, 0, 0);
      return date;
    }
  }]);
  return StandAloneLocalDayParser2;
})(Parser);
function setUTCISODay(dirtyDate, dirtyDay) {
  requiredArgs(2, arguments);
  var day = toInteger(dirtyDay);
  if (day % 7 === 0) {
    day = day - 7;
  }
  var weekStartsOn = 1;
  var date = toDate(dirtyDate);
  var currentDay = date.getUTCDay();
  var remainder = day % 7;
  var dayIndex = (remainder + 7) % 7;
  var diff = (dayIndex < weekStartsOn ? 7 : 0) + day - currentDay;
  date.setUTCDate(date.getUTCDate() + diff);
  return date;
}
function _typeof$f(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof$f = function _typeof2(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof$f = function _typeof2(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof$f(obj);
}
function _classCallCheck$e(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$e(target, props) {
  for (var i2 = 0; i2 < props.length; i2++) {
    var descriptor = props[i2];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$e(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties$e(Constructor.prototype, protoProps);
  return Constructor;
}
function _inherits$e(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
  if (superClass) _setPrototypeOf$e(subClass, superClass);
}
function _setPrototypeOf$e(o, p) {
  _setPrototypeOf$e = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
    o2.__proto__ = p2;
    return o2;
  };
  return _setPrototypeOf$e(o, p);
}
function _createSuper$e(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$e();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$e(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$e(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$e(this, result);
  };
}
function _possibleConstructorReturn$e(self2, call) {
  if (call && (_typeof$f(call) === "object" || typeof call === "function")) {
    return call;
  }
  return _assertThisInitialized$e(self2);
}
function _assertThisInitialized$e(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _isNativeReflectConstruct$e() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e2) {
    return false;
  }
}
function _getPrototypeOf$e(o) {
  _getPrototypeOf$e = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf$e(o);
}
function _defineProperty$e(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
var ISODayParser = /* @__PURE__ */ (function(_Parser) {
  _inherits$e(ISODayParser2, _Parser);
  var _super = _createSuper$e(ISODayParser2);
  function ISODayParser2() {
    var _this;
    _classCallCheck$e(this, ISODayParser2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty$e(_assertThisInitialized$e(_this), "priority", 90);
    _defineProperty$e(_assertThisInitialized$e(_this), "incompatibleTokens", ["y", "Y", "u", "q", "Q", "M", "L", "w", "d", "D", "E", "e", "c", "t", "T"]);
    return _this;
  }
  _createClass$e(ISODayParser2, [{
    key: "parse",
    value: function parse2(dateString, token, match2) {
      var valueCallback3 = function valueCallback4(value) {
        if (value === 0) {
          return 7;
        }
        return value;
      };
      switch (token) {
        // 2
        case "i":
        case "ii":
          return parseNDigits(token.length, dateString);
        // 2nd
        case "io":
          return match2.ordinalNumber(dateString, {
            unit: "day"
          });
        // Tue
        case "iii":
          return mapValue(match2.day(dateString, {
            width: "abbreviated",
            context: "formatting"
          }) || match2.day(dateString, {
            width: "short",
            context: "formatting"
          }) || match2.day(dateString, {
            width: "narrow",
            context: "formatting"
          }), valueCallback3);
        // T
        case "iiiii":
          return mapValue(match2.day(dateString, {
            width: "narrow",
            context: "formatting"
          }), valueCallback3);
        // Tu
        case "iiiiii":
          return mapValue(match2.day(dateString, {
            width: "short",
            context: "formatting"
          }) || match2.day(dateString, {
            width: "narrow",
            context: "formatting"
          }), valueCallback3);
        // Tuesday
        case "iiii":
        default:
          return mapValue(match2.day(dateString, {
            width: "wide",
            context: "formatting"
          }) || match2.day(dateString, {
            width: "abbreviated",
            context: "formatting"
          }) || match2.day(dateString, {
            width: "short",
            context: "formatting"
          }) || match2.day(dateString, {
            width: "narrow",
            context: "formatting"
          }), valueCallback3);
      }
    }
  }, {
    key: "validate",
    value: function validate(_date, value) {
      return value >= 1 && value <= 7;
    }
  }, {
    key: "set",
    value: function set2(date, _flags, value) {
      date = setUTCISODay(date, value);
      date.setUTCHours(0, 0, 0, 0);
      return date;
    }
  }]);
  return ISODayParser2;
})(Parser);
function _typeof$e(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof$e = function _typeof2(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof$e = function _typeof2(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof$e(obj);
}
function _classCallCheck$d(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$d(target, props) {
  for (var i2 = 0; i2 < props.length; i2++) {
    var descriptor = props[i2];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$d(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties$d(Constructor.prototype, protoProps);
  return Constructor;
}
function _inherits$d(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
  if (superClass) _setPrototypeOf$d(subClass, superClass);
}
function _setPrototypeOf$d(o, p) {
  _setPrototypeOf$d = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
    o2.__proto__ = p2;
    return o2;
  };
  return _setPrototypeOf$d(o, p);
}
function _createSuper$d(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$d();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$d(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$d(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$d(this, result);
  };
}
function _possibleConstructorReturn$d(self2, call) {
  if (call && (_typeof$e(call) === "object" || typeof call === "function")) {
    return call;
  }
  return _assertThisInitialized$d(self2);
}
function _assertThisInitialized$d(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _isNativeReflectConstruct$d() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e2) {
    return false;
  }
}
function _getPrototypeOf$d(o) {
  _getPrototypeOf$d = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf$d(o);
}
function _defineProperty$d(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
var AMPMParser = /* @__PURE__ */ (function(_Parser) {
  _inherits$d(AMPMParser2, _Parser);
  var _super = _createSuper$d(AMPMParser2);
  function AMPMParser2() {
    var _this;
    _classCallCheck$d(this, AMPMParser2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty$d(_assertThisInitialized$d(_this), "priority", 80);
    _defineProperty$d(_assertThisInitialized$d(_this), "incompatibleTokens", ["b", "B", "H", "k", "t", "T"]);
    return _this;
  }
  _createClass$d(AMPMParser2, [{
    key: "parse",
    value: function parse2(dateString, token, match2) {
      switch (token) {
        case "a":
        case "aa":
        case "aaa":
          return match2.dayPeriod(dateString, {
            width: "abbreviated",
            context: "formatting"
          }) || match2.dayPeriod(dateString, {
            width: "narrow",
            context: "formatting"
          });
        case "aaaaa":
          return match2.dayPeriod(dateString, {
            width: "narrow",
            context: "formatting"
          });
        case "aaaa":
        default:
          return match2.dayPeriod(dateString, {
            width: "wide",
            context: "formatting"
          }) || match2.dayPeriod(dateString, {
            width: "abbreviated",
            context: "formatting"
          }) || match2.dayPeriod(dateString, {
            width: "narrow",
            context: "formatting"
          });
      }
    }
  }, {
    key: "set",
    value: function set2(date, _flags, value) {
      date.setUTCHours(dayPeriodEnumToHours(value), 0, 0, 0);
      return date;
    }
  }]);
  return AMPMParser2;
})(Parser);
function _typeof$d(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof$d = function _typeof2(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof$d = function _typeof2(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof$d(obj);
}
function _classCallCheck$c(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$c(target, props) {
  for (var i2 = 0; i2 < props.length; i2++) {
    var descriptor = props[i2];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$c(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties$c(Constructor.prototype, protoProps);
  return Constructor;
}
function _inherits$c(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
  if (superClass) _setPrototypeOf$c(subClass, superClass);
}
function _setPrototypeOf$c(o, p) {
  _setPrototypeOf$c = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
    o2.__proto__ = p2;
    return o2;
  };
  return _setPrototypeOf$c(o, p);
}
function _createSuper$c(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$c();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$c(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$c(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$c(this, result);
  };
}
function _possibleConstructorReturn$c(self2, call) {
  if (call && (_typeof$d(call) === "object" || typeof call === "function")) {
    return call;
  }
  return _assertThisInitialized$c(self2);
}
function _assertThisInitialized$c(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _isNativeReflectConstruct$c() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e2) {
    return false;
  }
}
function _getPrototypeOf$c(o) {
  _getPrototypeOf$c = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf$c(o);
}
function _defineProperty$c(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
var AMPMMidnightParser = /* @__PURE__ */ (function(_Parser) {
  _inherits$c(AMPMMidnightParser2, _Parser);
  var _super = _createSuper$c(AMPMMidnightParser2);
  function AMPMMidnightParser2() {
    var _this;
    _classCallCheck$c(this, AMPMMidnightParser2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty$c(_assertThisInitialized$c(_this), "priority", 80);
    _defineProperty$c(_assertThisInitialized$c(_this), "incompatibleTokens", ["a", "B", "H", "k", "t", "T"]);
    return _this;
  }
  _createClass$c(AMPMMidnightParser2, [{
    key: "parse",
    value: function parse2(dateString, token, match2) {
      switch (token) {
        case "b":
        case "bb":
        case "bbb":
          return match2.dayPeriod(dateString, {
            width: "abbreviated",
            context: "formatting"
          }) || match2.dayPeriod(dateString, {
            width: "narrow",
            context: "formatting"
          });
        case "bbbbb":
          return match2.dayPeriod(dateString, {
            width: "narrow",
            context: "formatting"
          });
        case "bbbb":
        default:
          return match2.dayPeriod(dateString, {
            width: "wide",
            context: "formatting"
          }) || match2.dayPeriod(dateString, {
            width: "abbreviated",
            context: "formatting"
          }) || match2.dayPeriod(dateString, {
            width: "narrow",
            context: "formatting"
          });
      }
    }
  }, {
    key: "set",
    value: function set2(date, _flags, value) {
      date.setUTCHours(dayPeriodEnumToHours(value), 0, 0, 0);
      return date;
    }
  }]);
  return AMPMMidnightParser2;
})(Parser);
function _typeof$c(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof$c = function _typeof2(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof$c = function _typeof2(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof$c(obj);
}
function _classCallCheck$b(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$b(target, props) {
  for (var i2 = 0; i2 < props.length; i2++) {
    var descriptor = props[i2];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$b(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties$b(Constructor.prototype, protoProps);
  return Constructor;
}
function _inherits$b(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
  if (superClass) _setPrototypeOf$b(subClass, superClass);
}
function _setPrototypeOf$b(o, p) {
  _setPrototypeOf$b = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
    o2.__proto__ = p2;
    return o2;
  };
  return _setPrototypeOf$b(o, p);
}
function _createSuper$b(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$b();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$b(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$b(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$b(this, result);
  };
}
function _possibleConstructorReturn$b(self2, call) {
  if (call && (_typeof$c(call) === "object" || typeof call === "function")) {
    return call;
  }
  return _assertThisInitialized$b(self2);
}
function _assertThisInitialized$b(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _isNativeReflectConstruct$b() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e2) {
    return false;
  }
}
function _getPrototypeOf$b(o) {
  _getPrototypeOf$b = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf$b(o);
}
function _defineProperty$b(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
var DayPeriodParser = /* @__PURE__ */ (function(_Parser) {
  _inherits$b(DayPeriodParser2, _Parser);
  var _super = _createSuper$b(DayPeriodParser2);
  function DayPeriodParser2() {
    var _this;
    _classCallCheck$b(this, DayPeriodParser2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty$b(_assertThisInitialized$b(_this), "priority", 80);
    _defineProperty$b(_assertThisInitialized$b(_this), "incompatibleTokens", ["a", "b", "t", "T"]);
    return _this;
  }
  _createClass$b(DayPeriodParser2, [{
    key: "parse",
    value: function parse2(dateString, token, match2) {
      switch (token) {
        case "B":
        case "BB":
        case "BBB":
          return match2.dayPeriod(dateString, {
            width: "abbreviated",
            context: "formatting"
          }) || match2.dayPeriod(dateString, {
            width: "narrow",
            context: "formatting"
          });
        case "BBBBB":
          return match2.dayPeriod(dateString, {
            width: "narrow",
            context: "formatting"
          });
        case "BBBB":
        default:
          return match2.dayPeriod(dateString, {
            width: "wide",
            context: "formatting"
          }) || match2.dayPeriod(dateString, {
            width: "abbreviated",
            context: "formatting"
          }) || match2.dayPeriod(dateString, {
            width: "narrow",
            context: "formatting"
          });
      }
    }
  }, {
    key: "set",
    value: function set2(date, _flags, value) {
      date.setUTCHours(dayPeriodEnumToHours(value), 0, 0, 0);
      return date;
    }
  }]);
  return DayPeriodParser2;
})(Parser);
function _typeof$b(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof$b = function _typeof2(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof$b = function _typeof2(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof$b(obj);
}
function _classCallCheck$a(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$a(target, props) {
  for (var i2 = 0; i2 < props.length; i2++) {
    var descriptor = props[i2];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$a(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties$a(Constructor.prototype, protoProps);
  return Constructor;
}
function _inherits$a(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
  if (superClass) _setPrototypeOf$a(subClass, superClass);
}
function _setPrototypeOf$a(o, p) {
  _setPrototypeOf$a = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
    o2.__proto__ = p2;
    return o2;
  };
  return _setPrototypeOf$a(o, p);
}
function _createSuper$a(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$a();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$a(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$a(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$a(this, result);
  };
}
function _possibleConstructorReturn$a(self2, call) {
  if (call && (_typeof$b(call) === "object" || typeof call === "function")) {
    return call;
  }
  return _assertThisInitialized$a(self2);
}
function _assertThisInitialized$a(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _isNativeReflectConstruct$a() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e2) {
    return false;
  }
}
function _getPrototypeOf$a(o) {
  _getPrototypeOf$a = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf$a(o);
}
function _defineProperty$a(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
var Hour1to12Parser = /* @__PURE__ */ (function(_Parser) {
  _inherits$a(Hour1to12Parser2, _Parser);
  var _super = _createSuper$a(Hour1to12Parser2);
  function Hour1to12Parser2() {
    var _this;
    _classCallCheck$a(this, Hour1to12Parser2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty$a(_assertThisInitialized$a(_this), "priority", 70);
    _defineProperty$a(_assertThisInitialized$a(_this), "incompatibleTokens", ["H", "K", "k", "t", "T"]);
    return _this;
  }
  _createClass$a(Hour1to12Parser2, [{
    key: "parse",
    value: function parse2(dateString, token, match2) {
      switch (token) {
        case "h":
          return parseNumericPattern(numericPatterns.hour12h, dateString);
        case "ho":
          return match2.ordinalNumber(dateString, {
            unit: "hour"
          });
        default:
          return parseNDigits(token.length, dateString);
      }
    }
  }, {
    key: "validate",
    value: function validate(_date, value) {
      return value >= 1 && value <= 12;
    }
  }, {
    key: "set",
    value: function set2(date, _flags, value) {
      var isPM = date.getUTCHours() >= 12;
      if (isPM && value < 12) {
        date.setUTCHours(value + 12, 0, 0, 0);
      } else if (!isPM && value === 12) {
        date.setUTCHours(0, 0, 0, 0);
      } else {
        date.setUTCHours(value, 0, 0, 0);
      }
      return date;
    }
  }]);
  return Hour1to12Parser2;
})(Parser);
function _typeof$a(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof$a = function _typeof2(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof$a = function _typeof2(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof$a(obj);
}
function _classCallCheck$9(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$9(target, props) {
  for (var i2 = 0; i2 < props.length; i2++) {
    var descriptor = props[i2];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$9(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties$9(Constructor.prototype, protoProps);
  return Constructor;
}
function _inherits$9(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
  if (superClass) _setPrototypeOf$9(subClass, superClass);
}
function _setPrototypeOf$9(o, p) {
  _setPrototypeOf$9 = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
    o2.__proto__ = p2;
    return o2;
  };
  return _setPrototypeOf$9(o, p);
}
function _createSuper$9(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$9();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$9(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$9(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$9(this, result);
  };
}
function _possibleConstructorReturn$9(self2, call) {
  if (call && (_typeof$a(call) === "object" || typeof call === "function")) {
    return call;
  }
  return _assertThisInitialized$9(self2);
}
function _assertThisInitialized$9(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _isNativeReflectConstruct$9() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e2) {
    return false;
  }
}
function _getPrototypeOf$9(o) {
  _getPrototypeOf$9 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf$9(o);
}
function _defineProperty$9(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
var Hour0to23Parser = /* @__PURE__ */ (function(_Parser) {
  _inherits$9(Hour0to23Parser2, _Parser);
  var _super = _createSuper$9(Hour0to23Parser2);
  function Hour0to23Parser2() {
    var _this;
    _classCallCheck$9(this, Hour0to23Parser2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty$9(_assertThisInitialized$9(_this), "priority", 70);
    _defineProperty$9(_assertThisInitialized$9(_this), "incompatibleTokens", ["a", "b", "h", "K", "k", "t", "T"]);
    return _this;
  }
  _createClass$9(Hour0to23Parser2, [{
    key: "parse",
    value: function parse2(dateString, token, match2) {
      switch (token) {
        case "H":
          return parseNumericPattern(numericPatterns.hour23h, dateString);
        case "Ho":
          return match2.ordinalNumber(dateString, {
            unit: "hour"
          });
        default:
          return parseNDigits(token.length, dateString);
      }
    }
  }, {
    key: "validate",
    value: function validate(_date, value) {
      return value >= 0 && value <= 23;
    }
  }, {
    key: "set",
    value: function set2(date, _flags, value) {
      date.setUTCHours(value, 0, 0, 0);
      return date;
    }
  }]);
  return Hour0to23Parser2;
})(Parser);
function _typeof$9(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof$9 = function _typeof2(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof$9 = function _typeof2(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof$9(obj);
}
function _classCallCheck$8(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$8(target, props) {
  for (var i2 = 0; i2 < props.length; i2++) {
    var descriptor = props[i2];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$8(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties$8(Constructor.prototype, protoProps);
  return Constructor;
}
function _inherits$8(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
  if (superClass) _setPrototypeOf$8(subClass, superClass);
}
function _setPrototypeOf$8(o, p) {
  _setPrototypeOf$8 = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
    o2.__proto__ = p2;
    return o2;
  };
  return _setPrototypeOf$8(o, p);
}
function _createSuper$8(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$8();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$8(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$8(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$8(this, result);
  };
}
function _possibleConstructorReturn$8(self2, call) {
  if (call && (_typeof$9(call) === "object" || typeof call === "function")) {
    return call;
  }
  return _assertThisInitialized$8(self2);
}
function _assertThisInitialized$8(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _isNativeReflectConstruct$8() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e2) {
    return false;
  }
}
function _getPrototypeOf$8(o) {
  _getPrototypeOf$8 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf$8(o);
}
function _defineProperty$8(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
var Hour0To11Parser = /* @__PURE__ */ (function(_Parser) {
  _inherits$8(Hour0To11Parser2, _Parser);
  var _super = _createSuper$8(Hour0To11Parser2);
  function Hour0To11Parser2() {
    var _this;
    _classCallCheck$8(this, Hour0To11Parser2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty$8(_assertThisInitialized$8(_this), "priority", 70);
    _defineProperty$8(_assertThisInitialized$8(_this), "incompatibleTokens", ["h", "H", "k", "t", "T"]);
    return _this;
  }
  _createClass$8(Hour0To11Parser2, [{
    key: "parse",
    value: function parse2(dateString, token, match2) {
      switch (token) {
        case "K":
          return parseNumericPattern(numericPatterns.hour11h, dateString);
        case "Ko":
          return match2.ordinalNumber(dateString, {
            unit: "hour"
          });
        default:
          return parseNDigits(token.length, dateString);
      }
    }
  }, {
    key: "validate",
    value: function validate(_date, value) {
      return value >= 0 && value <= 11;
    }
  }, {
    key: "set",
    value: function set2(date, _flags, value) {
      var isPM = date.getUTCHours() >= 12;
      if (isPM && value < 12) {
        date.setUTCHours(value + 12, 0, 0, 0);
      } else {
        date.setUTCHours(value, 0, 0, 0);
      }
      return date;
    }
  }]);
  return Hour0To11Parser2;
})(Parser);
function _typeof$8(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof$8 = function _typeof2(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof$8 = function _typeof2(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof$8(obj);
}
function _classCallCheck$7(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$7(target, props) {
  for (var i2 = 0; i2 < props.length; i2++) {
    var descriptor = props[i2];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$7(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties$7(Constructor.prototype, protoProps);
  return Constructor;
}
function _inherits$7(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
  if (superClass) _setPrototypeOf$7(subClass, superClass);
}
function _setPrototypeOf$7(o, p) {
  _setPrototypeOf$7 = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
    o2.__proto__ = p2;
    return o2;
  };
  return _setPrototypeOf$7(o, p);
}
function _createSuper$7(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$7();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$7(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$7(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$7(this, result);
  };
}
function _possibleConstructorReturn$7(self2, call) {
  if (call && (_typeof$8(call) === "object" || typeof call === "function")) {
    return call;
  }
  return _assertThisInitialized$7(self2);
}
function _assertThisInitialized$7(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _isNativeReflectConstruct$7() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e2) {
    return false;
  }
}
function _getPrototypeOf$7(o) {
  _getPrototypeOf$7 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf$7(o);
}
function _defineProperty$7(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
var Hour1To24Parser = /* @__PURE__ */ (function(_Parser) {
  _inherits$7(Hour1To24Parser2, _Parser);
  var _super = _createSuper$7(Hour1To24Parser2);
  function Hour1To24Parser2() {
    var _this;
    _classCallCheck$7(this, Hour1To24Parser2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty$7(_assertThisInitialized$7(_this), "priority", 70);
    _defineProperty$7(_assertThisInitialized$7(_this), "incompatibleTokens", ["a", "b", "h", "H", "K", "t", "T"]);
    return _this;
  }
  _createClass$7(Hour1To24Parser2, [{
    key: "parse",
    value: function parse2(dateString, token, match2) {
      switch (token) {
        case "k":
          return parseNumericPattern(numericPatterns.hour24h, dateString);
        case "ko":
          return match2.ordinalNumber(dateString, {
            unit: "hour"
          });
        default:
          return parseNDigits(token.length, dateString);
      }
    }
  }, {
    key: "validate",
    value: function validate(_date, value) {
      return value >= 1 && value <= 24;
    }
  }, {
    key: "set",
    value: function set2(date, _flags, value) {
      var hours = value <= 24 ? value % 24 : value;
      date.setUTCHours(hours, 0, 0, 0);
      return date;
    }
  }]);
  return Hour1To24Parser2;
})(Parser);
function _typeof$7(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof$7 = function _typeof2(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof$7 = function _typeof2(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof$7(obj);
}
function _classCallCheck$6(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$6(target, props) {
  for (var i2 = 0; i2 < props.length; i2++) {
    var descriptor = props[i2];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$6(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties$6(Constructor.prototype, protoProps);
  return Constructor;
}
function _inherits$6(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
  if (superClass) _setPrototypeOf$6(subClass, superClass);
}
function _setPrototypeOf$6(o, p) {
  _setPrototypeOf$6 = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
    o2.__proto__ = p2;
    return o2;
  };
  return _setPrototypeOf$6(o, p);
}
function _createSuper$6(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$6();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$6(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$6(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$6(this, result);
  };
}
function _possibleConstructorReturn$6(self2, call) {
  if (call && (_typeof$7(call) === "object" || typeof call === "function")) {
    return call;
  }
  return _assertThisInitialized$6(self2);
}
function _assertThisInitialized$6(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _isNativeReflectConstruct$6() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e2) {
    return false;
  }
}
function _getPrototypeOf$6(o) {
  _getPrototypeOf$6 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf$6(o);
}
function _defineProperty$6(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
var MinuteParser = /* @__PURE__ */ (function(_Parser) {
  _inherits$6(MinuteParser2, _Parser);
  var _super = _createSuper$6(MinuteParser2);
  function MinuteParser2() {
    var _this;
    _classCallCheck$6(this, MinuteParser2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty$6(_assertThisInitialized$6(_this), "priority", 60);
    _defineProperty$6(_assertThisInitialized$6(_this), "incompatibleTokens", ["t", "T"]);
    return _this;
  }
  _createClass$6(MinuteParser2, [{
    key: "parse",
    value: function parse2(dateString, token, match2) {
      switch (token) {
        case "m":
          return parseNumericPattern(numericPatterns.minute, dateString);
        case "mo":
          return match2.ordinalNumber(dateString, {
            unit: "minute"
          });
        default:
          return parseNDigits(token.length, dateString);
      }
    }
  }, {
    key: "validate",
    value: function validate(_date, value) {
      return value >= 0 && value <= 59;
    }
  }, {
    key: "set",
    value: function set2(date, _flags, value) {
      date.setUTCMinutes(value, 0, 0);
      return date;
    }
  }]);
  return MinuteParser2;
})(Parser);
function _typeof$6(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof$6 = function _typeof2(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof$6 = function _typeof2(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof$6(obj);
}
function _classCallCheck$5(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$5(target, props) {
  for (var i2 = 0; i2 < props.length; i2++) {
    var descriptor = props[i2];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$5(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties$5(Constructor.prototype, protoProps);
  return Constructor;
}
function _inherits$5(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
  if (superClass) _setPrototypeOf$5(subClass, superClass);
}
function _setPrototypeOf$5(o, p) {
  _setPrototypeOf$5 = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
    o2.__proto__ = p2;
    return o2;
  };
  return _setPrototypeOf$5(o, p);
}
function _createSuper$5(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$5();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$5(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$5(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$5(this, result);
  };
}
function _possibleConstructorReturn$5(self2, call) {
  if (call && (_typeof$6(call) === "object" || typeof call === "function")) {
    return call;
  }
  return _assertThisInitialized$5(self2);
}
function _assertThisInitialized$5(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _isNativeReflectConstruct$5() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e2) {
    return false;
  }
}
function _getPrototypeOf$5(o) {
  _getPrototypeOf$5 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf$5(o);
}
function _defineProperty$5(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
var SecondParser = /* @__PURE__ */ (function(_Parser) {
  _inherits$5(SecondParser2, _Parser);
  var _super = _createSuper$5(SecondParser2);
  function SecondParser2() {
    var _this;
    _classCallCheck$5(this, SecondParser2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty$5(_assertThisInitialized$5(_this), "priority", 50);
    _defineProperty$5(_assertThisInitialized$5(_this), "incompatibleTokens", ["t", "T"]);
    return _this;
  }
  _createClass$5(SecondParser2, [{
    key: "parse",
    value: function parse2(dateString, token, match2) {
      switch (token) {
        case "s":
          return parseNumericPattern(numericPatterns.second, dateString);
        case "so":
          return match2.ordinalNumber(dateString, {
            unit: "second"
          });
        default:
          return parseNDigits(token.length, dateString);
      }
    }
  }, {
    key: "validate",
    value: function validate(_date, value) {
      return value >= 0 && value <= 59;
    }
  }, {
    key: "set",
    value: function set2(date, _flags, value) {
      date.setUTCSeconds(value, 0);
      return date;
    }
  }]);
  return SecondParser2;
})(Parser);
function _typeof$5(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof$5 = function _typeof2(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof$5 = function _typeof2(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof$5(obj);
}
function _classCallCheck$4(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$4(target, props) {
  for (var i2 = 0; i2 < props.length; i2++) {
    var descriptor = props[i2];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$4(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties$4(Constructor.prototype, protoProps);
  return Constructor;
}
function _inherits$4(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
  if (superClass) _setPrototypeOf$4(subClass, superClass);
}
function _setPrototypeOf$4(o, p) {
  _setPrototypeOf$4 = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
    o2.__proto__ = p2;
    return o2;
  };
  return _setPrototypeOf$4(o, p);
}
function _createSuper$4(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$4();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$4(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$4(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$4(this, result);
  };
}
function _possibleConstructorReturn$4(self2, call) {
  if (call && (_typeof$5(call) === "object" || typeof call === "function")) {
    return call;
  }
  return _assertThisInitialized$4(self2);
}
function _assertThisInitialized$4(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _isNativeReflectConstruct$4() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e2) {
    return false;
  }
}
function _getPrototypeOf$4(o) {
  _getPrototypeOf$4 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf$4(o);
}
function _defineProperty$4(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
var FractionOfSecondParser = /* @__PURE__ */ (function(_Parser) {
  _inherits$4(FractionOfSecondParser2, _Parser);
  var _super = _createSuper$4(FractionOfSecondParser2);
  function FractionOfSecondParser2() {
    var _this;
    _classCallCheck$4(this, FractionOfSecondParser2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty$4(_assertThisInitialized$4(_this), "priority", 30);
    _defineProperty$4(_assertThisInitialized$4(_this), "incompatibleTokens", ["t", "T"]);
    return _this;
  }
  _createClass$4(FractionOfSecondParser2, [{
    key: "parse",
    value: function parse2(dateString, token) {
      var valueCallback3 = function valueCallback4(value) {
        return Math.floor(value * Math.pow(10, -token.length + 3));
      };
      return mapValue(parseNDigits(token.length, dateString), valueCallback3);
    }
  }, {
    key: "set",
    value: function set2(date, _flags, value) {
      date.setUTCMilliseconds(value);
      return date;
    }
  }]);
  return FractionOfSecondParser2;
})(Parser);
function _typeof$4(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof$4 = function _typeof2(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof$4 = function _typeof2(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof$4(obj);
}
function _classCallCheck$3(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$3(target, props) {
  for (var i2 = 0; i2 < props.length; i2++) {
    var descriptor = props[i2];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$3(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties$3(Constructor.prototype, protoProps);
  return Constructor;
}
function _inherits$3(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
  if (superClass) _setPrototypeOf$3(subClass, superClass);
}
function _setPrototypeOf$3(o, p) {
  _setPrototypeOf$3 = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
    o2.__proto__ = p2;
    return o2;
  };
  return _setPrototypeOf$3(o, p);
}
function _createSuper$3(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$3();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$3(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$3(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$3(this, result);
  };
}
function _possibleConstructorReturn$3(self2, call) {
  if (call && (_typeof$4(call) === "object" || typeof call === "function")) {
    return call;
  }
  return _assertThisInitialized$3(self2);
}
function _assertThisInitialized$3(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _isNativeReflectConstruct$3() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e2) {
    return false;
  }
}
function _getPrototypeOf$3(o) {
  _getPrototypeOf$3 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf$3(o);
}
function _defineProperty$3(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
var ISOTimezoneWithZParser = /* @__PURE__ */ (function(_Parser) {
  _inherits$3(ISOTimezoneWithZParser2, _Parser);
  var _super = _createSuper$3(ISOTimezoneWithZParser2);
  function ISOTimezoneWithZParser2() {
    var _this;
    _classCallCheck$3(this, ISOTimezoneWithZParser2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty$3(_assertThisInitialized$3(_this), "priority", 10);
    _defineProperty$3(_assertThisInitialized$3(_this), "incompatibleTokens", ["t", "T", "x"]);
    return _this;
  }
  _createClass$3(ISOTimezoneWithZParser2, [{
    key: "parse",
    value: function parse2(dateString, token) {
      switch (token) {
        case "X":
          return parseTimezonePattern(timezonePatterns.basicOptionalMinutes, dateString);
        case "XX":
          return parseTimezonePattern(timezonePatterns.basic, dateString);
        case "XXXX":
          return parseTimezonePattern(timezonePatterns.basicOptionalSeconds, dateString);
        case "XXXXX":
          return parseTimezonePattern(timezonePatterns.extendedOptionalSeconds, dateString);
        case "XXX":
        default:
          return parseTimezonePattern(timezonePatterns.extended, dateString);
      }
    }
  }, {
    key: "set",
    value: function set2(date, flags, value) {
      if (flags.timestampIsSet) {
        return date;
      }
      return new Date(date.getTime() - value);
    }
  }]);
  return ISOTimezoneWithZParser2;
})(Parser);
function _typeof$3(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof$3 = function _typeof2(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof$3 = function _typeof2(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof$3(obj);
}
function _classCallCheck$2(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$2(target, props) {
  for (var i2 = 0; i2 < props.length; i2++) {
    var descriptor = props[i2];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$2(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties$2(Constructor.prototype, protoProps);
  return Constructor;
}
function _inherits$2(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
  if (superClass) _setPrototypeOf$2(subClass, superClass);
}
function _setPrototypeOf$2(o, p) {
  _setPrototypeOf$2 = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
    o2.__proto__ = p2;
    return o2;
  };
  return _setPrototypeOf$2(o, p);
}
function _createSuper$2(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$2();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$2(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$2(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$2(this, result);
  };
}
function _possibleConstructorReturn$2(self2, call) {
  if (call && (_typeof$3(call) === "object" || typeof call === "function")) {
    return call;
  }
  return _assertThisInitialized$2(self2);
}
function _assertThisInitialized$2(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _isNativeReflectConstruct$2() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e2) {
    return false;
  }
}
function _getPrototypeOf$2(o) {
  _getPrototypeOf$2 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf$2(o);
}
function _defineProperty$2(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
var ISOTimezoneParser = /* @__PURE__ */ (function(_Parser) {
  _inherits$2(ISOTimezoneParser2, _Parser);
  var _super = _createSuper$2(ISOTimezoneParser2);
  function ISOTimezoneParser2() {
    var _this;
    _classCallCheck$2(this, ISOTimezoneParser2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty$2(_assertThisInitialized$2(_this), "priority", 10);
    _defineProperty$2(_assertThisInitialized$2(_this), "incompatibleTokens", ["t", "T", "X"]);
    return _this;
  }
  _createClass$2(ISOTimezoneParser2, [{
    key: "parse",
    value: function parse2(dateString, token) {
      switch (token) {
        case "x":
          return parseTimezonePattern(timezonePatterns.basicOptionalMinutes, dateString);
        case "xx":
          return parseTimezonePattern(timezonePatterns.basic, dateString);
        case "xxxx":
          return parseTimezonePattern(timezonePatterns.basicOptionalSeconds, dateString);
        case "xxxxx":
          return parseTimezonePattern(timezonePatterns.extendedOptionalSeconds, dateString);
        case "xxx":
        default:
          return parseTimezonePattern(timezonePatterns.extended, dateString);
      }
    }
  }, {
    key: "set",
    value: function set2(date, flags, value) {
      if (flags.timestampIsSet) {
        return date;
      }
      return new Date(date.getTime() - value);
    }
  }]);
  return ISOTimezoneParser2;
})(Parser);
function _typeof$2(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof$2 = function _typeof2(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof$2 = function _typeof2(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof$2(obj);
}
function _classCallCheck$1(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$1(target, props) {
  for (var i2 = 0; i2 < props.length; i2++) {
    var descriptor = props[i2];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$1(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties$1(Constructor.prototype, protoProps);
  return Constructor;
}
function _inherits$1(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
  if (superClass) _setPrototypeOf$1(subClass, superClass);
}
function _setPrototypeOf$1(o, p) {
  _setPrototypeOf$1 = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
    o2.__proto__ = p2;
    return o2;
  };
  return _setPrototypeOf$1(o, p);
}
function _createSuper$1(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$1();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$1(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$1(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$1(this, result);
  };
}
function _possibleConstructorReturn$1(self2, call) {
  if (call && (_typeof$2(call) === "object" || typeof call === "function")) {
    return call;
  }
  return _assertThisInitialized$1(self2);
}
function _assertThisInitialized$1(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _isNativeReflectConstruct$1() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e2) {
    return false;
  }
}
function _getPrototypeOf$1(o) {
  _getPrototypeOf$1 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf$1(o);
}
function _defineProperty$1(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
var TimestampSecondsParser = /* @__PURE__ */ (function(_Parser) {
  _inherits$1(TimestampSecondsParser2, _Parser);
  var _super = _createSuper$1(TimestampSecondsParser2);
  function TimestampSecondsParser2() {
    var _this;
    _classCallCheck$1(this, TimestampSecondsParser2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty$1(_assertThisInitialized$1(_this), "priority", 40);
    _defineProperty$1(_assertThisInitialized$1(_this), "incompatibleTokens", "*");
    return _this;
  }
  _createClass$1(TimestampSecondsParser2, [{
    key: "parse",
    value: function parse2(dateString) {
      return parseAnyDigitsSigned(dateString);
    }
  }, {
    key: "set",
    value: function set2(_date, _flags, value) {
      return [new Date(value * 1e3), {
        timestampIsSet: true
      }];
    }
  }]);
  return TimestampSecondsParser2;
})(Parser);
function _typeof$1(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof$1 = function _typeof2(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof$1 = function _typeof2(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof$1(obj);
}
function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties(target, props) {
  for (var i2 = 0; i2 < props.length; i2++) {
    var descriptor = props[i2];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  return Constructor;
}
function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
  if (superClass) _setPrototypeOf(subClass, superClass);
}
function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
    o2.__proto__ = p2;
    return o2;
  };
  return _setPrototypeOf(o, p);
}
function _createSuper(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}
function _possibleConstructorReturn(self2, call) {
  if (call && (_typeof$1(call) === "object" || typeof call === "function")) {
    return call;
  }
  return _assertThisInitialized(self2);
}
function _assertThisInitialized(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _isNativeReflectConstruct() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e2) {
    return false;
  }
}
function _getPrototypeOf(o) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf(o);
}
function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
var TimestampMillisecondsParser = /* @__PURE__ */ (function(_Parser) {
  _inherits(TimestampMillisecondsParser2, _Parser);
  var _super = _createSuper(TimestampMillisecondsParser2);
  function TimestampMillisecondsParser2() {
    var _this;
    _classCallCheck(this, TimestampMillisecondsParser2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty(_assertThisInitialized(_this), "priority", 20);
    _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", "*");
    return _this;
  }
  _createClass(TimestampMillisecondsParser2, [{
    key: "parse",
    value: function parse2(dateString) {
      return parseAnyDigitsSigned(dateString);
    }
  }, {
    key: "set",
    value: function set2(_date, _flags, value) {
      return [new Date(value), {
        timestampIsSet: true
      }];
    }
  }]);
  return TimestampMillisecondsParser2;
})(Parser);
var parsers = {
  G: new EraParser(),
  y: new YearParser(),
  Y: new LocalWeekYearParser(),
  R: new ISOWeekYearParser(),
  u: new ExtendedYearParser(),
  Q: new QuarterParser(),
  q: new StandAloneQuarterParser(),
  M: new MonthParser(),
  L: new StandAloneMonthParser(),
  w: new LocalWeekParser(),
  I: new ISOWeekParser(),
  d: new DateParser(),
  D: new DayOfYearParser(),
  E: new DayParser(),
  e: new LocalDayParser(),
  c: new StandAloneLocalDayParser(),
  i: new ISODayParser(),
  a: new AMPMParser(),
  b: new AMPMMidnightParser(),
  B: new DayPeriodParser(),
  h: new Hour1to12Parser(),
  H: new Hour0to23Parser(),
  K: new Hour0To11Parser(),
  k: new Hour1To24Parser(),
  m: new MinuteParser(),
  s: new SecondParser(),
  S: new FractionOfSecondParser(),
  X: new ISOTimezoneWithZParser(),
  x: new ISOTimezoneParser(),
  t: new TimestampSecondsParser(),
  T: new TimestampMillisecondsParser()
};
function _typeof(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof = function _typeof2(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof = function _typeof2(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof(obj);
}
function _createForOfIteratorHelper(o, allowArrayLike) {
  var it;
  if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) {
    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike) {
      if (it) o = it;
      var i2 = 0;
      var F = function F2() {
      };
      return { s: F, n: function n() {
        if (i2 >= o.length) return { done: true };
        return { done: false, value: o[i2++] };
      }, e: function e2(_e) {
        throw _e;
      }, f: F };
    }
    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  var normalCompletion = true, didErr = false, err;
  return { s: function s3() {
    it = o[Symbol.iterator]();
  }, n: function n() {
    var step = it.next();
    normalCompletion = step.done;
    return step;
  }, e: function e2(_e2) {
    didErr = true;
    err = _e2;
  }, f: function f() {
    try {
      if (!normalCompletion && it.return != null) it.return();
    } finally {
      if (didErr) throw err;
    }
  } };
}
function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}
function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;
  for (var i2 = 0, arr2 = new Array(len); i2 < len; i2++) {
    arr2[i2] = arr[i2];
  }
  return arr2;
}
var formattingTokensRegExp = /[yYQqMLwIdDecihHKkms]o|(\w)\1*|''|'(''|[^'])+('|$)|./g;
var longFormattingTokensRegExp = /P+p+|P+|p+|''|'(''|[^'])+('|$)|./g;
var escapedStringRegExp = /^'([^]*?)'?$/;
var doubleQuoteRegExp = /''/g;
var notWhitespaceRegExp = /\S/;
var unescapedLatinCharacterRegExp = /[a-zA-Z]/;
function parse(dirtyDateString, dirtyFormatString, dirtyReferenceDate, options) {
  var _ref, _options$locale, _ref2, _ref3, _ref4, _options$firstWeekCon, _defaultOptions$local, _defaultOptions$local2, _ref5, _ref6, _ref7, _options$weekStartsOn, _defaultOptions$local3, _defaultOptions$local4;
  requiredArgs(3, arguments);
  var dateString = String(dirtyDateString);
  var formatString = String(dirtyFormatString);
  var defaultOptions2 = getDefaultOptions();
  var locale$1 = (_ref = (_options$locale = void 0) !== null && _options$locale !== void 0 ? _options$locale : defaultOptions2.locale) !== null && _ref !== void 0 ? _ref : locale;
  if (!locale$1.match) {
    throw new RangeError("locale must contain match property");
  }
  var firstWeekContainsDate = toInteger((_ref2 = (_ref3 = (_ref4 = (_options$firstWeekCon = void 0) !== null && _options$firstWeekCon !== void 0 ? _options$firstWeekCon : void 0) !== null && _ref4 !== void 0 ? _ref4 : defaultOptions2.firstWeekContainsDate) !== null && _ref3 !== void 0 ? _ref3 : (_defaultOptions$local = defaultOptions2.locale) === null || _defaultOptions$local === void 0 ? void 0 : (_defaultOptions$local2 = _defaultOptions$local.options) === null || _defaultOptions$local2 === void 0 ? void 0 : _defaultOptions$local2.firstWeekContainsDate) !== null && _ref2 !== void 0 ? _ref2 : 1);
  if (!(firstWeekContainsDate >= 1 && firstWeekContainsDate <= 7)) {
    throw new RangeError("firstWeekContainsDate must be between 1 and 7 inclusively");
  }
  var weekStartsOn = toInteger((_ref5 = (_ref6 = (_ref7 = (_options$weekStartsOn = void 0) !== null && _options$weekStartsOn !== void 0 ? _options$weekStartsOn : void 0) !== null && _ref7 !== void 0 ? _ref7 : defaultOptions2.weekStartsOn) !== null && _ref6 !== void 0 ? _ref6 : (_defaultOptions$local3 = defaultOptions2.locale) === null || _defaultOptions$local3 === void 0 ? void 0 : (_defaultOptions$local4 = _defaultOptions$local3.options) === null || _defaultOptions$local4 === void 0 ? void 0 : _defaultOptions$local4.weekStartsOn) !== null && _ref5 !== void 0 ? _ref5 : 0);
  if (!(weekStartsOn >= 0 && weekStartsOn <= 6)) {
    throw new RangeError("weekStartsOn must be between 0 and 6 inclusively");
  }
  if (formatString === "") {
    if (dateString === "") {
      return toDate(dirtyReferenceDate);
    } else {
      return /* @__PURE__ */ new Date(NaN);
    }
  }
  var subFnOptions = {
    firstWeekContainsDate,
    weekStartsOn,
    locale: locale$1
  };
  var setters = [new DateToSystemTimezoneSetter()];
  var tokens = formatString.match(longFormattingTokensRegExp).map(function(substring) {
    var firstCharacter = substring[0];
    if (firstCharacter in longFormatters) {
      var longFormatter = longFormatters[firstCharacter];
      return longFormatter(substring, locale$1.formatLong);
    }
    return substring;
  }).join("").match(formattingTokensRegExp);
  var usedTokens = [];
  var _iterator = _createForOfIteratorHelper(tokens), _step;
  try {
    var _loop = function _loop2() {
      var token = _step.value;
      if (!(options !== null && options !== void 0 && options.useAdditionalWeekYearTokens) && isProtectedWeekYearToken(token)) {
        throwProtectedError(token, formatString, dirtyDateString);
      }
      if (!(options !== null && options !== void 0 && options.useAdditionalDayOfYearTokens) && isProtectedDayOfYearToken(token)) {
        throwProtectedError(token, formatString, dirtyDateString);
      }
      var firstCharacter = token[0];
      var parser = parsers[firstCharacter];
      if (parser) {
        var incompatibleTokens = parser.incompatibleTokens;
        if (Array.isArray(incompatibleTokens)) {
          var incompatibleToken = usedTokens.find(function(usedToken) {
            return incompatibleTokens.includes(usedToken.token) || usedToken.token === firstCharacter;
          });
          if (incompatibleToken) {
            throw new RangeError("The format string mustn't contain `".concat(incompatibleToken.fullToken, "` and `").concat(token, "` at the same time"));
          }
        } else if (parser.incompatibleTokens === "*" && usedTokens.length > 0) {
          throw new RangeError("The format string mustn't contain `".concat(token, "` and any other token at the same time"));
        }
        usedTokens.push({
          token: firstCharacter,
          fullToken: token
        });
        var parseResult = parser.run(dateString, token, locale$1.match, subFnOptions);
        if (!parseResult) {
          return {
            v: /* @__PURE__ */ new Date(NaN)
          };
        }
        setters.push(parseResult.setter);
        dateString = parseResult.rest;
      } else {
        if (firstCharacter.match(unescapedLatinCharacterRegExp)) {
          throw new RangeError("Format string contains an unescaped latin alphabet character `" + firstCharacter + "`");
        }
        if (token === "''") {
          token = "'";
        } else if (firstCharacter === "'") {
          token = cleanEscapedString(token);
        }
        if (dateString.indexOf(token) === 0) {
          dateString = dateString.slice(token.length);
        } else {
          return {
            v: /* @__PURE__ */ new Date(NaN)
          };
        }
      }
    };
    for (_iterator.s(); !(_step = _iterator.n()).done; ) {
      var _ret = _loop();
      if (_typeof(_ret) === "object") return _ret.v;
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }
  if (dateString.length > 0 && notWhitespaceRegExp.test(dateString)) {
    return /* @__PURE__ */ new Date(NaN);
  }
  var uniquePrioritySetters = setters.map(function(setter2) {
    return setter2.priority;
  }).sort(function(a3, b2) {
    return b2 - a3;
  }).filter(function(priority, index, array) {
    return array.indexOf(priority) === index;
  }).map(function(priority) {
    return setters.filter(function(setter2) {
      return setter2.priority === priority;
    }).sort(function(a3, b2) {
      return b2.subPriority - a3.subPriority;
    });
  }).map(function(setterArray) {
    return setterArray[0];
  });
  var date = toDate(dirtyReferenceDate);
  if (isNaN(date.getTime())) {
    return /* @__PURE__ */ new Date(NaN);
  }
  var utcDate = subMilliseconds(date, getTimezoneOffsetInMilliseconds(date));
  var flags = {};
  var _iterator2 = _createForOfIteratorHelper(uniquePrioritySetters), _step2;
  try {
    for (_iterator2.s(); !(_step2 = _iterator2.n()).done; ) {
      var setter = _step2.value;
      if (!setter.validate(utcDate, subFnOptions)) {
        return /* @__PURE__ */ new Date(NaN);
      }
      var result = setter.set(utcDate, flags, subFnOptions);
      if (Array.isArray(result)) {
        utcDate = result[0];
        assign(flags, result[1]);
      } else {
        utcDate = result;
      }
    }
  } catch (err) {
    _iterator2.e(err);
  } finally {
    _iterator2.f();
  }
  return utcDate;
}
function cleanEscapedString(input) {
  return input.match(escapedStringRegExp)[1].replace(doubleQuoteRegExp, "'");
}
window.Vaadin.Flow.datepickerConnector = {};
window.Vaadin.Flow.datepickerConnector.initLazy = (datepicker) => {
  if (datepicker.$connector) {
    return;
  }
  datepicker.$connector = {};
  const createLocaleBasedDateFormat = function(locale2) {
    try {
      (/* @__PURE__ */ new Date()).toLocaleDateString(locale2);
    } catch (e2) {
      console.warn("The locale is not supported, using default format setting (ISO 8601).");
      return "yyyy-MM-dd";
    }
    const testDate = new Date(Date.UTC(1234, 4, 6));
    let pattern = testDate.toLocaleDateString(locale2, { timeZone: "UTC" });
    pattern = pattern.replace(/([a-zA-Z]+)/g, "'$1'").replace("06", "dd").replace("6", "d").replace("05", "MM").replace("5", "M").replace("1234", "yyyy");
    const isValidPattern = pattern.includes("d") && pattern.includes("M") && pattern.includes("y");
    if (!isValidPattern) {
      console.warn("The locale is not supported, using default format setting (ISO 8601).");
      return "yyyy-MM-dd";
    }
    return pattern;
  };
  function createFormatterAndParser(formats) {
    if (!formats || formats.length === 0) {
      throw new Error("Array of custom date formats is null or empty");
    }
    function getShortYearFormat(format2) {
      if (format2.includes("yyyy") && !format2.includes("yyyyy")) {
        return format2.replace("yyyy", "yy");
      }
      if (format2.includes("YYYY") && !format2.includes("YYYYY")) {
        return format2.replace("YYYY", "YY");
      }
      return void 0;
    }
    function isFormatWithYear(format2) {
      return format2.includes("y") || format2.includes("Y");
    }
    function isShortYearFormat(format2) {
      return !format2.includes("yyyy") && !format2.includes("YYYY");
    }
    function getExtendedFormats(formats2) {
      return formats2.reduce((acc, format2) => {
        if (isFormatWithYear(format2) && !isShortYearFormat(format2)) {
          acc.push(getShortYearFormat(format2));
        }
        acc.push(format2);
        return acc;
      }, []);
    }
    function correctFullYear(date) {
      if (datepicker.$connector._lastParseStatus === "error") {
        return;
      }
      if (datepicker.$connector._lastParseStatus === "successful") {
        if (datepicker.$connector._lastParsedDate.day === date.getDate() && datepicker.$connector._lastParsedDate.month === date.getMonth() && datepicker.$connector._lastParsedDate.year % 100 === date.getFullYear() % 100) {
          date.setFullYear(datepicker.$connector._lastParsedDate.year);
        }
        return;
      }
      const currentValue = parseDate(datepicker.value);
      if (isValid(currentValue) && currentValue.getDate() === date.getDate() && currentValue.getMonth() === date.getMonth() && currentValue.getFullYear() % 100 === date.getFullYear() % 100) {
        date.setFullYear(currentValue.getFullYear());
      }
    }
    function formatDate(dateParts) {
      const format$1 = formats[0];
      const date = parseDate(`${dateParts.year}-${dateParts.month + 1}-${dateParts.day}`);
      return format(date, format$1);
    }
    function doParseDate(dateString, format2, referenceDate) {
      const refDate = isFormatWithYear(format2) ? referenceDate : /* @__PURE__ */ new Date();
      const date = parse(dateString, format2, refDate);
      if (isValid(date)) {
        if (isFormatWithYear(format2) && isShortYearFormat(format2)) {
          correctFullYear(date);
        }
        return {
          day: date.getDate(),
          month: date.getMonth(),
          year: date.getFullYear()
        };
      }
    }
    function parseDate$1(dateString) {
      const referenceDate = _getReferenceDate();
      for (let format2 of getExtendedFormats(formats)) {
        const parsedDate = doParseDate(dateString, format2, referenceDate);
        if (parsedDate) {
          datepicker.$connector._lastParseStatus = "successful";
          datepicker.$connector._lastParsedDate = parsedDate;
          return parsedDate;
        }
      }
      datepicker.$connector._lastParseStatus = "error";
      return false;
    }
    return {
      formatDate,
      parseDate: parseDate$1
    };
  }
  function _getReferenceDate() {
    const { referenceDate } = datepicker.i18n;
    return referenceDate ? new Date(referenceDate.year, referenceDate.month, referenceDate.day) : /* @__PURE__ */ new Date();
  }
  datepicker.$connector.updateI18n = (locale2, i18n) => {
    const hasCustomFormats = i18n && i18n.dateFormats && i18n.dateFormats.length > 0;
    if (i18n && i18n.referenceDate) {
      i18n.referenceDate = extractDateParts(new Date(i18n.referenceDate));
    }
    const usedFormats = hasCustomFormats ? i18n.dateFormats : [createLocaleBasedDateFormat(locale2)];
    const formatterAndParser = createFormatterAndParser(usedFormats);
    datepicker.i18n = Object.assign({}, datepicker.i18n, i18n, formatterAndParser);
  };
  datepicker.addEventListener("opened-changed", () => datepicker.$connector._lastParseStatus = void 0);
};
/**
 * @license
 * Copyright (c) 2018 - 2025 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
registerStyles$1("vaadin-time-picker-item", [item, comboBoxItem], {
  moduleId: "lumo-time-picker-item"
});
registerStyles$1(
  "vaadin-time-picker-overlay",
  [
    overlay,
    menuOverlayCore,
    comboBoxOverlay,
    css`
      :host {
        --_vaadin-time-picker-items-container-border-width: var(--lumo-space-xs);
        --_vaadin-time-picker-items-container-border-style: solid;
      }
    `
  ],
  {
    moduleId: "lumo-time-picker-overlay"
  }
);
const timePicker = css`
  [part~='toggle-button']::before {
    content: var(--lumo-icons-clock);
  }

  :host([dir='rtl']) [part='input-field'] ::slotted(input:placeholder-shown) {
    --_lumo-text-field-overflow-mask-image: none;
  }

  :host([dir='rtl']) [part='input-field'] ::slotted(input) {
    --_lumo-text-field-overflow-mask-image: linear-gradient(to left, transparent, #000 1.25em);
  }
`;
registerStyles$1("vaadin-time-picker", [inputFieldShared$1, timePicker], { moduleId: "lumo-time-picker" });
/**
 * @license
 * Copyright (c) 2018 - 2025 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
class TimePickerItem extends ComboBoxItemMixin(ThemableMixin(DirMixin(PolymerElement))) {
  static get is() {
    return "vaadin-time-picker-item";
  }
  static get template() {
    return html`
      <style>
        :host {
          display: block;
        }

        :host([hidden]) {
          display: none !important;
        }
      </style>
      <span part="checkmark" aria-hidden="true"></span>
      <div part="content">
        <slot></slot>
      </div>
    `;
  }
}
defineCustomElement(TimePickerItem);
/**
 * @license
 * Copyright (c) 2018 - 2025 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const timePickerOverlayStyles = css`
  #overlay {
    width: var(--vaadin-time-picker-overlay-width, var(--_vaadin-time-picker-overlay-default-width, auto));
  }

  [part='content'] {
    display: flex;
    flex-direction: column;
    height: 100%;
  }
`;
registerStyles$1("vaadin-time-picker-overlay", [overlayStyles, timePickerOverlayStyles], {
  moduleId: "vaadin-time-picker-overlay-styles"
});
class TimePickerOverlay extends ComboBoxOverlayMixin(OverlayMixin(DirMixin(ThemableMixin(PolymerElement)))) {
  static get is() {
    return "vaadin-time-picker-overlay";
  }
  static get template() {
    return html`
      <div id="backdrop" part="backdrop" hidden></div>
      <div part="overlay" id="overlay">
        <div part="content" id="content">
          <slot></slot>
        </div>
      </div>
    `;
  }
}
defineCustomElement(TimePickerOverlay);
/**
 * @license
 * Copyright (c) 2018 - 2025 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
class TimePickerScroller extends ComboBoxScrollerMixin(PolymerElement) {
  static get is() {
    return "vaadin-time-picker-scroller";
  }
  static get template() {
    return html`
      <style>
        :host {
          display: block;
          min-height: 1px;
          overflow: auto;

          /* Fixes item background from getting on top of scrollbars on Safari */
          transform: translate3d(0, 0, 0);

          /* Enable momentum scrolling on iOS */
          -webkit-overflow-scrolling: touch;

          /* Fixes scrollbar disappearing when 'Show scroll bars: Always' enabled in Safari */
          box-shadow: 0 0 0 white;
        }

        #selector {
          border-width: var(--_vaadin-time-picker-items-container-border-width);
          border-style: var(--_vaadin-time-picker-items-container-border-style);
          border-color: var(--_vaadin-time-picker-items-container-border-color, transparent);
          position: relative;
        }
      </style>
      <div id="selector">
        <slot></slot>
      </div>
    `;
  }
}
defineCustomElement(TimePickerScroller);
/**
 * @license
 * Copyright (c) 2018 - 2025 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
class TimePickerComboBox extends ComboBoxMixin(ThemableMixin(PolymerElement)) {
  static get is() {
    return "vaadin-time-picker-combo-box";
  }
  static get template() {
    return html`
      <style>
        :host([opened]) {
          pointer-events: auto;
        }
      </style>

      <slot></slot>

      <vaadin-time-picker-overlay
        id="overlay"
        opened="[[_overlayOpened]]"
        loading$="[[loading]]"
        theme$="[[_theme]]"
        position-target="[[positionTarget]]"
        no-vertical-overlap
        restore-focus-node="[[inputElement]]"
      ></vaadin-time-picker-overlay>
    `;
  }
  static get properties() {
    return {
      positionTarget: {
        type: Object
      }
    };
  }
  /**
   * Tag name prefix used by scroller and items.
   * @protected
   * @return {string}
   */
  get _tagNamePrefix() {
    return "vaadin-time-picker";
  }
  /**
   * Reference to the clear button element.
   * @protected
   * @return {!HTMLElement}
   */
  get clearElement() {
    return this.querySelector('[part="clear-button"]');
  }
  /** @protected */
  ready() {
    super.ready();
    this.allowCustomValue = true;
    this._toggleElement = this.querySelector(".toggle-button");
    this.setAttribute("dir", "ltr");
  }
}
defineCustomElement(TimePickerComboBox);
/**
 * @license
 * Copyright (c) 2018 - 2025 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
function formatISOTime(time) {
  if (!time) {
    return "";
  }
  const pad = (num = 0, fmt = "00") => (fmt + num).substr((fmt + num).length - fmt.length);
  let timeString = `${pad(time.hours)}:${pad(time.minutes)}`;
  if (time.seconds !== void 0) {
    timeString += `:${pad(time.seconds)}`;
  }
  if (time.milliseconds !== void 0) {
    timeString += `.${pad(time.milliseconds, "000")}`;
  }
  return timeString;
}
const MATCH_HOURS = "(\\d|[0-1]\\d|2[0-3])";
const MATCH_MINUTES = "(\\d|[0-5]\\d)";
const MATCH_SECONDS = MATCH_MINUTES;
const MATCH_MILLISECONDS = "(\\d{1,3})";
const re = new RegExp(`^${MATCH_HOURS}(?::${MATCH_MINUTES}(?::${MATCH_SECONDS}(?:\\.${MATCH_MILLISECONDS})?)?)?$`, "u");
function parseISOTime(timeString) {
  const parts = re.exec(timeString);
  if (parts) {
    if (parts[4]) {
      while (parts[4].length < 3) {
        parts[4] += "0";
      }
    }
    return { hours: parts[1], minutes: parts[2], seconds: parts[3], milliseconds: parts[4] };
  }
}
function getStepSegment(stepValue) {
  const step = stepValue == null ? 60 : parseFloat(stepValue);
  if (step % 3600 === 0) {
    return 1;
  } else if (step % 60 === 0 || !step) {
    return 2;
  } else if (step % 1 === 0) {
    return 3;
  } else if (step < 1) {
    return 4;
  }
}
function validateTime(timeObject, step) {
  if (timeObject) {
    const stepSegment = getStepSegment(step);
    timeObject.hours = parseInt(timeObject.hours);
    timeObject.minutes = parseInt(timeObject.minutes || 0);
    timeObject.seconds = stepSegment < 3 ? void 0 : parseInt(timeObject.seconds || 0);
    timeObject.milliseconds = stepSegment < 4 ? void 0 : parseInt(timeObject.milliseconds || 0);
  }
  return timeObject;
}
/**
 * @license
 * Copyright (c) 2018 - 2025 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const timePickerI18nDefaults = Object.freeze({
  formatTime: formatISOTime,
  parseTime: parseISOTime
});
const MIN_ALLOWED_TIME = "00:00:00.000";
const MAX_ALLOWED_TIME = "23:59:59.999";
const TimePickerMixin = (superClass) => class TimePickerMixinClass extends PatternMixin(InputControlMixin(superClass)) {
  static get properties() {
    return {
      /**
       * The time value for this element.
       *
       * Supported time formats are in ISO 8601:
       * - `hh:mm` (default)
       * - `hh:mm:ss`
       * - `hh:mm:ss.fff`
       * @type {string}
       */
      value: {
        type: String,
        notify: true,
        value: "",
        sync: true
      },
      /**
       * True if the dropdown is open, false otherwise.
       */
      opened: {
        type: Boolean,
        notify: true,
        value: false,
        reflectToAttribute: true,
        sync: true
      },
      /**
       * Minimum time allowed.
       *
       * Supported time formats are in ISO 8601:
       * - `hh:mm`
       * - `hh:mm:ss`
       * - `hh:mm:ss.fff`
       * @type {string}
       */
      min: {
        type: String,
        value: "",
        sync: true
      },
      /**
       * Maximum time allowed.
       *
       * Supported time formats are in ISO 8601:
       * - `hh:mm`
       * - `hh:mm:ss`
       * - `hh:mm:ss.fff`
       * @type {string}
       */
      max: {
        type: String,
        value: "",
        sync: true
      },
      /**
       * Defines the time interval (in seconds) between the items displayed
       * in the time selection box. The default is 1 hour (i.e. `3600`).
       *
       * It also configures the precision of the value string. By default
       * the component formats values as `hh:mm` but setting a step value
       * lower than one minute or one second, format resolution changes to
       * `hh:mm:ss` and `hh:mm:ss.fff` respectively.
       *
       * Unit must be set in seconds, and for correctly configuring intervals
       * in the dropdown, it need to evenly divide a day.
       *
       * Note: it is possible to define step that is dividing an hour in inexact
       * fragments (i.e. 5760 seconds which equals 1 hour 36 minutes), but it is
       * not recommended to use it for better UX experience.
       */
      step: {
        type: Number,
        sync: true
      },
      /**
       * Set true to prevent the overlay from opening automatically.
       * @attr {boolean} auto-open-disabled
       */
      autoOpenDisabled: {
        type: Boolean,
        sync: true
      },
      /**
       * A space-delimited list of CSS class names to set on the overlay element.
       *
       * @attr {string} overlay-class
       */
      overlayClass: {
        type: String
      },
      /**
       * The object used to localize this component.
       * To change the default localization, replace the entire
       * _i18n_ object or just the property you want to modify.
       *
       * The object has the following JSON structure:
       *
       * ```
       * {
       *   // A function to format given `Object` as
       *   // time string. Object is in the format `{ hours: ..., minutes: ..., seconds: ..., milliseconds: ... }`
       *   formatTime: (time) => {
       *     // returns a string representation of the given
       *     // object in `hh` / 'hh:mm' / 'hh:mm:ss' / 'hh:mm:ss.fff' - formats
       *   },
       *
       *   // A function to parse the given text to an `Object` in the format
       *   // `{ hours: ..., minutes: ..., seconds: ..., milliseconds: ... }`.
       *   // Must properly parse (at least) text
       *   // formatted by `formatTime`.
       *   parseTime: text => {
       *     // Parses a string in object/string that can be formatted by`formatTime`.
       *   }
       * }
       * ```
       *
       * Both `formatTime` and `parseTime` need to be implemented
       * to ensure the component works properly.
       *
       * @type {!TimePickerI18n}
       */
      i18n: {
        type: Object,
        sync: true,
        value: () => ({ ...timePickerI18nDefaults })
      },
      /** @private */
      _comboBoxValue: {
        type: String,
        sync: true,
        observer: "__comboBoxValueChanged"
      },
      /** @private */
      __dropdownItems: {
        type: Array,
        sync: true
      },
      /** @private */
      _inputContainer: {
        type: Object
      }
    };
  }
  static get observers() {
    return [
      "__updateAriaAttributes(__dropdownItems, opened, inputElement)",
      "__updateDropdownItems(i18n, min, max, step)"
    ];
  }
  static get constraints() {
    return [...super.constraints, "min", "max"];
  }
  /**
   * Used by `ClearButtonMixin` as a reference to the clear button element.
   * @protected
   * @return {!HTMLElement}
   */
  get clearElement() {
    return this.$.clearButton;
  }
  /**
   * The input element's value when it cannot be parsed as a time, and an empty string otherwise.
   *
   * @private
   * @return {string}
   */
  get __unparsableValue() {
    if (this._inputElementValue && !this.i18n.parseTime(this._inputElementValue)) {
      return this._inputElementValue;
    }
    return "";
  }
  /** @protected */
  ready() {
    super.ready();
    this.addController(
      new InputController(
        this,
        (input) => {
          this._setInputElement(input);
          this._setFocusElement(input);
          this.stateTarget = input;
          this.ariaTarget = input;
        },
        {
          // The "search" word is a trick to prevent Safari from enabling AutoFill,
          // which is causing click issues:
          // https://github.com/vaadin/web-components/issues/6817#issuecomment-2268229567
          uniqueIdPrefix: "search-input"
        }
      )
    );
    this.addController(new LabelledInputController(this.inputElement, this._labelController));
    this._inputContainer = this.shadowRoot.querySelector('[part~="input-field"]');
    this._tooltipController = new TooltipController(this);
    this._tooltipController.setShouldShow((timePicker2) => !timePicker2.opened);
    this._tooltipController.setPosition("top");
    this._tooltipController.setAriaTarget(this.inputElement);
    this.addController(this._tooltipController);
  }
  /**
   * Override method inherited from `InputMixin` to forward the input to combo-box.
   * @protected
   * @override
   */
  _inputElementChanged(input) {
    super._inputElementChanged(input);
    if (input) {
      this.$.comboBox._setInputElement(input);
    }
  }
  /**
   * Opens the dropdown list.
   */
  open() {
    if (!this.disabled && !this.readonly) {
      this.opened = true;
    }
  }
  /**
   * Closes the dropdown list.
   */
  close() {
    this.opened = false;
  }
  /**
   * Returns true if the current input value satisfies all constraints (if any).
   * You can override this method for custom validations.
   *
   * @return {boolean} True if the value is valid
   */
  checkValidity() {
    return !!(this.inputElement.checkValidity() && (!this.value || this._timeAllowed(this.i18n.parseTime(this.value))) && (!this._comboBoxValue || this.i18n.parseTime(this._comboBoxValue)));
  }
  /**
   * @param {boolean} focused
   * @override
   * @protected
   */
  _setFocused(focused) {
    super._setFocused(focused);
    if (!focused) {
      if (document.hasFocus()) {
        this._requestValidation();
      }
    }
  }
  /** @private */
  __validDayDivisor(step) {
    return !step || 24 * 3600 % step === 0 || step < 1 && step % 1 * 1e3 % 1 === 0;
  }
  /**
   * Override an event listener from `KeyboardMixin`.
   * @param {!KeyboardEvent} e
   * @protected
   */
  _onKeyDown(e2) {
    super._onKeyDown(e2);
    if (this.readonly || this.disabled || this.__dropdownItems.length) {
      return;
    }
    const stepResolution = this.__validDayDivisor(this.step) && this.step || 60;
    if (e2.keyCode === 40) {
      this.__onArrowPressWithStep(-stepResolution);
    } else if (e2.keyCode === 38) {
      this.__onArrowPressWithStep(stepResolution);
    }
  }
  /**
   * Override an event listener from `KeyboardMixin`.
   * Do not call `super` in order to override clear
   * button logic defined in `InputControlMixin`.
   * @param {Event} event
   * @protected
   */
  _onEscape() {
  }
  /** @private */
  __onArrowPressWithStep(step) {
    const objWithStep = this.__addStep(this.__getMsec(this.__memoValue), step, true);
    this.__memoValue = objWithStep;
    this.__useMemo = true;
    this._comboBoxValue = this.i18n.formatTime(objWithStep);
    this.__useMemo = false;
    this.__commitValueChange();
  }
  /**
   * Depending on the nature of the value change that has occurred since
   * the last commit attempt, triggers validation and fires an event:
   *
   * Value change             | Event
   * -------------------------|-------------------
   * empty => parsable        | change
   * empty => unparsable      | unparsable-change
   * parsable => empty        | change
   * parsable => parsable     | change
   * parsable => unparsable   | change
   * unparsable => empty      | unparsable-change
   * unparsable => parsable   | change
   * unparsable => unparsable | unparsable-change
   *
   * @private
   */
  __commitValueChange() {
    const unparsableValue = this.__unparsableValue;
    if (this.__committedValue !== this.value) {
      this._requestValidation();
      this.dispatchEvent(new CustomEvent("change", { bubbles: true }));
    } else if (this.__committedUnparsableValue !== unparsableValue) {
      this._requestValidation();
      this.dispatchEvent(new CustomEvent("unparsable-change"));
    }
    this.__committedValue = this.value;
    this.__committedUnparsableValue = unparsableValue;
  }
  /**
   * Returning milliseconds from Object in the format `{ hours: ..., minutes: ..., seconds: ..., milliseconds: ... }`
   * @private
   */
  __getMsec(obj) {
    let result = (obj && obj.hours || 0) * 60 * 60 * 1e3;
    result += (obj && obj.minutes || 0) * 60 * 1e3;
    result += (obj && obj.seconds || 0) * 1e3;
    result += obj && parseInt(obj.milliseconds) || 0;
    return result;
  }
  /**
   * Returning seconds from Object in the format `{ hours: ..., minutes: ..., seconds: ..., milliseconds: ... }`
   * @private
   */
  __getSec(obj) {
    let result = (obj && obj.hours || 0) * 60 * 60;
    result += (obj && obj.minutes || 0) * 60;
    result += obj && obj.seconds || 0;
    result += obj && obj.milliseconds / 1e3 || 0;
    return result;
  }
  /**
   * Returning Object in the format `{ hours: ..., minutes: ..., seconds: ..., milliseconds: ... }`
   * from the result of adding step value in milliseconds to the milliseconds amount.
   * With `precision` parameter rounding the value to the closest step valid interval.
   * @private
   */
  __addStep(msec, step, precision) {
    if (msec === 0 && step < 0) {
      msec = 24 * 60 * 60 * 1e3;
    }
    const stepMsec = step * 1e3;
    const diffToNext = msec % stepMsec;
    if (stepMsec < 0 && diffToNext && precision) {
      msec -= diffToNext;
    } else if (stepMsec > 0 && diffToNext && precision) {
      msec -= diffToNext - stepMsec;
    } else {
      msec += stepMsec;
    }
    const hh = Math.floor(msec / 1e3 / 60 / 60);
    msec -= hh * 1e3 * 60 * 60;
    const mm = Math.floor(msec / 1e3 / 60);
    msec -= mm * 1e3 * 60;
    const ss = Math.floor(msec / 1e3);
    msec -= ss * 1e3;
    return { hours: hh < 24 ? hh : 0, minutes: mm, seconds: ss, milliseconds: msec };
  }
  /** @private */
  __updateDropdownItems(i18n, min, max, step) {
    const minTimeObj = validateTime(parseISOTime(min || MIN_ALLOWED_TIME), step);
    const minSec = this.__getSec(minTimeObj);
    const maxTimeObj = validateTime(parseISOTime(max || MAX_ALLOWED_TIME), step);
    const maxSec = this.__getSec(maxTimeObj);
    this.__dropdownItems = this.__generateDropdownList(minSec, maxSec, step);
    if (step !== this.__oldStep) {
      this.__oldStep = step;
      const parsedObj = validateTime(parseISOTime(this.value), step);
      this.__updateValue(parsedObj);
    }
    if (this.value) {
      this._comboBoxValue = i18n.formatTime(i18n.parseTime(this.value));
    }
  }
  /** @private */
  __updateAriaAttributes(items, opened, input) {
    if (items === void 0 || input === void 0) {
      return;
    }
    if (items.length === 0) {
      input.removeAttribute("role");
      input.removeAttribute("aria-expanded");
    } else {
      input.setAttribute("role", "combobox");
      input.setAttribute("aria-expanded", !!opened);
    }
  }
  /** @private */
  __generateDropdownList(minSec, maxSec, step) {
    if (step < 15 * 60 || !this.__validDayDivisor(step)) {
      return [];
    }
    const generatedList = [];
    if (!step) {
      step = 3600;
    }
    let time = -step + minSec;
    while (time + step >= minSec && time + step <= maxSec) {
      const timeObj = validateTime(this.__addStep(time * 1e3, step), step);
      time += step;
      const formatted = this.i18n.formatTime(timeObj);
      generatedList.push({ label: formatted, value: formatted });
    }
    return generatedList;
  }
  /**
   * Override an observer from `InputMixin`.
   * @protected
   * @override
   */
  _valueChanged(value, oldValue) {
    const parsedObj = this.__memoValue = parseISOTime(value);
    const newValue = formatISOTime(parsedObj) || "";
    if (!this.__keepCommittedValue) {
      this.__committedValue = value;
      this.__committedUnparsableValue = "";
    }
    if (value !== "" && value !== null && !parsedObj) {
      this.value = oldValue === void 0 ? "" : oldValue;
    } else if (value !== newValue) {
      this.value = newValue;
    } else if (this.__keepInvalidInput) {
      delete this.__keepInvalidInput;
    } else {
      this.__updateInputValue(parsedObj);
    }
    this._toggleHasValue(this._hasValue);
  }
  /** @private */
  __comboBoxValueChanged(value, oldValue) {
    if (value === "" && oldValue === void 0) {
      return;
    }
    const parsedObj = this.__useMemo ? this.__memoValue : this.i18n.parseTime(value);
    const newValue = this.i18n.formatTime(parsedObj) || "";
    if (parsedObj) {
      if (value !== newValue) {
        this._comboBoxValue = newValue;
      } else {
        this.__keepCommittedValue = true;
        this.__updateValue(parsedObj);
        this.__keepCommittedValue = false;
      }
    } else {
      if (this.value !== "" && value !== "") {
        this.__keepInvalidInput = true;
      }
      this.__keepCommittedValue = true;
      this.value = "";
      this.__keepCommittedValue = false;
    }
  }
  /** @private */
  __onComboBoxChange(event) {
    event.stopPropagation();
    this.__commitValueChange();
  }
  /** @private */
  __updateValue(obj) {
    const timeString = formatISOTime(validateTime(obj, this.step)) || "";
    this.value = timeString;
    this.__updateInputValue(obj);
  }
  /** @private */
  __updateInputValue(obj) {
    const timeString = this.i18n.formatTime(validateTime(obj, this.step)) || "";
    this._comboBoxValue = timeString;
  }
  /**
   * Returns true if `time` satisfies the `min` and `max` constraints (if any).
   *
   * @param {!TimePickerTime} time Value to check against constraints
   * @return {boolean} True if `time` satisfies the constraints
   * @protected
   */
  _timeAllowed(time) {
    const parsedMin = this.i18n.parseTime(this.min || MIN_ALLOWED_TIME);
    const parsedMax = this.i18n.parseTime(this.max || MAX_ALLOWED_TIME);
    return (!this.__getMsec(parsedMin) || this.__getMsec(time) >= this.__getMsec(parsedMin)) && (!this.__getMsec(parsedMax) || this.__getMsec(time) <= this.__getMsec(parsedMax));
  }
  /**
   * Override method inherited from `InputControlMixin`.
   * @protected
   */
  _onClearButtonClick() {
  }
  /**
   * Override method inherited from `InputConstraintsMixin`.
   * @protected
   */
  _onChange() {
  }
  /**
   * Override method inherited from `InputMixin`.
   * @protected
   */
  _onInput() {
  }
  /**
   * Fired when the user commits a value change.
   *
   * @event change
   */
};
/**
 * @license
 * Copyright (c) 2018 - 2025 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
registerStyles$1("vaadin-time-picker", inputFieldShared, { moduleId: "vaadin-time-picker-styles" });
class TimePicker extends TimePickerMixin(ThemableMixin(ElementMixin(PolymerElement))) {
  static get is() {
    return "vaadin-time-picker";
  }
  static get template() {
    return html`
      <style>
        /* See https://github.com/vaadin/vaadin-time-picker/issues/145 */
        :host([dir='rtl']) [part='input-field'] {
          direction: ltr;
        }

        :host([dir='rtl']) [part='input-field'] ::slotted(input)::placeholder {
          direction: rtl;
          text-align: left;
        }

        [part~='toggle-button'] {
          cursor: pointer;
        }
      </style>

      <div class="vaadin-time-picker-container">
        <div part="label">
          <slot name="label"></slot>
          <span part="required-indicator" aria-hidden="true" on-click="focus"></span>
        </div>

        <vaadin-time-picker-combo-box
          id="comboBox"
          filtered-items="[[__dropdownItems]]"
          value="{{_comboBoxValue}}"
          opened="{{opened}}"
          disabled="[[disabled]]"
          readonly="[[readonly]]"
          clear-button-visible="[[clearButtonVisible]]"
          auto-open-disabled="[[autoOpenDisabled]]"
          overlay-class="[[overlayClass]]"
          position-target="[[_inputContainer]]"
          theme$="[[_theme]]"
          on-change="__onComboBoxChange"
        >
          <vaadin-input-container
            part="input-field"
            readonly="[[readonly]]"
            disabled="[[disabled]]"
            invalid="[[invalid]]"
            theme$="[[_theme]]"
          >
            <slot name="prefix" slot="prefix"></slot>
            <slot name="input"></slot>
            <div id="clearButton" part="clear-button" slot="suffix" aria-hidden="true"></div>
            <div id="toggleButton" class="toggle-button" part="toggle-button" slot="suffix" aria-hidden="true"></div>
          </vaadin-input-container>
        </vaadin-time-picker-combo-box>

        <div part="helper-text">
          <slot name="helper"></slot>
        </div>

        <div part="error-message">
          <slot name="error-message"></slot>
        </div>
      </div>
      <slot name="tooltip"></slot>
    `;
  }
}
defineCustomElement(TimePicker);
const dateTimePicker = css`
  ::slotted([slot='date-picker']) {
    margin-inline-end: 2px;
    --vaadin-input-field-top-end-radius: 0;
    --vaadin-input-field-bottom-end-radius: 0;
  }

  ::slotted([slot='time-picker']) {
    --vaadin-input-field-top-start-radius: 0;
    --vaadin-input-field-bottom-start-radius: 0;
  }
`;
registerStyles$1("vaadin-date-time-picker", [dateTimePicker, requiredField, helper, customField], {
  moduleId: "lumo-date-time-picker"
});
/**
 * @license
 * Copyright (c) 2019 - 2025 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const datePickerI18nProps = Object.keys(datePickerI18nDefaults);
const timePickerI18nProps = Object.keys(timePickerI18nDefaults);
class PickerSlotController extends SlotController {
  constructor(host, type) {
    super(host, `${type}-picker`, `vaadin-${type}-picker`, {
      initializer: (picker, host2) => {
        const prop = `__${type}Picker`;
        host2[prop] = picker;
      }
    });
  }
}
const DateTimePickerMixin = (superClass) => class DateTimePickerMixinClass extends FieldMixin(FocusMixin(DisabledMixin(superClass))) {
  static get properties() {
    return {
      /**
       * The name of the control, which is submitted with the form data.
       */
      name: {
        type: String
      },
      /**
       * The value for this element.
       *
       * Supported date time format is based on ISO 8601 (without a time zone designator):
       * - Minute precision `"YYYY-MM-DDThh:mm"` (default)
       * - Second precision `"YYYY-MM-DDThh:mm:ss"`
       * - Millisecond precision `"YYYY-MM-DDThh:mm:ss.fff"`
       * @type {string}
       */
      value: {
        type: String,
        notify: true,
        value: "",
        observer: "__valueChanged",
        sync: true
      },
      /**
       * The earliest allowed value (date and time) that can be selected. All earlier values will be disabled.
       *
       * Supported date time format is based on ISO 8601 (without a time zone designator):
       * - Minute precision `"YYYY-MM-DDThh:mm"`
       * - Second precision `"YYYY-MM-DDThh:mm:ss"`
       * - Millisecond precision `"YYYY-MM-DDThh:mm:ss.fff"`
       *
       * @type {string | undefined}
       */
      min: {
        type: String,
        observer: "__minChanged",
        sync: true
      },
      /**
       * The latest value (date and time) that can be selected. All later values will be disabled.
       *
       * Supported date time format is based on ISO 8601 (without a time zone designator):
       * - Minute precision `"YYYY-MM-DDThh:mm"`
       * - Second precision `"YYYY-MM-DDThh:mm:ss"`
       * - Millisecond precision `"YYYY-MM-DDThh:mm:ss.fff"`
       *
       * @type {string | undefined}
       */
      max: {
        type: String,
        observer: "__maxChanged",
        sync: true
      },
      /**
       * The earliest value that can be selected. All earlier values will be disabled.
       * @private
       */
      __minDateTime: {
        type: Date,
        value: "",
        sync: true
      },
      /**
       * The latest value that can be selected. All later values will be disabled.
       * @private
       */
      __maxDateTime: {
        type: Date,
        value: "",
        sync: true
      },
      /**
       * A placeholder string for the date field.
       * @attr {string} date-placeholder
       */
      datePlaceholder: {
        type: String,
        sync: true
      },
      /**
       * A placeholder string for the time field.
       * @attr {string} time-placeholder
       */
      timePlaceholder: {
        type: String,
        sync: true
      },
      /**
       * Defines the time interval (in seconds) between the items displayed
       * in the time selection box. The default is 1 hour (i.e. `3600`).
       *
       * It also configures the precision of the time part of the value string. By default
       * the component formats time values as `hh:mm` but setting a step value
       * lower than one minute or one second, format resolution changes to
       * `hh:mm:ss` and `hh:mm:ss.fff` respectively.
       *
       * Unit must be set in seconds, and for correctly configuring intervals
       * in the dropdown, it need to evenly divide a day.
       *
       * Note: it is possible to define step that is dividing an hour in inexact
       * fragments (i.e. 5760 seconds which equals 1 hour 36 minutes), but it is
       * not recommended to use it for better UX.
       */
      step: {
        type: Number,
        sync: true
      },
      /**
       * Date which should be visible in the date picker overlay when there is no value selected.
       *
       * The same date formats as for the `value` property are supported but without the time part.
       * @attr {string} initial-position
       */
      initialPosition: {
        type: String,
        sync: true
      },
      /**
       * Set true to display ISO-8601 week numbers in the calendar. Notice that
       * displaying week numbers is only supported when `i18n.firstDayOfWeek`
       * is 1 (Monday).
       * @attr {boolean} show-week-numbers
       */
      showWeekNumbers: {
        type: Boolean,
        value: false,
        sync: true
      },
      /**
       * Set to true to prevent the overlays from opening automatically.
       * @attr {boolean} auto-open-disabled
       */
      autoOpenDisabled: {
        type: Boolean,
        sync: true
      },
      /**
       * Set to true to make this element read-only.
       * @type {boolean}
       */
      readonly: {
        type: Boolean,
        value: false,
        reflectToAttribute: true,
        sync: true
      },
      /**
       * Specify that this control should have input focus when the page loads.
       * @type {boolean}
       */
      autofocus: {
        type: Boolean
      },
      /**
       * The current selected date time.
       * @private
       */
      __selectedDateTime: {
        type: Date,
        sync: true
      },
      /**
       * The object used to localize this component.
       * To change the default localization, replace the entire
       * `i18n` object or just the properties you want to modify.
       *
       * The object is a combination of the i18n properties supported by
       * [`<vaadin-date-picker>`](#/elements/vaadin-date-picker) and
       * [`<vaadin-time-picker>`](#/elements/vaadin-time-picker).
       * @type {!DateTimePickerI18n}
       */
      i18n: {
        type: Object,
        sync: true,
        value: () => ({ ...datePickerI18nDefaults, ...timePickerI18nDefaults })
      },
      /**
       * A space-delimited list of CSS class names to set on the overlay elements
       * of the internal components controlled by the `<vaadin-date-time-picker>`:
       *
       * - [`<vaadin-date-picker>`](#/elements/vaadin-date-picker#property-overlayClass)
       * - [`<vaadin-time-picker>`](#/elements/vaadin-time-picker#property-overlayClass)
       *
       * @attr {string} overlay-class
       */
      overlayClass: {
        type: String
      },
      /**
       * The current slotted date picker.
       * @private
       */
      __datePicker: {
        type: Object,
        sync: true,
        observer: "__datePickerChanged"
      },
      /**
       * The current slotted time picker.
       * @private
       */
      __timePicker: {
        type: Object,
        sync: true,
        observer: "__timePickerChanged"
      }
    };
  }
  static get observers() {
    return [
      "__selectedDateTimeChanged(__selectedDateTime)",
      "__datePlaceholderChanged(datePlaceholder, __datePicker)",
      "__timePlaceholderChanged(timePlaceholder, __timePicker)",
      "__stepChanged(step, __timePicker)",
      "__initialPositionChanged(initialPosition, __datePicker)",
      "__showWeekNumbersChanged(showWeekNumbers, __datePicker)",
      "__requiredChanged(required, __datePicker, __timePicker)",
      "__invalidChanged(invalid, __datePicker, __timePicker)",
      "__disabledChanged(disabled, __datePicker, __timePicker)",
      "__readonlyChanged(readonly, __datePicker, __timePicker)",
      "__i18nChanged(i18n, __datePicker, __timePicker)",
      "__autoOpenDisabledChanged(autoOpenDisabled, __datePicker, __timePicker)",
      "__themeChanged(_theme, __datePicker, __timePicker)",
      "__overlayClassChanged(overlayClass, __datePicker, __timePicker)",
      "__pickersChanged(__datePicker, __timePicker)",
      "__labelOrAccessibleNameChanged(label, accessibleName, i18n, __datePicker, __timePicker)"
    ];
  }
  constructor() {
    super();
    this.__defaultDateMinMaxValue = void 0;
    this.__defaultTimeMinValue = "00:00:00.000";
    this.__defaultTimeMaxValue = "23:59:59.999";
    this.__changeEventHandler = this.__changeEventHandler.bind(this);
    this.__valueChangedEventHandler = this.__valueChangedEventHandler.bind(this);
    this.__openedChangedEventHandler = this.__openedChangedEventHandler.bind(this);
  }
  /** @private */
  get __pickers() {
    return [this.__datePicker, this.__timePicker];
  }
  /** @private */
  get __formattedValue() {
    const values = this.__pickers.map((picker) => picker.value);
    return values.every(Boolean) ? values.join("T") : "";
  }
  /** @protected */
  ready() {
    super.ready();
    this._datePickerController = new PickerSlotController(this, "date");
    this.addController(this._datePickerController);
    this._timePickerController = new PickerSlotController(this, "time");
    this.addController(this._timePickerController);
    if (this.autofocus && !this.disabled) {
      window.requestAnimationFrame(() => this.focus());
    }
    this.setAttribute("role", "group");
    this._tooltipController = new TooltipController(this);
    this.addController(this._tooltipController);
    this._tooltipController.setPosition("top");
    this._tooltipController.setShouldShow((target) => {
      return target.__datePicker && !target.__datePicker.opened && target.__timePicker && !target.__timePicker.opened;
    });
    this.ariaTarget = this;
  }
  focus() {
    if (this.__datePicker) {
      this.__datePicker.focus();
    }
  }
  /**
   * Override method inherited from `FocusMixin` to validate on blur.
   * @param {boolean} focused
   * @protected
   * @override
   */
  _setFocused(focused) {
    super._setFocused(focused);
    if (!focused && document.hasFocus()) {
      this._requestValidation();
    }
  }
  /**
   * Override method inherited from `FocusMixin` to not remove focused
   * state when focus moves between pickers or to the overlay.
   * @param {FocusEvent} event
   * @return {boolean}
   * @protected
   * @override
   */
  _shouldRemoveFocus(event) {
    const target = event.relatedTarget;
    const overlayContent = this.__datePicker._overlayContent;
    if (this.__datePicker.contains(target) || this.__timePicker.contains(target) || overlayContent && overlayContent.contains(target)) {
      return false;
    }
    return true;
  }
  /** @private */
  __syncI18n(target, source, props = Object.keys(source.i18n)) {
    const i18n = { ...target.i18n };
    props.forEach((prop) => {
      if (source.i18n && source.i18n.hasOwnProperty(prop)) {
        i18n[prop] = source.i18n[prop];
      }
    });
    target.i18n = i18n;
  }
  /** @private */
  __changeEventHandler(event) {
    event.stopPropagation();
    if (this.__dispatchChangeForValue === this.value) {
      this._requestValidation();
      this.__dispatchChange();
    }
    this.__dispatchChangeForValue = void 0;
  }
  /** @private */
  __openedChangedEventHandler() {
    const opened = this.__datePicker.opened || this.__timePicker.opened;
    this.style.pointerEvents = opened ? "auto" : "";
  }
  /** @private */
  __addInputListeners(node) {
    node.addEventListener("change", this.__changeEventHandler);
    node.addEventListener("value-changed", this.__valueChangedEventHandler);
    node.addEventListener("opened-changed", this.__openedChangedEventHandler);
  }
  /** @private */
  __removeInputListeners(node) {
    node.removeEventListener("change", this.__changeEventHandler);
    node.removeEventListener("value-changed", this.__valueChangedEventHandler);
    node.removeEventListener("opened-changed", this.__openedChangedEventHandler);
  }
  /** @private */
  __isDefaultPicker(picker, type) {
    const controller = this[`_${type}PickerController`];
    return controller && picker === controller.defaultNode;
  }
  /** @private */
  __datePickerChanged(newDatePicker, existingDatePicker) {
    if (!newDatePicker) {
      return;
    }
    if (existingDatePicker) {
      this.__removeInputListeners(existingDatePicker);
      existingDatePicker.remove();
    }
    this.__addInputListeners(newDatePicker);
    if (!this.__isDefaultPicker(newDatePicker, "date")) {
      this.datePlaceholder = newDatePicker.placeholder;
      this.initialPosition = newDatePicker.initialPosition;
      this.showWeekNumbers = newDatePicker.showWeekNumbers;
      this.__syncI18n(this, newDatePicker, datePickerI18nProps);
    }
    newDatePicker.min = this.__formatDateISO(this.__minDateTime, this.__defaultDateMinMaxValue);
    newDatePicker.max = this.__formatDateISO(this.__maxDateTime, this.__defaultDateMinMaxValue);
    newDatePicker.manualValidation = true;
  }
  /** @private */
  __timePickerChanged(newTimePicker, existingTimePicker) {
    if (!newTimePicker) {
      return;
    }
    if (existingTimePicker) {
      this.__removeInputListeners(existingTimePicker);
      existingTimePicker.remove();
    }
    this.__addInputListeners(newTimePicker);
    if (!this.__isDefaultPicker(newTimePicker, "time")) {
      this.timePlaceholder = newTimePicker.placeholder;
      this.step = newTimePicker.step;
      this.__syncI18n(this, newTimePicker, timePickerI18nProps);
    }
    this.__updateTimePickerMinMax();
    newTimePicker.manualValidation = true;
  }
  /** @private */
  __updateTimePickerMinMax() {
    if (this.__timePicker && this.__datePicker) {
      const selectedDate = this.__parseDate(this.__datePicker.value);
      const isMinMaxSameDay = dateEquals(this.__minDateTime, this.__maxDateTime, normalizeUTCDate);
      if (this.__minDateTime && dateEquals(selectedDate, this.__minDateTime, normalizeUTCDate) || isMinMaxSameDay) {
        this.__timePicker.min = this.__dateToIsoTimeString(this.__minDateTime);
      } else {
        this.__timePicker.min = this.__defaultTimeMinValue;
      }
      if (this.__maxDateTime && dateEquals(selectedDate, this.__maxDateTime, normalizeUTCDate) || isMinMaxSameDay) {
        this.__timePicker.max = this.__dateToIsoTimeString(this.__maxDateTime);
      } else {
        this.__timePicker.max = this.__defaultTimeMaxValue;
      }
    }
  }
  /** @private */
  __i18nChanged(_i18n, datePicker2, timePicker2) {
    if (datePicker2) {
      this.__syncI18n(datePicker2, this, datePickerI18nProps);
    }
    if (timePicker2) {
      this.__syncI18n(timePicker2, this, timePickerI18nProps);
    }
  }
  /** @private */
  __labelOrAccessibleNameChanged(label, accessibleName, i18n, datePicker2, timePicker2) {
    const name = accessibleName || label || "";
    if (datePicker2) {
      datePicker2.accessibleName = `${name} ${i18n.dateLabel || ""}`.trim();
    }
    if (timePicker2) {
      timePicker2.accessibleName = `${name} ${i18n.timeLabel || ""}`.trim();
    }
  }
  /** @private */
  __datePlaceholderChanged(datePlaceholder, datePicker2) {
    if (datePicker2) {
      datePicker2.placeholder = datePlaceholder;
    }
  }
  /** @private */
  __timePlaceholderChanged(timePlaceholder, timePicker2) {
    if (timePicker2) {
      timePicker2.placeholder = timePlaceholder;
    }
  }
  /** @private */
  __stepChanged(step, timePicker2) {
    if (timePicker2 && timePicker2.step !== step) {
      timePicker2.step = step;
    }
  }
  /** @private */
  __initialPositionChanged(initialPosition, datePicker2) {
    if (datePicker2) {
      datePicker2.initialPosition = initialPosition;
    }
  }
  /** @private */
  __showWeekNumbersChanged(showWeekNumbers, datePicker2) {
    if (datePicker2) {
      datePicker2.showWeekNumbers = showWeekNumbers;
    }
  }
  /** @private */
  __invalidChanged(invalid, datePicker2, timePicker2) {
    if (datePicker2) {
      datePicker2.invalid = invalid;
    }
    if (timePicker2) {
      timePicker2.invalid = invalid;
    }
  }
  /** @private */
  __requiredChanged(required, datePicker2, timePicker2) {
    if (datePicker2) {
      datePicker2.required = required;
    }
    if (timePicker2) {
      timePicker2.required = required;
    }
    if (this.__oldRequired && !required) {
      this._requestValidation();
    }
    this.__oldRequired = required;
  }
  /** @private */
  __disabledChanged(disabled, datePicker2, timePicker2) {
    if (datePicker2) {
      datePicker2.disabled = disabled;
    }
    if (timePicker2) {
      timePicker2.disabled = disabled;
    }
  }
  /** @private */
  __readonlyChanged(readonly, datePicker2, timePicker2) {
    if (datePicker2) {
      datePicker2.readonly = readonly;
    }
    if (timePicker2) {
      timePicker2.readonly = readonly;
    }
  }
  /**
   * String (ISO date) to Date object
   * @param {string} str e.g. 'yyyy-mm-dd'
   * @return {Date | undefined}
   * @private
   */
  __parseDate(str) {
    return parseUTCDate(str);
  }
  /**
   * Date object to string (ISO date)
   * @param {Date} date
   * @param {string} defaultValue
   * @return {string} e.g. 'yyyy-mm-dd' (or defaultValue when date is falsy)
   * @private
   */
  __formatDateISO(date, defaultValue) {
    if (!date) {
      return defaultValue;
    }
    return formatUTCISODate(date);
  }
  /**
   * String (ISO date time) to Date object
   * @param {string} str e.g. 'yyyy-mm-ddThh:mm', 'yyyy-mm-ddThh:mm:ss', 'yyyy-mm-ddThh:mm:ss.fff'
   * @return {Date | undefined}
   * @private
   */
  __parseDateTime(str) {
    const [dateValue, timeValue] = str.split("T");
    if (!(dateValue && timeValue)) {
      return;
    }
    const date = this.__parseDate(dateValue);
    if (!date) {
      return;
    }
    const time = parseISOTime(timeValue);
    if (!time) {
      return;
    }
    date.setUTCHours(parseInt(time.hours));
    date.setUTCMinutes(parseInt(time.minutes || 0));
    date.setUTCSeconds(parseInt(time.seconds || 0));
    date.setUTCMilliseconds(parseInt(time.milliseconds || 0));
    return date;
  }
  /**
   * Date object to string (ISO date time)
   * @param {Date} date
   * @return {string} e.g. 'yyyy-mm-ddThh:mm', 'yyyy-mm-ddThh:mm:ss', 'yyyy-mm-ddThh:mm:ss.fff'
   *                  (depending on precision defined by "step" property)
   * @private
   */
  __formatDateTime(date) {
    if (!date) {
      return "";
    }
    const dateValue = this.__formatDateISO(date, "");
    const timeValue = this.__dateToIsoTimeString(date);
    return `${dateValue}T${timeValue}`;
  }
  /**
   * Date object to string (ISO time)
   * @param {Date} date
   * @return {string} e.g. 'hh:mm', 'hh:mm:ss', 'hh:mm:ss.fff' (depending on precision defined by "step" property)
   * @private
   */
  __dateToIsoTimeString(date) {
    return formatISOTime(
      validateTime(
        {
          hours: date.getUTCHours(),
          minutes: date.getUTCMinutes(),
          seconds: date.getUTCSeconds(),
          milliseconds: date.getUTCMilliseconds()
        },
        this.step
      )
    );
  }
  /**
   * Returns true if the current input value satisfies all constraints (if any)
   *
   * You can override the `checkValidity` method for custom validations.
   * @return {boolean}
   */
  checkValidity() {
    const hasInvalidPickers = this.__pickers.some((picker) => !picker.checkValidity());
    const hasEmptyRequiredPickers = this.required && this.__pickers.some((picker) => !picker.value);
    return !hasInvalidPickers && !hasEmptyRequiredPickers;
  }
  /**
   * @param {Date} date1
   * @param {Date} date2
   * @return {boolean}
   * @private
   */
  __dateTimeEquals(date1, date2) {
    if (!dateEquals(date1, date2, normalizeUTCDate)) {
      return false;
    }
    return date1.getUTCHours() === date2.getUTCHours() && date1.getUTCMinutes() === date2.getUTCMinutes() && date1.getUTCSeconds() === date2.getUTCSeconds() && date1.getUTCMilliseconds() === date2.getUTCMilliseconds();
  }
  /** @private */
  __handleDateTimeChange(property, parsedProperty, value, oldValue) {
    if (!value) {
      this[property] = "";
      this[parsedProperty] = "";
      return;
    }
    const dateTime = this.__parseDateTime(value);
    if (!dateTime) {
      this[property] = oldValue;
      return;
    }
    if (!this.__dateTimeEquals(this[parsedProperty], dateTime)) {
      this[parsedProperty] = dateTime;
    }
  }
  /** @private */
  __valueChanged(value, oldValue) {
    this.__handleDateTimeChange("value", "__selectedDateTime", value, oldValue);
    if (oldValue !== void 0) {
      this.__dispatchChangeForValue = value;
    }
    this.toggleAttribute("has-value", !!value);
    this.__updateTimePickerMinMax();
  }
  /** @private */
  __dispatchChange() {
    this.dispatchEvent(new CustomEvent("change", { bubbles: true }));
  }
  /** @private */
  __minChanged(value, oldValue) {
    this.__handleDateTimeChange("min", "__minDateTime", value, oldValue);
    if (this.__datePicker) {
      this.__datePicker.min = this.__formatDateISO(this.__minDateTime, this.__defaultDateMinMaxValue);
    }
    this.__updateTimePickerMinMax();
    if (this.__datePicker && this.__timePicker && this.value) {
      this._requestValidation();
    }
  }
  /** @private */
  __maxChanged(value, oldValue) {
    this.__handleDateTimeChange("max", "__maxDateTime", value, oldValue);
    if (this.__datePicker) {
      this.__datePicker.max = this.__formatDateISO(this.__maxDateTime, this.__defaultDateMinMaxValue);
    }
    this.__updateTimePickerMinMax();
    if (this.__datePicker && this.__timePicker && this.value) {
      this._requestValidation();
    }
  }
  /** @private */
  __selectedDateTimeChanged(selectedDateTime) {
    const formattedValue = this.__formatDateTime(selectedDateTime);
    if (this.value !== formattedValue) {
      this.value = formattedValue;
    }
    const isDatePickerReady = Boolean(this.__datePicker && this.__datePicker.$);
    if (isDatePickerReady && !this.__ignoreInputValueChange) {
      this.__ignoreInputValueChange = true;
      const [dateValue, timeValue] = this.value.split("T");
      this.__datePicker.value = dateValue || "";
      this.__timePicker.value = timeValue || "";
      this.__ignoreInputValueChange = false;
    }
  }
  /** @private */
  __valueChangedEventHandler() {
    if (this.__ignoreInputValueChange) {
      return;
    }
    this.__ignoreInputValueChange = true;
    this.__updateTimePickerMinMax();
    this.value = this.__formattedValue;
    this.__ignoreInputValueChange = false;
  }
  /** @private */
  __autoOpenDisabledChanged(autoOpenDisabled, datePicker2, timePicker2) {
    if (datePicker2) {
      datePicker2.autoOpenDisabled = autoOpenDisabled;
    }
    if (timePicker2) {
      timePicker2.autoOpenDisabled = autoOpenDisabled;
    }
  }
  /** @private */
  __themeChanged(theme, datePicker2, timePicker2) {
    if (!datePicker2 || !timePicker2) {
      return;
    }
    [datePicker2, timePicker2].forEach((picker) => {
      if (theme) {
        picker.setAttribute("theme", theme);
      } else {
        picker.removeAttribute("theme");
      }
    });
  }
  /** @private */
  __overlayClassChanged(overlayClass, datePicker2, timePicker2) {
    if (!datePicker2 || !timePicker2) {
      return;
    }
    datePicker2.overlayClass = overlayClass;
    timePicker2.overlayClass = overlayClass;
  }
  /** @private */
  __pickersChanged(datePicker2, timePicker2) {
    if (!datePicker2 || !timePicker2) {
      return;
    }
    if (this.__isDefaultPicker(datePicker2, "date") !== this.__isDefaultPicker(timePicker2, "time")) {
      return;
    }
    if (datePicker2.value) {
      this.__valueChangedEventHandler();
    } else if (this.value) {
      this.__selectedDateTimeChanged(this.__selectedDateTime);
      if (this.min && this.__minDateTime || this.max && this.__maxDateTime) {
        this._requestValidation();
      }
    }
  }
  /**
   * Fired when the user commits a value change.
   *
   * @event change
   */
};
/**
 * @license
 * Copyright (c) 2019 - 2025 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
registerStyles$1("vaadin-date-time-picker", inputFieldShared, { moduleId: "vaadin-date-time-picker" });
class DateTimePicker extends DateTimePickerMixin(ThemableMixin(ElementMixin(PolymerElement))) {
  static get template() {
    return html`
      <style>
        .vaadin-date-time-picker-container {
          --vaadin-field-default-width: auto;
        }

        .slots {
          display: flex;
          --vaadin-field-default-width: 12em;
        }

        .slots ::slotted([slot='date-picker']) {
          min-width: 0;
          flex: 1 1 auto;
        }

        .slots ::slotted([slot='time-picker']) {
          min-width: 0;
          flex: 1 1.65 auto;
        }
      </style>

      <div class="vaadin-date-time-picker-container">
        <div part="label" on-click="focus">
          <slot name="label"></slot>
          <span part="required-indicator" aria-hidden="true"></span>
        </div>

        <div class="slots">
          <slot name="date-picker" id="dateSlot"></slot>
          <slot name="time-picker" id="timeSlot"></slot>
        </div>

        <div part="helper-text">
          <slot name="helper"></slot>
        </div>

        <div part="error-message">
          <slot name="error-message"></slot>
        </div>
      </div>

      <slot name="tooltip"></slot>
    `;
  }
  static get is() {
    return "vaadin-date-time-picker";
  }
}
defineCustomElement(DateTimePicker);
const EASTERN_ARABIC_DIGIT_MAP = {
  "\\u0660": "0",
  "\\u0661": "1",
  "\\u0662": "2",
  "\\u0663": "3",
  "\\u0664": "4",
  "\\u0665": "5",
  "\\u0666": "6",
  "\\u0667": "7",
  "\\u0668": "8",
  "\\u0669": "9"
};
function escapeRegExp(string) {
  return string.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
}
function parseEasternArabicDigits(digits) {
  return digits.replace(/[\u0660-\u0669]/g, function(char) {
    const unicode = "\\u0" + char.charCodeAt(0).toString(16);
    return EASTERN_ARABIC_DIGIT_MAP[unicode];
  });
}
function getAmOrPmString(locale2, testTime) {
  const testTimeString = testTime.toLocaleTimeString(locale2);
  const amOrPmRegExp = /[^\d\u0660-\u0669]/;
  const matches2 = (
    // In most locales, the time ends with AM/PM:
    testTimeString.match(new RegExp(`${amOrPmRegExp.source}+$`, "g")) || // In some locales, the time starts with AM/PM e.g in Chinese:
    testTimeString.match(new RegExp(`^${amOrPmRegExp.source}+`, "g"))
  );
  return matches2 && matches2[0].trim();
}
function getSeparator(locale2) {
  let timeString = TEST_PM_TIME.toLocaleTimeString(locale2);
  const pmString = getPmString(locale2);
  if (pmString && timeString.startsWith(pmString)) {
    timeString = timeString.replace(pmString, "");
  }
  const matches2 = timeString.match(/[^\u0660-\u0669\s\d]/);
  return matches2 && matches2[0];
}
function searchAmOrPmToken(timeString, amOrPmString) {
  if (!amOrPmString) return null;
  const tokenRegExpString = amOrPmString.split(/\s*/).map(escapeRegExp).join("\\s*");
  const tokenRegExp = new RegExp(tokenRegExpString, "i");
  const tokenMatches = timeString.match(tokenRegExp);
  if (tokenMatches) {
    return tokenMatches[0];
  }
}
const TEST_PM_TIME = /* @__PURE__ */ new Date("August 19, 1975 23:15:30");
const TEST_AM_TIME = /* @__PURE__ */ new Date("August 19, 1975 05:15:30");
function getPmString(locale2) {
  return getAmOrPmString(locale2, TEST_PM_TIME);
}
function getAmString(locale2) {
  return getAmOrPmString(locale2, TEST_AM_TIME);
}
function parseDigitsIntoInteger(digits) {
  return parseInt(parseEasternArabicDigits(digits));
}
function parseMillisecondsIntoInteger(milliseconds) {
  milliseconds = parseEasternArabicDigits(milliseconds);
  if (milliseconds.length === 1) {
    milliseconds += "00";
  } else if (milliseconds.length === 2) {
    milliseconds += "0";
  }
  return parseInt(milliseconds);
}
function formatMilliseconds(timeString, milliseconds, amString, pmString) {
  let cleanedTimeString = timeString;
  if (timeString.endsWith(amString)) {
    cleanedTimeString = timeString.replace(" " + amString, "");
  } else if (timeString.endsWith(pmString)) {
    cleanedTimeString = timeString.replace(" " + pmString, "");
  }
  if (milliseconds) {
    let millisecondsString = milliseconds < 10 ? "0" : "";
    millisecondsString += milliseconds < 100 ? "0" : "";
    millisecondsString += milliseconds;
    cleanedTimeString += "." + millisecondsString;
  } else {
    cleanedTimeString += ".000";
  }
  if (timeString.endsWith(amString)) {
    cleanedTimeString = cleanedTimeString + " " + amString;
  } else if (timeString.endsWith(pmString)) {
    cleanedTimeString = cleanedTimeString + " " + pmString;
  }
  return cleanedTimeString;
}
function when(predicate, callback, timeout = 0) {
  if (predicate()) {
    callback();
  } else {
    setTimeout(() => when(predicate, callback, 200), timeout);
  }
}
function parseISO(text) {
  const timeObject = parseISOTime(text);
  return {
    hours: parseInt(timeObject.hours || 0),
    minutes: parseInt(timeObject.minutes || 0),
    seconds: parseInt(timeObject.seconds || 0),
    milliseconds: parseInt(timeObject.milliseconds || 0)
  };
}
window.Vaadin.Flow.timepickerConnector = {};
window.Vaadin.Flow.timepickerConnector.initLazy = (timepicker) => {
  if (timepicker.$connector) {
    return;
  }
  timepicker.$connector = {};
  timepicker.$connector.setLocale = (locale2) => {
    let previousValueObject;
    if (timepicker.value && timepicker.value !== "") {
      previousValueObject = parseISO(timepicker.value);
    }
    try {
      TEST_PM_TIME.toLocaleTimeString(locale2);
    } catch (e2) {
      locale2 = "en-US";
      throw new Error(
        "vaadin-time-picker: The locale " + locale2 + " is not supported, falling back to default locale setting(en-US)."
      );
    }
    const pmString = getPmString(locale2);
    const amString = getAmString(locale2);
    const separator = getSeparator(locale2);
    const includeSeconds = function() {
      return timepicker.step && timepicker.step < 60;
    };
    const includeMilliSeconds = function() {
      return timepicker.step && timepicker.step < 1;
    };
    let cachedTimeString;
    let cachedTimeObject;
    timepicker.i18n = {
      formatTime(timeObject) {
        if (!timeObject) return;
        const timeToBeFormatted = /* @__PURE__ */ new Date();
        timeToBeFormatted.setHours(timeObject.hours);
        timeToBeFormatted.setMinutes(timeObject.minutes);
        timeToBeFormatted.setSeconds(timeObject.seconds !== void 0 ? timeObject.seconds : 0);
        let localeTimeString = timeToBeFormatted.toLocaleTimeString(locale2, {
          hour: "numeric",
          minute: "numeric",
          second: includeSeconds() ? "numeric" : void 0
        });
        if (includeMilliSeconds()) {
          localeTimeString = formatMilliseconds(localeTimeString, timeObject.milliseconds, amString, pmString);
        }
        return localeTimeString;
      },
      parseTime(timeString) {
        if (timeString && timeString === cachedTimeString && cachedTimeObject) {
          return cachedTimeObject;
        }
        if (!timeString) {
          return;
        }
        const amToken = searchAmOrPmToken(timeString, amString);
        const pmToken = searchAmOrPmToken(timeString, pmString);
        const numbersOnlyTimeString = timeString.replace(amToken || "", "").replace(pmToken || "", "").trim();
        const numbersRegExp = new RegExp("([\\d\\u0660-\\u0669]){1,2}(?:" + separator + ")?", "g");
        let hours = numbersRegExp.exec(numbersOnlyTimeString);
        if (hours) {
          hours = parseDigitsIntoInteger(hours[0].replace(separator, ""));
          if (amToken !== pmToken) {
            if (hours === 12 && amToken) {
              hours = 0;
            }
            if (hours !== 12 && pmToken) {
              hours += 12;
            }
          }
          const minutes = numbersRegExp.exec(numbersOnlyTimeString);
          const seconds = minutes && numbersRegExp.exec(numbersOnlyTimeString);
          const millisecondRegExp = /[[\.][\d\u0660-\u0669]{1,3}$/;
          let milliseconds = seconds && includeMilliSeconds() && millisecondRegExp.exec(numbersOnlyTimeString);
          if (milliseconds && milliseconds["index"] <= seconds["index"]) {
            milliseconds = void 0;
          }
          cachedTimeObject = hours !== void 0 && {
            hours,
            minutes: minutes ? parseDigitsIntoInteger(minutes[0].replace(separator, "")) : 0,
            seconds: seconds ? parseDigitsIntoInteger(seconds[0].replace(separator, "")) : 0,
            milliseconds: minutes && seconds && milliseconds ? parseMillisecondsIntoInteger(milliseconds[0].replace(".", "")) : 0
          };
          cachedTimeString = timeString;
          return cachedTimeObject;
        }
      }
    };
    if (previousValueObject) {
      when(
        () => timepicker.$,
        () => {
          const newValue = timepicker.i18n.formatTime(previousValueObject);
          if (timepicker.inputElement.value !== newValue) {
            timepicker.inputElement.value = newValue;
            timepicker.$.comboBox.value = newValue;
          }
        }
      );
    }
  };
};
/**
 * @license
 * Copyright (c) 2017 - 2025 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const DialogOverlayMixin = (superClass) => class DialogOverlayMixin extends OverlayMixin(superClass) {
  static get properties() {
    return {
      /**
       * String used for rendering a dialog title.
       */
      headerTitle: {
        type: String
      },
      /**
       * Custom function for rendering the dialog header.
       */
      headerRenderer: {
        type: Object
      },
      /**
       * Custom function for rendering the dialog footer.
       */
      footerRenderer: {
        type: Object
      }
    };
  }
  static get observers() {
    return [
      "_headerFooterRendererChange(headerRenderer, footerRenderer, opened)",
      "_headerTitleChanged(headerTitle, opened)"
    ];
  }
  /** @protected */
  ready() {
    super.ready();
    this.__resizeObserver = new ResizeObserver(() => {
      this.__updateOverflow();
    });
    this.__resizeObserver.observe(this.$.resizerContainer);
    this.$.content.addEventListener("scroll", () => {
      this.__updateOverflow();
    });
  }
  /** @private */
  __createContainer(slot) {
    const container = document.createElement("div");
    container.setAttribute("slot", slot);
    return container;
  }
  /** @private */
  __clearContainer(container) {
    container.innerHTML = "";
    delete container._$litPart$;
  }
  /** @private */
  __initContainer(container, slot) {
    if (container) {
      this.__clearContainer(container);
    } else {
      container = this.__createContainer(slot);
    }
    return container;
  }
  /** @private */
  _headerFooterRendererChange(headerRenderer, footerRenderer, opened) {
    const headerRendererChanged = this.__oldHeaderRenderer !== headerRenderer;
    this.__oldHeaderRenderer = headerRenderer;
    const footerRendererChanged = this.__oldFooterRenderer !== footerRenderer;
    this.__oldFooterRenderer = footerRenderer;
    const openedChanged = this._oldOpenedFooterHeader !== opened;
    this._oldOpenedFooterHeader = opened;
    this.toggleAttribute("has-header", !!headerRenderer);
    this.toggleAttribute("has-footer", !!footerRenderer);
    if (headerRendererChanged) {
      if (headerRenderer) {
        this.headerContainer = this.__initContainer(this.headerContainer, "header-content");
      } else if (this.headerContainer) {
        this.headerContainer.remove();
        this.headerContainer = null;
        this.__updateOverflow();
      }
    }
    if (footerRendererChanged) {
      if (footerRenderer) {
        this.footerContainer = this.__initContainer(this.footerContainer, "footer");
      } else if (this.footerContainer) {
        this.footerContainer.remove();
        this.footerContainer = null;
        this.__updateOverflow();
      }
    }
    if (headerRenderer && (headerRendererChanged || openedChanged) || footerRenderer && (footerRendererChanged || openedChanged)) {
      if (opened) {
        this.requestContentUpdate();
      }
    }
  }
  /** @private */
  _headerTitleChanged(headerTitle, opened) {
    this.toggleAttribute("has-title", !!headerTitle);
    if (opened && (headerTitle || this._oldHeaderTitle)) {
      this.requestContentUpdate();
    }
    this._oldHeaderTitle = headerTitle;
  }
  /** @private */
  _headerTitleRenderer() {
    if (this.headerTitle) {
      if (!this.headerTitleElement) {
        this.headerTitleElement = document.createElement("h2");
        this.headerTitleElement.setAttribute("slot", "title");
        this.headerTitleElement.classList.add("draggable");
      }
      this.appendChild(this.headerTitleElement);
      this.headerTitleElement.textContent = this.headerTitle;
    } else if (this.headerTitleElement) {
      this.headerTitleElement.remove();
      this.headerTitleElement = null;
    }
  }
  /**
   * @override
   */
  requestContentUpdate() {
    super.requestContentUpdate();
    if (this.headerContainer) {
      if (!this.headerContainer.parentElement) {
        this.appendChild(this.headerContainer);
      }
      if (this.headerRenderer) {
        this.headerRenderer.call(this.owner, this.headerContainer, this.owner);
      }
    }
    if (this.footerContainer) {
      if (!this.footerContainer.parentElement) {
        this.appendChild(this.footerContainer);
      }
      if (this.footerRenderer) {
        this.footerRenderer.call(this.owner, this.footerContainer, this.owner);
      }
    }
    this._headerTitleRenderer();
    this.__updateOverflow();
  }
  /**
   * Updates the coordinates of the overlay.
   * @param {!DialogOverlayBoundsParam} bounds
   * @param {boolean} absolute
   */
  setBounds(bounds, absolute = true) {
    const overlay2 = this.$.overlay;
    const parsedBounds = { ...bounds };
    if (absolute && overlay2.style.position !== "absolute") {
      overlay2.style.position = "absolute";
    }
    Object.keys(parsedBounds).forEach((arg) => {
      if (!isNaN(parsedBounds[arg])) {
        parsedBounds[arg] = `${parsedBounds[arg]}px`;
      }
    });
    Object.assign(overlay2.style, parsedBounds);
  }
  /**
   * Retrieves the coordinates of the overlay.
   * @return {!DialogOverlayBounds}
   */
  getBounds() {
    const overlayBounds = this.$.overlay.getBoundingClientRect();
    const containerBounds = this.getBoundingClientRect();
    const top = overlayBounds.top - containerBounds.top;
    const left = overlayBounds.left - containerBounds.left;
    const width = overlayBounds.width;
    const height = overlayBounds.height;
    return { top, left, width, height };
  }
  /** @private */
  __updateOverflow() {
    let overflow = "";
    if (this.hasAttribute("has-header") || this.hasAttribute("has-footer") || this.headerTitle) {
      const content = this.$.content;
      if (content.scrollTop > 0) {
        overflow += " top";
      }
      if (content.scrollTop < content.scrollHeight - content.clientHeight) {
        overflow += " bottom";
      }
    }
    const value = overflow.trim();
    if (value.length > 0 && this.getAttribute("overflow") !== value) {
      this.setAttribute("overflow", value);
    } else if (value.length === 0 && this.hasAttribute("overflow")) {
      this.removeAttribute("overflow");
    }
  }
};
/**
 * @license
 * Copyright (c) 2017 - 2025 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
registerStyles$1("vaadin-dialog-overlay", [overlayStyles, dialogOverlay, resizableOverlay], {
  moduleId: "vaadin-dialog-overlay-styles"
});
class DialogOverlay extends DialogOverlayMixin(DirMixin(ThemableMixin(PolymerElement))) {
  static get is() {
    return "vaadin-dialog-overlay";
  }
  static get template() {
    return html`
      <div id="backdrop" part="backdrop" hidden$="[[!withBackdrop]]"></div>
      <div part="overlay" id="overlay" tabindex="0">
        <section id="resizerContainer" class="resizer-container">
          <header part="header">
            <div part="title"><slot name="title"></slot></div>
            <div part="header-content"><slot name="header-content"></slot></div>
          </header>
          <div part="content" id="content"><slot></slot></div>
          <footer part="footer"><slot name="footer"></slot></footer>
        </section>
      </div>
    `;
  }
}
defineCustomElement(DialogOverlay);
/**
 * @license
 * Copyright (c) 2017 - 2025 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
function getMouseOrFirstTouchEvent(e2) {
  return e2.touches ? e2.touches[0] : e2;
}
function eventInWindow(e2) {
  return e2.clientX >= 0 && e2.clientX <= window.innerWidth && e2.clientY >= 0 && e2.clientY <= window.innerHeight;
}
/**
 * @license
 * Copyright (c) 2017 - 2025 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const DialogDraggableMixin = (superClass) => class VaadinDialogDraggableMixin extends superClass {
  static get properties() {
    return {
      /**
       * Set to true to enable repositioning the dialog by clicking and dragging.
       *
       * By default, only the overlay area can be used to drag the element. But,
       * a child element can be marked as a draggable area by adding a
       * "`draggable`" class to it, this will by default make all of its children draggable also.
       * If you want a child element to be draggable
       * but still have its children non-draggable (by default), mark it with
       * "`draggable-leaf-only`" class name.
       *
       * @type {boolean}
       */
      draggable: {
        type: Boolean,
        value: false,
        reflectToAttribute: true
      },
      /** @private */
      _touchDevice: {
        type: Boolean,
        value: isTouch
      },
      /* TODO: Expose as a public property (check naming) */
      __dragHandleClassName: {
        type: String
      }
    };
  }
  /** @protected */
  ready() {
    super.ready();
    this._originalBounds = {};
    this._originalMouseCoords = {};
    this._startDrag = this._startDrag.bind(this);
    this._drag = this._drag.bind(this);
    this._stopDrag = this._stopDrag.bind(this);
    this.$.overlay.$.overlay.addEventListener("mousedown", this._startDrag);
    this.$.overlay.$.overlay.addEventListener("touchstart", this._startDrag);
  }
  /** @private */
  _startDrag(e2) {
    if (e2.type === "touchstart" && e2.touches.length > 1) {
      return;
    }
    if (this.draggable && (e2.button === 0 || e2.touches)) {
      const resizerContainer = this.$.overlay.$.resizerContainer;
      const isResizerContainer = e2.target === resizerContainer;
      const isResizerContainerScrollbar = e2.offsetX > resizerContainer.clientWidth || e2.offsetY > resizerContainer.clientHeight;
      const isContentPart = e2.target === this.$.overlay.$.content;
      const isDraggable = e2.composedPath().some((node, index) => {
        if (!node.classList) {
          return false;
        }
        const isDraggableNode = node.classList.contains(this.__dragHandleClassName || "draggable");
        const isDraggableLeafOnly = node.classList.contains("draggable-leaf-only");
        const isLeafNode = index === 0;
        return isDraggableLeafOnly && isLeafNode || isDraggableNode && (!isDraggableLeafOnly || isLeafNode);
      });
      if (isResizerContainer && !isResizerContainerScrollbar || isContentPart || isDraggable) {
        if (!isDraggable) {
          e2.preventDefault();
        }
        this._originalBounds = this.$.overlay.getBounds();
        const event = getMouseOrFirstTouchEvent(e2);
        this._originalMouseCoords = { top: event.pageY, left: event.pageX };
        window.addEventListener("mouseup", this._stopDrag);
        window.addEventListener("touchend", this._stopDrag);
        window.addEventListener("mousemove", this._drag);
        window.addEventListener("touchmove", this._drag);
        if (this.$.overlay.$.overlay.style.position !== "absolute") {
          const { top, left } = this._originalBounds;
          this.$.overlay.setBounds({ top, left });
        }
      }
    }
  }
  /** @private */
  _drag(e2) {
    const event = getMouseOrFirstTouchEvent(e2);
    if (eventInWindow(event)) {
      const top = this._originalBounds.top + (event.pageY - this._originalMouseCoords.top);
      const left = this._originalBounds.left + (event.pageX - this._originalMouseCoords.left);
      this.top = top;
      this.left = left;
    }
  }
  /** @private */
  _stopDrag() {
    this.dispatchEvent(
      new CustomEvent("dragged", { bubbles: true, composed: true, detail: { top: this.top, left: this.left } })
    );
    window.removeEventListener("mouseup", this._stopDrag);
    window.removeEventListener("touchend", this._stopDrag);
    window.removeEventListener("mousemove", this._drag);
    window.removeEventListener("touchmove", this._drag);
  }
  /**
   * Fired when the dialog drag is finished.
   *
   * @event dragged
   */
};
/**
 * @license
 * Copyright (c) 2017 - 2025 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const DialogRendererMixin = (superClass) => class DialogRendererMixin extends superClass {
  static get properties() {
    return {
      /**
       * Custom function for rendering the content of the dialog.
       * Receives two arguments:
       *
       * - `root` The root container DOM element. Append your content to it.
       * - `dialog` The reference to the `<vaadin-dialog>` element.
       * @type {DialogRenderer | undefined}
       */
      renderer: {
        type: Object
      },
      /**
       * String used for rendering a dialog title.
       *
       * If both `headerTitle` and `headerRenderer` are defined, the title
       * and the elements created by the renderer will be placed next to
       * each other, with the title coming first.
       *
       * When `headerTitle` is set, the attribute `has-title` is added to the overlay element.
       * @attr {string} header-title
       */
      headerTitle: String,
      /**
       * Custom function for rendering the dialog header.
       * Receives two arguments:
       *
       * - `root` The root container DOM element. Append your content to it.
       * - `dialog` The reference to the `<vaadin-dialog>` element.
       *
       * If both `headerTitle` and `headerRenderer` are defined, the title
       * and the elements created by the renderer will be placed next to
       * each other, with the title coming first.
       *
       * When `headerRenderer` is set, the attribute `has-header` is added to the overlay element.
       * @type {DialogRenderer | undefined}
       */
      headerRenderer: {
        type: Object
      },
      /**
       * Custom function for rendering the dialog footer.
       * Receives two arguments:
       *
       * - `root` The root container DOM element. Append your content to it.
       * - `dialog` The reference to the `<vaadin-dialog>` element.
       *
       * When `footerRenderer` is set, the attribute `has-footer` is added to the overlay element.
       * @type {DialogRenderer | undefined}
       */
      footerRenderer: {
        type: Object
      }
    };
  }
  /**
   * Requests an update for the content of the dialog.
   * While performing the update, it invokes the renderer passed in the `renderer` property,
   * as well as `headerRender` and `footerRenderer` properties, if these are defined.
   *
   * It is not guaranteed that the update happens immediately (synchronously) after it is requested.
   */
  requestContentUpdate() {
    if (this._overlayElement) {
      this._overlayElement.requestContentUpdate();
    }
  }
};
/**
 * @license
 * Copyright (c) 2017 - 2025 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const DialogResizableMixin = (superClass) => class VaadinDialogResizableMixin extends superClass {
  static get properties() {
    return {
      /**
       * Set to true to enable resizing the dialog by dragging the corners and edges.
       * @type {boolean}
       */
      resizable: {
        type: Boolean,
        value: false,
        reflectToAttribute: true
      }
    };
  }
  /** @protected */
  ready() {
    super.ready();
    this._originalBounds = {};
    this._originalMouseCoords = {};
    this._resizeListeners = { start: {}, resize: {}, stop: {} };
    this._addResizeListeners();
  }
  /** @private */
  _addResizeListeners() {
    ["n", "e", "s", "w", "nw", "ne", "se", "sw"].forEach((direction) => {
      const resizer = document.createElement("div");
      this._resizeListeners.start[direction] = (e2) => this._startResize(e2, direction);
      this._resizeListeners.resize[direction] = (e2) => this._resize(e2, direction);
      this._resizeListeners.stop[direction] = () => this._stopResize(direction);
      if (direction.length === 1) {
        resizer.classList.add("edge");
      }
      resizer.classList.add("resizer");
      resizer.classList.add(direction);
      resizer.addEventListener("mousedown", this._resizeListeners.start[direction]);
      resizer.addEventListener("touchstart", this._resizeListeners.start[direction]);
      this.$.overlay.$.resizerContainer.appendChild(resizer);
    });
  }
  /**
   * @param {!MouseEvent | !TouchEvent} e
   * @param {!DialogResizableDirection} direction
   * @protected
   */
  _startResize(e2, direction) {
    if (e2.type === "touchstart" && e2.touches.length > 1) {
      return;
    }
    if (e2.button === 0 || e2.touches) {
      e2.preventDefault();
      this._originalBounds = this.$.overlay.getBounds();
      const event = getMouseOrFirstTouchEvent(e2);
      this._originalMouseCoords = { top: event.pageY, left: event.pageX };
      window.addEventListener("mousemove", this._resizeListeners.resize[direction]);
      window.addEventListener("touchmove", this._resizeListeners.resize[direction]);
      window.addEventListener("mouseup", this._resizeListeners.stop[direction]);
      window.addEventListener("touchend", this._resizeListeners.stop[direction]);
      if (this.$.overlay.$.overlay.style.position !== "absolute" || this.width || this.height) {
        this.$.overlay.setBounds(this._originalBounds);
      }
      this.$.overlay.setAttribute("has-bounds-set", "");
    }
  }
  /**
   * @param {!MouseEvent | !TouchEvent} e
   * @param {!DialogResizableDirection} resizer
   * @protected
   */
  _resize(e2, resizer) {
    const event = getMouseOrFirstTouchEvent(e2);
    if (eventInWindow(event)) {
      const minimumSize = 40;
      resizer.split("").forEach((direction) => {
        switch (direction) {
          case "n": {
            const height = this._originalBounds.height - (event.pageY - this._originalMouseCoords.top);
            const top = this._originalBounds.top + (event.pageY - this._originalMouseCoords.top);
            if (height > minimumSize) {
              this.top = top;
              this.height = height;
            }
            break;
          }
          case "e": {
            const width = this._originalBounds.width + (event.pageX - this._originalMouseCoords.left);
            if (width > minimumSize) {
              this.width = width;
            }
            break;
          }
          case "s": {
            const height = this._originalBounds.height + (event.pageY - this._originalMouseCoords.top);
            if (height > minimumSize) {
              this.height = height;
            }
            break;
          }
          case "w": {
            const width = this._originalBounds.width - (event.pageX - this._originalMouseCoords.left);
            const left = this._originalBounds.left + (event.pageX - this._originalMouseCoords.left);
            if (width > minimumSize) {
              this.left = left;
              this.width = width;
            }
            break;
          }
        }
      });
    }
  }
  /**
   * @param {!DialogResizableDirection} direction
   * @protected
   */
  _stopResize(direction) {
    window.removeEventListener("mousemove", this._resizeListeners.resize[direction]);
    window.removeEventListener("touchmove", this._resizeListeners.resize[direction]);
    window.removeEventListener("mouseup", this._resizeListeners.stop[direction]);
    window.removeEventListener("touchend", this._resizeListeners.stop[direction]);
    this.dispatchEvent(new CustomEvent("resize", { detail: this._getResizeDimensions() }));
  }
  /**
   * @return {!DialogResizeDimensions}
   * @protected
   */
  _getResizeDimensions() {
    const scrollPosition = this.$.overlay.$.resizerContainer.scrollTop;
    const { width, height, top, left } = getComputedStyle(this.$.overlay.$.overlay);
    const content = this.$.overlay.$.content;
    content.setAttribute(
      "style",
      "position: absolute; top: 0; right: 0; bottom: 0; left: 0; box-sizing: content-box; height: auto;"
    );
    const { width: contentWidth, height: contentHeight } = getComputedStyle(content);
    content.removeAttribute("style");
    this.$.overlay.$.resizerContainer.scrollTop = scrollPosition;
    return { width, height, contentWidth, contentHeight, top, left };
  }
  /**
   * Fired when the dialog resize is finished.
   *
   * @event resize
   */
};
/**
 * @license
 * Copyright (c) 2017 - 2025 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
class Dialog extends DialogDraggableMixin(
  DialogResizableMixin(
    DialogRendererMixin(DialogBaseMixin(OverlayClassMixin(ThemePropertyMixin(ElementMixin(PolymerElement)))))
  )
) {
  static get template() {
    return html`
      <style>
        :host {
          display: none !important;
        }
      </style>

      <vaadin-dialog-overlay
        id="overlay"
        role$="[[overlayRole]]"
        header-title="[[headerTitle]]"
        on-opened-changed="_onOverlayOpened"
        on-mousedown="_bringOverlayToFront"
        on-touchstart="_bringOverlayToFront"
        theme$="[[_theme]]"
        modeless="[[modeless]]"
        with-backdrop="[[!modeless]]"
        resizable$="[[resizable]]"
        restore-focus-on-close
        focus-trap
      ></vaadin-dialog-overlay>
    `;
  }
  static get is() {
    return "vaadin-dialog";
  }
  static get properties() {
    return {
      /**
       * Set the `aria-label` attribute for assistive technologies like
       * screen readers. An empty string value for this property (the
       * default) means that the `aria-label` attribute is not present.
       */
      ariaLabel: {
        type: String,
        value: ""
      }
    };
  }
  static get observers() {
    return [
      "_openedChanged(opened)",
      "_ariaLabelChanged(ariaLabel, headerTitle)",
      "_rendererChanged(renderer, headerRenderer, footerRenderer)"
    ];
  }
  /** @protected */
  ready() {
    super.ready();
    processTemplates(this);
  }
  /** @private */
  _rendererChanged(renderer, headerRenderer, footerRenderer) {
    this.$.overlay.setProperties({ owner: this, renderer, headerRenderer, footerRenderer });
  }
  /** @private */
  _openedChanged(opened) {
    this.$.overlay.opened = opened;
  }
  /** @private */
  _ariaLabelChanged(ariaLabel, headerTitle) {
    if (ariaLabel || headerTitle) {
      this.$.overlay.setAttribute("aria-label", ariaLabel || headerTitle);
    } else {
      this.$.overlay.removeAttribute("aria-label");
    }
  }
}
defineCustomElement(Dialog);
window.Vaadin = window.Vaadin || {};
window.Vaadin.Flow = window.Vaadin.Flow || {};
window.Vaadin.Flow.dndConnector = {
  __ondragenterListener: function(event) {
    const effect = event.currentTarget["__dropEffect"];
    if (!event.currentTarget.hasAttribute("disabled")) {
      if (effect) {
        event.dataTransfer.dropEffect = effect;
      }
      if (effect !== "none") {
        if (event.currentTarget.classList.contains("v-drag-over-target")) {
          event.currentTarget["__skip-leave"] = true;
        } else {
          event.currentTarget.classList.add("v-drag-over-target");
        }
        event.preventDefault();
        event.stopPropagation();
      }
    }
  },
  __ondragoverListener: function(event) {
    if (!event.currentTarget.hasAttribute("disabled")) {
      const effect = event.currentTarget["__dropEffect"];
      if (effect) {
        event.dataTransfer.dropEffect = effect;
      }
      event.preventDefault();
      event.stopPropagation();
    }
  },
  __ondragleaveListener: function(event) {
    if (event.currentTarget["__skip-leave"]) {
      event.currentTarget["__skip-leave"] = false;
    } else {
      event.currentTarget.classList.remove("v-drag-over-target");
    }
    event.stopPropagation();
  },
  __ondropListener: function(event) {
    const effect = event.currentTarget["__dropEffect"];
    if (effect) {
      event.dataTransfer.dropEffect = effect;
    }
    event.currentTarget.classList.remove("v-drag-over-target");
    event.preventDefault();
    event.stopPropagation();
  },
  updateDropTarget: function(element) {
    if (element["__active"]) {
      element.addEventListener("dragenter", this.__ondragenterListener, false);
      element.addEventListener("dragover", this.__ondragoverListener, false);
      element.addEventListener("dragleave", this.__ondragleaveListener, false);
      element.addEventListener("drop", this.__ondropListener, false);
    } else {
      element.removeEventListener("dragenter", this.__ondragenterListener, false);
      element.removeEventListener("dragover", this.__ondragoverListener, false);
      element.removeEventListener("dragleave", this.__ondragleaveListener, false);
      element.removeEventListener("drop", this.__ondropListener, false);
      element.classList.remove("v-drag-over-target");
    }
  },
  /** DRAG SOURCE METHODS: */
  __dragstartListener: function(event) {
    event.stopPropagation();
    event.dataTransfer.setData("text/plain", "");
    if (event.currentTarget.hasAttribute("disabled")) {
      event.preventDefault();
    } else {
      if (event.currentTarget["__effectAllowed"]) {
        event.dataTransfer.effectAllowed = event.currentTarget["__effectAllowed"];
      }
      event.currentTarget.classList.add("v-dragged");
    }
    if (event.currentTarget.__dragImage) {
      if (event.currentTarget.__dragImage.style.display === "none") {
        event.currentTarget.__dragImage.style.display = "block";
        event.currentTarget.classList.add("shown");
      }
      event.dataTransfer.setDragImage(
        event.currentTarget.__dragImage,
        event.currentTarget.__dragImageOffsetX,
        event.currentTarget.__dragImageOffsetY
      );
    }
  },
  __dragendListener: function(event) {
    event.currentTarget.classList.remove("v-dragged");
    if (event.currentTarget.classList.contains("shown")) {
      event.currentTarget.classList.remove("shown");
      event.currentTarget.__dragImage.style.display = "none";
    }
  },
  updateDragSource: function(element) {
    if (element["draggable"]) {
      element.addEventListener("dragstart", this.__dragstartListener, false);
      element.addEventListener("dragend", this.__dragendListener, false);
    } else {
      element.removeEventListener("dragstart", this.__dragstartListener, false);
      element.removeEventListener("dragend", this.__dragendListener, false);
    }
  },
  setDragImage: function(dragImage, offsetX, offsetY, dragSource) {
    dragSource.__dragImage = dragImage;
    dragSource.__dragImageOffsetX = offsetX;
    dragSource.__dragImageOffsetY = offsetY;
  }
};
registerStyles$1(
  "vaadin-form-layout",
  css`
    :host {
      --vaadin-form-layout-column-spacing: var(--lumo-space-l);
      --vaadin-form-layout-row-spacing: 0;
    }
  `,
  { moduleId: "lumo-form-layout" }
);
/**
 * @license
 * Copyright (c) 2017 - 2025 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
function isValidCSSLength(value) {
  return CSS.supports("word-spacing", value) && !["inherit", "normal"].includes(value);
}
const FormLayoutMixin = (superClass) => class extends ResizeMixin(superClass) {
  static get properties() {
    return {
      /**
       * @typedef FormLayoutResponsiveStep
       * @type {object}
       * @property {string} minWidth - The threshold value for this step in CSS length units.
       * @property {number} columns - Number of columns. Only natural numbers are valid.
       * @property {string} labelsPosition - Labels position option, valid values: `"aside"` (default), `"top"`.
       */
      /**
       * Allows specifying a responsive behavior with the number of columns
       * and the label position depending on the layout width.
       *
       * Format: array of objects, each object defines one responsive step
       * with `minWidth` CSS length, `columns` number, and optional
       * `labelsPosition` string of `"aside"` or `"top"`. At least one item is required.
       *
       * #### Examples
       *
       * ```javascript
       * formLayout.responsiveSteps = [{columns: 1}];
       * // The layout is always a single column, labels aside.
       * ```
       *
       * ```javascript
       * formLayout.responsiveSteps = [
       *   {minWidth: 0, columns: 1},
       *   {minWidth: '40em', columns: 2}
       * ];
       * // Sets two responsive steps:
       * // 1. When the layout width is < 40em, one column, labels aside.
       * // 2. Width >= 40em, two columns, labels aside.
       * ```
       *
       * ```javascript
       * formLayout.responsiveSteps = [
       *   {minWidth: 0, columns: 1, labelsPosition: 'top'},
       *   {minWidth: '20em', columns: 1},
       *   {minWidth: '40em', columns: 2}
       * ];
       * // Default value. Three responsive steps:
       * // 1. Width < 20em, one column, labels on top.
       * // 2. 20em <= width < 40em, one column, labels aside.
       * // 3. Width >= 40em, two columns, labels aside.
       * ```
       *
       * @type {!Array<!FormLayoutResponsiveStep>}
       */
      responsiveSteps: {
        type: Array,
        value() {
          return [
            { minWidth: 0, columns: 1, labelsPosition: "top" },
            { minWidth: "20em", columns: 1 },
            { minWidth: "40em", columns: 2 }
          ];
        },
        observer: "_responsiveStepsChanged",
        sync: true
      },
      /**
       * Current number of columns in the layout
       * @private
       */
      _columnCount: {
        type: Number,
        sync: true
      },
      /**
       * Indicates that labels are on top
       * @private
       */
      _labelsOnTop: {
        type: Boolean,
        sync: true
      }
    };
  }
  static get observers() {
    return ["_invokeUpdateLayout(_columnCount, _labelsOnTop)"];
  }
  /** @protected */
  connectedCallback() {
    super.connectedCallback();
    this.__childrenObserver = new MutationObserver(() => this._updateLayout());
    this.__childrenObserver.observe(this, { childList: true });
    this.__childrenAttributesObserver = new MutationObserver((mutations) => {
      if (mutations.some((mutation) => mutation.target.parentElement === this)) {
        this._updateLayout();
      }
    });
    this.__childrenAttributesObserver.observe(this, {
      subtree: true,
      attributes: true,
      attributeFilter: ["colspan", "data-colspan", "hidden"]
    });
    requestAnimationFrame(() => this._selectResponsiveStep());
    requestAnimationFrame(() => this._updateLayout());
  }
  /** @protected */
  disconnectedCallback() {
    super.disconnectedCallback();
    this.__childrenObserver.disconnect();
    this.__childrenAttributesObserver.disconnect();
  }
  /** @private */
  _naturalNumberOrOne(n) {
    if (typeof n === "number" && n >= 1 && n < Infinity) {
      return Math.floor(n);
    }
    return 1;
  }
  /** @private */
  _responsiveStepsChanged(responsiveSteps, oldResponsiveSteps) {
    try {
      if (!Array.isArray(responsiveSteps)) {
        throw new Error('Invalid "responsiveSteps" type, an Array is required.');
      }
      if (responsiveSteps.length < 1) {
        throw new Error('Invalid empty "responsiveSteps" array, at least one item is required.');
      }
      responsiveSteps.forEach((step) => {
        if (this._naturalNumberOrOne(step.columns) !== step.columns) {
          throw new Error(`Invalid 'columns' value of ${step.columns}, a natural number is required.`);
        }
        if (step.minWidth !== void 0 && !isValidCSSLength(step.minWidth)) {
          throw new Error(`Invalid 'minWidth' value of ${step.minWidth}, a valid CSS length required.`);
        }
        if (step.labelsPosition !== void 0 && ["aside", "top"].indexOf(step.labelsPosition) === -1) {
          throw new Error(
            `Invalid 'labelsPosition' value of ${step.labelsPosition}, 'aside' or 'top' string is required.`
          );
        }
      });
    } catch (e2) {
      if (oldResponsiveSteps && oldResponsiveSteps !== responsiveSteps) {
        console.warn(`${e2.message} Using previously set 'responsiveSteps' instead.`);
        this.responsiveSteps = oldResponsiveSteps;
      } else {
        console.warn(`${e2.message} Using default 'responsiveSteps' instead.`);
        this.responsiveSteps = [
          { minWidth: 0, columns: 1, labelsPosition: "top" },
          { minWidth: "20em", columns: 1 },
          { minWidth: "40em", columns: 2 }
        ];
      }
    }
    this._selectResponsiveStep();
  }
  /** @private */
  _selectResponsiveStep() {
    let selectedStep;
    const tmpStyleProp = "background-position";
    this.responsiveSteps.forEach((step) => {
      this.$.layout.style.setProperty(tmpStyleProp, step.minWidth);
      const stepMinWidthPx = parseFloat(getComputedStyle(this.$.layout).getPropertyValue(tmpStyleProp));
      if (stepMinWidthPx <= this.offsetWidth) {
        selectedStep = step;
      }
    });
    this.$.layout.style.removeProperty(tmpStyleProp);
    if (selectedStep) {
      this._columnCount = selectedStep.columns;
      this._labelsOnTop = selectedStep.labelsPosition === "top";
    }
  }
  /** @private */
  _invokeUpdateLayout() {
    this._updateLayout();
  }
  /**
   * Update the layout.
   * @protected
   */
  _updateLayout() {
    if (isElementHidden(this)) {
      return;
    }
    const style = getComputedStyle(this);
    const columnSpacing = style.getPropertyValue("--vaadin-form-layout-column-spacing");
    const direction = style.direction;
    const marginStartProp = `margin-${direction === "ltr" ? "left" : "right"}`;
    const marginEndProp = `margin-${direction === "ltr" ? "right" : "left"}`;
    const containerWidth = this.offsetWidth;
    let col = 0;
    Array.from(this.children).filter((child) => child.localName === "br" || getComputedStyle(child).display !== "none").forEach((child, index, children) => {
      if (child.localName === "br") {
        col = 0;
        return;
      }
      const attrColspan = child.getAttribute("colspan") || child.getAttribute("data-colspan");
      let colspan;
      colspan = this._naturalNumberOrOne(parseFloat(attrColspan));
      colspan = Math.min(colspan, this._columnCount);
      const childRatio = colspan / this._columnCount;
      child.style.width = `calc(${childRatio * 100}% - ${1 - childRatio} * ${columnSpacing})`;
      if (col + colspan > this._columnCount) {
        col = 0;
      }
      if (col === 0) {
        child.style.setProperty(marginStartProp, "0px");
      } else {
        child.style.removeProperty(marginStartProp);
      }
      const nextIndex = index + 1;
      const nextLineBreak = nextIndex < children.length && children[nextIndex].localName === "br";
      if (col + colspan === this._columnCount) {
        child.style.setProperty(marginEndProp, "0px");
      } else if (nextLineBreak) {
        const colspanRatio = (this._columnCount - col - colspan) / this._columnCount;
        child.style.setProperty(
          marginEndProp,
          `calc(${colspanRatio * containerWidth}px + ${colspanRatio} * ${columnSpacing})`
        );
      } else {
        child.style.removeProperty(marginEndProp);
      }
      col = (col + colspan) % this._columnCount;
      if (child.localName === "vaadin-form-item") {
        if (this._labelsOnTop) {
          if (child.getAttribute("label-position") !== "top") {
            child.__useLayoutLabelPosition = true;
            child.setAttribute("label-position", "top");
          }
        } else if (child.__useLayoutLabelPosition) {
          delete child.__useLayoutLabelPosition;
          child.removeAttribute("label-position");
        }
      }
    });
  }
  /**
   * @protected
   * @override
   */
  _onResize(contentRect) {
    if (contentRect.width === 0 && contentRect.height === 0) {
      this.$.layout.style.opacity = "0";
      return;
    }
    this._selectResponsiveStep();
    this._updateLayout();
    this.$.layout.style.opacity = "";
  }
};
/**
 * @license
 * Copyright (c) 2018 - 2025 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const formLayoutStyles = css`
  :host {
    /* Default values */
    --vaadin-form-layout-row-spacing: 1em;
    --vaadin-form-layout-column-spacing: 2em;
    --vaadin-form-layout-label-width: 8em;
    --vaadin-form-layout-label-spacing: 1em;

    display: block;
    max-width: 100%;
    align-self: stretch;
  }

  :host([hidden]) {
    display: none !important;
  }

  #layout {
    display: flex;

    align-items: baseline; /* default \`stretch\` is not appropriate */

    flex-wrap: wrap; /* the items should wrap */
  }

  #layout ::slotted(*) {
    /* Items should neither grow nor shrink. */
    flex-grow: 0;
    flex-shrink: 0;

    /* Margins make spacing between the columns */
    margin-left: calc(0.5 * var(--vaadin-form-layout-column-spacing));
    margin-right: calc(0.5 * var(--vaadin-form-layout-column-spacing));
  }

  #layout ::slotted(br) {
    display: none;
  }
`;
const formItemStyles = css`
  :host {
    display: inline-flex;
    flex-direction: row;
    align-items: baseline;
    margin: calc(0.5 * var(--vaadin-form-item-row-spacing, var(--vaadin-form-layout-row-spacing, 1em))) 0;
  }

  :host([label-position='top']) {
    flex-direction: column;
    align-items: stretch;
  }

  :host([hidden]) {
    display: none !important;
  }

  #label {
    width: var(--vaadin-form-item-label-width, var(--vaadin-form-layout-label-width, 8em));
    flex: 0 0 auto;
  }

  :host([label-position='top']) #label {
    width: auto;
  }

  #spacing {
    width: var(--vaadin-form-item-label-spacing, var(--vaadin-form-layout-label-spacing, 1em));
    flex: 0 0 auto;
  }

  #content {
    flex: 1 1 auto;
    min-width: 0;
  }

  #content ::slotted(.full-width) {
    box-sizing: border-box;
    width: 100%;
    min-width: 0;
  }
`;
/**
 * @license
 * Copyright (c) 2017 - 2025 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
registerStyles$1("vaadin-form-layout", formLayoutStyles, { moduleId: "vaadin-form-layout-styles" });
class FormLayout extends FormLayoutMixin(ThemableMixin(ElementMixin(PolymerElement))) {
  static get is() {
    return "vaadin-form-layout";
  }
  static get template() {
    return html`
      <div id="layout">
        <slot id="slot"></slot>
      </div>
    `;
  }
}
defineCustomElement(FormLayout);
registerStyles$1(
  "vaadin-form-item",
  css`
    /* font-weight, margin-bottom, transition and line-height same as for part label in text-field */
    [part='label'] {
      color: var(--lumo-secondary-text-color);
      font-family: var(--lumo-font-family);
      font-size: var(--lumo-font-size-s);
      font-weight: 500;
      margin-top: var(--lumo-space-m);
      margin-left: calc(var(--lumo-border-radius-m) / 4);
      margin-bottom: var(--lumo-space-xs);
      transition: color 0.4s;
      line-height: 1.333;
    }

    [part='required-indicator']::after {
      content: var(--lumo-required-field-indicator, '\\2022');
      transition: opacity 0.2s;
      opacity: 0;
      color: var(--lumo-required-field-indicator-color, var(--lumo-primary-text-color));
      position: relative;
      width: 1em;
      text-align: center;
    }

    :host([required]) [part='required-indicator']::after {
      opacity: 1;
    }

    :host([invalid]) [part='required-indicator']::after {
      color: var(--lumo-required-field-indicator-color, var(--lumo-error-text-color));
    }
  `,
  { moduleId: "lumo-form-item" }
);
/**
 * @license
 * Copyright (c) 2017 - 2025 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
let spacingDeprecationNotified = false;
let labelWidthDeprecationNotified = false;
let labelSpacingDeprecationNotified = false;
const FormItemMixin = (superClass) => class extends superClass {
  constructor() {
    super();
    this.__updateInvalidState = this.__updateInvalidState.bind(this);
    this.__fieldNodeObserver = new MutationObserver(() => this.__updateRequiredState(this.__fieldNode.required));
    this.__labelNode = null;
    this.__fieldNode = null;
  }
  /** @protected */
  ready() {
    super.ready();
    const computedStyle = getComputedStyle(this);
    const spacing = computedStyle.getPropertyValue("--vaadin-form-item-row-spacing");
    const labelWidth = computedStyle.getPropertyValue("--vaadin-form-item-label-width");
    const labelSpacing = computedStyle.getPropertyValue("--vaadin-form-item-label-spacing");
    if (!spacingDeprecationNotified && spacing !== "" && parseInt(spacing) !== 0) {
      console.warn(
        "`--vaadin-form-item-row-spacing` is deprecated since 24.7. Use `--vaadin-form-layout-row-spacing` on <vaadin-form-layout> instead."
      );
      spacingDeprecationNotified = true;
    }
    if (!labelWidthDeprecationNotified && labelWidth !== "" && parseInt(labelWidth) !== 0) {
      console.warn(
        "`--vaadin-form-item-label-width` is deprecated since 24.7. Use `--vaadin-form-layout-label-width` on <vaadin-form-layout> instead."
      );
      labelWidthDeprecationNotified = true;
    }
    if (!labelSpacingDeprecationNotified && labelSpacing !== "" && parseInt(labelSpacing) !== 0) {
      console.warn(
        "`--vaadin-form-item-label-spacing` is deprecated since 24.7. Use `--vaadin-form-layout-label-spacing` on <vaadin-form-layout> instead."
      );
      labelSpacingDeprecationNotified = true;
    }
  }
  /**
   * Returns a target element to add ARIA attributes to for a field.
   *
   * - For Vaadin field components, the method returns an element
   * obtained through the `ariaTarget` property defined in `FieldMixin`.
   * - In other cases, the method returns the field element itself.
   *
   * @param {HTMLElement} field
   * @protected
   */
  _getFieldAriaTarget(field) {
    return field.ariaTarget || field;
  }
  /**
   * Links the label to a field by adding the label id to
   * the `aria-labelledby` attribute of the field's ARIA target element.
   *
   * @param {HTMLElement} field
   * @private
   */
  __linkLabelToField(field) {
    addValueToAttribute(this._getFieldAriaTarget(field), "aria-labelledby", this.__labelId);
  }
  /**
   * Unlinks the label from a field by removing the label id from
   * the `aria-labelledby` attribute of the field's ARIA target element.
   *
   * @param {HTMLElement} field
   * @private
   */
  __unlinkLabelFromField(field) {
    removeValueFromAttribute(this._getFieldAriaTarget(field), "aria-labelledby", this.__labelId);
  }
  /** @private */
  __onLabelClick() {
    const fieldNode = this.__fieldNode;
    if (fieldNode) {
      fieldNode.focus();
      fieldNode.click();
    }
  }
  /** @private */
  __getValidateFunction(field) {
    return field.validate || field.checkValidity;
  }
  /**
   * A `slotchange` event handler for the label slot.
   *
   * - Ensures the label id is only assigned to the first label node.
   * - Ensures the label node is linked to the first field node via the `aria-labelledby` attribute
   * if both nodes are provided, and unlinked otherwise.
   *
   * @private
   */
  __onLabelSlotChange() {
    if (this.__labelNode) {
      this.__labelNode = null;
      if (this.__fieldNode) {
        this.__unlinkLabelFromField(this.__fieldNode);
      }
    }
    const newLabelNode = this.$.labelSlot.assignedElements()[0];
    if (newLabelNode) {
      this.__labelNode = newLabelNode;
      if (this.__labelNode.id) {
        this.__labelId = this.__labelNode.id;
      } else {
        this.__labelId = `label-${this.localName}-${generateUniqueId()}`;
        this.__labelNode.id = this.__labelId;
      }
      if (this.__fieldNode) {
        this.__linkLabelToField(this.__fieldNode);
      }
    }
  }
  /**
   * A `slotchange` event handler for the content slot.
   *
   * - Ensures the label node is only linked to the first field node via the `aria-labelledby` attribute.
   * - Sets up an observer for the `required` attribute changes on the first field
   * to reflect the attribute on the component. Ensures the observer is disconnected from the field
   * as soon as it is removed or replaced by another one.
   *
   * @private
   */
  __onContentSlotChange() {
    if (this.__fieldNode) {
      this.__unlinkLabelFromField(this.__fieldNode);
      this.__updateRequiredState(false);
      this.__fieldNodeObserver.disconnect();
      this.__fieldNode = null;
    }
    const fieldNodes = this.$.contentSlot.assignedElements();
    if (fieldNodes.length > 1) {
      console.warn(
        `WARNING: Since Vaadin 23, placing multiple fields directly to a <vaadin-form-item> is deprecated.
Please wrap fields with a <vaadin-custom-field> instead.`
      );
    }
    const newFieldNode = fieldNodes.find((field) => {
      return !!this.__getValidateFunction(field);
    });
    if (newFieldNode) {
      this.__fieldNode = newFieldNode;
      this.__updateRequiredState(this.__fieldNode.required);
      this.__fieldNodeObserver.observe(this.__fieldNode, { attributes: true, attributeFilter: ["required"] });
      if (this.__labelNode) {
        this.__linkLabelToField(this.__fieldNode);
      }
    }
  }
  /** @private */
  __updateRequiredState(required) {
    if (required) {
      this.setAttribute("required", "");
      this.__fieldNode.addEventListener("blur", this.__updateInvalidState);
      this.__fieldNode.addEventListener("change", this.__updateInvalidState);
    } else {
      this.removeAttribute("invalid");
      this.removeAttribute("required");
      this.__fieldNode.removeEventListener("blur", this.__updateInvalidState);
      this.__fieldNode.removeEventListener("change", this.__updateInvalidState);
    }
  }
  /** @private */
  __updateInvalidState() {
    const isValid2 = this.__getValidateFunction(this.__fieldNode).call(this.__fieldNode);
    this.toggleAttribute("invalid", isValid2 === false);
  }
};
/**
 * @license
 * Copyright (c) 2017 - 2025 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
registerStyles$1("vaadin-form-item", formItemStyles, { moduleId: "vaadin-form-item-styles" });
class FormItem extends FormItemMixin(ThemableMixin(PolymerElement)) {
  static get is() {
    return "vaadin-form-item";
  }
  static get template() {
    return html`
      <div id="label" part="label" on-click="__onLabelClick">
        <slot name="label" id="labelSlot" on-slotchange="__onLabelSlotChange"></slot>
        <span part="required-indicator" aria-hidden="true"></span>
      </div>
      <div id="spacing"></div>
      <div id="content">
        <slot id="contentSlot" on-slotchange="__onContentSlotChange"></slot>
      </div>
    `;
  }
}
defineCustomElement(FormItem);
/**
 * @license
 * Copyright (c) 2016 - 2025 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
function getBodyRowCells(row) {
  return row.__cells || Array.from(row.querySelectorAll('[part~="cell"]:not([part~="details-cell"])'));
}
function iterateChildren(container, callback) {
  [...container.children].forEach(callback);
}
function iterateRowCells(row, callback) {
  getBodyRowCells(row).forEach(callback);
  if (row.__detailsCell) {
    callback(row.__detailsCell);
  }
}
function updateColumnOrders(columns, scope, baseOrder) {
  let c2 = 1;
  columns.forEach((column) => {
    if (c2 % 10 === 0) {
      c2 += 1;
    }
    column._order = baseOrder + c2 * scope;
    c2 += 1;
  });
}
function updateState(element, attribute, value) {
  switch (typeof value) {
    case "boolean":
      element.toggleAttribute(attribute, value);
      break;
    case "string":
      element.setAttribute(attribute, value);
      break;
    default:
      element.removeAttribute(attribute);
      break;
  }
}
function updatePart(element, value, part) {
  if (value || value === "") {
    addValueToAttribute(element, "part", part);
  } else {
    removeValueFromAttribute(element, "part", part);
  }
}
function updateCellsPart(cells, part, value) {
  cells.forEach((cell) => {
    updatePart(cell, value, part);
  });
}
function updateBooleanRowStates(row, states) {
  const cells = getBodyRowCells(row);
  Object.entries(states).forEach(([state, value]) => {
    updateState(row, state, value);
    const rowPart = `${state}-row`;
    updatePart(row, value, rowPart);
    updateCellsPart(cells, `${rowPart}-cell`, value);
  });
}
function updateStringRowStates(row, states) {
  const cells = getBodyRowCells(row);
  Object.entries(states).forEach(([state, value]) => {
    const prevValue = row.getAttribute(state);
    updateState(row, state, value);
    if (prevValue) {
      const prevRowPart = `${state}-${prevValue}-row`;
      updatePart(row, false, prevRowPart);
      updateCellsPart(cells, `${prevRowPart}-cell`, false);
    }
    if (value) {
      const rowPart = `${state}-${value}-row`;
      updatePart(row, value, rowPart);
      updateCellsPart(cells, `${rowPart}-cell`, value);
    }
  });
}
function updateCellState(cell, attribute, value, part, oldPart) {
  updateState(cell, attribute, value);
  if (oldPart) {
    updatePart(cell, false, oldPart);
  }
  updatePart(cell, value, part || `${attribute}-cell`);
}
class ColumnObserver {
  constructor(host, callback) {
    this.__host = host;
    this.__callback = callback;
    this.__currentSlots = [];
    this.__onMutation = this.__onMutation.bind(this);
    this.__observer = new MutationObserver(this.__onMutation);
    this.__observer.observe(host, {
      childList: true
    });
    this.__initialCallDebouncer = Debouncer$1.debounce(this.__initialCallDebouncer, microTask$1, () => this.__onMutation());
  }
  disconnect() {
    this.__observer.disconnect();
    this.__initialCallDebouncer.cancel();
    this.__toggleSlotChangeListeners(false);
  }
  flush() {
    this.__onMutation();
  }
  __toggleSlotChangeListeners(add) {
    this.__currentSlots.forEach((slot) => {
      if (add) {
        slot.addEventListener("slotchange", this.__onMutation);
      } else {
        slot.removeEventListener("slotchange", this.__onMutation);
      }
    });
  }
  __onMutation() {
    const initialCall = !this.__currentColumns;
    this.__currentColumns = this.__currentColumns || [];
    const columns = ColumnObserver.getColumns(this.__host);
    const addedColumns = columns.filter((column) => !this.__currentColumns.includes(column));
    const removedColumns = this.__currentColumns.filter((column) => !columns.includes(column));
    const orderChanged = this.__currentColumns.some((column, index) => column !== columns[index]);
    this.__currentColumns = columns;
    this.__toggleSlotChangeListeners(false);
    this.__currentSlots = [...this.__host.children].filter((child) => child instanceof HTMLSlotElement);
    this.__toggleSlotChangeListeners(true);
    const invokeCallback = initialCall || addedColumns.length || removedColumns.length || orderChanged;
    if (invokeCallback) {
      this.__callback(addedColumns, removedColumns);
    }
  }
  /**
   * Default filter for column elements.
   */
  static __isColumnElement(node) {
    return node.nodeType === Node.ELEMENT_NODE && /\bcolumn\b/u.test(node.localName);
  }
  static getColumns(host) {
    const columns = [];
    const isColumnElement = host._isColumnElement || ColumnObserver.__isColumnElement;
    [...host.children].forEach((child) => {
      if (isColumnElement(child)) {
        columns.push(child);
      } else if (child instanceof HTMLSlotElement) {
        [...child.assignedElements({ flatten: true })].filter((assignedElement) => isColumnElement(assignedElement)).forEach((assignedElement) => columns.push(assignedElement));
      }
    });
    return columns;
  }
}
/**
 * @license
 * Copyright (c) 2016 - 2025 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const ColumnBaseMixin = (superClass) => class ColumnBaseMixin extends superClass {
  static get properties() {
    return {
      /**
       * When set to true, the column is user-resizable.
       * @default false
       */
      resizable: {
        type: Boolean,
        sync: true,
        value() {
          if (this.localName === "vaadin-grid-column-group") {
            return;
          }
          const parent = this.parentNode;
          if (parent && parent.localName === "vaadin-grid-column-group") {
            return parent.resizable || false;
          }
          return false;
        }
      },
      /**
       * When true, the column is frozen. When a column inside of a column group is frozen,
       * all of the sibling columns inside the group will get frozen also.
       * @type {boolean}
       */
      frozen: {
        type: Boolean,
        value: false,
        sync: true
      },
      /**
       * When true, the column is frozen to end of grid.
       *
       * When a column inside of a column group is frozen to end, all of the sibling columns
       * inside the group will get frozen to end also.
       *
       * Column can not be set as `frozen` and `frozenToEnd` at the same time.
       * @attr {boolean} frozen-to-end
       * @type {boolean}
       */
      frozenToEnd: {
        type: Boolean,
        value: false,
        sync: true
      },
      /**
       * When true, the cells for this column will be rendered with the `role` attribute
       * set as `rowheader`, instead of the `gridcell` role value used by default.
       *
       * When a column is set as row header, its cells will be announced by screen readers
       * while navigating to help user identify the current row as uniquely as possible.
       *
       * @attr {boolean} row-header
       * @type {boolean}
       */
      rowHeader: {
        type: Boolean,
        value: false,
        sync: true
      },
      /**
       * When set to true, the cells for this column are hidden.
       */
      hidden: {
        type: Boolean,
        value: false,
        sync: true
      },
      /**
       * Text content to display in the header cell of the column.
       */
      header: {
        type: String,
        sync: true
      },
      /**
       * Aligns the columns cell content horizontally.
       * Supported values: "start", "center" and "end".
       * @attr {start|center|end} text-align
       * @type {GridColumnTextAlign | null | undefined}
       */
      textAlign: {
        type: String,
        sync: true
      },
      /**
       * Custom part name for the header cell.
       *
       * @attr {string} header-part-name
       */
      headerPartName: {
        type: String,
        sync: true
      },
      /**
       * Custom part name for the footer cell.
       *
       * @attr {string} footer-part-name
       */
      footerPartName: {
        type: String,
        sync: true
      },
      /**
       * @type {boolean}
       * @protected
       */
      _lastFrozen: {
        type: Boolean,
        value: false,
        sync: true
      },
      /**
       * @type {boolean}
       * @protected
       */
      _bodyContentHidden: {
        type: Boolean,
        value: false,
        sync: true
      },
      /**
       * @type {boolean}
       * @protected
       */
      _firstFrozenToEnd: {
        type: Boolean,
        value: false,
        sync: true
      },
      /** @protected */
      _order: {
        type: Number,
        sync: true
      },
      /** @private */
      _reorderStatus: {
        type: Boolean,
        sync: true
      },
      /**
       * @type {Array<!HTMLElement>}
       * @protected
       */
      _emptyCells: Array,
      /** @private */
      _headerCell: {
        type: Object,
        sync: true
      },
      /** @private */
      _footerCell: {
        type: Object,
        sync: true
      },
      /** @protected */
      _grid: Object,
      /**
       * By default, the Polymer doesn't invoke the observer
       * during initialization if all of its dependencies are `undefined`.
       * This internal property can be used to force initial invocation of an observer
       * even the other dependencies of the observer are `undefined`.
       *
       * @private
       */
      __initialized: {
        type: Boolean,
        value: true
      },
      /**
       * Custom function for rendering the header content.
       * Receives two arguments:
       *
       * - `root` The header cell content DOM element. Append your content to it.
       * - `column` The `<vaadin-grid-column>` element.
       *
       * @type {GridHeaderFooterRenderer | null | undefined}
       */
      headerRenderer: {
        type: Function,
        sync: true
      },
      /**
       * Represents the final header renderer computed on the set of observable arguments.
       * It is supposed to be used internally when rendering the header cell content.
       *
       * @protected
       * @type {GridHeaderFooterRenderer | undefined}
       */
      _headerRenderer: {
        type: Function,
        computed: "_computeHeaderRenderer(headerRenderer, header, __initialized)"
      },
      /**
       * Custom function for rendering the footer content.
       * Receives two arguments:
       *
       * - `root` The footer cell content DOM element. Append your content to it.
       * - `column` The `<vaadin-grid-column>` element.
       *
       * @type {GridHeaderFooterRenderer | null | undefined}
       */
      footerRenderer: {
        type: Function,
        sync: true
      },
      /**
       * Represents the final footer renderer computed on the set of observable arguments.
       * It is supposed to be used internally when rendering the footer cell content.
       *
       * @protected
       * @type {GridHeaderFooterRenderer | undefined}
       */
      _footerRenderer: {
        type: Function,
        computed: "_computeFooterRenderer(footerRenderer, __initialized)"
      },
      /**
       * An internal property that is mainly used by `vaadin-template-renderer`
       * to identify grid column elements.
       *
       * @private
       */
      __gridColumnElement: {
        type: Boolean,
        value: true
      }
    };
  }
  static get observers() {
    return [
      "_widthChanged(width, _headerCell, _footerCell, _cells)",
      "_frozenChanged(frozen, _headerCell, _footerCell, _cells)",
      "_frozenToEndChanged(frozenToEnd, _headerCell, _footerCell, _cells)",
      "_flexGrowChanged(flexGrow, _headerCell, _footerCell, _cells)",
      "_textAlignChanged(textAlign, _cells, _headerCell, _footerCell)",
      "_orderChanged(_order, _headerCell, _footerCell, _cells)",
      "_lastFrozenChanged(_lastFrozen)",
      "_firstFrozenToEndChanged(_firstFrozenToEnd)",
      "_onRendererOrBindingChanged(_renderer, _cells, _bodyContentHidden, path)",
      "_onHeaderRendererOrBindingChanged(_headerRenderer, _headerCell, path, header)",
      "_onFooterRendererOrBindingChanged(_footerRenderer, _footerCell)",
      "_resizableChanged(resizable, _headerCell)",
      "_reorderStatusChanged(_reorderStatus, _headerCell, _footerCell, _cells)",
      "_hiddenChanged(hidden, _headerCell, _footerCell, _cells)",
      "_rowHeaderChanged(rowHeader, _cells)",
      "__headerFooterPartNameChanged(_headerCell, _footerCell, headerPartName, footerPartName)"
    ];
  }
  /**
   * @return {!Grid | undefined}
   * @protected
   */
  get _grid() {
    if (!this._gridValue) {
      this._gridValue = this._findHostGrid();
    }
    return this._gridValue;
  }
  /**
   * @return {!Array<!HTMLElement>}
   * @protected
   */
  get _allCells() {
    return [].concat(this._cells || []).concat(this._emptyCells || []).concat(this._headerCell).concat(this._footerCell).filter((cell) => cell);
  }
  /** @protected */
  connectedCallback() {
    super.connectedCallback();
    requestAnimationFrame(() => {
      if (!this._grid) {
        return;
      }
      this._allCells.forEach((cell) => {
        if (!cell._content.parentNode) {
          this._grid.appendChild(cell._content);
        }
      });
    });
  }
  /** @protected */
  disconnectedCallback() {
    super.disconnectedCallback();
    requestAnimationFrame(() => {
      if (this._grid) {
        return;
      }
      this._allCells.forEach((cell) => {
        if (cell._content.parentNode) {
          cell._content.parentNode.removeChild(cell._content);
        }
      });
    });
    this._gridValue = void 0;
  }
  /** @protected */
  ready() {
    super.ready();
    processTemplates(this);
  }
  /**
   * @return {!Grid | undefined}
   * @protected
   */
  _findHostGrid() {
    let el = this;
    while (el && !/^vaadin.*grid(-pro)?$/u.test(el.localName)) {
      el = el.assignedSlot ? el.assignedSlot.parentNode : el.parentNode;
    }
    return el || void 0;
  }
  /** @protected */
  _renderHeaderAndFooter() {
    this._renderHeaderCellContent(this._headerRenderer, this._headerCell);
    this._renderFooterCellContent(this._footerRenderer, this._footerCell);
  }
  /** @private */
  _flexGrowChanged(flexGrow) {
    if (this.parentElement && this.parentElement._columnPropChanged) {
      this.parentElement._columnPropChanged("flexGrow");
    }
    this._allCells.forEach((cell) => {
      cell.style.flexGrow = flexGrow;
    });
  }
  /** @private */
  _orderChanged(order) {
    this._allCells.forEach((cell) => {
      cell.style.order = order;
    });
  }
  /** @private */
  _widthChanged(width) {
    if (this.parentElement && this.parentElement._columnPropChanged) {
      this.parentElement._columnPropChanged("width");
    }
    this._allCells.forEach((cell) => {
      cell.style.width = width;
    });
  }
  /** @private */
  _frozenChanged(frozen) {
    if (this.parentElement && this.parentElement._columnPropChanged) {
      this.parentElement._columnPropChanged("frozen", frozen);
    }
    this._allCells.forEach((cell) => {
      updateCellState(cell, "frozen", frozen);
    });
    if (this._grid && this._grid._frozenCellsChanged) {
      this._grid._frozenCellsChanged();
    }
  }
  /** @private */
  _frozenToEndChanged(frozenToEnd) {
    if (this.parentElement && this.parentElement._columnPropChanged) {
      this.parentElement._columnPropChanged("frozenToEnd", frozenToEnd);
    }
    this._allCells.forEach((cell) => {
      if (this._grid && cell.parentElement === this._grid.$.sizer) {
        return;
      }
      updateCellState(cell, "frozen-to-end", frozenToEnd);
    });
    if (this._grid && this._grid._frozenCellsChanged) {
      this._grid._frozenCellsChanged();
    }
  }
  /** @private */
  _lastFrozenChanged(lastFrozen) {
    this._allCells.forEach((cell) => {
      updateCellState(cell, "last-frozen", lastFrozen);
    });
    if (this.parentElement && this.parentElement._columnPropChanged) {
      this.parentElement._lastFrozen = lastFrozen;
    }
  }
  /** @private */
  _firstFrozenToEndChanged(firstFrozenToEnd) {
    this._allCells.forEach((cell) => {
      if (this._grid && cell.parentElement === this._grid.$.sizer) {
        return;
      }
      updateCellState(cell, "first-frozen-to-end", firstFrozenToEnd);
    });
    if (this.parentElement && this.parentElement._columnPropChanged) {
      this.parentElement._firstFrozenToEnd = firstFrozenToEnd;
    }
  }
  /** @private */
  _rowHeaderChanged(rowHeader, cells) {
    if (!cells) {
      return;
    }
    cells.forEach((cell) => {
      cell.setAttribute("role", rowHeader ? "rowheader" : "gridcell");
    });
  }
  /**
   * @param {string} path
   * @return {string}
   * @protected
   */
  _generateHeader(path) {
    return path.substr(path.lastIndexOf(".") + 1).replace(/([A-Z])/gu, "-$1").toLowerCase().replace(/-/gu, " ").replace(/^./u, (match2) => match2.toUpperCase());
  }
  /** @private */
  _reorderStatusChanged(reorderStatus) {
    const prevStatus = this.__previousReorderStatus;
    const oldPart = prevStatus ? `reorder-${prevStatus}-cell` : "";
    const newPart = `reorder-${reorderStatus}-cell`;
    this._allCells.forEach((cell) => {
      updateCellState(cell, "reorder-status", reorderStatus, newPart, oldPart);
    });
    this.__previousReorderStatus = reorderStatus;
  }
  /** @private */
  _resizableChanged(resizable, headerCell) {
    if (resizable === void 0 || headerCell === void 0) {
      return;
    }
    if (headerCell) {
      [headerCell].concat(this._emptyCells).forEach((cell) => {
        if (cell) {
          const existingHandle = cell.querySelector('[part~="resize-handle"]');
          if (existingHandle) {
            cell.removeChild(existingHandle);
          }
          if (resizable) {
            const handle = document.createElement("div");
            handle.setAttribute("part", "resize-handle");
            cell.appendChild(handle);
          }
        }
      });
    }
  }
  /** @private */
  _textAlignChanged(textAlign) {
    if (textAlign === void 0 || this._grid === void 0) {
      return;
    }
    if (["start", "end", "center"].indexOf(textAlign) === -1) {
      console.warn('textAlign can only be set as "start", "end" or "center"');
      return;
    }
    let textAlignFallback;
    if (getComputedStyle(this._grid).direction === "ltr") {
      if (textAlign === "start") {
        textAlignFallback = "left";
      } else if (textAlign === "end") {
        textAlignFallback = "right";
      }
    } else if (textAlign === "start") {
      textAlignFallback = "right";
    } else if (textAlign === "end") {
      textAlignFallback = "left";
    }
    this._allCells.forEach((cell) => {
      cell._content.style.textAlign = textAlign;
      if (getComputedStyle(cell._content).textAlign !== textAlign) {
        cell._content.style.textAlign = textAlignFallback;
      }
    });
  }
  /** @private */
  _hiddenChanged(hidden) {
    if (this.parentElement && this.parentElement._columnPropChanged) {
      this.parentElement._columnPropChanged("hidden", hidden);
    }
    if (!!hidden !== !!this._previousHidden && this._grid) {
      if (hidden === true) {
        this._allCells.forEach((cell) => {
          if (cell._content.parentNode) {
            cell._content.parentNode.removeChild(cell._content);
          }
        });
      }
      this._grid._debouncerHiddenChanged = Debouncer$1.debounce(
        this._grid._debouncerHiddenChanged,
        animationFrame$1,
        () => {
          if (this._grid && this._grid._renderColumnTree) {
            this._grid._renderColumnTree(this._grid._columnTree);
          }
        }
      );
      if (this._grid._debounceUpdateFrozenColumn) {
        this._grid._debounceUpdateFrozenColumn();
      }
      if (this._grid._resetKeyboardNavigation) {
        this._grid._resetKeyboardNavigation();
      }
    }
    this._previousHidden = hidden;
  }
  /** @protected */
  _runRenderer(renderer, cell, model) {
    const isVisibleBodyCell = model && model.item && !cell.parentElement.hidden;
    const shouldRender = isVisibleBodyCell || renderer === this._headerRenderer || renderer === this._footerRenderer;
    if (!shouldRender) {
      return;
    }
    const args = [cell._content, this];
    if (isVisibleBodyCell) {
      args.push(model);
    }
    renderer.apply(this, args);
  }
  /**
   * Renders the content to the given cells using a renderer.
   *
   * @private
   */
  __renderCellsContent(renderer, cells) {
    if (this.hidden || !this._grid) {
      return;
    }
    cells.forEach((cell) => {
      if (!cell.parentElement) {
        return;
      }
      const model = this._grid.__getRowModel(cell.parentElement);
      if (!renderer) {
        return;
      }
      if (cell._renderer !== renderer) {
        this._clearCellContent(cell);
      }
      cell._renderer = renderer;
      this._runRenderer(renderer, cell, model);
    });
  }
  /**
   * Clears the content of a cell.
   *
   * @protected
   */
  _clearCellContent(cell) {
    cell._content.innerHTML = "";
    delete cell._content._$litPart$;
  }
  /**
   * Renders the header cell content using a renderer,
   * and then updates the visibility of the parent row depending on
   * whether all its children cells are empty or not.
   *
   * @protected
   */
  _renderHeaderCellContent(headerRenderer, headerCell) {
    if (!headerCell || !headerRenderer) {
      return;
    }
    this.__renderCellsContent(headerRenderer, [headerCell]);
    if (this._grid && headerCell.parentElement) {
      this._grid.__debounceUpdateHeaderFooterRowVisibility(headerCell.parentElement);
    }
  }
  /** @protected */
  _onHeaderRendererOrBindingChanged(headerRenderer, headerCell, ..._bindings) {
    this._renderHeaderCellContent(headerRenderer, headerCell);
  }
  /** @private */
  __headerFooterPartNameChanged(headerCell, footerCell, headerPartName, footerPartName) {
    [
      { cell: headerCell, partName: headerPartName },
      { cell: footerCell, partName: footerPartName }
    ].forEach(({ cell, partName }) => {
      if (cell) {
        const customParts = cell.__customParts || [];
        cell.part.remove(...customParts);
        cell.__customParts = partName ? partName.trim().split(" ") : [];
        cell.part.add(...cell.__customParts);
      }
    });
  }
  /**
   * Renders the content of body cells using a renderer.
   *
   * @protected
   */
  _renderBodyCellsContent(renderer, cells) {
    if (!cells || !renderer) {
      return;
    }
    this.__renderCellsContent(renderer, cells);
  }
  /** @protected */
  _onRendererOrBindingChanged(renderer, cells, ..._bindings) {
    this._renderBodyCellsContent(renderer, cells);
  }
  /**
   * Renders the footer cell content using a renderer
   * and then updates the visibility of the parent row depending on
   * whether all its children cells are empty or not.
   *
   * @protected
   */
  _renderFooterCellContent(footerRenderer, footerCell) {
    if (!footerCell || !footerRenderer) {
      return;
    }
    this.__renderCellsContent(footerRenderer, [footerCell]);
    if (this._grid && footerCell.parentElement) {
      this._grid.__debounceUpdateHeaderFooterRowVisibility(footerCell.parentElement);
    }
  }
  /** @protected */
  _onFooterRendererOrBindingChanged(footerRenderer, footerCell) {
    this._renderFooterCellContent(footerRenderer, footerCell);
  }
  /** @private */
  __setTextContent(node, textContent) {
    if (node.textContent !== textContent) {
      node.textContent = textContent;
    }
  }
  /**
   * Renders the text header to the header cell.
   *
   * @private
   */
  __textHeaderRenderer() {
    this.__setTextContent(this._headerCell._content, this.header);
  }
  /**
   * Computes the property name based on the path and renders it to the header cell.
   * If the path is not defined, then nothing is rendered.
   *
   * @protected
   */
  _defaultHeaderRenderer() {
    if (!this.path) {
      return;
    }
    this.__setTextContent(this._headerCell._content, this._generateHeader(this.path));
  }
  /**
   * Computes the item property value based on the path and renders it to the body cell.
   * If the path is not defined, then nothing is rendered.
   *
   * @protected
   */
  _defaultRenderer(root2, _owner, { item: item2 }) {
    if (!this.path) {
      return;
    }
    this.__setTextContent(root2, get$2(this.path, item2));
  }
  /**
   * By default, nothing is rendered to the footer cell.
   *
   * @protected
   */
  _defaultFooterRenderer() {
  }
  /**
   * Computes the final header renderer for the `_headerRenderer` computed property.
   * All the arguments are observable by the Polymer, it re-calls the method
   * once an argument is changed to update the property value.
   *
   * @protected
   * @return {GridHeaderFooterRenderer | undefined}
   */
  _computeHeaderRenderer(headerRenderer, header) {
    if (headerRenderer) {
      return headerRenderer;
    }
    if (header !== void 0 && header !== null) {
      return this.__textHeaderRenderer;
    }
    return this._defaultHeaderRenderer;
  }
  /**
   * Computes the final renderer for the `_renderer` property.
   * All the arguments are observable by the Polymer, it re-calls the method
   * once an argument is changed to update the property value.
   *
   * @protected
   * @return {GridBodyRenderer | undefined}
   */
  _computeRenderer(renderer) {
    if (renderer) {
      return renderer;
    }
    return this._defaultRenderer;
  }
  /**
   * Computes the final footer renderer for the `_footerRenderer` property.
   * All the arguments are observable by the Polymer, it re-calls the method
   * once an argument is changed to update the property value.
   *
   * @protected
   * @return {GridHeaderFooterRenderer | undefined}
   */
  _computeFooterRenderer(footerRenderer) {
    if (footerRenderer) {
      return footerRenderer;
    }
    return this._defaultFooterRenderer;
  }
};
const GridColumnMixin = (superClass) => class extends ColumnBaseMixin(DirMixin(superClass)) {
  static get properties() {
    return {
      /**
       * Width of the cells for this column.
       *
       * Please note that using the `em` length unit is discouraged as
       * it might lead to misalignment issues if the header, body, and footer
       * cells have different font sizes. Instead, use `rem` if you need
       * a length unit relative to the font size.
       */
      width: {
        type: String,
        value: "100px",
        sync: true
      },
      /**
       * Flex grow ratio for the cell widths. When set to 0, cell width is fixed.
       * @attr {number} flex-grow
       * @type {number}
       */
      flexGrow: {
        type: Number,
        value: 1,
        sync: true
      },
      /**
       * Custom function for rendering the cell content.
       * Receives three arguments:
       *
       * - `root` The cell content DOM element. Append your content to it.
       * - `column` The `<vaadin-grid-column>` element.
       * - `model` The object with the properties related with
       *   the rendered item, contains:
       *   - `model.index` The index of the item.
       *   - `model.item` The item.
       *   - `model.expanded` Sublevel toggle state.
       *   - `model.level` Level of the tree represented with a horizontal offset of the toggle button.
       *   - `model.selected` Selected state.
       *   - `model.detailsOpened` Details opened state.
       *
       * @type {GridBodyRenderer | null | undefined}
       */
      renderer: {
        type: Function,
        sync: true
      },
      /**
       * Represents the final renderer computed on the set of observable arguments.
       * It is supposed to be used internally when rendering the content of a body cell.
       *
       * @protected
       * @type {GridBodyRenderer | undefined}
       */
      _renderer: {
        type: Function,
        computed: "_computeRenderer(renderer, __initialized)"
      },
      /**
       * Path to an item sub-property whose value gets displayed in the column body cells.
       * The property name is also shown in the column header if an explicit header or renderer isn't defined.
       */
      path: {
        type: String,
        sync: true
      },
      /**
       * Automatically sets the width of the column based on the column contents when this is set to `true`.
       *
       * For performance reasons the column width is calculated automatically only once when the grid items
       * are rendered for the first time and the calculation only considers the rows which are currently
       * rendered in DOM (a bit more than what is currently visible). If the grid is scrolled, or the cell
       * content changes, the column width might not match the contents anymore.
       *
       * Hidden columns are ignored in the calculation and their widths are not automatically updated when
       * you show a column that was initially hidden.
       *
       * You can manually trigger the auto sizing behavior again by calling `grid.recalculateColumnWidths()`.
       *
       * The column width may still grow larger when `flexGrow` is not 0.
       * @attr {boolean} auto-width
       * @type {boolean}
       */
      autoWidth: {
        type: Boolean,
        value: false
      },
      /**
       * When true, wraps the cell's slot into an element with role="button", and sets
       * the tabindex attribute on the button element, instead of the cell itself.
       * This is needed to keep focus in sync with VoiceOver cursor when navigating
       * with Control + Option + arrow keys: focusing the `<td>` element does not fire
       * a focus event, but focusing an element with role="button" inside a cell fires it.
       * @protected
       */
      _focusButtonMode: {
        type: Boolean,
        value: false
      },
      /**
       * @type {Array<!HTMLElement>}
       * @protected
       */
      _cells: {
        type: Array,
        sync: true
      }
    };
  }
};
/**
 * @license
 * Copyright (c) 2016 - 2025 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const GridColumnGroupMixin = (superClass) => class extends ColumnBaseMixin(superClass) {
  static get properties() {
    return {
      /** @private */
      _childColumns: {
        value() {
          return this._getChildColumns(this);
        }
      },
      /**
       * Flex grow ratio for the column group as the sum of the ratios of its child columns.
       * @attr {number} flex-grow
       */
      flexGrow: {
        type: Number,
        readOnly: true,
        sync: true
      },
      /**
       * Width of the column group as the sum of the widths of its child columns.
       */
      width: {
        type: String,
        readOnly: true,
        sync: true
      },
      /** @private */
      _visibleChildColumns: Array,
      /** @private */
      _colSpan: Number,
      /** @private */
      _rootColumns: Array
    };
  }
  static get observers() {
    return [
      "_groupFrozenChanged(frozen, _rootColumns)",
      "_groupFrozenToEndChanged(frozenToEnd, _rootColumns)",
      "_groupHiddenChanged(hidden)",
      "_colSpanChanged(_colSpan, _headerCell, _footerCell)",
      "_groupOrderChanged(_order, _rootColumns)",
      "_groupReorderStatusChanged(_reorderStatus, _rootColumns)",
      "_groupResizableChanged(resizable, _rootColumns)"
    ];
  }
  /** @protected */
  connectedCallback() {
    super.connectedCallback();
    this._addNodeObserver();
    this._updateFlexAndWidth();
  }
  /** @protected */
  disconnectedCallback() {
    super.disconnectedCallback();
    if (this._observer) {
      this._observer.disconnect();
    }
  }
  /**
   * @param {string} path
   * @param {unknown=} value
   * @protected
   */
  _columnPropChanged(path, value) {
    if (path === "hidden") {
      this._preventHiddenSynchronization = true;
      this._updateVisibleChildColumns(this._childColumns);
      this._preventHiddenSynchronization = false;
    }
    if (/flexGrow|width|hidden|_childColumns/u.test(path)) {
      this._updateFlexAndWidth();
    }
    if (path === "frozen" && !this.frozen) {
      this.frozen = value;
    }
    if (path === "lastFrozen" && !this._lastFrozen) {
      this._lastFrozen = value;
    }
    if (path === "frozenToEnd" && !this.frozenToEnd) {
      this.frozenToEnd = value;
    }
    if (path === "firstFrozenToEnd" && !this._firstFrozenToEnd) {
      this._firstFrozenToEnd = value;
    }
  }
  /** @private */
  _groupOrderChanged(order, rootColumns) {
    if (rootColumns) {
      const _rootColumns = rootColumns.slice(0);
      if (!order) {
        _rootColumns.forEach((column) => {
          column._order = 0;
        });
        return;
      }
      const trailingZeros = /(0+)$/u.exec(order).pop().length;
      const childCountDigits = ~~(Math.log(rootColumns.length) / Math.LN10) + 1;
      const scope = 10 ** (trailingZeros - childCountDigits);
      if (_rootColumns[0] && _rootColumns[0]._order) {
        _rootColumns.sort((a3, b2) => a3._order - b2._order);
      }
      updateColumnOrders(_rootColumns, scope, order);
    }
  }
  /** @private */
  _groupReorderStatusChanged(reorderStatus, rootColumns) {
    if (reorderStatus === void 0 || rootColumns === void 0) {
      return;
    }
    rootColumns.forEach((column) => {
      column._reorderStatus = reorderStatus;
    });
  }
  /** @private */
  _groupResizableChanged(resizable, rootColumns) {
    if (resizable === void 0 || rootColumns === void 0) {
      return;
    }
    rootColumns.forEach((column) => {
      column.resizable = resizable;
    });
  }
  /** @private */
  _updateVisibleChildColumns(childColumns) {
    this._visibleChildColumns = Array.prototype.filter.call(childColumns, (col) => !col.hidden);
    this._colSpan = this._visibleChildColumns.length;
    this._updateAutoHidden();
  }
  /** @protected */
  _updateFlexAndWidth() {
    if (!this._visibleChildColumns) {
      return;
    }
    if (this._visibleChildColumns.length > 0) {
      const width = this._visibleChildColumns.reduce((prev, curr) => {
        prev += ` + ${(curr.width || "0px").replace("calc", "")}`;
        return prev;
      }, "").substring(3);
      this._setWidth(`calc(${width})`);
    } else {
      this._setWidth("0px");
    }
    this._setFlexGrow(
      Array.prototype.reduce.call(this._visibleChildColumns, (prev, curr) => prev + curr.flexGrow, 0)
    );
  }
  /**
   * This method is called before the group's frozen value is being propagated to the child columns.
   * In case some of the child columns are frozen, while others are not, the non-frozen ones
   * will get automatically frozen as well. As this may sometimes be unintended, this method
   * shows a warning in the console in such cases.
   * @private
   */
  __scheduleAutoFreezeWarning(columns, frozenProp) {
    if (this._grid) {
      const frozenAttr = frozenProp.replace(/([A-Z])/gu, "-$1").toLowerCase();
      const firstColumnFrozen = columns[0][frozenProp] || columns[0].hasAttribute(frozenAttr);
      const allSameFrozen = columns.every((column) => {
        return (column[frozenProp] || column.hasAttribute(frozenAttr)) === firstColumnFrozen;
      });
      if (!allSameFrozen) {
        this._grid.__autoFreezeWarningDebouncer = Debouncer$1.debounce(
          this._grid.__autoFreezeWarningDebouncer,
          animationFrame$1,
          () => {
            console.warn(
              `WARNING: Joining ${frozenProp} and non-${frozenProp} Grid columns inside the same column group! This will automatically freeze all the joined columns to avoid rendering issues. If this was intentional, consider marking each joined column explicitly as ${frozenProp}. Otherwise, exclude the ${frozenProp} columns from the joined group.`
            );
          }
        );
      }
    }
  }
  /** @private */
  _groupFrozenChanged(frozen, rootColumns) {
    if (rootColumns === void 0 || frozen === void 0) {
      return;
    }
    if (frozen !== false) {
      this.__scheduleAutoFreezeWarning(rootColumns, "frozen");
      Array.from(rootColumns).forEach((col) => {
        col.frozen = frozen;
      });
    }
  }
  /** @private */
  _groupFrozenToEndChanged(frozenToEnd, rootColumns) {
    if (rootColumns === void 0 || frozenToEnd === void 0) {
      return;
    }
    if (frozenToEnd !== false) {
      this.__scheduleAutoFreezeWarning(rootColumns, "frozenToEnd");
      Array.from(rootColumns).forEach((col) => {
        col.frozenToEnd = frozenToEnd;
      });
    }
  }
  /** @private */
  _groupHiddenChanged(hidden) {
    if (hidden || this.__groupHiddenInitialized) {
      this._synchronizeHidden();
    }
    this.__groupHiddenInitialized = true;
  }
  /** @private */
  _updateAutoHidden() {
    const wasAutoHidden = this._autoHidden;
    this._autoHidden = (this._visibleChildColumns || []).length === 0;
    if (wasAutoHidden || this._autoHidden) {
      this.hidden = this._autoHidden;
    }
  }
  /** @private */
  _synchronizeHidden() {
    if (this._childColumns && !this._preventHiddenSynchronization) {
      this._childColumns.forEach((column) => {
        column.hidden = this.hidden;
      });
    }
  }
  /** @private */
  _colSpanChanged(colSpan, headerCell, footerCell) {
    if (headerCell) {
      headerCell.setAttribute("colspan", colSpan);
      if (this._grid) {
        this._grid._a11yUpdateCellColspan(headerCell, colSpan);
      }
    }
    if (footerCell) {
      footerCell.setAttribute("colspan", colSpan);
      if (this._grid) {
        this._grid._a11yUpdateCellColspan(footerCell, colSpan);
      }
    }
  }
  /**
   * @param {!GridColumnGroup} el
   * @return {!Array<!GridColumn>}
   * @protected
   */
  _getChildColumns(el) {
    return ColumnObserver.getColumns(el);
  }
  /** @private */
  _addNodeObserver() {
    this._observer = new ColumnObserver(this, () => {
      this._preventHiddenSynchronization = true;
      this._rootColumns = this._getChildColumns(this);
      this._childColumns = this._rootColumns;
      this._updateVisibleChildColumns(this._childColumns);
      this._preventHiddenSynchronization = false;
      if (this._grid && this._grid._debounceUpdateColumnTree) {
        this._grid._debounceUpdateColumnTree();
      }
    });
    this._observer.flush();
  }
  /**
   * @param {!Node} node
   * @return {boolean}
   * @protected
   */
  _isColumnElement(node) {
    return node.nodeType === Node.ELEMENT_NODE && /\bcolumn\b/u.test(node.localName);
  }
};
/**
 * @license
 * Copyright (c) 2016 - 2025 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
class GridColumnGroup extends GridColumnGroupMixin(PolymerElement) {
  static get is() {
    return "vaadin-grid-column-group";
  }
}
defineCustomElement(GridColumnGroup);
registerStyles$1(
  "vaadin-grid",
  css`
    :host {
      font-family: var(--lumo-font-family);
      font-size: var(--lumo-font-size-m);
      line-height: var(--lumo-line-height-s);
      color: var(--lumo-body-text-color);
      background-color: var(--lumo-base-color);
      box-sizing: border-box;
      -webkit-text-size-adjust: 100%;
      -webkit-tap-highlight-color: transparent;
      -webkit-font-smoothing: antialiased;
      -moz-osx-font-smoothing: grayscale;
      --_focus-ring-color: var(--vaadin-focus-ring-color, var(--lumo-primary-color-50pct));
      --_focus-ring-width: var(--vaadin-focus-ring-width, 2px);
      /* For internal use only */
      --_lumo-grid-border-color: var(--lumo-contrast-20pct);
      --_lumo-grid-secondary-border-color: var(--lumo-contrast-10pct);
      --_lumo-grid-border-width: 1px;
      --_lumo-grid-selected-row-color: var(--lumo-primary-color-10pct);
    }

    /* No (outer) border */

    :host(:not([theme~='no-border'])) {
      border: var(--_lumo-grid-border-width) solid var(--_lumo-grid-border-color);
    }

    :host([disabled]) {
      opacity: 0.7;
    }

    /* Cell styles */

    [part~='cell'] {
      min-height: var(--lumo-size-m);
      background-color: var(--vaadin-grid-cell-background, var(--lumo-base-color));
      cursor: default;
      --_cell-padding: var(--vaadin-grid-cell-padding, var(--_cell-default-padding));
      --_cell-default-padding: var(--lumo-space-xs) var(--lumo-space-m);
    }

    [part~='cell'] ::slotted(vaadin-grid-cell-content) {
      cursor: inherit;
      padding: var(--_cell-padding);
    }

    /* Apply row borders by default and introduce the "no-row-borders" variant */
    :host(:not([theme~='no-row-borders'])) [part~='cell']:not([part~='details-cell']) {
      border-top: var(--_lumo-grid-border-width) solid var(--_lumo-grid-secondary-border-color);
    }

    /* Hide first body row top border */
    :host(:not([theme~='no-row-borders'])) [part~='first-row'] [part~='cell']:not([part~='details-cell']) {
      border-top: 0;
      min-height: calc(var(--lumo-size-m) - var(--_lumo-grid-border-width));
    }

    /* Focus-ring */

    [part~='row'] {
      position: relative;
    }

    [part~='row']:focus,
    [part~='focused-cell']:focus {
      outline: none;
    }

    :host([navigating]) [part~='row']:focus::before,
    :host([navigating]) [part~='focused-cell']:focus::before {
      content: '';
      position: absolute;
      inset: 0;
      pointer-events: none;
      box-shadow: inset 0 0 0 var(--_focus-ring-width) var(--_focus-ring-color);
    }

    :host([navigating]) [part~='row']:focus::before {
      transform: translateX(calc(-1 * var(--_grid-horizontal-scroll-position)));
      z-index: 3;
    }

    /* Empty state */
    [part~='empty-state'] {
      padding: var(--lumo-space-m);
      color: var(--lumo-secondary-text-color);
    }

    /* Drag and Drop styles */
    :host([dragover])::after {
      content: '';
      position: absolute;
      z-index: 100;
      inset: 0;
      pointer-events: none;
      box-shadow: inset 0 0 0 var(--_focus-ring-width) var(--_focus-ring-color);
    }

    [part~='row'][dragover] {
      z-index: 100 !important;
    }

    [part~='row'][dragover] [part~='cell'] {
      overflow: visible;
    }

    [part~='row'][dragover] [part~='cell']::after {
      content: '';
      position: absolute;
      inset: 0;
      height: calc(var(--_lumo-grid-border-width) + 2px);
      pointer-events: none;
      background: var(--lumo-primary-color-50pct);
    }

    [part~='row'][dragover] [part~='cell'][last-frozen]::after {
      right: -1px;
    }

    :host([theme~='no-row-borders']) [dragover] [part~='cell']::after {
      height: 2px;
    }

    [part~='row'][dragover='below'] [part~='cell']::after {
      top: 100%;
      bottom: auto;
      margin-top: -1px;
    }

    :host([all-rows-visible]) [part~='last-row'][dragover='below'] [part~='cell']::after {
      height: 1px;
    }

    [part~='row'][dragover='above'] [part~='cell']::after {
      top: auto;
      bottom: 100%;
      margin-bottom: -1px;
    }

    [part~='row'][details-opened][dragover='below'] [part~='cell']:not([part~='details-cell'])::after,
    [part~='row'][details-opened][dragover='above'] [part~='details-cell']::after {
      display: none;
    }

    [part~='row'][dragover][dragover='on-top'] [part~='cell']::after {
      height: 100%;
      opacity: 0.5;
    }

    [part~='row'][dragstart] [part~='cell'] {
      border: none !important;
      box-shadow: none !important;
    }

    [part~='row'][dragstart] [part~='cell'][last-column] {
      border-radius: 0 var(--lumo-border-radius-s) var(--lumo-border-radius-s) 0;
    }

    [part~='row'][dragstart] [part~='cell'][first-column] {
      border-radius: var(--lumo-border-radius-s) 0 0 var(--lumo-border-radius-s);
    }

    #scroller [part~='row'][dragstart]:not([dragstart=''])::after {
      display: block;
      position: absolute;
      left: var(--_grid-drag-start-x);
      top: var(--_grid-drag-start-y);
      z-index: 100;
      content: attr(dragstart);
      align-items: center;
      justify-content: center;
      box-sizing: border-box;
      padding: calc(var(--lumo-space-xs) * 0.8);
      color: var(--lumo-error-contrast-color);
      background-color: var(--lumo-error-color);
      border-radius: var(--lumo-border-radius-m);
      font-family: var(--lumo-font-family);
      font-size: var(--lumo-font-size-xxs);
      line-height: 1;
      font-weight: 500;
      text-transform: initial;
      letter-spacing: initial;
      min-width: calc(var(--lumo-size-s) * 0.7);
      text-align: center;
    }

    /* Headers and footers */

    [part~='header-cell'],
    [part~='footer-cell'],
    [part~='reorder-ghost'] {
      font-size: var(--lumo-font-size-s);
      font-weight: 500;
    }

    [part~='footer-cell'] {
      font-weight: 400;
    }

    [part~='row']:only-child [part~='header-cell'] {
      min-height: var(--lumo-size-xl);
    }

    /* Header borders */

    /* Hide first header row top border */
    :host(:not([theme~='no-row-borders'])) [part~='row']:first-child [part~='header-cell'] {
      border-top: 0;
    }

    /* Hide header row top border if previous row is hidden */
    [part~='row'][hidden] + [part~='row'] [part~='header-cell'] {
      border-top: 0;
    }

    [part~='row']:last-child [part~='header-cell'] {
      border-bottom: var(--_lumo-grid-border-width) solid transparent;
    }

    :host(:not([theme~='no-row-borders'])) [part~='row']:last-child [part~='header-cell'] {
      border-bottom-color: var(--_lumo-grid-secondary-border-color);
    }

    /* Overflow uses a stronger border color */
    :host([overflow~='top']) [part~='row']:last-child [part~='header-cell'] {
      border-bottom-color: var(--_lumo-grid-border-color);
    }

    /* Footer borders */

    [part~='row']:first-child [part~='footer-cell'] {
      border-top: var(--_lumo-grid-border-width) solid transparent;
    }

    :host(:not([theme~='no-row-borders'])) [part~='row']:first-child [part~='footer-cell'] {
      border-top-color: var(--_lumo-grid-secondary-border-color);
    }

    /* Overflow uses a stronger border color */
    :host([overflow~='bottom']) [part~='row']:first-child [part~='footer-cell'] {
      border-top-color: var(--_lumo-grid-border-color);
    }

    /* Column reordering */

    :host([reordering]) [part~='cell'] {
      background: linear-gradient(var(--lumo-shade-20pct), var(--lumo-shade-20pct)) var(--lumo-base-color);
    }

    :host([reordering]) [part~='cell'][reorder-status='allowed'] {
      background: var(--lumo-base-color);
    }

    :host([reordering]) [part~='cell'][reorder-status='dragging'] {
      background: linear-gradient(var(--lumo-contrast-5pct), var(--lumo-contrast-5pct)) var(--lumo-base-color);
    }

    [part~='reorder-ghost'] {
      opacity: 0.85;
      box-shadow: var(--lumo-box-shadow-s);
      /* TODO Use the same styles as for the cell element (reorder-ghost copies styles from the cell element) */
      padding: var(--lumo-space-s) var(--lumo-space-m) !important;
    }

    /* Column resizing */

    [part='resize-handle'] {
      --_resize-handle-width: 3px;
      width: var(--_resize-handle-width);
      background-color: var(--lumo-primary-color-50pct);
      opacity: 0;
      transition: opacity 0.2s;
    }

    [part='resize-handle']::before {
      transform: translateX(calc(-50% + var(--_resize-handle-width) / 2));
      width: var(--lumo-size-s);
    }

    :host(:not([reordering])) *:not([column-resizing]) [part~='cell']:hover [part='resize-handle'],
    [part='resize-handle']:active {
      opacity: 1;
      transition-delay: 0.15s;
    }

    /* Column borders */

    :host([theme~='column-borders']) [part~='cell']:not([last-column]):not([part~='details-cell']) {
      border-right: var(--_lumo-grid-border-width) solid var(--_lumo-grid-secondary-border-color);
    }

    /* Frozen columns */

    [last-frozen] {
      border-right: var(--_lumo-grid-border-width) solid transparent;
      overflow: hidden;
    }

    :host([overflow~='start']) [part~='cell'][last-frozen]:not([part~='details-cell']) {
      border-right-color: var(--_lumo-grid-border-color);
    }

    [first-frozen-to-end] {
      border-left: var(--_lumo-grid-border-width) solid transparent;
    }

    :host([overflow~='end']) [part~='cell'][first-frozen-to-end]:not([part~='details-cell']) {
      border-left-color: var(--_lumo-grid-border-color);
    }

    /* Row stripes */

    :host([theme~='row-stripes']) [part~='even-row'] [part~='body-cell'],
    :host([theme~='row-stripes']) [part~='even-row'] [part~='details-cell'] {
      background-image: linear-gradient(var(--lumo-contrast-5pct), var(--lumo-contrast-5pct));
      background-repeat: repeat-x;
    }

    /* Selected row */

    /* Raise the selected rows above unselected rows (so that box-shadow can cover unselected rows) */
    :host(:not([reordering])) [part~='row'][selected] {
      z-index: 1;
    }

    :host(:not([reordering])) [part~='row'][selected] [part~='body-cell']:not([part~='details-cell']) {
      background-image: linear-gradient(var(--_lumo-grid-selected-row-color), var(--_lumo-grid-selected-row-color));
      background-repeat: repeat;
    }

    /* Cover the border of an unselected row */
    :host(:not([theme~='no-row-borders'])) [part~='row'][selected] [part~='cell']:not([part~='details-cell']) {
      box-shadow: 0 var(--_lumo-grid-border-width) 0 0 var(--_lumo-grid-selected-row-color);
    }

    /* Compact */

    :host([theme~='compact']) [part~='row']:only-child [part~='header-cell'] {
      min-height: var(--lumo-size-m);
    }

    :host([theme~='compact']) [part~='cell'] {
      min-height: var(--lumo-size-s);
      --_cell-default-padding: var(--lumo-space-xs) var(--lumo-space-s);
    }

    :host([theme~='compact']) [part~='first-row'] [part~='cell']:not([part~='details-cell']) {
      min-height: calc(var(--lumo-size-s) - var(--_lumo-grid-border-width));
    }

    :host([theme~='compact']) [part~='empty-state'] {
      padding: var(--lumo-space-s);
    }

    /* Wrap cell contents */

    :host([theme~='wrap-cell-content']) [part~='cell'] ::slotted(vaadin-grid-cell-content) {
      white-space: normal;
    }

    /* RTL specific styles */

    :host([dir='rtl']) [part~='row'][dragstart] [part~='cell'][last-column] {
      border-radius: var(--lumo-border-radius-s) 0 0 var(--lumo-border-radius-s);
    }

    :host([dir='rtl']) [part~='row'][dragstart] [part~='cell'][first-column] {
      border-radius: 0 var(--lumo-border-radius-s) var(--lumo-border-radius-s) 0;
    }

    :host([dir='rtl'][theme~='column-borders']) [part~='cell']:not([last-column]):not([part~='details-cell']) {
      border-right: none;
      border-left: var(--_lumo-grid-border-width) solid var(--_lumo-grid-secondary-border-color);
    }

    :host([dir='rtl']) [last-frozen] {
      border-right: none;
      border-left: var(--_lumo-grid-border-width) solid transparent;
    }

    :host([dir='rtl']) [first-frozen-to-end] {
      border-left: none;
      border-right: var(--_lumo-grid-border-width) solid transparent;
    }

    :host([dir='rtl'][overflow~='start']) [part~='cell'][last-frozen]:not([part~='details-cell']) {
      border-left-color: var(--_lumo-grid-border-color);
    }

    :host([dir='rtl'][overflow~='end']) [part~='cell'][first-frozen-to-end]:not([part~='details-cell']) {
      border-right-color: var(--_lumo-grid-border-color);
    }
  `,
  { moduleId: "lumo-grid" }
);
/**
 * @license
 * Copyright (c) 2016 - 2025 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
class GridColumn extends GridColumnMixin(PolymerElement) {
  static get is() {
    return "vaadin-grid-column";
  }
}
defineCustomElement(GridColumn);
/**
 * @license
 * Copyright (c) 2016 - 2025 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const A11yMixin = (superClass) => class A11yMixin extends superClass {
  static get properties() {
    return {
      /**
       * String used to label the grid to screen reader users.
       * @attr {string} accessible-name
       */
      accessibleName: {
        type: String
      }
    };
  }
  static get observers() {
    return ["_a11yUpdateGridSize(size, _columnTree, __emptyState)"];
  }
  /** @private */
  _a11yGetHeaderRowCount(_columnTree) {
    return _columnTree.filter(
      (level) => level.some((col) => col.headerRenderer || col.path && col.header !== null || col.header)
    ).length;
  }
  /** @private */
  _a11yGetFooterRowCount(_columnTree) {
    return _columnTree.filter((level) => level.some((col) => col.footerRenderer)).length;
  }
  /** @private */
  _a11yUpdateGridSize(size, _columnTree, emptyState) {
    if (size === void 0 || _columnTree === void 0) {
      return;
    }
    const headerRowsCount = this._a11yGetHeaderRowCount(_columnTree);
    const footerRowsCount = this._a11yGetFooterRowCount(_columnTree);
    const bodyRowsCount = emptyState ? 1 : size;
    const rowsCount = bodyRowsCount + headerRowsCount + footerRowsCount;
    this.$.table.setAttribute("aria-rowcount", rowsCount);
    const bodyColumns = _columnTree[_columnTree.length - 1];
    const columnsCount = emptyState ? 1 : rowsCount && bodyColumns && bodyColumns.length || 0;
    this.$.table.setAttribute("aria-colcount", columnsCount);
    this._a11yUpdateHeaderRows();
    this._a11yUpdateFooterRows();
  }
  /** @protected */
  _a11yUpdateHeaderRows() {
    iterateChildren(this.$.header, (headerRow, index) => {
      headerRow.setAttribute("aria-rowindex", index + 1);
    });
  }
  /** @protected */
  _a11yUpdateFooterRows() {
    iterateChildren(this.$.footer, (footerRow, index) => {
      footerRow.setAttribute("aria-rowindex", this._a11yGetHeaderRowCount(this._columnTree) + this.size + index + 1);
    });
  }
  /**
   * @param {!HTMLElement} row
   * @param {number} index
   * @protected
   */
  _a11yUpdateRowRowindex(row, index) {
    row.setAttribute("aria-rowindex", index + this._a11yGetHeaderRowCount(this._columnTree) + 1);
  }
  /**
   * @param {!HTMLElement} row
   * @param {boolean} selected
   * @protected
   */
  _a11yUpdateRowSelected(row, selected) {
    row.setAttribute("aria-selected", Boolean(selected));
    iterateRowCells(row, (cell) => {
      cell.setAttribute("aria-selected", Boolean(selected));
    });
  }
  /**
   * @param {!HTMLElement} row
   * @protected
   */
  _a11yUpdateRowExpanded(row) {
    if (this.__isRowExpandable(row)) {
      row.setAttribute("aria-expanded", "false");
    } else if (this.__isRowCollapsible(row)) {
      row.setAttribute("aria-expanded", "true");
    } else {
      row.removeAttribute("aria-expanded");
    }
  }
  /**
   * @param {!HTMLElement} row
   * @param {number} level
   * @protected
   */
  _a11yUpdateRowLevel(row, level) {
    if (level > 0 || this.__isRowCollapsible(row) || this.__isRowExpandable(row)) {
      row.setAttribute("aria-level", level + 1);
    } else {
      row.removeAttribute("aria-level");
    }
  }
  /**
   * @param {!HTMLElement} row
   * @param {!HTMLElement} detailsCell
   * @protected
   */
  _a11ySetRowDetailsCell(row, detailsCell) {
    iterateRowCells(row, (cell) => {
      if (cell !== detailsCell) {
        cell.setAttribute("aria-controls", detailsCell.id);
      }
    });
  }
  /**
   * @param {!HTMLElement} row
   * @param {number} colspan
   * @protected
   */
  _a11yUpdateCellColspan(cell, colspan) {
    cell.setAttribute("aria-colspan", Number(colspan));
  }
  /** @protected */
  _a11yUpdateSorters() {
    Array.from(this.querySelectorAll("vaadin-grid-sorter")).forEach((sorter) => {
      let cellContent = sorter.parentNode;
      while (cellContent && cellContent.localName !== "vaadin-grid-cell-content") {
        cellContent = cellContent.parentNode;
      }
      if (cellContent && cellContent.assignedSlot) {
        const cell = cellContent.assignedSlot.parentNode;
        cell.setAttribute(
          "aria-sort",
          {
            asc: "ascending",
            desc: "descending"
          }[String(sorter.direction)] || "none"
        );
      }
    });
  }
};
/**
 * @license
 * Copyright (c) 2016 - 2025 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const isFocusable = (target) => {
  return target.offsetParent && !target.part.contains("body-cell") && isElementFocusable(target) && getComputedStyle(target).visibility !== "hidden";
};
const ActiveItemMixin = (superClass) => class ActiveItemMixin extends superClass {
  static get properties() {
    return {
      /**
       * The item user has last interacted with. Turns to `null` after user deactivates
       * the item by re-interacting with the currently active item.
       * @type {GridItem}
       */
      activeItem: {
        type: Object,
        notify: true,
        value: null,
        sync: true
      }
    };
  }
  /** @protected */
  ready() {
    super.ready();
    this.$.scroller.addEventListener("click", this._onClick.bind(this));
    this.addEventListener("cell-activate", this._activateItem.bind(this));
    this.addEventListener("row-activate", this._activateItem.bind(this));
  }
  /** @private */
  _activateItem(e2) {
    const model = e2.detail.model;
    const clickedItem = model ? model.item : null;
    if (clickedItem) {
      this.activeItem = !this._itemsEqual(this.activeItem, clickedItem) ? clickedItem : null;
    }
  }
  /**
   * Checks whether the click event should not activate the cell on which it occurred.
   *
   * @protected
   */
  _shouldPreventCellActivationOnClick(e2) {
    const { cell } = this._getGridEventLocation(e2);
    return (
      // Something has handled this click already, e. g., <vaadin-grid-sorter>
      e2.defaultPrevented || // No clicked cell available
      !cell || // Cell is a details cell
      cell.getAttribute("part").includes("details-cell") || // Cell is the empty state cell
      cell === this.$.emptystatecell || // Cell content is focused
      cell._content.contains(this.getRootNode().activeElement) || // Clicked on a focusable element
      this._isFocusable(e2.target) || // Clicked on a label element
      e2.target instanceof HTMLLabelElement
    );
  }
  /**
   * @param {!MouseEvent} e
   * @protected
   */
  _onClick(e2) {
    if (this._shouldPreventCellActivationOnClick(e2)) {
      return;
    }
    const { cell } = this._getGridEventLocation(e2);
    if (cell) {
      this.dispatchEvent(
        new CustomEvent("cell-activate", {
          detail: {
            model: this.__getRowModel(cell.parentElement)
          }
        })
      );
    }
  }
  /**
   * @param {!Element} target
   * @return {boolean}
   * @protected
   */
  _isFocusable(target) {
    return isFocusable(target);
  }
  /**
   * Fired when the `activeItem` property changes.
   *
   * @event active-item-changed
   */
  /**
   * Fired when the cell is activated with click or keyboard.
   *
   * @event cell-activate
   */
};
function get(path, object) {
  return path.split(".").reduce((obj, property) => obj[property], object);
}
function checkPaths(arrayToCheck, action, items) {
  if (items.length === 0) {
    return false;
  }
  let result = true;
  arrayToCheck.forEach(({ path }) => {
    if (!path || path.indexOf(".") === -1) {
      return;
    }
    const parentProperty = path.replace(/\.[^.]*$/u, "");
    if (get(parentProperty, items[0]) === void 0) {
      console.warn(`Path "${path}" used for ${action} does not exist in all of the items, ${action} is disabled.`);
      result = false;
    }
  });
  return result;
}
function normalizeEmptyValue(value) {
  if ([void 0, null].indexOf(value) >= 0) {
    return "";
  } else if (isNaN(value)) {
    return value.toString();
  }
  return value;
}
function compare(a3, b2) {
  a3 = normalizeEmptyValue(a3);
  b2 = normalizeEmptyValue(b2);
  if (a3 < b2) {
    return -1;
  }
  if (a3 > b2) {
    return 1;
  }
  return 0;
}
function multiSort(items, sortOrders) {
  return items.sort((a3, b2) => {
    return sortOrders.map((sortOrder) => {
      if (sortOrder.direction === "asc") {
        return compare(get(sortOrder.path, a3), get(sortOrder.path, b2));
      } else if (sortOrder.direction === "desc") {
        return compare(get(sortOrder.path, b2), get(sortOrder.path, a3));
      }
      return 0;
    }).reduce((p, n) => {
      return p !== 0 ? p : n;
    }, 0);
  });
}
function filter(items, filters) {
  return items.filter((item2) => {
    return filters.every((filter2) => {
      const value = normalizeEmptyValue(get(filter2.path, item2));
      const filterValueLowercase = normalizeEmptyValue(filter2.value).toString().toLowerCase();
      return value.toString().toLowerCase().includes(filterValueLowercase);
    });
  });
}
const createArrayDataProvider = (allItems) => {
  return (params, callback) => {
    let items = allItems ? [...allItems] : [];
    if (params.filters && checkPaths(params.filters, "filtering", items)) {
      items = filter(items, params.filters);
    }
    if (Array.isArray(params.sortOrders) && params.sortOrders.length && checkPaths(params.sortOrders, "sorting", items)) {
      items = multiSort(items, params.sortOrders);
    }
    const count = Math.min(items.length, params.pageSize);
    const start = params.page * count;
    const end = start + count;
    const slice = items.slice(start, end);
    callback(slice, items.length);
  };
};
/**
 * @license
 * Copyright (c) 2016 - 2025 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const ArrayDataProviderMixin = (superClass) => class ArrayDataProviderMixin extends superClass {
  static get properties() {
    return {
      /**
       * An array containing the items which will be passed to renderer functions.
       *
       * @type {Array<!GridItem> | undefined}
       */
      items: {
        type: Array,
        sync: true
      }
    };
  }
  static get observers() {
    return ["__dataProviderOrItemsChanged(dataProvider, items, isAttached, items.*)"];
  }
  /** @private */
  __setArrayDataProvider(items) {
    const arrayDataProvider = createArrayDataProvider(this.items);
    arrayDataProvider.__items = items;
    this._arrayDataProvider = arrayDataProvider;
    this.size = items.length;
    this.dataProvider = arrayDataProvider;
  }
  /**
   * @override
   * @protected
   */
  _onDataProviderPageReceived() {
    super._onDataProviderPageReceived();
    if (this._arrayDataProvider) {
      this.size = this._flatSize;
    }
  }
  /** @private */
  __dataProviderOrItemsChanged(dataProvider, items, isAttached) {
    if (!isAttached) {
      return;
    }
    if (this._arrayDataProvider) {
      if (dataProvider !== this._arrayDataProvider) {
        this._arrayDataProvider = void 0;
        this.items = void 0;
      } else if (!items) {
        this._arrayDataProvider = void 0;
        this.dataProvider = void 0;
        this.size = 0;
        this.clearCache();
      } else if (this._arrayDataProvider.__items === items) {
        this.clearCache();
      } else {
        this.__setArrayDataProvider(items);
      }
    } else if (items) {
      this.__setArrayDataProvider(items);
    }
  }
};
/**
 * @license
 * Copyright (c) 2016 - 2025 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const ColumnAutoWidthMixin = (superClass) => class extends superClass {
  static get properties() {
    return {
      /** @private */
      __pendingRecalculateColumnWidths: {
        type: Boolean,
        value: true
      }
    };
  }
  static get observers() {
    return [
      "__dataProviderChangedAutoWidth(dataProvider)",
      "__columnTreeChangedAutoWidth(_columnTree)",
      "__flatSizeChangedAutoWidth(_flatSize)"
    ];
  }
  constructor() {
    super();
    this.addEventListener("animationend", this.__onAnimationEndAutoWidth);
  }
  /** @private */
  __onAnimationEndAutoWidth(e2) {
    if (e2.animationName.indexOf("vaadin-grid-appear") === 0) {
      this.__tryToRecalculateColumnWidthsIfPending();
    }
  }
  /** @private */
  __dataProviderChangedAutoWidth(_dataProvider) {
    if (this.__hasHadRenderedRowsForColumnWidthCalculation) {
      return;
    }
    this.recalculateColumnWidths();
  }
  /** @private */
  __columnTreeChangedAutoWidth(_columnTree) {
    queueMicrotask(() => this.recalculateColumnWidths());
  }
  /** @private */
  __flatSizeChangedAutoWidth(flatSize) {
    requestAnimationFrame(() => {
      if (!!flatSize && !this.__hasHadRenderedRowsForColumnWidthCalculation) {
        this.recalculateColumnWidths();
      } else {
        this.__tryToRecalculateColumnWidthsIfPending();
      }
    });
  }
  /**
   * @protected
   * @override
   */
  _onDataProviderPageLoaded() {
    super._onDataProviderPageLoaded();
    this.__tryToRecalculateColumnWidthsIfPending();
  }
  /**
   * @protected
   * @override
   */
  _updateFrozenColumn() {
    super._updateFrozenColumn();
    this.__tryToRecalculateColumnWidthsIfPending();
  }
  /** @private */
  __getIntrinsicWidth(col) {
    if (!this.__intrinsicWidthCache.has(col)) {
      this.__calculateAndCacheIntrinsicWidths([col]);
    }
    return this.__intrinsicWidthCache.get(col);
  }
  /** @private */
  __getDistributedWidth(col, innerColumn) {
    if (col == null || col === this) {
      return 0;
    }
    const columnWidth = Math.max(
      this.__getIntrinsicWidth(col),
      this.__getDistributedWidth((col.assignedSlot || col).parentElement, col)
    );
    if (!innerColumn) {
      return columnWidth;
    }
    const columnGroup = col;
    const columnGroupWidth = columnWidth;
    const sumOfWidthOfAllChildColumns = columnGroup._visibleChildColumns.map((col2) => this.__getIntrinsicWidth(col2)).reduce((sum, curr) => sum + curr, 0);
    const extraNecessarySpaceForGridColumnGroup = Math.max(0, columnGroupWidth - sumOfWidthOfAllChildColumns);
    const proportionOfExtraSpace = this.__getIntrinsicWidth(innerColumn) / sumOfWidthOfAllChildColumns;
    const shareOfInnerColumnFromNecessaryExtraSpace = proportionOfExtraSpace * extraNecessarySpaceForGridColumnGroup;
    return this.__getIntrinsicWidth(innerColumn) + shareOfInnerColumnFromNecessaryExtraSpace;
  }
  /**
   * @param {!Array<!GridColumn>} cols the columns to auto size based on their content width
   * @private
   */
  _recalculateColumnWidths() {
    this.__virtualizer.flush();
    [...this.$.header.children, ...this.$.footer.children].forEach((row) => {
      if (row.__debounceUpdateHeaderFooterRowVisibility) {
        row.__debounceUpdateHeaderFooterRowVisibility.flush();
      }
    });
    this.__hasHadRenderedRowsForColumnWidthCalculation = this.__hasHadRenderedRowsForColumnWidthCalculation || this._getRenderedRows().length > 0;
    this.__intrinsicWidthCache = /* @__PURE__ */ new Map();
    const fvi = this._firstVisibleIndex;
    const lvi = this._lastVisibleIndex;
    this.__viewportRowsCache = this._getRenderedRows().filter((row) => row.index >= fvi && row.index <= lvi);
    const cols = this.__getAutoWidthColumns();
    this.__calculateAndCacheIntrinsicWidths(cols);
    cols.forEach((col) => {
      col.width = `${this.__getDistributedWidth(col)}px`;
    });
  }
  /**
   * Toggles the cell content for the given column to use or not use auto width.
   *
   * While content for all the column cells uses auto width (instead of the default 100%),
   * their offsetWidth can be used to calculate the collective intrinsic width of the column.
   *
   * @private
   */
  __setVisibleCellContentAutoWidth(col, autoWidth) {
    col._allCells.filter((cell) => {
      if (this.$.items.contains(cell)) {
        return this.__viewportRowsCache.includes(cell.parentElement);
      }
      return true;
    }).forEach((cell) => {
      cell.__measuringAutoWidth = autoWidth;
      if (cell.__measuringAutoWidth) {
        cell.__originalWidth = cell.style.width;
        cell.style.width = "auto";
        cell.style.position = "absolute";
      } else {
        cell.style.width = cell.__originalWidth;
        delete cell.__originalWidth;
        cell.style.position = "";
      }
    });
    if (autoWidth) {
      this.$.scroller.setAttribute("measuring-auto-width", "");
    } else {
      this.$.scroller.removeAttribute("measuring-auto-width");
    }
  }
  /**
   * Returns the maximum intrinsic width of the cell content in the given column.
   * Only cells which are marked for measuring auto width are considered.
   *
   * @private
   */
  __getAutoWidthCellsMaxWidth(col) {
    return col._allCells.reduce((width, cell) => {
      return cell.__measuringAutoWidth ? Math.max(width, cell.offsetWidth + 1) : width;
    }, 0);
  }
  /**
   * Calculates and caches the intrinsic width of each given column.
   *
   * @private
   */
  __calculateAndCacheIntrinsicWidths(cols) {
    cols.forEach((col) => this.__setVisibleCellContentAutoWidth(col, true));
    cols.forEach((col) => {
      const width = this.__getAutoWidthCellsMaxWidth(col);
      this.__intrinsicWidthCache.set(col, width);
    });
    cols.forEach((col) => this.__setVisibleCellContentAutoWidth(col, false));
  }
  /**
   * Updates the `width` of all columns which have `autoWidth` set to `true`.
   */
  recalculateColumnWidths() {
    if (!this.__isReadyForColumnWidthCalculation()) {
      this.__pendingRecalculateColumnWidths = true;
      return;
    }
    this._recalculateColumnWidths();
  }
  /**
   * This internal method should be called whenever a condition that may have prevented
   * previous column width calculation is resolved.
   * @private
   */
  __tryToRecalculateColumnWidthsIfPending() {
    if (!this.__pendingRecalculateColumnWidths) {
      return;
    }
    this.__pendingRecalculateColumnWidths = false;
    this.recalculateColumnWidths();
  }
  /** @private */
  __getAutoWidthColumns() {
    return this._getColumns().filter((col) => !col.hidden && col.autoWidth);
  }
  /**
   * Returns true if the grid is ready for column width calculation, false otherwise.
   * @private
   */
  __isReadyForColumnWidthCalculation() {
    if (!this._columnTree) {
      return false;
    }
    const undefinedCols = this.__getAutoWidthColumns().filter((col) => !customElements.get(col.localName));
    if (undefinedCols.length) {
      Promise.all(undefinedCols.map((col) => customElements.whenDefined(col.localName))).then(() => {
        this.__tryToRecalculateColumnWidthsIfPending();
      });
      return false;
    }
    const hasRowsWithUndefinedIndex = [...this.$.items.children].some((row) => row.index === void 0);
    const debouncingHiddenChanged = this._debouncerHiddenChanged && this._debouncerHiddenChanged.isActive();
    const debouncingUpdateFrozenColumn = this.__debounceUpdateFrozenColumn && this.__debounceUpdateFrozenColumn.isActive();
    const hasHeight = this.clientHeight > 0;
    return !this._dataProviderController.isLoading() && !hasRowsWithUndefinedIndex && !isElementHidden(this) && !debouncingHiddenChanged && !debouncingUpdateFrozenColumn && hasHeight;
  }
};
/**
 * @license
 * Copyright (c) 2016 - 2025 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const ColumnReorderingMixin = (superClass) => class ColumnReorderingMixin extends superClass {
  static get properties() {
    return {
      /**
       * Set to true to allow column reordering.
       * @attr {boolean} column-reordering-allowed
       * @type {boolean}
       */
      columnReorderingAllowed: {
        type: Boolean,
        value: false
      },
      /** @private */
      _orderBaseScope: {
        type: Number,
        value: 1e7
      }
    };
  }
  static get observers() {
    return ["_updateOrders(_columnTree)"];
  }
  /** @protected */
  ready() {
    super.ready();
    addListener(this, "track", this._onTrackEvent);
    this._reorderGhost = this.shadowRoot.querySelector('[part="reorder-ghost"]');
    this.addEventListener("touchstart", this._onTouchStart.bind(this));
    this.addEventListener("touchmove", this._onTouchMove.bind(this));
    this.addEventListener("touchend", this._onTouchEnd.bind(this));
    this.addEventListener("contextmenu", this._onContextMenu.bind(this));
  }
  /** @private */
  _onContextMenu(e2) {
    if (this.hasAttribute("reordering")) {
      e2.preventDefault();
      if (!isTouch) {
        this._onTrackEnd();
      }
    }
  }
  /** @private */
  _onTouchStart(e2) {
    this._startTouchReorderTimeout = setTimeout(() => {
      this._onTrackStart({
        detail: {
          x: e2.touches[0].clientX,
          y: e2.touches[0].clientY
        }
      });
    }, 100);
  }
  /** @private */
  _onTouchMove(e2) {
    if (this._draggedColumn) {
      e2.preventDefault();
    }
    clearTimeout(this._startTouchReorderTimeout);
  }
  /** @private */
  _onTouchEnd() {
    clearTimeout(this._startTouchReorderTimeout);
    this._onTrackEnd();
  }
  /** @private */
  _onTrackEvent(e2) {
    if (e2.detail.state === "start") {
      const path = e2.composedPath();
      const headerCell = path[path.indexOf(this.$.header) - 2];
      if (!headerCell || !headerCell._content) {
        return;
      }
      if (headerCell._content.contains(this.getRootNode().activeElement)) {
        return;
      }
      if (this.$.scroller.hasAttribute("column-resizing")) {
        return;
      }
      if (!this._touchDevice) {
        this._onTrackStart(e2);
      }
    } else if (e2.detail.state === "track") {
      this._onTrack(e2);
    } else if (e2.detail.state === "end") {
      this._onTrackEnd(e2);
    }
  }
  /** @private */
  _onTrackStart(e2) {
    if (!this.columnReorderingAllowed) {
      return;
    }
    const path = e2.composedPath && e2.composedPath();
    if (path && path.slice(0, Math.max(0, path.indexOf(this))).some((node) => node.draggable)) {
      return;
    }
    const headerCell = this._cellFromPoint(e2.detail.x, e2.detail.y);
    if (!headerCell || !headerCell.getAttribute("part").includes("header-cell")) {
      return;
    }
    this.toggleAttribute("reordering", true);
    this._draggedColumn = headerCell._column;
    while (this._draggedColumn.parentElement.childElementCount === 1) {
      this._draggedColumn = this._draggedColumn.parentElement;
    }
    this._setSiblingsReorderStatus(this._draggedColumn, "allowed");
    this._draggedColumn._reorderStatus = "dragging";
    this._updateGhost(headerCell);
    this._reorderGhost.style.visibility = "visible";
    this._updateGhostPosition(e2.detail.x, this._touchDevice ? e2.detail.y - 50 : e2.detail.y);
    this._autoScroller();
  }
  /** @private */
  _onTrack(e2) {
    if (!this._draggedColumn) {
      return;
    }
    const targetCell = this._cellFromPoint(e2.detail.x, e2.detail.y);
    if (!targetCell) {
      return;
    }
    const targetColumn = this._getTargetColumn(targetCell, this._draggedColumn);
    if (this._isSwapAllowed(this._draggedColumn, targetColumn) && this._isSwappableByPosition(targetColumn, e2.detail.x)) {
      const columnTreeLevel = this._columnTree.findIndex((level) => level.includes(targetColumn));
      const levelColumnsInOrder = this._getColumnsInOrder(columnTreeLevel);
      const startIndex = levelColumnsInOrder.indexOf(this._draggedColumn);
      const endIndex = levelColumnsInOrder.indexOf(targetColumn);
      const direction = startIndex < endIndex ? 1 : -1;
      for (let i2 = startIndex; i2 !== endIndex; i2 += direction) {
        this._swapColumnOrders(this._draggedColumn, levelColumnsInOrder[i2 + direction]);
      }
    }
    this._updateGhostPosition(e2.detail.x, this._touchDevice ? e2.detail.y - 50 : e2.detail.y);
    this._lastDragClientX = e2.detail.x;
  }
  /** @private */
  _onTrackEnd() {
    if (!this._draggedColumn) {
      return;
    }
    this.toggleAttribute("reordering", false);
    this._draggedColumn._reorderStatus = "";
    this._setSiblingsReorderStatus(this._draggedColumn, "");
    this._draggedColumn = null;
    this._lastDragClientX = null;
    this._reorderGhost.style.visibility = "hidden";
    this.dispatchEvent(
      new CustomEvent("column-reorder", {
        detail: {
          columns: this._getColumnsInOrder()
        }
      })
    );
  }
  /**
   * Returns the columns (or column groups) on the specified header level in visual order.
   * By default, the bottom level is used.
   *
   * @return {!Array<!GridColumn>}
   * @protected
   */
  _getColumnsInOrder(headerLevel = this._columnTree.length - 1) {
    return this._columnTree[headerLevel].filter((c2) => !c2.hidden).sort((b2, a3) => b2._order - a3._order);
  }
  /**
   * @param {number} x
   * @param {number} y
   * @return {HTMLElement | undefined}
   * @protected
   */
  _cellFromPoint(x2 = 0, y3 = 0) {
    if (!this._draggedColumn) {
      this.$.scroller.toggleAttribute("no-content-pointer-events", true);
    }
    const elementFromPoint = this.shadowRoot.elementFromPoint(x2, y3);
    this.$.scroller.toggleAttribute("no-content-pointer-events", false);
    return this._getCellFromElement(elementFromPoint);
  }
  /** @private */
  _getCellFromElement(element) {
    if (element) {
      if (element._column) {
        return element;
      }
      const { parentElement } = element;
      if (parentElement && parentElement._focusButton === element) {
        return parentElement;
      }
    }
    return null;
  }
  /**
   * @param {number} eventClientX
   * @param {number} eventClientY
   * @protected
   */
  _updateGhostPosition(eventClientX, eventClientY) {
    const ghostRect = this._reorderGhost.getBoundingClientRect();
    const targetLeft = eventClientX - ghostRect.width / 2;
    const targetTop = eventClientY - ghostRect.height / 2;
    const _left = parseInt(this._reorderGhost._left || 0);
    const _top = parseInt(this._reorderGhost._top || 0);
    this._reorderGhost._left = _left - (ghostRect.left - targetLeft);
    this._reorderGhost._top = _top - (ghostRect.top - targetTop);
    this._reorderGhost.style.transform = `translate(${this._reorderGhost._left}px, ${this._reorderGhost._top}px)`;
  }
  /**
   * @param {!HTMLElement} cell
   * @return {!HTMLElement}
   * @protected
   */
  _updateGhost(cell) {
    const ghost = this._reorderGhost;
    ghost.textContent = cell._content.innerText;
    const style = window.getComputedStyle(cell);
    [
      "boxSizing",
      "display",
      "width",
      "height",
      "background",
      "alignItems",
      "padding",
      "border",
      "flex-direction",
      "overflow"
    ].forEach((propertyName) => {
      ghost.style[propertyName] = style[propertyName];
    });
    return ghost;
  }
  /** @private */
  _updateOrders(columnTree) {
    if (columnTree === void 0) {
      return;
    }
    columnTree[0].forEach((column) => {
      column._order = 0;
    });
    updateColumnOrders(columnTree[0], this._orderBaseScope, 0);
  }
  /**
   * @param {!GridColumn} column
   * @param {string} status
   * @protected
   */
  _setSiblingsReorderStatus(column, status) {
    iterateChildren(column.parentNode, (sibling) => {
      if (/column/u.test(sibling.localName) && this._isSwapAllowed(sibling, column)) {
        sibling._reorderStatus = status;
      }
    });
  }
  /** @protected */
  _autoScroller() {
    if (this._lastDragClientX) {
      const rightDiff = this._lastDragClientX - this.getBoundingClientRect().right + 50;
      const leftDiff = this.getBoundingClientRect().left - this._lastDragClientX + 50;
      if (rightDiff > 0) {
        this.$.table.scrollLeft += rightDiff / 10;
      } else if (leftDiff > 0) {
        this.$.table.scrollLeft -= leftDiff / 10;
      }
    }
    if (this._draggedColumn) {
      setTimeout(() => this._autoScroller(), 10);
    }
  }
  /**
   * @param {GridColumn | undefined} column1
   * @param {GridColumn | undefined} column2
   * @return {boolean | undefined}
   * @protected
   */
  _isSwapAllowed(column1, column2) {
    if (column1 && column2) {
      const differentColumns = column1 !== column2;
      const sameParent = column1.parentElement === column2.parentElement;
      const sameFrozen = column1.frozen && column2.frozen || // Both columns are frozen
      column1.frozenToEnd && column2.frozenToEnd || // Both columns are frozen to end
      !column1.frozen && !column1.frozenToEnd && !column2.frozen && !column2.frozenToEnd;
      return differentColumns && sameParent && sameFrozen;
    }
  }
  /**
   * @param {!GridColumn} targetColumn
   * @param {number} clientX
   * @return {boolean}
   * @protected
   */
  _isSwappableByPosition(targetColumn, clientX) {
    const targetCell = Array.from(this.$.header.querySelectorAll('tr:not([hidden]) [part~="cell"]')).find(
      (cell) => targetColumn.contains(cell._column)
    );
    const sourceCellRect = this.$.header.querySelector("tr:not([hidden]) [reorder-status=dragging]").getBoundingClientRect();
    const targetRect = targetCell.getBoundingClientRect();
    if (targetRect.left > sourceCellRect.left) {
      return clientX > targetRect.right - sourceCellRect.width;
    }
    return clientX < targetRect.left + sourceCellRect.width;
  }
  /**
   * @param {!GridColumn} column1
   * @param {!GridColumn} column2
   * @protected
   */
  _swapColumnOrders(column1, column2) {
    [column1._order, column2._order] = [column2._order, column1._order];
    this._debounceUpdateFrozenColumn();
    this._updateFirstAndLastColumn();
  }
  /**
   * @param {HTMLElement | undefined} targetCell
   * @param {GridColumn} draggedColumn
   * @return {GridColumn | undefined}
   * @protected
   */
  _getTargetColumn(targetCell, draggedColumn) {
    if (targetCell && draggedColumn) {
      let candidate = targetCell._column;
      while (candidate.parentElement !== draggedColumn.parentElement && candidate !== this) {
        candidate = candidate.parentElement;
      }
      if (candidate.parentElement === draggedColumn.parentElement) {
        return candidate;
      }
      return targetCell._column;
    }
  }
  /**
   * Fired when the columns in the grid are reordered.
   *
   * @event column-reorder
   * @param {Object} detail
   * @param {Object} detail.columns the columns in the new order
   */
};
/**
 * @license
 * Copyright (c) 2016 - 2025 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const ColumnResizingMixin = (superClass) => class ColumnResizingMixin extends superClass {
  /** @protected */
  ready() {
    super.ready();
    const scroller2 = this.$.scroller;
    addListener(scroller2, "track", this._onHeaderTrack.bind(this));
    scroller2.addEventListener("touchmove", (e2) => scroller2.hasAttribute("column-resizing") && e2.preventDefault());
    scroller2.addEventListener(
      "contextmenu",
      (e2) => e2.target.getAttribute("part") === "resize-handle" && e2.preventDefault()
    );
    scroller2.addEventListener(
      "mousedown",
      (e2) => e2.target.getAttribute("part") === "resize-handle" && e2.preventDefault()
    );
  }
  /** @private */
  _onHeaderTrack(e2) {
    const handle = e2.target;
    if (handle.getAttribute("part") === "resize-handle") {
      const cell = handle.parentElement;
      let column = cell._column;
      this.$.scroller.toggleAttribute("column-resizing", true);
      while (column.localName === "vaadin-grid-column-group") {
        column = column._childColumns.slice(0).sort((a3, b2) => a3._order - b2._order).filter((column2) => !column2.hidden).pop();
      }
      const isRTL = this.__isRTL;
      const eventX = e2.detail.x;
      const columnRowCells = Array.from(this.$.header.querySelectorAll('[part~="row"]:last-child [part~="cell"]'));
      const targetCell = columnRowCells.find((cell2) => cell2._column === column);
      if (targetCell.offsetWidth) {
        const style = getComputedStyle(targetCell._content);
        const minWidth = 10 + parseInt(style.paddingLeft) + parseInt(style.paddingRight) + parseInt(style.borderLeftWidth) + parseInt(style.borderRightWidth) + parseInt(style.marginLeft) + parseInt(style.marginRight);
        let maxWidth;
        const cellWidth = targetCell.offsetWidth;
        const cellRect = targetCell.getBoundingClientRect();
        if (targetCell.hasAttribute("frozen-to-end")) {
          maxWidth = cellWidth + (isRTL ? eventX - cellRect.right : cellRect.left - eventX);
        } else {
          maxWidth = cellWidth + (isRTL ? cellRect.left - eventX : eventX - cellRect.right);
        }
        column.width = `${Math.max(minWidth, maxWidth)}px`;
        column.flexGrow = 0;
      }
      columnRowCells.sort((a3, b2) => a3._column._order - b2._column._order).forEach((cell2, index, array) => {
        if (index < array.indexOf(targetCell)) {
          cell2._column.width = `${cell2.offsetWidth}px`;
          cell2._column.flexGrow = 0;
        }
      });
      const cellFrozenToEnd = this._frozenToEndCells[0];
      if (cellFrozenToEnd && this.$.table.scrollWidth > this.$.table.offsetWidth) {
        const frozenRect = cellFrozenToEnd.getBoundingClientRect();
        const offset = eventX - (isRTL ? frozenRect.right : frozenRect.left);
        if (isRTL && offset <= 0 || !isRTL && offset >= 0) {
          this.$.table.scrollLeft += offset;
        }
      }
      if (e2.detail.state === "end") {
        this.$.scroller.toggleAttribute("column-resizing", false);
        this.dispatchEvent(
          new CustomEvent("column-resize", {
            detail: { resizedColumn: column }
          })
        );
      }
      this._resizeHandler();
    }
  }
  /**
   * Fired when a column in the grid is resized by the user.
   *
   * @event column-resize
   * @param {Object} detail
   * @param {Object} detail.resizedColumn the column that was resized
   */
};
/**
 * @license
 * Copyright (c) 2016 - 2025 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const DataProviderMixin = (superClass) => class DataProviderMixin extends superClass {
  static get properties() {
    return {
      /**
       * The number of root-level items in the grid.
       * @attr {number} size
       * @type {number}
       */
      size: {
        type: Number,
        notify: true,
        sync: true
      },
      /**
       * @type {number}
       * @protected
       */
      _flatSize: {
        type: Number,
        sync: true
      },
      /**
       * Number of items fetched at a time from the dataprovider.
       * @attr {number} page-size
       * @type {number}
       */
      pageSize: {
        type: Number,
        value: 50,
        observer: "_pageSizeChanged",
        sync: true
      },
      /**
       * Function that provides items lazily. Receives arguments `params`, `callback`
       *
       * `params.page` Requested page index
       *
       * `params.pageSize` Current page size
       *
       * `params.filters` Currently applied filters
       *
       * `params.sortOrders` Currently applied sorting orders
       *
       * `params.parentItem` When tree is used, and sublevel items
       * are requested, reference to parent item of the requested sublevel.
       * Otherwise `undefined`.
       *
       * `callback(items, size)` Callback function with arguments:
       *   - `items` Current page of items
       *   - `size` Total number of items. When tree sublevel items
       *     are requested, total number of items in the requested sublevel.
       *     Optional when tree is not used, required for tree.
       *
       * @type {GridDataProvider | null | undefined}
       */
      dataProvider: {
        type: Object,
        notify: true,
        observer: "_dataProviderChanged",
        sync: true
      },
      /**
       * `true` while data is being requested from the data provider.
       */
      loading: {
        type: Boolean,
        notify: true,
        readOnly: true,
        reflectToAttribute: true
      },
      /**
       * @protected
       */
      _hasData: {
        type: Boolean,
        value: false,
        sync: true
      },
      /**
       * Path to an item sub-property that indicates whether the item has child items.
       * @attr {string} item-has-children-path
       */
      itemHasChildrenPath: {
        type: String,
        value: "children",
        observer: "__itemHasChildrenPathChanged",
        sync: true
      },
      /**
       * Path to an item sub-property that identifies the item.
       * @attr {string} item-id-path
       */
      itemIdPath: {
        type: String,
        value: null,
        sync: true
      },
      /**
       * An array that contains the expanded items.
       * @type {!Array<!GridItem>}
       */
      expandedItems: {
        type: Object,
        notify: true,
        value: () => [],
        sync: true
      },
      /**
       * @private
       */
      __expandedKeys: {
        type: Object,
        computed: "__computeExpandedKeys(itemIdPath, expandedItems)"
      }
    };
  }
  static get observers() {
    return ["_sizeChanged(size)", "_expandedItemsChanged(expandedItems)"];
  }
  constructor() {
    super();
    this._dataProviderController = new DataProviderController(this, {
      size: this.size || 0,
      pageSize: this.pageSize,
      getItemId: this.getItemId.bind(this),
      isExpanded: this._isExpanded.bind(this),
      dataProvider: this.dataProvider ? this.dataProvider.bind(this) : null,
      dataProviderParams: () => {
        return {
          sortOrders: this._mapSorters(),
          filters: this._mapFilters()
        };
      }
    });
    this._dataProviderController.addEventListener("page-requested", this._onDataProviderPageRequested.bind(this));
    this._dataProviderController.addEventListener("page-received", this._onDataProviderPageReceived.bind(this));
    this._dataProviderController.addEventListener("page-loaded", this._onDataProviderPageLoaded.bind(this));
  }
  /**
   * @protected
   * @deprecated since 24.3 and will be removed in Vaadin 25.
   */
  get _cache() {
    console.warn("<vaadin-grid> The `_cache` property is deprecated and will be removed in Vaadin 25.");
    return this._dataProviderController.rootCache;
  }
  /**
   * @protected
   * @deprecated since 24.3 and will be removed in Vaadin 25.
   */
  get _effectiveSize() {
    console.warn("<vaadin-grid> The `_effectiveSize` property is deprecated and will be removed in Vaadin 25.");
    return this._flatSize;
  }
  /** @private */
  _sizeChanged(size) {
    this._dataProviderController.rootCache.size = size;
    this._dataProviderController.recalculateFlatSize();
    this._flatSize = this._dataProviderController.flatSize;
  }
  /** @private */
  __itemHasChildrenPathChanged(value, oldValue) {
    if (!oldValue && value === "children") {
      return;
    }
    this.requestContentUpdate();
  }
  /**
   * @param {number} index
   * @param {HTMLElement} el
   * @protected
   */
  _getItem(index, el) {
    el.index = index;
    const { item: item2 } = this._dataProviderController.getFlatIndexContext(index);
    if (item2) {
      this.__updateLoading(el, false);
      this._updateItem(el, item2);
      if (this._isExpanded(item2)) {
        this._dataProviderController.ensureFlatIndexHierarchy(index);
      }
    } else {
      this.__updateLoading(el, true);
      this._dataProviderController.ensureFlatIndexLoaded(index);
    }
  }
  /**
   * @param {!HTMLElement} row
   * @param {boolean} loading
   * @private
   */
  __updateLoading(row, loading) {
    const cells = getBodyRowCells(row);
    updateState(row, "loading", loading);
    updateCellsPart(cells, "loading-row-cell", loading);
    if (loading) {
      this._generateCellClassNames(row);
      this._generateCellPartNames(row);
    }
  }
  /**
   * Returns a value that identifies the item. Uses `itemIdPath` if available.
   * Can be customized by overriding.
   * @param {!GridItem} item
   * @return {!GridItem | !unknown}
   */
  getItemId(item2) {
    return this.itemIdPath ? get$2(this.itemIdPath, item2) : item2;
  }
  /**
   * @param {!GridItem} item
   * @return {boolean}
   * @protected
   */
  _isExpanded(item2) {
    return this.__expandedKeys && this.__expandedKeys.has(this.getItemId(item2));
  }
  /** @private */
  _expandedItemsChanged() {
    this._dataProviderController.recalculateFlatSize();
    this._flatSize = this._dataProviderController.flatSize;
    this.__updateVisibleRows();
  }
  /** @private */
  __computeExpandedKeys(_itemIdPath, expandedItems) {
    const expanded = expandedItems || [];
    const expandedKeys = /* @__PURE__ */ new Set();
    expanded.forEach((item2) => {
      expandedKeys.add(this.getItemId(item2));
    });
    return expandedKeys;
  }
  /**
   * Expands the given item tree.
   * @param {!GridItem} item
   */
  expandItem(item2) {
    if (!this._isExpanded(item2)) {
      this.expandedItems = [...this.expandedItems, item2];
    }
  }
  /**
   * Collapses the given item tree.
   * @param {!GridItem} item
   */
  collapseItem(item2) {
    if (this._isExpanded(item2)) {
      this.expandedItems = this.expandedItems.filter((i2) => !this._itemsEqual(i2, item2));
    }
  }
  /**
   * @param {number} index
   * @return {number}
   * @protected
   */
  _getIndexLevel(index = 0) {
    const { level } = this._dataProviderController.getFlatIndexContext(index);
    return level;
  }
  /**
   * @param {number} page
   * @param {ItemCache} cache
   * @protected
   * @deprecated since 24.3 and will be removed in Vaadin 25.
   */
  _loadPage(page, cache) {
    console.warn("<vaadin-grid> The `_loadPage` method is deprecated and will be removed in Vaadin 25.");
    this._dataProviderController.__loadCachePage(cache, page);
  }
  /** @protected */
  _onDataProviderPageRequested() {
    this._setLoading(true);
  }
  /** @protected */
  _onDataProviderPageReceived() {
    if (this._flatSize !== this._dataProviderController.flatSize) {
      this._shouldUpdateAllRenderedRowsAfterPageLoad = true;
      this._flatSize = this._dataProviderController.flatSize;
    }
    this._getRenderedRows().forEach((row) => {
      this._dataProviderController.ensureFlatIndexHierarchy(row.index);
    });
    this._hasData = true;
  }
  /** @protected */
  _onDataProviderPageLoaded() {
    this._debouncerApplyCachedData = Debouncer$1.debounce(this._debouncerApplyCachedData, timeOut$1.after(0), () => {
      this._setLoading(false);
      const shouldUpdateAllRenderedRowsAfterPageLoad = this._shouldUpdateAllRenderedRowsAfterPageLoad;
      this._shouldUpdateAllRenderedRowsAfterPageLoad = false;
      this._getRenderedRows().forEach((row) => {
        const { item: item2 } = this._dataProviderController.getFlatIndexContext(row.index);
        if (item2 || shouldUpdateAllRenderedRowsAfterPageLoad) {
          this._getItem(row.index, row);
        }
      });
      this.__scrollToPendingIndexes();
      this.__dispatchPendingBodyCellFocus();
    });
    if (!this._dataProviderController.isLoading()) {
      this._debouncerApplyCachedData.flush();
    }
  }
  /** @private */
  __debounceClearCache() {
    this.__clearCacheDebouncer = Debouncer$1.debounce(this.__clearCacheDebouncer, microTask$1, () => this.clearCache());
  }
  /**
   * Clears the cached pages and reloads data from dataprovider when needed.
   */
  clearCache() {
    this._dataProviderController.clearCache();
    this._dataProviderController.rootCache.size = this.size || 0;
    this._dataProviderController.recalculateFlatSize();
    this._hasData = false;
    this.__updateVisibleRows();
    if (!this.__virtualizer || !this.__virtualizer.size) {
      this._dataProviderController.loadFirstPage();
    }
  }
  /** @private */
  _pageSizeChanged(pageSize, oldPageSize) {
    this._dataProviderController.setPageSize(pageSize);
    if (oldPageSize !== void 0 && pageSize !== oldPageSize) {
      this.clearCache();
    }
  }
  /** @protected */
  _checkSize() {
    if (this.size === void 0 && this._flatSize === 0) {
      console.warn(
        "The <vaadin-grid> needs the total number of items in order to display rows, which you can specify either by setting the `size` property, or by providing it to the second argument of the `dataProvider` function `callback` call."
      );
    }
  }
  /** @private */
  _dataProviderChanged(dataProvider, oldDataProvider) {
    this._dataProviderController.setDataProvider(dataProvider ? dataProvider.bind(this) : null);
    if (oldDataProvider !== void 0) {
      this.clearCache();
    }
    this._ensureFirstPageLoaded();
    this._debouncerCheckSize = Debouncer$1.debounce(
      this._debouncerCheckSize,
      timeOut$1.after(2e3),
      this._checkSize.bind(this)
    );
  }
  /** @protected */
  _ensureFirstPageLoaded() {
    if (!this._hasData) {
      this._dataProviderController.loadFirstPage();
    }
  }
  /**
   * @param {!GridItem} item1
   * @param {!GridItem} item2
   * @return {boolean}
   * @protected
   */
  _itemsEqual(item1, item2) {
    return this.getItemId(item1) === this.getItemId(item2);
  }
  /**
   * @param {!GridItem} item
   * @param {!Array<!GridItem>} array
   * @return {number}
   * @protected
   */
  _getItemIndexInArray(item2, array) {
    let result = -1;
    array.forEach((i2, idx) => {
      if (this._itemsEqual(i2, item2)) {
        result = idx;
      }
    });
    return result;
  }
  /**
   * Scroll to a specific row index in the virtual list. Note that the row index is
   * not always the same for any particular item. For example, sorting or filtering
   * items can affect the row index related to an item.
   *
   * The `indexes` parameter can be either a single number or multiple numbers.
   * The grid will first try to scroll to the item at the first index on the top level.
   * In case the item at the first index is expanded, the grid will then try scroll to the
   * item at the second index within the children of the expanded first item, and so on.
   * Each given index points to a child of the item at the previous index.
   *
   * Using `Infinity` as an index will point to the last item on the level.
   *
   * @param indexes {...number} Row indexes to scroll to
   */
  scrollToIndex(...indexes) {
    if (!this.__virtualizer || !this.clientHeight || !this._columnTree) {
      this.__pendingScrollToIndexes = indexes;
      return;
    }
    let targetIndex;
    while (targetIndex !== (targetIndex = this._dataProviderController.getFlatIndexByPath(indexes))) {
      this._scrollToFlatIndex(targetIndex);
    }
    if (this._dataProviderController.isLoading()) {
      this.__pendingScrollToIndexes = indexes;
    }
  }
  /** @private */
  __scrollToPendingIndexes() {
    if (this.__pendingScrollToIndexes && this.$.items.children.length) {
      const indexes = this.__pendingScrollToIndexes;
      delete this.__pendingScrollToIndexes;
      this.scrollToIndex(...indexes);
    }
  }
  /**
   * Fired when the `expandedItems` property changes.
   *
   * @event expanded-items-changed
   */
  /**
   * Fired when the `loading` property changes.
   *
   * @event loading-changed
   */
};
/**
 * @license
 * Copyright (c) 2016 - 2025 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const DropMode = {
  BETWEEN: "between",
  ON_TOP_OR_BETWEEN: "on-top-or-between",
  ON_GRID: "on-grid"
};
const DropLocation = {
  ON_TOP: "on-top",
  ABOVE: "above",
  BELOW: "below",
  EMPTY: "empty"
};
const DragAndDropMixin = (superClass) => class DragAndDropMixin extends superClass {
  static get properties() {
    return {
      /**
       * Defines the locations within the Grid row where an element can be dropped.
       *
       * Possible values are:
       * - `between`: The drop event can happen between Grid rows.
       * - `on-top`: The drop event can happen on top of Grid rows.
       * - `on-top-or-between`: The drop event can happen either on top of or between Grid rows.
       * - `on-grid`: The drop event will not happen on any specific row, it will show the drop target outline around the whole grid.
       * @attr {between|on-top|on-top-or-between|on-grid} drop-mode
       * @type {GridDropMode | null | undefined}
       */
      dropMode: {
        type: String,
        sync: true
      },
      /**
       * Marks the grid's rows to be available for dragging.
       * @attr {boolean} rows-draggable
       */
      rowsDraggable: {
        type: Boolean,
        sync: true
      },
      /**
       * A function that filters dragging of specific grid rows. The return value should be false
       * if dragging of the row should be disabled.
       *
       * Receives one argument:
       * - `model` The object with the properties related with
       *   the rendered item, contains:
       *   - `model.index` The index of the item.
       *   - `model.item` The item.
       *   - `model.expanded` Sublevel toggle state.
       *   - `model.level` Level of the tree represented with a horizontal offset of the toggle button.
       *   - `model.selected` Selected state.
       *
       * @type {GridDragAndDropFilter | null | undefined}
       */
      dragFilter: {
        type: Function,
        sync: true
      },
      /**
       * A function that filters dropping on specific grid rows. The return value should be false
       * if dropping on the row should be disabled.
       *
       * Receives one argument:
       * - `model` The object with the properties related with
       *   the rendered item, contains:
       *   - `model.index` The index of the item.
       *   - `model.item` The item.
       *   - `model.expanded` Sublevel toggle state.
       *   - `model.level` Level of the tree represented with a horizontal offset of the toggle button.
       *   - `model.selected` Selected state.
       *
       * @type {GridDragAndDropFilter | null | undefined}
       */
      dropFilter: {
        type: Function,
        sync: true
      },
      /** @private */
      __dndAutoScrollThreshold: {
        value: 50
      },
      /** @private  */
      __draggedItems: {
        value: () => []
      }
    };
  }
  static get observers() {
    return ["_dragDropAccessChanged(rowsDraggable, dropMode, dragFilter, dropFilter, loading)"];
  }
  constructor() {
    super();
    this.__onDocumentDragStart = this.__onDocumentDragStart.bind(this);
  }
  /** @protected */
  ready() {
    super.ready();
    this.$.table.addEventListener("dragstart", this._onDragStart.bind(this));
    this.$.table.addEventListener("dragend", this._onDragEnd.bind(this));
    this.$.table.addEventListener("dragover", this._onDragOver.bind(this));
    this.$.table.addEventListener("dragleave", this._onDragLeave.bind(this));
    this.$.table.addEventListener("drop", this._onDrop.bind(this));
    this.$.table.addEventListener("dragenter", (e2) => {
      if (this.dropMode) {
        e2.preventDefault();
        e2.stopPropagation();
      }
    });
  }
  /** @protected */
  connectedCallback() {
    super.connectedCallback();
    document.addEventListener("dragstart", this.__onDocumentDragStart, { capture: true });
  }
  /** @protected */
  disconnectedCallback() {
    super.disconnectedCallback();
    document.removeEventListener("dragstart", this.__onDocumentDragStart, { capture: true });
  }
  /** @private */
  _onDragStart(e2) {
    if (this.rowsDraggable) {
      let row = e2.target;
      if (row.localName === "vaadin-grid-cell-content") {
        row = row.assignedSlot.parentNode.parentNode;
      }
      if (row.parentNode !== this.$.items) {
        return;
      }
      e2.stopPropagation();
      this.toggleAttribute("dragging-rows", true);
      if (this._safari) {
        const transform = row.style.transform;
        row.style.top = /translateY\((.*)\)/u.exec(transform)[1];
        row.style.transform = "none";
        requestAnimationFrame(() => {
          row.style.top = "";
          row.style.transform = transform;
        });
      }
      const rowRect = row.getBoundingClientRect();
      e2.dataTransfer.setDragImage(row, e2.clientX - rowRect.left, e2.clientY - rowRect.top);
      let rows = [row];
      if (this._isSelected(row._item)) {
        rows = this.__getViewportRows().filter((row2) => this._isSelected(row2._item)).filter((row2) => !this.dragFilter || this.dragFilter(this.__getRowModel(row2)));
      }
      this.__draggedItems = rows.map((row2) => row2._item);
      e2.dataTransfer.setData("text", this.__formatDefaultTransferData(rows));
      updateBooleanRowStates(row, { dragstart: rows.length > 1 ? `${rows.length}` : "" });
      this.style.setProperty("--_grid-drag-start-x", `${e2.clientX - rowRect.left + 20}px`);
      this.style.setProperty("--_grid-drag-start-y", `${e2.clientY - rowRect.top + 10}px`);
      requestAnimationFrame(() => {
        updateBooleanRowStates(row, { dragstart: false });
        this.style.setProperty("--_grid-drag-start-x", "");
        this.style.setProperty("--_grid-drag-start-y", "");
        this.requestContentUpdate();
      });
      const event = new CustomEvent("grid-dragstart", {
        detail: {
          draggedItems: [...this.__draggedItems],
          setDragData: (type, data) => e2.dataTransfer.setData(type, data),
          setDraggedItemsCount: (count) => row.setAttribute("dragstart", count)
        }
      });
      event.originalEvent = e2;
      this.dispatchEvent(event);
    }
  }
  /** @private */
  _onDragEnd(e2) {
    this.toggleAttribute("dragging-rows", false);
    e2.stopPropagation();
    const event = new CustomEvent("grid-dragend");
    event.originalEvent = e2;
    this.dispatchEvent(event);
    this.__draggedItems = [];
    this.requestContentUpdate();
  }
  /** @private */
  _onDragLeave(e2) {
    if (!this.dropMode) {
      return;
    }
    e2.stopPropagation();
    this._clearDragStyles();
  }
  /** @private */
  _onDragOver(e2) {
    if (this.dropMode) {
      this._dropLocation = void 0;
      this._dragOverItem = void 0;
      if (this.__dndAutoScroll(e2.clientY)) {
        this._clearDragStyles();
        return;
      }
      let row = e2.composedPath().find((node) => node.localName === "tr");
      if (!this._flatSize || this.dropMode === DropMode.ON_GRID) {
        this._dropLocation = DropLocation.EMPTY;
      } else if (!row || row.parentNode !== this.$.items) {
        if (row) {
          return;
        } else if (this.dropMode === DropMode.BETWEEN || this.dropMode === DropMode.ON_TOP_OR_BETWEEN) {
          row = Array.from(this.$.items.children).filter((row2) => !row2.hidden).pop();
          this._dropLocation = DropLocation.BELOW;
        } else {
          return;
        }
      } else {
        const rowRect = row.getBoundingClientRect();
        this._dropLocation = DropLocation.ON_TOP;
        if (this.dropMode === DropMode.BETWEEN) {
          const dropAbove = e2.clientY - rowRect.top < rowRect.bottom - e2.clientY;
          this._dropLocation = dropAbove ? DropLocation.ABOVE : DropLocation.BELOW;
        } else if (this.dropMode === DropMode.ON_TOP_OR_BETWEEN) {
          if (e2.clientY - rowRect.top < rowRect.height / 3) {
            this._dropLocation = DropLocation.ABOVE;
          } else if (e2.clientY - rowRect.top > rowRect.height / 3 * 2) {
            this._dropLocation = DropLocation.BELOW;
          }
        }
      }
      if (row && row.hasAttribute("drop-disabled")) {
        this._dropLocation = void 0;
        return;
      }
      e2.stopPropagation();
      e2.preventDefault();
      if (this._dropLocation === DropLocation.EMPTY) {
        this.toggleAttribute("dragover", true);
      } else if (row) {
        this._dragOverItem = row._item;
        if (row.getAttribute("dragover") !== this._dropLocation) {
          updateStringRowStates(row, { dragover: this._dropLocation });
        }
      } else {
        this._clearDragStyles();
      }
    }
  }
  /**
   * Webkit-based browsers have issues with generating drag images
   * for elements that have children with massive heights. Chromium
   * browsers crash, while Safari experiences significant performance
   * issues. To mitigate these issues, we hide the scroller element
   * when drag starts to remove it from the drag image.
   *
   * Grids with fewer rows also have issues on Chromium and Safari
   * where the drag image is not properly clipped and may include
   * content outside the grid. Temporary inline styles are applied
   * to mitigate this issue.
   *
   * Related issues:
   * - https://github.com/vaadin/web-components/issues/7985
   * - https://issues.chromium.org/issues/383356871
   * - https://github.com/vaadin/web-components/issues/8386
   *
   * @private
   */
  __onDocumentDragStart(e2) {
    if (e2.target.contains(this)) {
      const elements = [e2.target, this.$.items, this.$.scroller];
      const originalInlineStyles = elements.map((element) => element.style.cssText);
      if (this.$.table.scrollHeight > 2e4) {
        this.$.scroller.style.display = "none";
      }
      if (isChrome) {
        e2.target.style.willChange = "transform";
      }
      if (isSafari) {
        this.$.items.style.flexShrink = 1;
      }
      requestAnimationFrame(() => {
        elements.forEach((element, index) => {
          element.style.cssText = originalInlineStyles[index];
        });
      });
    }
  }
  /** @private */
  __dndAutoScroll(clientY) {
    if (this.__dndAutoScrolling) {
      return true;
    }
    const headerBottom = this.$.header.getBoundingClientRect().bottom;
    const footerTop = this.$.footer.getBoundingClientRect().top;
    const topDiff = headerBottom - clientY + this.__dndAutoScrollThreshold;
    const bottomDiff = clientY - footerTop + this.__dndAutoScrollThreshold;
    let scrollTopDelta = 0;
    if (bottomDiff > 0) {
      scrollTopDelta = bottomDiff * 2;
    } else if (topDiff > 0) {
      scrollTopDelta = -topDiff * 2;
    }
    if (scrollTopDelta) {
      const scrollTop = this.$.table.scrollTop;
      this.$.table.scrollTop += scrollTopDelta;
      const scrollTopChanged = scrollTop !== this.$.table.scrollTop;
      if (scrollTopChanged) {
        this.__dndAutoScrolling = true;
        setTimeout(() => {
          this.__dndAutoScrolling = false;
        }, 20);
        return true;
      }
    }
  }
  /** @private */
  __getViewportRows() {
    const headerBottom = this.$.header.getBoundingClientRect().bottom;
    const footerTop = this.$.footer.getBoundingClientRect().top;
    return Array.from(this.$.items.children).filter((row) => {
      const rowRect = row.getBoundingClientRect();
      return rowRect.bottom > headerBottom && rowRect.top < footerTop;
    });
  }
  /** @protected */
  _clearDragStyles() {
    this.removeAttribute("dragover");
    iterateChildren(this.$.items, (row) => {
      updateStringRowStates(row, { dragover: null });
    });
  }
  /** @private */
  __updateDragSourceParts(row, model) {
    updateBooleanRowStates(row, { "drag-source": this.__draggedItems.includes(model.item) });
  }
  /** @private */
  _onDrop(e2) {
    if (this.dropMode) {
      e2.stopPropagation();
      e2.preventDefault();
      const dragData = e2.dataTransfer.types && Array.from(e2.dataTransfer.types).map((type) => {
        return {
          type,
          data: e2.dataTransfer.getData(type)
        };
      });
      this._clearDragStyles();
      const event = new CustomEvent("grid-drop", {
        bubbles: e2.bubbles,
        cancelable: e2.cancelable,
        detail: {
          dropTargetItem: this._dragOverItem,
          dropLocation: this._dropLocation,
          dragData
        }
      });
      event.originalEvent = e2;
      this.dispatchEvent(event);
    }
  }
  /** @private */
  __formatDefaultTransferData(rows) {
    return rows.map((row) => {
      return Array.from(row.children).filter((cell) => !cell.hidden && cell.getAttribute("part").indexOf("details-cell") === -1).sort((a3, b2) => {
        return a3._column._order > b2._column._order ? 1 : -1;
      }).map((cell) => cell._content.textContent.trim()).filter((content) => content).join("	");
    }).join("\n");
  }
  /** @private */
  _dragDropAccessChanged() {
    this.filterDragAndDrop();
  }
  /**
   * Runs the `dragFilter` and `dropFilter` hooks for the visible cells.
   * If the filter depends on varying conditions, you may need to
   * call this function manually in order to update the draggability when
   * the conditions change.
   */
  filterDragAndDrop() {
    iterateChildren(this.$.items, (row) => {
      if (!row.hidden) {
        this._filterDragAndDrop(row, this.__getRowModel(row));
      }
    });
  }
  /**
   * @param {!HTMLElement} row
   * @param {!GridItemModel} model
   * @protected
   */
  _filterDragAndDrop(row, model) {
    const loading = this.loading || row.hasAttribute("loading");
    const dragDisabled = !this.rowsDraggable || loading || this.dragFilter && !this.dragFilter(model);
    const dropDisabled = !this.dropMode || loading || this.dropFilter && !this.dropFilter(model);
    iterateRowCells(row, (cell) => {
      if (dragDisabled) {
        cell._content.removeAttribute("draggable");
      } else {
        cell._content.setAttribute("draggable", true);
      }
    });
    updateBooleanRowStates(row, {
      "drag-disabled": !!dragDisabled,
      "drop-disabled": !!dropDisabled
    });
  }
  /**
   * Fired when starting to drag grid rows.
   *
   * @event grid-dragstart
   * @param {Object} originalEvent The native dragstart event
   * @param {Object} detail
   * @param {Object} detail.draggedItems the items in the visible viewport that are dragged
   * @param {Function} detail.setDraggedItemsCount Overrides the default number shown in the drag image on multi row drag.
   * Parameter is of type number.
   * @param {Function} detail.setDragData Sets dataTransfer data for the drag operation.
   * Note that "text" is the only data type supported by all the browsers the grid currently supports (including IE11).
   * The function takes two parameters:
   * - type:string The type of the data
   * - data:string The data
   */
  /**
   * Fired when the dragging of the rows ends.
   *
   * @event grid-dragend
   * @param {Object} originalEvent The native dragend event
   */
  /**
   * Fired when a drop occurs on top of the grid.
   *
   * @event grid-drop
   * @param {Object} originalEvent The native drop event
   * @param {Object} detail
   * @param {Object} detail.dropTargetItem The item of the grid row on which the drop occurred.
   * @param {string} detail.dropLocation The position at which the drop event took place relative to a row.
   * Depending on the dropMode value, the drop location can be one of the following
   * - `on-top`: when the drop occurred on top of the row
   * - `above`: when the drop occurred above the row
   * - `below`: when the drop occurred below the row
   * - `empty`: when the drop occurred over the grid, not relative to any specific row
   * @param {string} detail.dragData An array of items with the payload as a string representation as the
   * `data` property and the type of the data as `type` property.
   */
};
/**
 * @license
 * Copyright (c) 2016 - 2025 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
function arrayEquals(arr1, arr2) {
  if (!arr1 || !arr2 || arr1.length !== arr2.length) {
    return false;
  }
  for (let i2 = 0, l = arr1.length; i2 < l; i2++) {
    if (arr1[i2] instanceof Array && arr2[i2] instanceof Array) {
      if (!arrayEquals(arr1[i2], arr2[i2])) {
        return false;
      }
    } else if (arr1[i2] !== arr2[i2]) {
      return false;
    }
  }
  return true;
}
const DynamicColumnsMixin = (superClass) => class DynamicColumnsMixin extends superClass {
  static get properties() {
    return {
      /**
       * @protected
       */
      _columnTree: {
        type: Object,
        sync: true
      }
    };
  }
  /** @protected */
  ready() {
    super.ready();
    this._addNodeObserver();
  }
  /** @private */
  _hasColumnGroups(columns) {
    return columns.some((column) => column.localName === "vaadin-grid-column-group");
  }
  /**
   * @param {!GridColumnGroup} el
   * @return {!Array<!GridColumn>}
   * @protected
   */
  _getChildColumns(el) {
    return ColumnObserver.getColumns(el);
  }
  /** @private */
  _flattenColumnGroups(columns) {
    return columns.map((col) => {
      if (col.localName === "vaadin-grid-column-group") {
        return this._getChildColumns(col);
      }
      return [col];
    }).reduce((prev, curr) => {
      return prev.concat(curr);
    }, []);
  }
  /** @private */
  _getColumnTree() {
    const rootColumns = ColumnObserver.getColumns(this);
    const columnTree = [rootColumns];
    let c2 = rootColumns;
    while (this._hasColumnGroups(c2)) {
      c2 = this._flattenColumnGroups(c2);
      columnTree.push(c2);
    }
    return columnTree;
  }
  /** @protected */
  _debounceUpdateColumnTree() {
    this.__updateColumnTreeDebouncer = Debouncer$1.debounce(
      this.__updateColumnTreeDebouncer,
      microTask$1,
      () => this._updateColumnTree()
    );
  }
  /** @protected */
  _updateColumnTree() {
    const columnTree = this._getColumnTree();
    if (!arrayEquals(columnTree, this._columnTree)) {
      this._columnTree = columnTree;
    }
  }
  /** @private */
  _addNodeObserver() {
    this._observer = new ColumnObserver(this, (_addedColumns, removedColumns) => {
      const allRemovedCells = removedColumns.flatMap((c2) => c2._allCells);
      const filterNotConnected = (element) => allRemovedCells.filter((cell) => cell && cell._content.contains(element)).length;
      this.__removeSorters(this._sorters.filter(filterNotConnected));
      this.__removeFilters(this._filters.filter(filterNotConnected));
      this._debounceUpdateColumnTree();
      this._debouncerCheckImports = Debouncer$1.debounce(
        this._debouncerCheckImports,
        timeOut$1.after(2e3),
        this._checkImports.bind(this)
      );
      this._ensureFirstPageLoaded();
    });
  }
  /** @protected */
  _checkImports() {
    [
      "vaadin-grid-column-group",
      "vaadin-grid-filter",
      "vaadin-grid-filter-column",
      "vaadin-grid-tree-toggle",
      "vaadin-grid-selection-column",
      "vaadin-grid-sort-column",
      "vaadin-grid-sorter"
    ].forEach((elementName) => {
      const element = this.querySelector(elementName);
      if (element && !customElements.get(elementName)) {
        console.warn(`Make sure you have imported the required module for <${elementName}> element.`);
      }
    });
  }
  /** @protected */
  _updateFirstAndLastColumn() {
    Array.from(this.shadowRoot.querySelectorAll("tr")).forEach((row) => this._updateFirstAndLastColumnForRow(row));
  }
  /**
   * @param {!HTMLElement} row
   * @protected
   */
  _updateFirstAndLastColumnForRow(row) {
    Array.from(row.querySelectorAll('[part~="cell"]:not([part~="details-cell"])')).sort((a3, b2) => {
      return a3._column._order - b2._column._order;
    }).forEach((cell, cellIndex, children) => {
      updateCellState(cell, "first-column", cellIndex === 0);
      updateCellState(cell, "last-column", cellIndex === children.length - 1);
    });
  }
  /**
   * @param {!Node} node
   * @return {boolean}
   * @protected
   */
  _isColumnElement(node) {
    return node.nodeType === Node.ELEMENT_NODE && /\bcolumn\b/u.test(node.localName);
  }
};
/**
 * @license
 * Copyright (c) 2016 - 2025 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const EventContextMixin = (superClass) => class EventContextMixin extends superClass {
  /**
   * Returns an object with context information about the event target:
   * - `item`: the data object corresponding to the targeted row (not specified when targeting header or footer)
   * - `column`: the column element corresponding to the targeted cell (not specified when targeting row details)
   * - `section`: whether the event targeted the body, header, footer or details of the grid
   *
   * These additional properties are included when `item` is specified:
   * - `index`: the index of the item
   * - `selected`: the selected state of the item
   * - `detailsOpened`: whether the row details are open for the item
   * - `expanded`: the expanded state of the tree toggle
   * - `level`: the tree hierarchy level
   *
   * The returned object is populated only when a grid cell, header, footer or row details is found in `event.composedPath()`.
   * This means mostly mouse and keyboard events. If such a grid part is not found in the path, an empty object is returned.
   * This may be the case eg. if the event is fired on the `<vaadin-grid>` element and not any deeper in the DOM, or if
   * the event targets the empty part of the grid body.
   *
   * @param {!Event} event
   * @return {GridEventContext}
   */
  getEventContext(event) {
    const context = {};
    const { cell } = this._getGridEventLocation(event);
    if (!cell) {
      return context;
    }
    context.section = ["body", "header", "footer", "details"].find(
      (section) => cell.getAttribute("part").indexOf(section) > -1
    );
    if (cell._column) {
      context.column = cell._column;
    }
    if (context.section === "body" || context.section === "details") {
      Object.assign(context, this.__getRowModel(cell.parentElement));
    }
    return context;
  }
};
/**
 * @license
 * Copyright (c) 2016 - 2025 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const FilterMixin = (superClass) => class FilterMixin extends superClass {
  static get properties() {
    return {
      /** @private */
      _filters: {
        type: Array,
        value: () => []
      }
    };
  }
  constructor() {
    super();
    this._filterChanged = this._filterChanged.bind(this);
    this.addEventListener("filter-changed", this._filterChanged);
  }
  /** @private */
  _filterChanged(e2) {
    e2.stopPropagation();
    this.__addFilter(e2.target);
    this.__applyFilters();
  }
  /** @private */
  __removeFilters(filtersToRemove) {
    if (filtersToRemove.length === 0) {
      return;
    }
    this._filters = this._filters.filter((filter2) => filtersToRemove.indexOf(filter2) < 0);
    this.__applyFilters();
  }
  /** @private */
  __addFilter(filter2) {
    const filterIndex = this._filters.indexOf(filter2);
    if (filterIndex === -1) {
      this._filters.push(filter2);
    }
  }
  /** @private */
  __applyFilters() {
    if (this.dataProvider && this.isAttached) {
      this.clearCache();
    }
  }
  /**
   * @return {!Array<!GridFilterDefinition>}
   * @protected
   */
  _mapFilters() {
    return this._filters.map((filter2) => {
      return {
        path: filter2.path,
        value: filter2.value
      };
    });
  }
};
/**
 * @license
 * Copyright (c) 2016 - 2025 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
function isRow(element) {
  return element instanceof HTMLTableRowElement;
}
function isCell(element) {
  return element instanceof HTMLTableCellElement;
}
function isDetailsCell(element) {
  return element.matches('[part~="details-cell"]');
}
const KeyboardNavigationMixin = (superClass) => class KeyboardNavigationMixin extends superClass {
  static get properties() {
    return {
      /** @private */
      _headerFocusable: {
        type: Object,
        observer: "_focusableChanged",
        sync: true
      },
      /**
       * @type {!HTMLElement | undefined}
       * @protected
       */
      _itemsFocusable: {
        type: Object,
        observer: "_focusableChanged",
        sync: true
      },
      /** @private */
      _footerFocusable: {
        type: Object,
        observer: "_focusableChanged",
        sync: true
      },
      /** @private */
      _navigatingIsHidden: Boolean,
      /**
       * @type {number}
       * @protected
       */
      _focusedItemIndex: {
        type: Number,
        value: 0
      },
      /** @private */
      _focusedColumnOrder: Number,
      /** @private */
      _focusedCell: {
        type: Object,
        observer: "_focusedCellChanged",
        sync: true
      },
      /**
       * Indicates whether the grid is currently in interaction mode.
       * In interaction mode the user is currently interacting with a control,
       * such as an input or a select, within a cell.
       * In interaction mode keyboard navigation between cells is disabled.
       * Interaction mode also prevents the focus target cell of that section of
       * the grid from receiving focus, allowing the user to switch focus to
       * controls in adjacent cells, rather than focussing the outer cell
       * itself.
       * @type {boolean}
       * @private
       */
      interacting: {
        type: Boolean,
        value: false,
        reflectToAttribute: true,
        readOnly: true,
        observer: "_interactingChanged"
      }
    };
  }
  /** @private */
  get __rowFocusMode() {
    return [this._headerFocusable, this._itemsFocusable, this._footerFocusable].some(isRow);
  }
  set __rowFocusMode(value) {
    ["_itemsFocusable", "_footerFocusable", "_headerFocusable"].forEach((prop) => {
      const focusable = this[prop];
      if (value) {
        const parent = focusable && focusable.parentElement;
        if (isCell(focusable)) {
          this[prop] = parent;
        } else if (isCell(parent)) {
          this[prop] = parent.parentElement;
        }
      } else if (!value && isRow(focusable)) {
        const cell = focusable.firstElementChild;
        this[prop] = cell._focusButton || cell;
      }
    });
  }
  /** @private */
  get _visibleItemsCount() {
    return this._lastVisibleIndex - this._firstVisibleIndex - 1;
  }
  /** @protected */
  ready() {
    super.ready();
    if (this._ios || this._android) {
      return;
    }
    this.addEventListener("keydown", this._onKeyDown);
    this.addEventListener("keyup", this._onKeyUp);
    this.addEventListener("focusin", this._onFocusIn);
    this.addEventListener("focusout", this._onFocusOut);
    this.$.table.addEventListener("focusin", this._onContentFocusIn.bind(this));
    this.addEventListener("mousedown", () => {
      this.toggleAttribute("navigating", false);
      this._isMousedown = true;
      this._focusedColumnOrder = void 0;
    });
    this.addEventListener("mouseup", () => {
      this._isMousedown = false;
    });
  }
  /** @private */
  _focusableChanged(focusable, oldFocusable) {
    if (oldFocusable) {
      oldFocusable.setAttribute("tabindex", "-1");
    }
    if (focusable) {
      this._updateGridSectionFocusTarget(focusable);
    }
  }
  /** @private */
  _focusedCellChanged(focusedCell, oldFocusedCell) {
    if (oldFocusedCell) {
      removeValueFromAttribute(oldFocusedCell, "part", "focused-cell");
    }
    if (focusedCell) {
      addValueToAttribute(focusedCell, "part", "focused-cell");
    }
  }
  /** @private */
  _interactingChanged() {
    this._updateGridSectionFocusTarget(this._headerFocusable);
    this._updateGridSectionFocusTarget(this._itemsFocusable);
    this._updateGridSectionFocusTarget(this._footerFocusable);
  }
  /**
   * Since the focused cell/row state is stored as an element reference, the reference may get
   * out of sync when the virtual indexes for elements update due to effective size change.
   * This function updates the reference to the correct element after a possible index change.
   * @private
   */
  __updateItemsFocusable() {
    if (!this._itemsFocusable) {
      return;
    }
    const wasFocused = this.shadowRoot.activeElement === this._itemsFocusable;
    this._getRenderedRows().forEach((row) => {
      if (row.index === this._focusedItemIndex) {
        if (this.__rowFocusMode) {
          this._itemsFocusable = row;
        } else {
          let parent = this._itemsFocusable.parentElement;
          let cell = this._itemsFocusable;
          if (parent) {
            if (isCell(parent)) {
              cell = parent;
              parent = parent.parentElement;
            }
            const cellIndex = [...parent.children].indexOf(cell);
            this._itemsFocusable = this.__getFocusable(row, row.children[cellIndex]);
          }
        }
      }
    });
    if (wasFocused) {
      this._itemsFocusable.focus();
    }
  }
  /**
   * @param {!KeyboardEvent} e
   * @protected
   */
  _onKeyDown(e2) {
    const key = e2.key;
    let keyGroup;
    switch (key) {
      case "ArrowUp":
      case "ArrowDown":
      case "ArrowLeft":
      case "ArrowRight":
      case "PageUp":
      case "PageDown":
      case "Home":
      case "End":
        keyGroup = "Navigation";
        break;
      case "Enter":
      case "Escape":
      case "F2":
        keyGroup = "Interaction";
        break;
      case "Tab":
        keyGroup = "Tab";
        break;
      case " ":
        keyGroup = "Space";
        break;
    }
    this._detectInteracting(e2);
    if (this.interacting && keyGroup !== "Interaction") {
      keyGroup = void 0;
    }
    if (keyGroup) {
      this[`_on${keyGroup}KeyDown`](e2, key);
    }
  }
  /** @private */
  __ensureFlatIndexInViewport(index) {
    const targetRowInDom = [...this.$.items.children].find((child) => child.index === index);
    if (!targetRowInDom) {
      this._scrollToFlatIndex(index);
    } else {
      this.__scrollIntoViewport(targetRowInDom);
    }
  }
  /** @private */
  __isRowExpandable(row) {
    if (this.itemHasChildrenPath) {
      const item2 = row._item;
      return !!(item2 && get$2(this.itemHasChildrenPath, item2) && !this._isExpanded(item2));
    }
  }
  /** @private */
  __isRowCollapsible(row) {
    return this._isExpanded(row._item);
  }
  /** @private */
  _onNavigationKeyDown(e2, key) {
    e2.preventDefault();
    const isRTL = this.__isRTL;
    const activeRow = e2.composedPath().find(isRow);
    const activeCell = e2.composedPath().find(isCell);
    let dx = 0, dy = 0;
    switch (key) {
      case "ArrowRight":
        dx = isRTL ? -1 : 1;
        break;
      case "ArrowLeft":
        dx = isRTL ? 1 : -1;
        break;
      case "Home":
        if (this.__rowFocusMode) {
          dy = -Infinity;
        } else if (e2.ctrlKey) {
          dy = -Infinity;
        } else {
          dx = -Infinity;
        }
        break;
      case "End":
        if (this.__rowFocusMode) {
          dy = Infinity;
        } else if (e2.ctrlKey) {
          dy = Infinity;
        } else {
          dx = Infinity;
        }
        break;
      case "ArrowDown":
        dy = 1;
        break;
      case "ArrowUp":
        dy = -1;
        break;
      case "PageDown":
        if (this.$.items.contains(activeRow)) {
          const currentRowIndex = this.__getIndexInGroup(activeRow, this._focusedItemIndex);
          this._scrollToFlatIndex(currentRowIndex);
        }
        dy = this._visibleItemsCount;
        break;
      case "PageUp":
        dy = -this._visibleItemsCount;
        break;
    }
    if (this.__rowFocusMode && !activeRow || !this.__rowFocusMode && !activeCell) {
      return;
    }
    const forwardsKey = isRTL ? "ArrowLeft" : "ArrowRight";
    const backwardsKey = isRTL ? "ArrowRight" : "ArrowLeft";
    if (key === forwardsKey) {
      if (this.__rowFocusMode) {
        if (this.__isRowExpandable(activeRow)) {
          this.expandItem(activeRow._item);
          return;
        }
        this.__rowFocusMode = false;
        this._onCellNavigation(activeRow.firstElementChild, 0, 0);
        return;
      }
    } else if (key === backwardsKey) {
      if (this.__rowFocusMode) {
        if (this.__isRowCollapsible(activeRow)) {
          this.collapseItem(activeRow._item);
          return;
        }
      } else {
        const activeRowCells = [...activeRow.children].sort((a3, b2) => a3._order - b2._order);
        if (activeCell === activeRowCells[0] || isDetailsCell(activeCell)) {
          this.__rowFocusMode = true;
          this._onRowNavigation(activeRow, 0);
          return;
        }
      }
    }
    if (this.__rowFocusMode) {
      this._onRowNavigation(activeRow, dy);
    } else {
      this._onCellNavigation(activeCell, dx, dy);
    }
  }
  /**
   * Focuses the target row after navigating by the given dy offset.
   * If the row is not in the viewport, it is first scrolled to.
   * @private
   */
  _onRowNavigation(activeRow, dy) {
    const { dstRow } = this.__navigateRows(dy, activeRow);
    if (dstRow) {
      dstRow.focus();
    }
  }
  /** @private */
  __getIndexInGroup(row, bodyFallbackIndex) {
    const rowGroup = row.parentNode;
    if (rowGroup === this.$.items) {
      return bodyFallbackIndex !== void 0 ? bodyFallbackIndex : row.index;
    }
    return [...rowGroup.children].indexOf(row);
  }
  /**
   * Returns the target row after navigating by the given dy offset.
   * Also returns information whether the details cell should be the target on the target row.
   * If the row is not in the viewport, it is first scrolled to.
   * @private
   */
  __navigateRows(dy, activeRow, activeCell) {
    const currentRowIndex = this.__getIndexInGroup(activeRow, this._focusedItemIndex);
    const activeRowGroup = activeRow.parentNode;
    const maxRowIndex = (activeRowGroup === this.$.items ? this._flatSize : activeRowGroup.children.length) - 1;
    let dstRowIndex = Math.max(0, Math.min(currentRowIndex + dy, maxRowIndex));
    if (activeRowGroup !== this.$.items) {
      if (dstRowIndex > currentRowIndex) {
        while (dstRowIndex < maxRowIndex && activeRowGroup.children[dstRowIndex].hidden) {
          dstRowIndex += 1;
        }
      } else if (dstRowIndex < currentRowIndex) {
        while (dstRowIndex > 0 && activeRowGroup.children[dstRowIndex].hidden) {
          dstRowIndex -= 1;
        }
      }
      this.toggleAttribute("navigating", true);
      return { dstRow: activeRowGroup.children[dstRowIndex] };
    }
    let dstIsRowDetails = false;
    if (activeCell) {
      const isRowDetails = isDetailsCell(activeCell);
      if (activeRowGroup === this.$.items) {
        const item2 = activeRow._item;
        const { item: dstItem } = this._dataProviderController.getFlatIndexContext(dstRowIndex);
        if (isRowDetails) {
          dstIsRowDetails = dy === 0;
        } else {
          dstIsRowDetails = dy === 1 && this._isDetailsOpened(item2) || dy === -1 && dstRowIndex !== currentRowIndex && this._isDetailsOpened(dstItem);
        }
        if (dstIsRowDetails !== isRowDetails && (dy === 1 && dstIsRowDetails || dy === -1 && !dstIsRowDetails)) {
          dstRowIndex = currentRowIndex;
        }
      }
    }
    this.__ensureFlatIndexInViewport(dstRowIndex);
    this._focusedItemIndex = dstRowIndex;
    this.toggleAttribute("navigating", true);
    return {
      dstRow: [...activeRowGroup.children].find((el) => !el.hidden && el.index === dstRowIndex),
      dstIsRowDetails
    };
  }
  /**
   * Focuses the target cell after navigating by the given dx and dy offset.
   * If the cell is not in the viewport, it is first scrolled to.
   * @private
   */
  _onCellNavigation(activeCell, dx, dy) {
    const activeRow = activeCell.parentNode;
    const { dstRow, dstIsRowDetails } = this.__navigateRows(dy, activeRow, activeCell);
    if (!dstRow) {
      return;
    }
    let columnIndex = [...activeRow.children].indexOf(activeCell);
    if (this.$.items.contains(activeCell)) {
      columnIndex = [...this.$.sizer.children].findIndex((sizerCell) => sizerCell._column === activeCell._column);
    }
    const isCurrentCellRowDetails = isDetailsCell(activeCell);
    const activeRowGroup = activeRow.parentNode;
    const currentRowIndex = this.__getIndexInGroup(activeRow, this._focusedItemIndex);
    if (this._focusedColumnOrder === void 0) {
      if (isCurrentCellRowDetails) {
        this._focusedColumnOrder = 0;
      } else {
        this._focusedColumnOrder = this._getColumns(activeRowGroup, currentRowIndex).filter((c2) => !c2.hidden)[columnIndex]._order;
      }
    }
    if (dstIsRowDetails) {
      const dstCell = [...dstRow.children].find(isDetailsCell);
      dstCell.focus();
    } else {
      const dstRowIndex = this.__getIndexInGroup(dstRow, this._focusedItemIndex);
      const dstColumns = this._getColumns(activeRowGroup, dstRowIndex).filter((c2) => !c2.hidden);
      const dstSortedColumnOrders = dstColumns.map((c2) => c2._order).sort((b2, a3) => b2 - a3);
      const maxOrderedColumnIndex = dstSortedColumnOrders.length - 1;
      const orderedColumnIndex = dstSortedColumnOrders.indexOf(
        dstSortedColumnOrders.slice(0).sort((b2, a3) => Math.abs(b2 - this._focusedColumnOrder) - Math.abs(a3 - this._focusedColumnOrder))[0]
      );
      const dstOrderedColumnIndex = dy === 0 && isCurrentCellRowDetails ? orderedColumnIndex : Math.max(0, Math.min(orderedColumnIndex + dx, maxOrderedColumnIndex));
      if (dstOrderedColumnIndex !== orderedColumnIndex) {
        this._focusedColumnOrder = void 0;
      }
      const columnIndexByOrder = dstColumns.reduce((acc, col, i2) => {
        acc[col._order] = i2;
        return acc;
      }, {});
      const dstColumnIndex = columnIndexByOrder[dstSortedColumnOrders[dstOrderedColumnIndex]];
      let dstCell;
      if (this.$.items.contains(activeCell)) {
        const dstSizerCell = this.$.sizer.children[dstColumnIndex];
        if (this._lazyColumns) {
          if (!this.__isColumnInViewport(dstSizerCell._column)) {
            dstSizerCell.scrollIntoView();
          }
          this.__updateColumnsBodyContentHidden();
          this.__updateHorizontalScrollPosition();
        }
        dstCell = [...dstRow.children].find((cell) => cell._column === dstSizerCell._column);
        this._scrollHorizontallyToCell(dstCell);
      } else {
        dstCell = dstRow.children[dstColumnIndex];
        this._scrollHorizontallyToCell(dstCell);
      }
      dstCell.focus();
    }
  }
  /** @private */
  _onInteractionKeyDown(e2, key) {
    const localTarget = e2.composedPath()[0];
    const localTargetIsTextInput = localTarget.localName === "input" && !/^(button|checkbox|color|file|image|radio|range|reset|submit)$/iu.test(localTarget.type);
    let wantInteracting;
    switch (key) {
      case "Enter":
        wantInteracting = this.interacting ? !localTargetIsTextInput : true;
        break;
      case "Escape":
        wantInteracting = false;
        break;
      case "F2":
        wantInteracting = !this.interacting;
        break;
    }
    const { cell } = this._getGridEventLocation(e2);
    if (this.interacting !== wantInteracting && cell !== null) {
      if (wantInteracting) {
        const focusTarget = cell._content.querySelector("[focus-target]") || // If a child element hasn't been explicitly marked as a focus target,
        // fall back to any focusable element inside the cell.
        [...cell._content.querySelectorAll("*")].find((node) => this._isFocusable(node));
        if (focusTarget) {
          e2.preventDefault();
          focusTarget.focus();
          this._setInteracting(true);
          this.toggleAttribute("navigating", false);
        }
      } else {
        e2.preventDefault();
        this._focusedColumnOrder = void 0;
        cell.focus();
        this._setInteracting(false);
        this.toggleAttribute("navigating", true);
      }
    }
    if (key === "Escape") {
      this._hideTooltip(true);
    }
  }
  /** @private */
  _predictFocusStepTarget(srcElement, step) {
    const tabOrder = [
      this.$.table,
      this._headerFocusable,
      this.__emptyState ? this.$.emptystatecell : this._itemsFocusable,
      this._footerFocusable,
      this.$.focusexit
    ];
    let index = tabOrder.indexOf(srcElement);
    index += step;
    while (index >= 0 && index <= tabOrder.length - 1) {
      let rowElement = tabOrder[index];
      if (rowElement && !this.__rowFocusMode) {
        rowElement = tabOrder[index].parentNode;
      }
      if (!rowElement || rowElement.hidden) {
        index += step;
      } else {
        break;
      }
    }
    let focusStepTarget = tabOrder[index];
    if (focusStepTarget && !this.__isHorizontallyInViewport(focusStepTarget)) {
      const firstVisibleColumn = this._getColumnsInOrder().find((column) => this.__isColumnInViewport(column));
      if (firstVisibleColumn) {
        if (focusStepTarget === this._headerFocusable) {
          focusStepTarget = firstVisibleColumn._headerCell;
        } else if (focusStepTarget === this._itemsFocusable) {
          const rowIndex = focusStepTarget._column._cells.indexOf(focusStepTarget);
          focusStepTarget = firstVisibleColumn._cells[rowIndex];
        } else if (focusStepTarget === this._footerFocusable) {
          focusStepTarget = firstVisibleColumn._footerCell;
        }
      }
    }
    return focusStepTarget;
  }
  /** @private */
  _onTabKeyDown(e2) {
    let focusTarget = this._predictFocusStepTarget(e2.composedPath()[0], e2.shiftKey ? -1 : 1);
    if (!focusTarget) {
      return;
    }
    e2.stopPropagation();
    if (focusTarget === this._itemsFocusable) {
      this.__ensureFlatIndexInViewport(this._focusedItemIndex);
      this.__updateItemsFocusable();
      focusTarget = this._itemsFocusable;
    }
    focusTarget.focus();
    if (focusTarget !== this.$.table && focusTarget !== this.$.focusexit) {
      e2.preventDefault();
    }
    this.toggleAttribute("navigating", true);
  }
  /** @private */
  _onSpaceKeyDown(e2) {
    e2.preventDefault();
    const element = e2.composedPath()[0];
    const isElementRow = isRow(element);
    if (isElementRow || !element._content || !element._content.firstElementChild) {
      this.dispatchEvent(
        new CustomEvent(isElementRow ? "row-activate" : "cell-activate", {
          detail: {
            model: this.__getRowModel(isElementRow ? element : element.parentElement)
          }
        })
      );
    }
  }
  /** @private */
  _onKeyUp(e2) {
    if (!/^( |SpaceBar)$/u.test(e2.key) || this.interacting) {
      return;
    }
    e2.preventDefault();
    const cell = e2.composedPath()[0];
    if (cell._content && cell._content.firstElementChild) {
      const wasNavigating = this.hasAttribute("navigating");
      cell._content.firstElementChild.dispatchEvent(
        new MouseEvent("click", {
          shiftKey: e2.shiftKey,
          bubbles: true,
          composed: true,
          cancelable: true
        })
      );
      this.toggleAttribute("navigating", wasNavigating);
    }
  }
  /**
   * @param {!FocusEvent} e
   * @protected
   */
  _onFocusIn(e2) {
    if (!this._isMousedown) {
      this.toggleAttribute("navigating", true);
    }
    const rootTarget = e2.composedPath()[0];
    if (rootTarget === this.$.table || rootTarget === this.$.focusexit) {
      if (!this._isMousedown) {
        this._predictFocusStepTarget(rootTarget, rootTarget === this.$.table ? 1 : -1).focus();
      }
      this._setInteracting(false);
    } else {
      this._detectInteracting(e2);
    }
  }
  /**
   * @param {!FocusEvent} e
   * @protected
   */
  _onFocusOut(e2) {
    this.toggleAttribute("navigating", false);
    this._detectInteracting(e2);
    this._hideTooltip();
    this._focusedCell = null;
  }
  /** @private */
  _onContentFocusIn(e2) {
    const { section, cell, row } = this._getGridEventLocation(e2);
    if (!cell && !this.__rowFocusMode) {
      return;
    }
    this._detectInteracting(e2);
    if (section && (cell || row)) {
      this._activeRowGroup = section;
      if (section === this.$.header) {
        this._headerFocusable = this.__getFocusable(row, cell);
      } else if (section === this.$.items) {
        this._itemsFocusable = this.__getFocusable(row, cell);
        this._focusedItemIndex = row.index;
      } else if (section === this.$.footer) {
        this._footerFocusable = this.__getFocusable(row, cell);
      }
      if (cell) {
        const context = this.getEventContext(e2);
        this.__pendingBodyCellFocus = this.loading && context.section === "body";
        if (!this.__pendingBodyCellFocus && cell !== this.$.emptystatecell) {
          cell.dispatchEvent(new CustomEvent("cell-focus", { bubbles: true, composed: true, detail: { context } }));
        }
        this._focusedCell = cell._focusButton || cell;
        if (isKeyboardActive() && e2.target === cell) {
          this._showTooltip(e2);
        }
      } else {
        this._focusedCell = null;
      }
    }
  }
  /**
   * @private
   */
  __dispatchPendingBodyCellFocus() {
    if (this.__pendingBodyCellFocus && this.shadowRoot.activeElement === this._itemsFocusable) {
      this._itemsFocusable.dispatchEvent(new Event("focusin", { bubbles: true, composed: true }));
    }
  }
  /**
   * Get the focusable element depending on the current focus mode.
   * It can be a row, a cell, or a focusable div inside a cell.
   *
   * @param {HTMLElement} row
   * @param {HTMLElement} cell
   * @return {HTMLElement}
   * @private
   */
  __getFocusable(row, cell) {
    return this.__rowFocusMode ? row : cell._focusButton || cell;
  }
  /**
   * Enables interaction mode if a cells descendant receives focus or keyboard
   * input. Disables it if the event is not related to cell content.
   * @param {!KeyboardEvent|!FocusEvent} e
   * @private
   */
  _detectInteracting(e2) {
    const isInteracting = e2.composedPath().some((el) => el.localName === "slot" && this.shadowRoot.contains(el));
    this._setInteracting(isInteracting);
    this.__updateHorizontalScrollPosition();
  }
  /**
   * Enables or disables the focus target of the containing section of the
   * grid from receiving focus, based on whether the user is interacting with
   * that section of the grid.
   * @param {HTMLElement} focusTarget
   * @private
   */
  _updateGridSectionFocusTarget(focusTarget) {
    if (!focusTarget) {
      return;
    }
    const section = this._getGridSectionFromFocusTarget(focusTarget);
    const isInteractingWithinActiveSection = this.interacting && section === this._activeRowGroup;
    focusTarget.tabIndex = isInteractingWithinActiveSection ? -1 : 0;
  }
  /** @protected */
  _preventScrollerRotatingCellFocus() {
    if (this._activeRowGroup !== this.$.items) {
      return;
    }
    this.__preventScrollerRotatingCellFocusDebouncer = Debouncer$1.debounce(
      this.__preventScrollerRotatingCellFocusDebouncer,
      animationFrame$1,
      () => {
        const isItemsRowGroupActive = this._activeRowGroup === this.$.items;
        const isFocusedItemRendered = this._getRenderedRows().some((row) => row.index === this._focusedItemIndex);
        if (isFocusedItemRendered) {
          this.__updateItemsFocusable();
          if (isItemsRowGroupActive && !this.__rowFocusMode) {
            this._focusedCell = this._itemsFocusable;
          }
          if (this._navigatingIsHidden) {
            this.toggleAttribute("navigating", true);
            this._navigatingIsHidden = false;
          }
        } else if (isItemsRowGroupActive) {
          this._focusedCell = null;
          if (this.hasAttribute("navigating")) {
            this._navigatingIsHidden = true;
            this.toggleAttribute("navigating", false);
          }
        }
      }
    );
  }
  /**
   * @param {HTMLTableSectionElement=} rowGroup
   * @param {number=} rowIndex
   * @return {!Array<!GridColumn>}
   * @protected
   */
  _getColumns(rowGroup, rowIndex) {
    let columnTreeLevel = this._columnTree.length - 1;
    if (rowGroup === this.$.header) {
      columnTreeLevel = rowIndex;
    } else if (rowGroup === this.$.footer) {
      columnTreeLevel = this._columnTree.length - 1 - rowIndex;
    }
    return this._columnTree[columnTreeLevel];
  }
  /** @private */
  __isValidFocusable(element) {
    return this.$.table.contains(element) && element.offsetHeight;
  }
  /** @protected */
  _resetKeyboardNavigation() {
    if (!this.$ && this.performUpdate) {
      this.performUpdate();
    }
    ["header", "footer"].forEach((section) => {
      if (!this.__isValidFocusable(this[`_${section}Focusable`])) {
        const firstVisibleRow = [...this.$[section].children].find((row) => row.offsetHeight);
        const firstVisibleCell = firstVisibleRow ? [...firstVisibleRow.children].find((cell) => !cell.hidden) : null;
        if (firstVisibleRow && firstVisibleCell) {
          this[`_${section}Focusable`] = this.__getFocusable(firstVisibleRow, firstVisibleCell);
        }
      }
    });
    if (!this.__isValidFocusable(this._itemsFocusable) && this.$.items.firstElementChild) {
      const firstVisibleRow = this.__getFirstVisibleItem();
      const firstVisibleCell = firstVisibleRow ? [...firstVisibleRow.children].find((cell) => !cell.hidden) : null;
      if (firstVisibleCell && firstVisibleRow) {
        this._focusedColumnOrder = void 0;
        this._itemsFocusable = this.__getFocusable(firstVisibleRow, firstVisibleCell);
      }
    } else {
      this.__updateItemsFocusable();
    }
  }
  /**
   * @param {!HTMLElement} dstCell
   * @protected
   */
  _scrollHorizontallyToCell(dstCell) {
    if (dstCell.hasAttribute("frozen") || dstCell.hasAttribute("frozen-to-end") || isDetailsCell(dstCell)) {
      return;
    }
    const dstCellRect = dstCell.getBoundingClientRect();
    const dstRow = dstCell.parentNode;
    const dstCellIndex = Array.from(dstRow.children).indexOf(dstCell);
    const tableRect = this.$.table.getBoundingClientRect();
    let leftBoundary = tableRect.left, rightBoundary = tableRect.right;
    for (let i2 = dstCellIndex - 1; i2 >= 0; i2--) {
      const cell = dstRow.children[i2];
      if (cell.hasAttribute("hidden") || isDetailsCell(cell)) {
        continue;
      }
      if (cell.hasAttribute("frozen") || cell.hasAttribute("frozen-to-end")) {
        leftBoundary = cell.getBoundingClientRect().right;
        break;
      }
    }
    for (let i2 = dstCellIndex + 1; i2 < dstRow.children.length; i2++) {
      const cell = dstRow.children[i2];
      if (cell.hasAttribute("hidden") || isDetailsCell(cell)) {
        continue;
      }
      if (cell.hasAttribute("frozen") || cell.hasAttribute("frozen-to-end")) {
        rightBoundary = cell.getBoundingClientRect().left;
        break;
      }
    }
    if (dstCellRect.left < leftBoundary) {
      this.$.table.scrollLeft += Math.round(dstCellRect.left - leftBoundary);
    }
    if (dstCellRect.right > rightBoundary) {
      this.$.table.scrollLeft += Math.round(dstCellRect.right - rightBoundary);
    }
  }
  /**
   * @typedef {Object} GridEventLocation
   * @property {HTMLTableSectionElement | null} section - The table section element that the event occurred in (header, body, or footer), or null if the event did not occur in a section
   * @property {HTMLTableRowElement | null} row - The row element that the event occurred in, or null if the event did not occur in a row
   * @property {HTMLTableCellElement | null} cell - The cell element that the event occurred in, or null if the event did not occur in a cell
   * @private
   */
  /**
   * Takes an event and returns a location object describing in which part of the grid the event occurred.
   * The event may either target table section, a row, a cell or contents of a cell.
   * @param {Event} e
   * @returns {GridEventLocation}
   * @protected
   */
  _getGridEventLocation(e2) {
    const path = e2.__composedPath || e2.composedPath();
    const tableIndex = path.indexOf(this.$.table);
    const section = tableIndex >= 1 ? path[tableIndex - 1] : null;
    const row = tableIndex >= 2 ? path[tableIndex - 2] : null;
    const cell = tableIndex >= 3 ? path[tableIndex - 3] : null;
    return {
      section,
      row,
      cell
    };
  }
  /**
   * Helper method that maps a focus target cell to the containing grid section
   * @param {HTMLElement} focusTarget
   * @returns {HTMLTableSectionElement | null}
   * @private
   */
  _getGridSectionFromFocusTarget(focusTarget) {
    if (focusTarget === this._headerFocusable) {
      return this.$.header;
    }
    if (focusTarget === this._itemsFocusable) {
      return this.$.items;
    }
    if (focusTarget === this._footerFocusable) {
      return this.$.footer;
    }
    return null;
  }
  /**
   * Fired when a cell is focused with click or keyboard navigation.
   *
   * Use context property of @see {@link GridCellFocusEvent} to get detail information about the event.
   *
   * @event cell-focus
   */
};
/**
 * @license
 * Copyright (c) 2016 - 2025 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const RowDetailsMixin = (superClass) => class RowDetailsMixin extends superClass {
  static get properties() {
    return {
      /**
       * An array containing references to items with open row details.
       * @type {!Array<!GridItem>}
       */
      detailsOpenedItems: {
        type: Array,
        value: () => [],
        sync: true
      },
      /**
       * Custom function for rendering the content of the row details.
       * Receives three arguments:
       *
       * - `root` The row details content DOM element. Append your content to it.
       * - `grid` The `<vaadin-grid>` element.
       * - `model` The object with the properties related with
       *   the rendered item, contains:
       *   - `model.index` The index of the item.
       *   - `model.item` The item.
       *   - `model.level` The number of the item's tree sublevel, starts from 0.
       *   - `model.expanded` True if the item's tree sublevel is expanded.
       *   - `model.selected` True if the item is selected.
       *
       * @type {GridRowDetailsRenderer | null | undefined}
       */
      rowDetailsRenderer: {
        type: Function,
        sync: true
      },
      /**
       * @type {!Array<!HTMLElement> | undefined}
       * @protected
       */
      _detailsCells: {
        type: Array
      }
    };
  }
  static get observers() {
    return [
      "_detailsOpenedItemsChanged(detailsOpenedItems, rowDetailsRenderer)",
      "_rowDetailsRendererChanged(rowDetailsRenderer)"
    ];
  }
  /** @protected */
  ready() {
    super.ready();
    this._detailsCellResizeObserver = new ResizeObserver((entries) => {
      entries.forEach(({ target: cell }) => {
        this._updateDetailsCellHeight(cell.parentElement);
      });
      this.__virtualizer.__adapter._resizeHandler();
    });
  }
  /** @private */
  _rowDetailsRendererChanged(rowDetailsRenderer) {
    if (!rowDetailsRenderer) {
      return;
    }
    if (this._columnTree) {
      iterateChildren(this.$.items, (row) => {
        if (!row.querySelector("[part~=details-cell]")) {
          this._updateRow(row, this._columnTree[this._columnTree.length - 1]);
          const isDetailsOpened = this._isDetailsOpened(row._item);
          this._toggleDetailsCell(row, isDetailsOpened);
        }
      });
    }
  }
  /** @private */
  _detailsOpenedItemsChanged(_detailsOpenedItems, rowDetailsRenderer) {
    iterateChildren(this.$.items, (row) => {
      if (row.hasAttribute("details-opened")) {
        this._updateItem(row, row._item);
        return;
      }
      if (rowDetailsRenderer && this._isDetailsOpened(row._item)) {
        this._updateItem(row, row._item);
      }
    });
  }
  /**
   * @param {!HTMLElement} cell
   * @protected
   */
  _configureDetailsCell(cell) {
    cell.setAttribute("part", "cell details-cell");
    cell.toggleAttribute("frozen", true);
    this._detailsCellResizeObserver.observe(cell);
  }
  /**
   * @param {!HTMLElement} row
   * @param {!GridItem} item
   * @protected
   */
  _toggleDetailsCell(row, detailsOpened) {
    const cell = row.querySelector('[part~="details-cell"]');
    if (!cell) {
      return;
    }
    cell.hidden = !detailsOpened;
    if (cell.hidden) {
      return;
    }
    if (this.rowDetailsRenderer) {
      cell._renderer = this.rowDetailsRenderer;
    }
  }
  /** @protected */
  _updateDetailsCellHeight(row) {
    const cell = row.querySelector('[part~="details-cell"]');
    if (!cell) {
      return;
    }
    this.__updateDetailsRowPadding(row, cell);
    requestAnimationFrame(() => this.__updateDetailsRowPadding(row, cell));
  }
  /** @private */
  __updateDetailsRowPadding(row, cell) {
    if (cell.hidden) {
      row.style.removeProperty("padding-bottom");
    } else {
      row.style.setProperty("padding-bottom", `${cell.offsetHeight}px`);
    }
  }
  /** @protected */
  _updateDetailsCellHeights() {
    iterateChildren(this.$.items, (row) => {
      this._updateDetailsCellHeight(row);
    });
  }
  /**
   * @param {!GridItem} item
   * @return {boolean}
   * @protected
   */
  _isDetailsOpened(item2) {
    return this.detailsOpenedItems && this._getItemIndexInArray(item2, this.detailsOpenedItems) !== -1;
  }
  /**
   * Open the details row of a given item.
   * @param {!GridItem} item
   */
  openItemDetails(item2) {
    if (!this._isDetailsOpened(item2)) {
      this.detailsOpenedItems = [...this.detailsOpenedItems, item2];
    }
  }
  /**
   * Close the details row of a given item.
   * @param {!GridItem} item
   */
  closeItemDetails(item2) {
    if (this._isDetailsOpened(item2)) {
      this.detailsOpenedItems = this.detailsOpenedItems.filter((i2) => !this._itemsEqual(i2, item2));
    }
  }
};
/**
 * @license
 * Copyright (c) 2016 - 2025 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const timeouts = {
  SCROLLING: 500,
  UPDATE_CONTENT_VISIBILITY: 100
};
const ScrollMixin = (superClass) => class ScrollMixin extends ResizeMixin(superClass) {
  static get properties() {
    return {
      /**
       * Allows you to choose between modes for rendering columns in the grid:
       *
       * "eager" (default): All columns are rendered upfront, regardless of their visibility within the viewport.
       * This mode should generally be preferred, as it avoids the limitations imposed by the "lazy" mode.
       * Use this mode unless the grid has a large number of columns and performance outweighs the limitations
       * in priority.
       *
       * "lazy": Optimizes the rendering of cells when there are multiple columns in the grid by virtualizing
       * horizontal scrolling. In this mode, body cells are rendered only when their corresponding columns are
       * inside the visible viewport.
       *
       * Using "lazy" rendering should be used only if you're dealing with a large number of columns and performance
       * is your highest priority. For most use cases, the default "eager" mode is recommended due to the
       * limitations imposed by the "lazy" mode.
       *
       * When using the "lazy" mode, keep the following limitations in mind:
       *
       * - Row Height: When only a number of columns are visible at once, the height of a row can only be that of
       * the highest cell currently visible on that row. Make sure each cell on a single row has the same height
       * as all other cells on that row. If row cells have different heights, users may experience jumpiness when
       * scrolling the grid horizontally as lazily rendered cells with different heights are scrolled into view.
       *
       * - Auto-width Columns: For the columns that are initially outside the visible viewport but still use auto-width,
       * only the header content is taken into account when calculating the column width because the body cells
       * of the columns outside the viewport are not initially rendered.
       *
       * - Screen Reader Compatibility: Screen readers may not be able to associate the focused cells with the correct
       * headers when only a subset of the body cells on a row is rendered.
       *
       * - Keyboard Navigation: Tabbing through focusable elements inside the grid body may not work as expected because
       * some of the columns that would include focusable elements in the body cells may be outside the visible viewport
       * and thus not rendered.
       *
       * @attr {eager|lazy} column-rendering
       * @type {!ColumnRendering}
       */
      columnRendering: {
        type: String,
        value: "eager",
        sync: true
      },
      /**
       * Cached array of frozen cells
       * @private
       */
      _frozenCells: {
        type: Array,
        value: () => []
      },
      /**
       * Cached array of cells frozen to end
       * @private
       */
      _frozenToEndCells: {
        type: Array,
        value: () => []
      }
    };
  }
  static get observers() {
    return ["__columnRenderingChanged(_columnTree, columnRendering)"];
  }
  /** @private */
  get _scrollLeft() {
    return this.$.table.scrollLeft;
  }
  /** @private */
  get _scrollTop() {
    return this.$.table.scrollTop;
  }
  /**
   * Override (from iron-scroll-target-behavior) to avoid document scroll
   * @private
   */
  set _scrollTop(top) {
    this.$.table.scrollTop = top;
  }
  /** @protected */
  get _lazyColumns() {
    return this.columnRendering === "lazy";
  }
  /** @protected */
  ready() {
    super.ready();
    this.scrollTarget = this.$.table;
    this.$.items.addEventListener("focusin", (e2) => {
      const composedPath = e2.composedPath();
      const row = composedPath[composedPath.indexOf(this.$.items) - 1];
      if (row) {
        if (!this._isMousedown) {
          const tableHeight = this.$.table.clientHeight;
          const headerHeight = this.$.header.clientHeight;
          const footerHeight = this.$.footer.clientHeight;
          const viewportHeight = tableHeight - headerHeight - footerHeight;
          const isRowLargerThanViewport = row.clientHeight > viewportHeight;
          const scrollTarget = isRowLargerThanViewport ? e2.target : row;
          this.__scrollIntoViewport(scrollTarget);
        }
        if (!this.$.table.contains(e2.relatedTarget)) {
          this.$.table.dispatchEvent(new CustomEvent("virtualizer-element-focused", { detail: { element: row } }));
        }
      }
    });
    this.$.table.addEventListener("scroll", () => this._afterScroll());
  }
  /**
   * @protected
   * @override
   */
  _onResize() {
    this._updateOverflow();
    this.__updateHorizontalScrollPosition();
    if (this._firefox) {
      const isVisible = !isElementHidden(this);
      if (isVisible && this.__previousVisible === false) {
        this._scrollTop = this.__memorizedScrollTop || 0;
      }
      this.__previousVisible = isVisible;
    }
  }
  /**
   * Scroll to a flat index in the grid. The method doesn't take into account
   * the hierarchy of the items.
   *
   * @param {number} index Row index to scroll to
   * @protected
   */
  _scrollToFlatIndex(index) {
    index = Math.min(this._flatSize - 1, Math.max(0, index));
    this.__virtualizer.scrollToIndex(index);
    const rowElement = [...this.$.items.children].find((child) => child.index === index);
    this.__scrollIntoViewport(rowElement);
  }
  /**
   * Makes sure the given element is fully inside the visible viewport,
   * taking header/footer into account.
   * @private
   */
  __scrollIntoViewport(element) {
    if (!element) {
      return;
    }
    const dstRect = element.getBoundingClientRect();
    const footerTop = this.$.footer.getBoundingClientRect().top;
    const headerBottom = this.$.header.getBoundingClientRect().bottom;
    if (dstRect.bottom > footerTop) {
      this.$.table.scrollTop += dstRect.bottom - footerTop;
    } else if (dstRect.top < headerBottom) {
      this.$.table.scrollTop -= headerBottom - dstRect.top;
    }
  }
  /** @private */
  _scheduleScrolling() {
    if (!this._scrollingFrame) {
      this._scrollingFrame = requestAnimationFrame(() => this.$.scroller.toggleAttribute("scrolling", true));
    }
    this._debounceScrolling = Debouncer$1.debounce(this._debounceScrolling, timeOut$1.after(timeouts.SCROLLING), () => {
      cancelAnimationFrame(this._scrollingFrame);
      delete this._scrollingFrame;
      this.$.scroller.toggleAttribute("scrolling", false);
    });
  }
  /** @private */
  _afterScroll() {
    this.__updateHorizontalScrollPosition();
    if (!this.hasAttribute("reordering")) {
      this._scheduleScrolling();
    }
    if (!this.hasAttribute("navigating")) {
      this._hideTooltip(true);
    }
    this._updateOverflow();
    this._debounceColumnContentVisibility = Debouncer$1.debounce(
      this._debounceColumnContentVisibility,
      timeOut$1.after(timeouts.UPDATE_CONTENT_VISIBILITY),
      () => {
        if (this._lazyColumns && this.__cachedScrollLeft !== this._scrollLeft) {
          this.__cachedScrollLeft = this._scrollLeft;
          this.__updateColumnsBodyContentHidden();
        }
      }
    );
    if (this._firefox) {
      const isVisible = !isElementHidden(this);
      if (isVisible && this.__previousVisible !== false) {
        this.__memorizedScrollTop = this._scrollTop;
      }
    }
  }
  /** @private */
  __updateColumnsBodyContentHidden() {
    if (!this._columnTree || !this._areSizerCellsAssigned()) {
      return;
    }
    const columnsInOrder = this._getColumnsInOrder();
    let bodyContentHiddenChanged = false;
    columnsInOrder.forEach((column) => {
      const bodyContentHidden = this._lazyColumns && !this.__isColumnInViewport(column);
      if (column._bodyContentHidden !== bodyContentHidden) {
        bodyContentHiddenChanged = true;
        column._cells.forEach((cell) => {
          if (cell !== column._sizerCell) {
            if (bodyContentHidden) {
              cell.remove();
            } else if (cell.__parentRow) {
              const followingColumnCell = [...cell.__parentRow.children].find(
                (child) => columnsInOrder.indexOf(child._column) > columnsInOrder.indexOf(column)
              );
              cell.__parentRow.insertBefore(cell, followingColumnCell);
            }
          }
        });
      }
      column._bodyContentHidden = bodyContentHidden;
    });
    if (bodyContentHiddenChanged) {
      this._frozenCellsChanged();
    }
    if (this._lazyColumns) {
      const lastFrozenColumn = [...columnsInOrder].reverse().find((column) => column.frozen);
      const lastFrozenColumnEnd = this.__getColumnEnd(lastFrozenColumn);
      const firstVisibleColumn = columnsInOrder.find((column) => !column.frozen && !column._bodyContentHidden);
      this.__lazyColumnsStart = this.__getColumnStart(firstVisibleColumn) - lastFrozenColumnEnd;
      this.$.items.style.setProperty("--_grid-lazy-columns-start", `${this.__lazyColumnsStart}px`);
      this._resetKeyboardNavigation();
    }
  }
  /** @private */
  __getColumnEnd(column) {
    if (!column) {
      return this.__isRTL ? this.$.table.clientWidth : 0;
    }
    return column._sizerCell.offsetLeft + (this.__isRTL ? 0 : column._sizerCell.offsetWidth);
  }
  /** @private */
  __getColumnStart(column) {
    if (!column) {
      return this.__isRTL ? this.$.table.clientWidth : 0;
    }
    return column._sizerCell.offsetLeft + (this.__isRTL ? column._sizerCell.offsetWidth : 0);
  }
  /**
   * Returns true if the given column is horizontally inside the viewport.
   * @private
   */
  __isColumnInViewport(column) {
    if (column.frozen || column.frozenToEnd) {
      return true;
    }
    return this.__isHorizontallyInViewport(column._sizerCell);
  }
  /** @private */
  __isHorizontallyInViewport(element) {
    return element.offsetLeft + element.offsetWidth >= this._scrollLeft && element.offsetLeft <= this._scrollLeft + this.clientWidth;
  }
  /** @private */
  __columnRenderingChanged(_columnTree, columnRendering) {
    if (columnRendering === "eager") {
      this.$.scroller.removeAttribute("column-rendering");
    } else {
      this.$.scroller.setAttribute("column-rendering", columnRendering);
    }
    this.__updateColumnsBodyContentHidden();
  }
  /** @private */
  _updateOverflow() {
    this._debounceOverflow = Debouncer$1.debounce(this._debounceOverflow, animationFrame$1, () => {
      this.__doUpdateOverflow();
    });
  }
  /** @private */
  __doUpdateOverflow() {
    let overflow = "";
    const table = this.$.table;
    if (table.scrollTop < table.scrollHeight - table.clientHeight) {
      overflow += " bottom";
    }
    if (table.scrollTop > 0) {
      overflow += " top";
    }
    const scrollLeft = getNormalizedScrollLeft(table, this.getAttribute("dir"));
    if (scrollLeft > 0) {
      overflow += " start";
    }
    if (scrollLeft < table.scrollWidth - table.clientWidth) {
      overflow += " end";
    }
    if (this.__isRTL) {
      overflow = overflow.replace(/start|end/giu, (matched) => {
        return matched === "start" ? "end" : "start";
      });
    }
    if (table.scrollLeft < table.scrollWidth - table.clientWidth) {
      overflow += " right";
    }
    if (table.scrollLeft > 0) {
      overflow += " left";
    }
    const value = overflow.trim();
    if (value.length > 0 && this.getAttribute("overflow") !== value) {
      this.setAttribute("overflow", value);
    } else if (value.length === 0 && this.hasAttribute("overflow")) {
      this.removeAttribute("overflow");
    }
  }
  /** @protected */
  _frozenCellsChanged() {
    this._debouncerCacheElements = Debouncer$1.debounce(this._debouncerCacheElements, microTask$1, () => {
      Array.from(this.shadowRoot.querySelectorAll('[part~="cell"]')).forEach((cell) => {
        cell.style.transform = "";
      });
      this._frozenCells = Array.prototype.slice.call(this.$.table.querySelectorAll("[frozen]"));
      this._frozenToEndCells = Array.prototype.slice.call(this.$.table.querySelectorAll("[frozen-to-end]"));
      this.__updateHorizontalScrollPosition();
    });
    this._debounceUpdateFrozenColumn();
  }
  /** @protected */
  _debounceUpdateFrozenColumn() {
    this.__debounceUpdateFrozenColumn = Debouncer$1.debounce(
      this.__debounceUpdateFrozenColumn,
      microTask$1,
      () => this._updateFrozenColumn()
    );
  }
  /** @private */
  _updateFrozenColumn() {
    if (!this._columnTree) {
      return;
    }
    const columnsRow = this._columnTree[this._columnTree.length - 1].slice(0);
    columnsRow.sort((a3, b2) => {
      return a3._order - b2._order;
    });
    let lastFrozen;
    let firstFrozenToEnd;
    for (let i2 = 0; i2 < columnsRow.length; i2++) {
      const col = columnsRow[i2];
      col._lastFrozen = false;
      col._firstFrozenToEnd = false;
      if (firstFrozenToEnd === void 0 && col.frozenToEnd && !col.hidden) {
        firstFrozenToEnd = i2;
      }
      if (col.frozen && !col.hidden) {
        lastFrozen = i2;
      }
    }
    if (lastFrozen !== void 0) {
      columnsRow[lastFrozen]._lastFrozen = true;
    }
    if (firstFrozenToEnd !== void 0) {
      columnsRow[firstFrozenToEnd]._firstFrozenToEnd = true;
    }
    this.__updateColumnsBodyContentHidden();
  }
  /** @private */
  __updateHorizontalScrollPosition() {
    if (!this._columnTree) {
      return;
    }
    const scrollWidth = this.$.table.scrollWidth;
    const clientWidth = this.$.table.clientWidth;
    const scrollLeft = Math.max(0, this.$.table.scrollLeft);
    const normalizedScrollLeft = getNormalizedScrollLeft(this.$.table, this.getAttribute("dir"));
    const transform = `translate(${-scrollLeft}px, 0)`;
    this.$.header.style.transform = transform;
    this.$.footer.style.transform = transform;
    this.$.items.style.transform = transform;
    const x2 = this.__isRTL ? normalizedScrollLeft + clientWidth - scrollWidth : scrollLeft;
    const transformFrozen = `translate(${x2}px, 0)`;
    this._frozenCells.forEach((cell) => {
      cell.style.transform = transformFrozen;
    });
    const remaining = this.__isRTL ? normalizedScrollLeft : scrollLeft + clientWidth - scrollWidth;
    const transformFrozenToEnd = `translate(${remaining}px, 0)`;
    let transformFrozenToEndBody = transformFrozenToEnd;
    if (this._lazyColumns && this._areSizerCellsAssigned()) {
      const columnsInOrder = this._getColumnsInOrder();
      const lastVisibleColumn = [...columnsInOrder].reverse().find((column) => !column.frozenToEnd && !column._bodyContentHidden);
      const lastVisibleColumnEnd = this.__getColumnEnd(lastVisibleColumn);
      const firstFrozenToEndColumn = columnsInOrder.find((column) => column.frozenToEnd);
      const firstFrozenToEndColumnStart = this.__getColumnStart(firstFrozenToEndColumn);
      const translateX = remaining + (firstFrozenToEndColumnStart - lastVisibleColumnEnd) + this.__lazyColumnsStart;
      transformFrozenToEndBody = `translate(${translateX}px, 0)`;
    }
    this._frozenToEndCells.forEach((cell) => {
      if (this.$.items.contains(cell)) {
        cell.style.transform = transformFrozenToEndBody;
      } else {
        cell.style.transform = transformFrozenToEnd;
      }
    });
    if (this.hasAttribute("navigating") && this.__rowFocusMode) {
      this.$.table.style.setProperty("--_grid-horizontal-scroll-position", `${-x2}px`);
    }
  }
  /** @private */
  _areSizerCellsAssigned() {
    return this._getColumnsInOrder().every((column) => column._sizerCell);
  }
};
/**
 * @license
 * Copyright (c) 2016 - 2025 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const SelectionMixin = (superClass) => class SelectionMixin extends superClass {
  static get properties() {
    return {
      /**
       * An array that contains the selected items.
       * @type {!Array<!GridItem>}
       */
      selectedItems: {
        type: Object,
        notify: true,
        value: () => [],
        sync: true
      },
      /**
       * A function to check whether a specific item in the grid may be
       * selected or deselected by the user. Used by the selection column to
       * conditionally enable to disable checkboxes for individual items. This
       * function does not prevent programmatic selection/deselection of
       * items. Changing the function does not modify the currently selected
       * items.
       *
       * Configuring this function hides the select all checkbox of the grid
       * selection column, which means users can not select or deselect all
       * items anymore, nor do they get feedback on whether all items are
       * selected or not.
       *
       * Receives an item instance and should return a boolean indicating
       * whether users may change the selection state of that item.
       *
       * @type {(item: !GridItem) => boolean}
       */
      isItemSelectable: {
        type: Function,
        notify: /* @__PURE__ */ (() => true)()
        // prevent Polymer analyzer from documenting a changed event
      },
      /**
       * Set of selected item ids
       * @private
       */
      __selectedKeys: {
        type: Object,
        computed: "__computeSelectedKeys(itemIdPath, selectedItems)"
      }
    };
  }
  static get observers() {
    return ["__selectedItemsChanged(itemIdPath, selectedItems, isItemSelectable)"];
  }
  /**
   * @param {!GridItem} item
   * @return {boolean}
   * @protected
   */
  _isSelected(item2) {
    return this.__selectedKeys.has(this.getItemId(item2));
  }
  /**
   * Determines whether the selection state of an item may be changed by the
   * user.
   *
   * @private
   */
  __isItemSelectable(item2) {
    if (!this.isItemSelectable || !item2) {
      return true;
    }
    return this.isItemSelectable(item2);
  }
  /**
   * Selects the given item.
   *
   * @method selectItem
   * @param {!GridItem} item The item object
   */
  selectItem(item2) {
    if (!this._isSelected(item2)) {
      this.selectedItems = [...this.selectedItems, item2];
    }
  }
  /**
   * Deselects the given item if it is already selected.
   *
   * @method deselect
   * @param {!GridItem} item The item object
   */
  deselectItem(item2) {
    if (this._isSelected(item2)) {
      this.selectedItems = this.selectedItems.filter((i2) => !this._itemsEqual(i2, item2));
    }
  }
  /** @private */
  __selectedItemsChanged() {
    this.requestContentUpdate();
  }
  /** @private */
  __computeSelectedKeys(_itemIdPath, selectedItems) {
    const selected = selectedItems || [];
    const selectedKeys = /* @__PURE__ */ new Set();
    selected.forEach((item2) => {
      selectedKeys.add(this.getItemId(item2));
    });
    return selectedKeys;
  }
  /**
   * Fired when the `selectedItems` property changes.
   *
   * @event selected-items-changed
   */
  /**
   * Fired when the user selects or deselects an item through the selection column.
   *
   * @event item-toggle
   * @param {Object} detail
   * @param {GridItem} detail.item the item that was selected or deselected
   * @param {boolean} detail.selected true if the item was selected
   * @param {boolean} detail.shiftKey true if the shift key was pressed
   */
};
/**
 * @license
 * Copyright (c) 2016 - 2025 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
let defaultMultiSortPriority = "prepend";
const SortMixin = (superClass) => class SortMixin extends superClass {
  static get properties() {
    return {
      /**
       * When `true`, all `<vaadin-grid-sorter>` are applied for sorting.
       * @attr {boolean} multi-sort
       * @type {boolean}
       */
      multiSort: {
        type: Boolean,
        value: false
      },
      /**
       * Controls how columns are added to the sort order when using multi-sort.
       * The sort order is visually indicated by numbers in grid sorters placed in column headers.
       *
       * By default, whenever an unsorted column is sorted, or the sort-direction of a column is
       * changed, that column gets sort priority 1, thus affecting the priority for all the other
       * sorted columns. This is identical to using `multi-sort-priority="prepend"`.
       *
       * Using this property allows to change this behavior so that sorting an unsorted column
       * would add it to the "end" of the sort, and changing column's sort direction would retain
       * it's previous priority. To set this, use `multi-sort-priority="append"`.
       *
       * @attr {string} multi-sort-priority
       */
      multiSortPriority: {
        type: String,
        value: () => defaultMultiSortPriority
      },
      /**
       * When `true`, Shift-clicking an unsorted column's sorter adds it to the multi-sort.
       * Shift + Space does the same action via keyboard. This property has precedence over the
       * `multiSort` property. If `multiSortOnShiftClick` is true, the multiSort property is effectively ignored.
       *
       * @attr {boolean} multi-sort-on-shift-click
       * @type {boolean}
       */
      multiSortOnShiftClick: {
        type: Boolean,
        value: false
      },
      /**
       * @type {!Array<!GridSorterDefinition>}
       * @protected
       */
      _sorters: {
        type: Array,
        value: () => []
      },
      /** @private */
      _previousSorters: {
        type: Array,
        value: () => []
      }
    };
  }
  /**
   * Sets the default multi-sort priority to use for all grid instances.
   * This method should be called before creating any grid instances.
   * Changing this setting does not affect the default for existing grids.
   *
   * @param {string} priority
   */
  static setDefaultMultiSortPriority(priority) {
    defaultMultiSortPriority = ["append", "prepend"].includes(priority) ? priority : "prepend";
  }
  /** @protected */
  ready() {
    super.ready();
    this.addEventListener("sorter-changed", this._onSorterChanged);
  }
  /** @private */
  _onSorterChanged(e2) {
    const sorter = e2.target;
    e2.stopPropagation();
    sorter._grid = this;
    this.__updateSorter(sorter, e2.detail.shiftClick, e2.detail.fromSorterClick);
    this.__applySorters();
  }
  /** @private */
  __removeSorters(sortersToRemove) {
    if (sortersToRemove.length === 0) {
      return;
    }
    this._sorters = this._sorters.filter((sorter) => !sortersToRemove.includes(sorter));
    this.__applySorters();
  }
  /** @private */
  __updateSortOrders() {
    this._sorters.forEach((sorter) => {
      sorter._order = null;
    });
    const activeSorters = this._getActiveSorters();
    if (activeSorters.length > 1) {
      activeSorters.forEach((sorter, index) => {
        sorter._order = index;
      });
    }
  }
  /** @private */
  __updateSorter(sorter, shiftClick, fromSorterClick) {
    if (!sorter.direction && !this._sorters.includes(sorter)) {
      return;
    }
    sorter._order = null;
    const restSorters = this._sorters.filter((s3) => s3 !== sorter);
    if (this.multiSort && (!this.multiSortOnShiftClick || !fromSorterClick) || this.multiSortOnShiftClick && shiftClick) {
      if (this.multiSortPriority === "append") {
        this._sorters = [...restSorters, sorter];
      } else {
        this._sorters = [sorter, ...restSorters];
      }
    } else if (sorter.direction || this.multiSortOnShiftClick) {
      this._sorters = sorter.direction ? [sorter] : [];
      restSorters.forEach((sorter2) => {
        sorter2._order = null;
        sorter2.direction = null;
      });
    }
  }
  /** @private */
  __applySorters() {
    this.__updateSortOrders();
    if (this.dataProvider && // No need to clear cache if sorters didn't change and grid is attached
    this.isAttached && JSON.stringify(this._previousSorters) !== JSON.stringify(this._mapSorters())) {
      this.__debounceClearCache();
    }
    this._a11yUpdateSorters();
    this._previousSorters = this._mapSorters();
  }
  /**
   * @type {GridSorterDefinition[]}
   * @protected
   */
  _getActiveSorters() {
    return this._sorters.filter((sorter) => sorter.direction && sorter.isConnected);
  }
  /**
   * @return {!Array<!GridSorterDefinition>}
   * @protected
   */
  _mapSorters() {
    return this._getActiveSorters().map((sorter) => {
      return {
        path: sorter.path,
        direction: sorter.direction
      };
    });
  }
};
/**
 * @license
 * Copyright (c) 2016 - 2025 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const StylingMixin = (superClass) => class StylingMixin extends superClass {
  static get properties() {
    return {
      /**
       * A function that allows generating CSS class names for grid cells
       * based on their row and column. The return value should be the generated
       * class name as a string, or multiple class names separated by whitespace
       * characters.
       *
       * Receives two arguments:
       * - `column` The `<vaadin-grid-column>` element (`undefined` for details-cell).
       * - `model` The object with the properties related with
       *   the rendered item, contains:
       *   - `model.index` The index of the item.
       *   - `model.item` The item.
       *   - `model.expanded` Sublevel toggle state.
       *   - `model.level` Level of the tree represented with a horizontal offset of the toggle button.
       *   - `model.selected` Selected state.
       *
       * @type {GridCellClassNameGenerator | null | undefined}
       * @deprecated Use `cellPartNameGenerator` instead.
       */
      cellClassNameGenerator: {
        type: Function,
        sync: true
      },
      /**
       * A function that allows generating CSS `part` names for grid cells in Shadow DOM based
       * on their row and column, for styling from outside using the `::part()` selector.
       *
       * The return value should be the generated part name as a string, or multiple part names
       * separated by whitespace characters.
       *
       * Receives two arguments:
       * - `column` The `<vaadin-grid-column>` element (`undefined` for details-cell).
       * - `model` The object with the properties related with
       *   the rendered item, contains:
       *   - `model.index` The index of the item.
       *   - `model.item` The item.
       *   - `model.expanded` Sublevel toggle state.
       *   - `model.level` Level of the tree represented with a horizontal offset of the toggle button.
       *   - `model.selected` Selected state.
       *
       * @type {GridCellPartNameGenerator | null | undefined}
       */
      cellPartNameGenerator: {
        type: Function,
        sync: true
      }
    };
  }
  static get observers() {
    return [
      "__cellClassNameGeneratorChanged(cellClassNameGenerator)",
      "__cellPartNameGeneratorChanged(cellPartNameGenerator)"
    ];
  }
  /** @private */
  __cellClassNameGeneratorChanged() {
    this.generateCellClassNames();
  }
  /** @private */
  __cellPartNameGeneratorChanged() {
    this.generateCellPartNames();
  }
  /**
   * Runs the `cellClassNameGenerator` for the visible cells.
   * If the generator depends on varying conditions, you need to
   * call this function manually in order to update the styles when
   * the conditions change.
   *
   * @deprecated Use `cellPartNameGenerator` and `generateCellPartNames()` instead.
   */
  generateCellClassNames() {
    iterateChildren(this.$.items, (row) => {
      if (!row.hidden) {
        this._generateCellClassNames(row, this.__getRowModel(row));
      }
    });
  }
  /**
   * Runs the `cellPartNameGenerator` for the visible cells.
   * If the generator depends on varying conditions, you need to
   * call this function manually in order to update the styles when
   * the conditions change.
   */
  generateCellPartNames() {
    iterateChildren(this.$.items, (row) => {
      if (!row.hidden) {
        this._generateCellPartNames(row, this.__getRowModel(row));
      }
    });
  }
  /** @private */
  _generateCellClassNames(row, model) {
    iterateRowCells(row, (cell) => {
      if (cell.__generatedClasses) {
        cell.__generatedClasses.forEach((className) => cell.classList.remove(className));
      }
      if (this.cellClassNameGenerator && !row.hasAttribute("loading")) {
        const result = this.cellClassNameGenerator(cell._column, model);
        cell.__generatedClasses = result && result.split(" ").filter((className) => className.length > 0);
        if (cell.__generatedClasses) {
          cell.__generatedClasses.forEach((className) => cell.classList.add(className));
        }
      }
    });
  }
  /** @private */
  _generateCellPartNames(row, model) {
    iterateRowCells(row, (cell) => {
      if (cell.__generatedParts) {
        cell.__generatedParts.forEach((partName) => {
          updatePart(cell, null, partName);
        });
      }
      if (this.cellPartNameGenerator && !row.hasAttribute("loading")) {
        const result = this.cellPartNameGenerator(cell._column, model);
        cell.__generatedParts = result && result.split(" ").filter((partName) => partName.length > 0);
        if (cell.__generatedParts) {
          cell.__generatedParts.forEach((partName) => {
            updatePart(cell, true, partName);
          });
        }
      }
    });
  }
};
/**
 * @license
 * Copyright (c) 2016 - 2025 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const GridMixin = (superClass) => class extends ColumnAutoWidthMixin(
  ArrayDataProviderMixin(
    DataProviderMixin(
      DynamicColumnsMixin(
        ActiveItemMixin(
          ScrollMixin(
            SelectionMixin(
              SortMixin(
                RowDetailsMixin(
                  KeyboardNavigationMixin(
                    A11yMixin(
                      FilterMixin(
                        ColumnReorderingMixin(
                          ColumnResizingMixin(
                            EventContextMixin(DragAndDropMixin(StylingMixin(TabindexMixin(superClass))))
                          )
                        )
                      )
                    )
                  )
                )
              )
            )
          )
        )
      )
    )
  )
) {
  static get observers() {
    return ["_columnTreeChanged(_columnTree)", "_flatSizeChanged(_flatSize, __virtualizer, _hasData, _columnTree)"];
  }
  static get properties() {
    return {
      /** @private */
      _safari: {
        type: Boolean,
        value: isSafari
      },
      /** @private */
      _ios: {
        type: Boolean,
        value: isIOS
      },
      /** @private */
      _firefox: {
        type: Boolean,
        value: isFirefox
      },
      /** @private */
      _android: {
        type: Boolean,
        value: isAndroid
      },
      /** @private */
      _touchDevice: {
        type: Boolean,
        value: isTouch
      },
      /**
       * If true, the grid's height is defined by its rows.
       *
       * Effectively, this disables the grid's virtual scrolling so that all the rows are rendered in the DOM at once.
       * If the grid has a large number of items, using the feature is discouraged to avoid performance issues.
       * @attr {boolean} all-rows-visible
       * @type {boolean}
       */
      allRowsVisible: {
        type: Boolean,
        value: false,
        reflectToAttribute: true
      },
      /** @private */
      isAttached: {
        value: false
      },
      /**
       * An internal property that is mainly used by `vaadin-template-renderer`
       * to identify grid elements.
       *
       * @private
       */
      __gridElement: {
        type: Boolean,
        value: true
      },
      /** @private */
      __hasEmptyStateContent: {
        type: Boolean,
        value: false
      },
      /** @private */
      __emptyState: {
        type: Boolean,
        computed: "__computeEmptyState(_flatSize, __hasEmptyStateContent)"
      }
    };
  }
  constructor() {
    super();
    this.addEventListener("animationend", this._onAnimationEnd);
  }
  /** @private */
  get _firstVisibleIndex() {
    const firstVisibleItem = this.__getFirstVisibleItem();
    return firstVisibleItem ? firstVisibleItem.index : void 0;
  }
  /** @private */
  get _lastVisibleIndex() {
    const lastVisibleItem = this.__getLastVisibleItem();
    return lastVisibleItem ? lastVisibleItem.index : void 0;
  }
  /** @protected */
  connectedCallback() {
    super.connectedCallback();
    this.isAttached = true;
    this.__virtualizer.hostConnected();
  }
  /** @protected */
  disconnectedCallback() {
    super.disconnectedCallback();
    this.isAttached = false;
    this._hideTooltip(true);
  }
  /** @private */
  __getFirstVisibleItem() {
    return this._getRenderedRows().find((row) => this._isInViewport(row));
  }
  /** @private */
  __getLastVisibleItem() {
    return this._getRenderedRows().reverse().find((row) => this._isInViewport(row));
  }
  /** @private */
  _isInViewport(item2) {
    const scrollTargetRect = this.$.table.getBoundingClientRect();
    const itemRect = item2.getBoundingClientRect();
    const headerHeight = this.$.header.getBoundingClientRect().height;
    const footerHeight = this.$.footer.getBoundingClientRect().height;
    return itemRect.bottom > scrollTargetRect.top + headerHeight && itemRect.top < scrollTargetRect.bottom - footerHeight;
  }
  /** @private */
  _getRenderedRows() {
    return Array.from(this.$.items.children).filter((item2) => !item2.hidden).sort((a3, b2) => a3.index - b2.index);
  }
  /** @protected */
  _getRowContainingNode(node) {
    const content = getClosestElement("vaadin-grid-cell-content", node);
    if (!content) {
      return;
    }
    const cell = content.assignedSlot.parentElement;
    return cell.parentElement;
  }
  /** @protected */
  _isItemAssignedToRow(item2, row) {
    const model = this.__getRowModel(row);
    return this.getItemId(item2) === this.getItemId(model.item);
  }
  /** @protected */
  ready() {
    super.ready();
    this.__virtualizer = new Virtualizer({
      createElements: this._createScrollerRows.bind(this),
      updateElement: this._updateScrollerItem.bind(this),
      scrollContainer: this.$.items,
      scrollTarget: this.$.table,
      reorderElements: true
    });
    new ResizeObserver(
      () => setTimeout(() => {
        this.__updateColumnsBodyContentHidden();
      })
    ).observe(this.$.table);
    const minHeightObserver = new ResizeObserver(
      () => setTimeout(() => {
        this.__updateMinHeight();
      })
    );
    minHeightObserver.observe(this.$.header);
    minHeightObserver.observe(this.$.items);
    minHeightObserver.observe(this.$.footer);
    processTemplates(this);
    this._tooltipController = new TooltipController(this);
    this.addController(this._tooltipController);
    this._tooltipController.setManual(true);
    this.__emptyStateContentObserver = new SlotObserver(this.$.emptystateslot, ({ currentNodes }) => {
      this.$.emptystatecell._content = currentNodes[0];
      this.__hasEmptyStateContent = !!this.$.emptystatecell._content;
    });
  }
  /** @private */
  __getBodyCellCoordinates(cell) {
    if (this.$.items.contains(cell) && cell.localName === "td") {
      return {
        item: cell.parentElement._item,
        column: cell._column
      };
    }
  }
  /** @private */
  __focusBodyCell({ item: item2, column }) {
    const row = this._getRenderedRows().find((row2) => row2._item === item2);
    const cell = row && [...row.children].find((cell2) => cell2._column === column);
    if (cell) {
      cell.focus();
    }
  }
  /** @protected */
  _focusFirstVisibleRow() {
    const row = this.__getFirstVisibleItem();
    this.__rowFocusMode = true;
    row.focus();
  }
  /** @private */
  _flatSizeChanged(flatSize, virtualizer, hasData, columnTree) {
    if (virtualizer && hasData && columnTree) {
      const cell = this.shadowRoot.activeElement;
      const cellCoordinates = this.__getBodyCellCoordinates(cell);
      const previousSize = virtualizer.size || 0;
      virtualizer.size = flatSize;
      virtualizer.update(previousSize - 1, previousSize - 1);
      if (flatSize < previousSize) {
        virtualizer.update(flatSize - 1, flatSize - 1);
      }
      if (cellCoordinates && cell.parentElement.hidden) {
        this.__focusBodyCell(cellCoordinates);
      }
      this._resetKeyboardNavigation();
    }
  }
  /** @private */
  _createScrollerRows(count) {
    const rows = [];
    for (let i2 = 0; i2 < count; i2++) {
      const row = document.createElement("tr");
      row.setAttribute("part", "row body-row");
      row.setAttribute("role", "row");
      row.setAttribute("tabindex", "-1");
      if (this._columnTree) {
        this._updateRow(row, this._columnTree[this._columnTree.length - 1], "body", false, true);
      }
      rows.push(row);
    }
    if (this._columnTree) {
      this._columnTree[this._columnTree.length - 1].forEach((c2) => {
        if (c2.isConnected && c2._cells) {
          c2._cells = [...c2._cells];
        }
      });
    }
    this.__afterCreateScrollerRowsDebouncer = Debouncer$1.debounce(
      this.__afterCreateScrollerRowsDebouncer,
      animationFrame$1,
      () => {
        this._afterScroll();
      }
    );
    return rows;
  }
  /** @private */
  _createCell(tagName, column) {
    const contentId = this._contentIndex = this._contentIndex + 1 || 0;
    const slotName = `vaadin-grid-cell-content-${contentId}`;
    const cellContent = document.createElement("vaadin-grid-cell-content");
    cellContent.setAttribute("slot", slotName);
    const cell = document.createElement(tagName);
    cell.id = slotName.replace("-content-", "-");
    cell.setAttribute("role", tagName === "td" ? "gridcell" : "columnheader");
    if (!isAndroid && !isIOS) {
      cell.addEventListener("mouseenter", (event) => {
        if (!this.$.scroller.hasAttribute("scrolling")) {
          this._showTooltip(event);
        }
      });
      cell.addEventListener("mouseleave", () => {
        this._hideTooltip();
      });
      cell.addEventListener("mousedown", () => {
        this._hideTooltip(true);
      });
    }
    const slot = document.createElement("slot");
    slot.setAttribute("name", slotName);
    if (column && column._focusButtonMode) {
      const div = document.createElement("div");
      div.setAttribute("role", "button");
      div.setAttribute("tabindex", "-1");
      cell.appendChild(div);
      cell._focusButton = div;
      cell.focus = function(options) {
        cell._focusButton.focus(options);
      };
      div.appendChild(slot);
    } else {
      cell.setAttribute("tabindex", "-1");
      cell.appendChild(slot);
    }
    cell._content = cellContent;
    cellContent.addEventListener("mousedown", () => {
      if (isChrome) {
        const mouseUpListener = (event) => {
          const contentContainsFocusedElement = cellContent.contains(this.getRootNode().activeElement);
          const mouseUpWithinCell = event.composedPath().includes(cellContent);
          if (!contentContainsFocusedElement && mouseUpWithinCell) {
            cell.focus({ preventScroll: true });
          }
          document.removeEventListener("mouseup", mouseUpListener, true);
        };
        document.addEventListener("mouseup", mouseUpListener, true);
      } else {
        setTimeout(() => {
          if (!cellContent.contains(this.getRootNode().activeElement)) {
            cell.focus({ preventScroll: true });
          }
        });
      }
    });
    return cell;
  }
  /**
   * @param {!HTMLTableRowElement} row
   * @param {!Array<!GridColumn>} columns
   * @param {?string} section
   * @param {boolean} isColumnRow
   * @param {boolean} noNotify
   * @protected
   */
  _updateRow(row, columns, section = "body", isColumnRow = false, noNotify = false) {
    const contentsFragment = document.createDocumentFragment();
    iterateRowCells(row, (cell) => {
      cell._vacant = true;
    });
    row.innerHTML = "";
    if (section === "body") {
      row.__cells = [];
      row.__detailsCell = null;
    }
    columns.filter((column) => !column.hidden).forEach((column, index, cols) => {
      let cell;
      if (section === "body") {
        if (!column._cells) {
          column._cells = [];
        }
        cell = column._cells.find((cell2) => cell2._vacant);
        if (!cell) {
          cell = this._createCell("td", column);
          if (column._onCellKeyDown) {
            cell.addEventListener("keydown", column._onCellKeyDown.bind(column));
          }
          column._cells.push(cell);
        }
        cell.setAttribute("part", "cell body-cell");
        cell.__parentRow = row;
        row.__cells.push(cell);
        const isSizerRow = row === this.$.sizer;
        if (!column._bodyContentHidden || isSizerRow) {
          row.appendChild(cell);
        }
        if (isSizerRow) {
          column._sizerCell = cell;
        }
        if (index === cols.length - 1 && this.rowDetailsRenderer) {
          if (!this._detailsCells) {
            this._detailsCells = [];
          }
          const detailsCell = this._detailsCells.find((cell2) => cell2._vacant) || this._createCell("td");
          if (this._detailsCells.indexOf(detailsCell) === -1) {
            this._detailsCells.push(detailsCell);
          }
          if (!detailsCell._content.parentElement) {
            contentsFragment.appendChild(detailsCell._content);
          }
          this._configureDetailsCell(detailsCell);
          row.appendChild(detailsCell);
          row.__detailsCell = detailsCell;
          this._a11ySetRowDetailsCell(row, detailsCell);
          detailsCell._vacant = false;
        }
        if (!noNotify) {
          column._cells = [...column._cells];
        }
      } else {
        const tagName = section === "header" ? "th" : "td";
        if (isColumnRow || column.localName === "vaadin-grid-column-group") {
          cell = column[`_${section}Cell`];
          if (!cell) {
            cell = this._createCell(tagName);
            if (column._onCellKeyDown) {
              cell.addEventListener("keydown", column._onCellKeyDown.bind(column));
            }
          }
          cell._column = column;
          row.appendChild(cell);
          column[`_${section}Cell`] = cell;
        } else {
          if (!column._emptyCells) {
            column._emptyCells = [];
          }
          cell = column._emptyCells.find((cell2) => cell2._vacant) || this._createCell(tagName);
          cell._column = column;
          row.appendChild(cell);
          if (column._emptyCells.indexOf(cell) === -1) {
            column._emptyCells.push(cell);
          }
        }
        cell.part.add("cell", `${section}-cell`);
      }
      if (!cell._content.parentElement) {
        contentsFragment.appendChild(cell._content);
      }
      cell._vacant = false;
      cell._column = column;
    });
    if (section !== "body") {
      this.__debounceUpdateHeaderFooterRowVisibility(row);
    }
    this.appendChild(contentsFragment);
    this._frozenCellsChanged();
    this._updateFirstAndLastColumnForRow(row);
  }
  /**
   * @param {HTMLTableRowElement} row
   * @protected
   */
  __debounceUpdateHeaderFooterRowVisibility(row) {
    row.__debounceUpdateHeaderFooterRowVisibility = Debouncer$1.debounce(
      row.__debounceUpdateHeaderFooterRowVisibility,
      microTask$1,
      () => this.__updateHeaderFooterRowVisibility(row)
    );
  }
  /**
   * @param {HTMLTableRowElement} row
   * @protected
   */
  __updateHeaderFooterRowVisibility(row) {
    if (!row) {
      return;
    }
    const visibleRowCells = Array.from(row.children).filter((cell) => {
      const column = cell._column;
      if (column._emptyCells && column._emptyCells.indexOf(cell) > -1) {
        return false;
      }
      if (row.parentElement === this.$.header) {
        if (column.headerRenderer) {
          return true;
        }
        if (column.header === null) {
          return false;
        }
        if (column.path || column.header !== void 0) {
          return true;
        }
      } else if (column.footerRenderer) {
        return true;
      }
      return false;
    });
    if (row.hidden !== !visibleRowCells.length) {
      row.hidden = !visibleRowCells.length;
    }
    this._resetKeyboardNavigation();
    this._a11yUpdateGridSize(this.size, this._columnTree, this.__emptyState);
  }
  /** @private */
  _updateScrollerItem(row, index) {
    this._preventScrollerRotatingCellFocus(row, index);
    if (!this._columnTree) {
      return;
    }
    this._updateRowOrderParts(row, index);
    this._a11yUpdateRowRowindex(row, index);
    this._getItem(index, row);
  }
  /** @private */
  _columnTreeChanged(columnTree) {
    this._renderColumnTree(columnTree);
    this.__updateColumnsBodyContentHidden();
  }
  /** @private */
  _updateRowOrderParts(row, index = row.index) {
    updateBooleanRowStates(row, {
      first: index === 0,
      last: index === this._flatSize - 1,
      odd: index % 2 !== 0,
      even: index % 2 === 0
    });
  }
  /** @private */
  _updateRowStateParts(row, { item: item2, expanded, selected, detailsOpened }) {
    updateBooleanRowStates(row, {
      expanded,
      collapsed: this.__isRowExpandable(row),
      selected,
      nonselectable: this.__isItemSelectable(item2) === false,
      "details-opened": detailsOpened
    });
  }
  /** @private */
  __computeEmptyState(flatSize, hasEmptyStateContent) {
    return flatSize === 0 && hasEmptyStateContent;
  }
  /**
   * @param {!Array<!GridColumn>} columnTree
   * @protected
   */
  _renderColumnTree(columnTree) {
    iterateChildren(this.$.items, (row) => {
      this._updateRow(row, columnTree[columnTree.length - 1], "body", false, true);
      const model = this.__getRowModel(row);
      this._updateRowOrderParts(row);
      this._updateRowStateParts(row, model);
      this._filterDragAndDrop(row, model);
    });
    while (this.$.header.children.length < columnTree.length) {
      const headerRow = document.createElement("tr");
      headerRow.setAttribute("part", "row");
      headerRow.setAttribute("role", "row");
      headerRow.setAttribute("tabindex", "-1");
      this.$.header.appendChild(headerRow);
      const footerRow = document.createElement("tr");
      footerRow.setAttribute("part", "row");
      footerRow.setAttribute("role", "row");
      footerRow.setAttribute("tabindex", "-1");
      this.$.footer.appendChild(footerRow);
    }
    while (this.$.header.children.length > columnTree.length) {
      this.$.header.removeChild(this.$.header.firstElementChild);
      this.$.footer.removeChild(this.$.footer.firstElementChild);
    }
    iterateChildren(this.$.header, (headerRow, index, rows) => {
      this._updateRow(headerRow, columnTree[index], "header", index === columnTree.length - 1);
      const cells = getBodyRowCells(headerRow);
      updateCellsPart(cells, "first-header-row-cell", index === 0);
      updateCellsPart(cells, "last-header-row-cell", index === rows.length - 1);
    });
    iterateChildren(this.$.footer, (footerRow, index, rows) => {
      this._updateRow(footerRow, columnTree[columnTree.length - 1 - index], "footer", index === 0);
      const cells = getBodyRowCells(footerRow);
      updateCellsPart(cells, "first-footer-row-cell", index === 0);
      updateCellsPart(cells, "last-footer-row-cell", index === rows.length - 1);
    });
    this._updateRow(this.$.sizer, columnTree[columnTree.length - 1]);
    this._resizeHandler();
    this._frozenCellsChanged();
    this._updateFirstAndLastColumn();
    this._resetKeyboardNavigation();
    this._a11yUpdateHeaderRows();
    this._a11yUpdateFooterRows();
    this.generateCellClassNames();
    this.generateCellPartNames();
    this.__updateHeaderAndFooter();
  }
  /**
   * @param {!HTMLElement} row
   * @param {GridItem} item
   * @protected
   */
  _updateItem(row, item2) {
    row._item = item2;
    const model = this.__getRowModel(row);
    this._toggleDetailsCell(row, model.detailsOpened);
    this._a11yUpdateRowLevel(row, model.level);
    this._a11yUpdateRowSelected(row, model.selected);
    this._updateRowStateParts(row, model);
    this._generateCellClassNames(row, model);
    this._generateCellPartNames(row, model);
    this._filterDragAndDrop(row, model);
    this.__updateDragSourceParts(row, model);
    iterateChildren(row, (cell) => {
      if (cell._column && !cell._column.isConnected) {
        return;
      }
      if (cell._renderer) {
        const owner = cell._column || this;
        cell._renderer.call(owner, cell._content, owner, model);
      }
    });
    this._updateDetailsCellHeight(row);
    this._a11yUpdateRowExpanded(row, model.expanded);
  }
  /** @private */
  _resizeHandler() {
    this._updateDetailsCellHeights();
    this.__updateHorizontalScrollPosition();
  }
  /** @private */
  _onAnimationEnd(e2) {
    if (e2.animationName.indexOf("vaadin-grid-appear") === 0) {
      e2.stopPropagation();
      this._resetKeyboardNavigation();
      requestAnimationFrame(() => {
        this.__scrollToPendingIndexes();
      });
    }
  }
  /**
   * @param {!HTMLTableRowElement} row
   * @return {!GridItemModel}
   * @protected
   */
  __getRowModel(row) {
    return {
      index: row.index,
      item: row._item,
      level: this._getIndexLevel(row.index),
      expanded: this._isExpanded(row._item),
      selected: this._isSelected(row._item),
      detailsOpened: !!this.rowDetailsRenderer && this._isDetailsOpened(row._item)
    };
  }
  /**
   * @param {Event} event
   * @protected
   */
  _showTooltip(event) {
    const tooltip = this._tooltipController.node;
    if (tooltip && tooltip.isConnected) {
      const target = event.target;
      if (!this.__isCellFullyVisible(target)) {
        return;
      }
      this._tooltipController.setTarget(target);
      this._tooltipController.setContext(this.getEventContext(event));
      tooltip._stateController.open({
        focus: event.type === "focusin",
        hover: event.type === "mouseenter"
      });
    }
  }
  /** @private */
  __isCellFullyVisible(cell) {
    if (cell.hasAttribute("frozen") || cell.hasAttribute("frozen-to-end")) {
      return true;
    }
    let { left, right } = this.getBoundingClientRect();
    const frozen = [...cell.parentNode.children].find((cell2) => cell2.hasAttribute("last-frozen"));
    if (frozen) {
      const frozenRect = frozen.getBoundingClientRect();
      left = this.__isRTL ? left : frozenRect.right;
      right = this.__isRTL ? frozenRect.left : right;
    }
    const frozenToEnd = [...cell.parentNode.children].find((cell2) => cell2.hasAttribute("first-frozen-to-end"));
    if (frozenToEnd) {
      const frozenToEndRect = frozenToEnd.getBoundingClientRect();
      left = this.__isRTL ? frozenToEndRect.right : left;
      right = this.__isRTL ? right : frozenToEndRect.left;
    }
    const cellRect = cell.getBoundingClientRect();
    return cellRect.left >= left && cellRect.right <= right;
  }
  /** @protected */
  _hideTooltip(immediate) {
    const tooltip = this._tooltipController && this._tooltipController.node;
    if (tooltip) {
      tooltip._stateController.close(immediate);
    }
  }
  /**
   * Requests an update for the content of cells.
   *
   * While performing the update, the following renderers are invoked:
   * - `Grid.rowDetailsRenderer`
   * - `GridColumn.renderer`
   * - `GridColumn.headerRenderer`
   * - `GridColumn.footerRenderer`
   *
   * It is not guaranteed that the update happens immediately (synchronously) after it is requested.
   */
  requestContentUpdate() {
    this.__updateHeaderAndFooter();
    this.__updateVisibleRows();
  }
  /** @private */
  __updateHeaderAndFooter() {
    (this._columnTree || []).forEach((level) => {
      level.forEach((column) => {
        if (column._renderHeaderAndFooter) {
          column._renderHeaderAndFooter();
        }
      });
    });
  }
  /** @protected */
  __updateVisibleRows(start, end) {
    if (this.__virtualizer) {
      this.__virtualizer.update(start, end);
    }
  }
  /** @private */
  __updateMinHeight() {
    const rowHeight = 36;
    const headerHeight = this.$.header.clientHeight;
    const footerHeight = this.$.footer.clientHeight;
    const scrollbarHeight = this.$.table.offsetHeight - this.$.table.clientHeight;
    const minHeight = headerHeight + rowHeight + footerHeight + scrollbarHeight;
    if (!this.__minHeightStyleSheet && supportsAdoptingStyleSheets$1) {
      this.__minHeightStyleSheet = new CSSStyleSheet();
      this.shadowRoot.adoptedStyleSheets = [...this.shadowRoot.adoptedStyleSheets, this.__minHeightStyleSheet];
    }
    if (this.__minHeightStyleSheet) {
      this.__minHeightStyleSheet.replaceSync(`:host { --_grid-min-height: ${minHeight}px; }`);
    } else {
      this.style.setProperty("--_grid-min-height", `${minHeight}px`);
    }
  }
};
/**
 * @license
 * Copyright (c) 2016 - 2025 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const gridStyles = css`
  @keyframes vaadin-grid-appear {
    to {
      opacity: 1;
    }
  }

  :host {
    display: flex;
    flex-direction: column;
    animation: 1ms vaadin-grid-appear;
    height: 400px;
    min-height: var(--_grid-min-height, 0);
    flex: 1 1 auto;
    align-self: stretch;
    position: relative;
  }

  :host([hidden]) {
    display: none !important;
  }

  :host([disabled]) {
    pointer-events: none;
  }

  #scroller {
    display: flex;
    flex-direction: column;
    min-height: 100%;
    transform: translateY(0);
    width: auto;
    height: auto;
    position: absolute;
    inset: 0;
  }

  :host([all-rows-visible]) {
    height: auto;
    align-self: flex-start;
    min-height: auto;
    flex-grow: 0;
    width: 100%;
  }

  :host([all-rows-visible]) #scroller {
    width: 100%;
    height: 100%;
    position: relative;
  }

  :host([all-rows-visible]) #items {
    min-height: 1px;
  }

  #table {
    display: flex;
    flex-direction: column;
    width: 100%;
    height: 100%;
    overflow: auto;
    position: relative;
    outline: none;
    /* Workaround for a Desktop Safari bug: new stacking context here prevents the scrollbar from getting hidden */
    z-index: 0;
  }

  #header,
  #footer {
    display: block;
    position: -webkit-sticky;
    position: sticky;
    left: 0;
    overflow: visible;
    width: 100%;
    z-index: 1;
  }

  #header {
    top: 0;
  }

  th {
    text-align: inherit;
  }

  /* Safari doesn't work with "inherit" */
  [safari] th {
    text-align: initial;
  }

  #footer {
    bottom: 0;
  }

  #items {
    flex-grow: 1;
    flex-shrink: 0;
    display: block;
    position: -webkit-sticky;
    position: sticky;
    width: 100%;
    left: 0;
    overflow: visible;
  }

  [part~='row'] {
    display: flex;
    width: 100%;
    box-sizing: border-box;
    margin: 0;
  }

  [part~='row'][loading] [part~='body-cell'] ::slotted(vaadin-grid-cell-content) {
    visibility: hidden;
  }

  [column-rendering='lazy'] [part~='body-cell']:not([frozen]):not([frozen-to-end]) {
    transform: translateX(var(--_grid-lazy-columns-start));
  }

  #items [part~='row'] {
    position: absolute;
  }

  #items [part~='row']:empty {
    height: 100%;
  }

  [part~='cell']:not([part~='details-cell']) {
    flex-shrink: 0;
    flex-grow: 1;
    box-sizing: border-box;
    display: flex;
    width: 100%;
    position: relative;
    align-items: center;
    padding: 0;
    white-space: nowrap;
  }

  [part~='cell'] {
    outline: none;
  }

  [part~='cell'] > [tabindex] {
    display: flex;
    align-items: inherit;
    outline: none;
    position: absolute;
    inset: 0;
  }

  /* Switch the focusButtonMode wrapping element to "position: static" temporarily
     when measuring real width of the cells in the auto-width columns. */
  [measuring-auto-width] [part~='cell'] > [tabindex] {
    position: static;
  }

  [part~='details-cell'] {
    position: absolute;
    bottom: 0;
    width: 100%;
    box-sizing: border-box;
    padding: 0;
  }

  [part~='cell'] ::slotted(vaadin-grid-cell-content) {
    display: block;
    width: 100%;
    box-sizing: border-box;
    overflow: hidden;
    text-overflow: ellipsis;
  }

  [hidden] {
    display: none !important;
  }

  [frozen],
  [frozen-to-end] {
    z-index: 2;
    will-change: transform;
  }

  [no-scrollbars][safari] #table,
  [no-scrollbars][firefox] #table {
    overflow: hidden;
  }

  /* Empty state */

  #scroller:not([empty-state]) #emptystatebody,
  #scroller[empty-state] #items {
    display: none;
  }

  #emptystatebody {
    display: flex;
    position: sticky;
    inset: 0;
    flex: 1;
    overflow: hidden;
  }

  #emptystaterow {
    display: flex;
    flex: 1;
  }

  #emptystatecell {
    display: block;
    flex: 1;
    overflow: auto;
  }

  /* Reordering styles */
  :host([reordering]) [part~='cell'] ::slotted(vaadin-grid-cell-content),
  :host([reordering]) [part~='resize-handle'],
  #scroller[no-content-pointer-events] [part~='cell'] ::slotted(vaadin-grid-cell-content) {
    pointer-events: none;
  }

  [part~='reorder-ghost'] {
    visibility: hidden;
    position: fixed;
    pointer-events: none;
    opacity: 0.5;

    /* Prevent overflowing the grid in Firefox */
    top: 0;
    left: 0;
  }

  :host([reordering]) {
    -webkit-user-select: none;
    user-select: none;
  }

  /* Resizing styles */
  [part~='resize-handle'] {
    position: absolute;
    top: 0;
    right: 0;
    height: 100%;
    cursor: col-resize;
    z-index: 1;
  }

  [part~='resize-handle']::before {
    position: absolute;
    content: '';
    height: 100%;
    width: 35px;
    transform: translateX(-50%);
  }

  [last-column] [part~='resize-handle']::before,
  [last-frozen] [part~='resize-handle']::before {
    width: 18px;
    transform: none;
    right: 0;
  }

  [frozen-to-end] [part~='resize-handle'] {
    left: 0;
    right: auto;
  }

  [frozen-to-end] [part~='resize-handle']::before {
    left: 0;
    right: auto;
  }

  [first-frozen-to-end] [part~='resize-handle']::before {
    width: 18px;
    transform: none;
  }

  [first-frozen-to-end] {
    margin-inline-start: auto;
  }

  /* Hide resize handle if scrolled to end */
  :host(:not([overflow~='end'])) [first-frozen-to-end] [part~='resize-handle'] {
    display: none;
  }

  #scroller[column-resizing],
  #scroller[range-selecting] {
    -webkit-user-select: none;
    user-select: none;
  }

  /* Sizer styles */
  #sizer {
    display: flex;
    position: absolute;
    visibility: hidden;
  }

  #sizer [part~='details-cell'] {
    display: none !important;
  }

  #sizer [part~='cell'][hidden] {
    display: none !important;
  }

  #sizer [part~='cell'] {
    display: block;
    flex-shrink: 0;
    line-height: 0;
    height: 0 !important;
    min-height: 0 !important;
    max-height: 0 !important;
    padding: 0 !important;
    border: none !important;
  }

  #sizer [part~='cell']::before {
    content: '-';
  }

  #sizer [part~='cell'] ::slotted(vaadin-grid-cell-content) {
    display: none !important;
  }

  /* RTL specific styles */

  :host([dir='rtl']) #items,
  :host([dir='rtl']) #header,
  :host([dir='rtl']) #footer {
    left: auto;
  }

  :host([dir='rtl']) [part~='reorder-ghost'] {
    left: auto;
    right: 0;
  }

  :host([dir='rtl']) [part~='resize-handle'] {
    left: 0;
    right: auto;
  }

  :host([dir='rtl']) [part~='resize-handle']::before {
    transform: translateX(50%);
  }

  :host([dir='rtl']) [last-column] [part~='resize-handle']::before,
  :host([dir='rtl']) [last-frozen] [part~='resize-handle']::before {
    left: 0;
    right: auto;
  }

  :host([dir='rtl']) [frozen-to-end] [part~='resize-handle'] {
    right: 0;
    left: auto;
  }

  :host([dir='rtl']) [frozen-to-end] [part~='resize-handle']::before {
    right: 0;
    left: auto;
  }

  @media (forced-colors: active) {
    [part~='selected-row'] [part~='first-column-cell']::after {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      bottom: 0;
      border: 2px solid;
    }

    [part~='focused-cell']::before {
      outline: 2px solid !important;
      outline-offset: -1px;
    }
  }
`;
/**
 * @license
 * Copyright (c) 2016 - 2025 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
registerStyles$1("vaadin-grid", gridStyles, { moduleId: "vaadin-grid-styles" });
class Grid extends GridMixin(ElementMixin(ThemableMixin(ControllerMixin(PolymerElement)))) {
  static get template() {
    return html`
      <div
        id="scroller"
        safari$="[[_safari]]"
        ios$="[[_ios]]"
        loading$="[[loading]]"
        column-reordering-allowed$="[[columnReorderingAllowed]]"
        empty-state$="[[__emptyState]]"
      >
        <table id="table" role="treegrid" aria-multiselectable="true" tabindex="0" aria-label$="[[accessibleName]]">
          <caption id="sizer" part="row"></caption>
          <thead id="header" role="rowgroup"></thead>
          <tbody id="items" role="rowgroup"></tbody>
          <tbody id="emptystatebody">
            <tr id="emptystaterow">
              <td part="empty-state" id="emptystatecell" tabindex="0">
                <slot name="empty-state" id="emptystateslot"></slot>
              </td>
            </tr>
          </tbody>
          <tfoot id="footer" role="rowgroup"></tfoot>
        </table>

        <div part="reorder-ghost"></div>
      </div>

      <slot name="tooltip"></slot>

      <div id="focusexit" tabindex="0"></div>
    `;
  }
  static get is() {
    return "vaadin-grid";
  }
}
defineCustomElement(Grid);
registerStyles$1(
  "vaadin-grid-sorter",
  css`
    :host {
      justify-content: flex-start;
      align-items: baseline;
      -webkit-user-select: none;
      user-select: none;
      cursor: var(--lumo-clickable-cursor);
    }

    [part='content'] {
      display: inline-block;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    [part='indicators'] {
      margin-left: var(--lumo-space-s);
    }

    [part='indicators']::before {
      transform: scale(0.8);
    }

    :host(:not([direction]):not(:hover)) [part='indicators'] {
      color: var(--lumo-tertiary-text-color);
    }

    :host([direction]) {
      color: var(--vaadin-selection-color-text, var(--lumo-primary-text-color));
    }

    [part='order'] {
      font-size: var(--lumo-font-size-xxs);
      line-height: 1;
    }

    /* RTL specific styles */

    :host([dir='rtl']) [part='indicators'] {
      margin-right: var(--lumo-space-s);
      margin-left: 0;
    }
  `,
  { moduleId: "lumo-grid-sorter" }
);
/**
 * @license
 * Copyright (c) 2016 - 2025 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const template$4 = document.createElement("template");
template$4.innerHTML = `
  <style>
    @font-face {
      font-family: 'vaadin-grid-sorter-icons';
      src: url(data:application/font-woff;charset=utf-8;base64,d09GRgABAAAAAAQwAA0AAAAABuwAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAABGRlRNAAAEFAAAABkAAAAcfep+mUdERUYAAAP4AAAAHAAAAB4AJwAOT1MvMgAAAZgAAAA/AAAAYA8TBPpjbWFwAAAB7AAAAFUAAAFeF1fZ4mdhc3AAAAPwAAAACAAAAAgAAAAQZ2x5ZgAAAlgAAABcAAAAnMvguMloZWFkAAABMAAAAC8AAAA2C5Ap72hoZWEAAAFgAAAAHQAAACQGbQPHaG10eAAAAdgAAAAUAAAAHAoAAABsb2NhAAACRAAAABIAAAASAIwAYG1heHAAAAGAAAAAFgAAACAACwAKbmFtZQAAArQAAAECAAACZxWCgKhwb3N0AAADuAAAADUAAABZCrApUXicY2BkYGAA4rDECVrx/DZfGbhZGEDgyqNPOxH0/wNMq5kPALkcDEwgUQBWRA0dAHicY2BkYGA+8P8AAwMLAwgwrWZgZEAFbABY4QM8AAAAeJxjYGRgYOAAQiYGEICQSAAAAi8AFgAAeJxjYGY6yziBgZWBgWkm0xkGBoZ+CM34msGYkZMBFTAKoAkwODAwvmRiPvD/AIMDMxCD1CDJKjAwAgBktQsXAHicY2GAAMZQCM0EwqshbAALxAEKeJxjYGBgZoBgGQZGBhCIAPIYwXwWBhsgzcXAwcAEhIwMCi+Z/v/9/x+sSuElA4T9/4k4K1gHFwMMMILMY2QDYmaoABOQYGJABUA7WBiGNwAAJd4NIQAAAAAAAAAACAAIABAAGAAmAEAATgAAeJyNjLENgDAMBP9tIURJwQCMQccSZgk2i5fIYBDAidJjycXr7x5EPwE2wY8si7jmyBNXGo/bNBerxJNrpxhbO3/fEFpx8ZICpV+ghxJ74fAMe+h7Ox14AbrsHB14nK2QQWrDMBRER4mTkhQK3ZRQKOgCNk7oGQqhhEIX2WSlWEI1BAlkJ5CDdNsj5Ey9Rncdi38ES+jzNJo/HwTgATcoDEthhY3wBHc4CE+pfwsX5F/hGe7Vo/AcK/UhvMSz+mGXKhZU6pww8ISz3oWn1BvhgnwTnuEJf8Jz1OpFeIlX9YULDLdFi4ASHolkSR0iuYdjLak1vAequBhj21D61Nqyi6l3qWybGPjySbPHGScGJl6dP58MYcQRI0bts7mjebBqrFENH7t3qWtj0OuqHnXcW7b0HOTZFnKryRGW2hFX1m0O2vEM3opNMfTau+CS6Z3Vx6veNnEXY6jwDxhsc2gAAHicY2BiwA84GBgYmRiYGJkZmBlZGFkZ2djScyoLMgzZS/MyDQwMwLSrpYEBlIbxjQDrzgsuAAAAAAEAAf//AA94nGNgZGBg4AFiMSBmYmAEQnYgZgHzGAAD6wA2eJxjYGBgZACCKyoz1cD0o087YTQATOcIewAAAA==) format('woff');
      font-weight: normal;
      font-style: normal;
    }
  </style>
`;
document.head.appendChild(template$4.content);
registerStyles$1(
  "vaadin-grid-sorter",
  css`
    :host {
      display: inline-flex;
      cursor: pointer;
      max-width: 100%;
    }

    [part='content'] {
      flex: 1 1 auto;
    }

    [part='indicators'] {
      position: relative;
      align-self: center;
      flex: none;
    }

    [part='order'] {
      display: inline;
      vertical-align: super;
    }

    [part='indicators']::before {
      font-family: 'vaadin-grid-sorter-icons';
      display: inline-block;
    }

    :host(:not([direction])) [part='indicators']::before {
      content: '\\e901';
    }

    :host([direction='asc']) [part='indicators']::before {
      content: '\\e900';
    }

    :host([direction='desc']) [part='indicators']::before {
      content: '\\e902';
    }
  `,
  { moduleId: "vaadin-grid-sorter-styles" }
);
const GridSorterMixin = (superClass) => class GridSorterMixinClass extends superClass {
  static get properties() {
    return {
      /**
       * JS Path of the property in the item used for sorting the data.
       */
      path: String,
      /**
       * How to sort the data.
       * Possible values are `asc` to use an ascending algorithm, `desc` to sort the data in
       * descending direction, or `null` for not sorting the data.
       * @type {GridSorterDirection | undefined}
       */
      direction: {
        type: String,
        reflectToAttribute: true,
        notify: true,
        value: null,
        sync: true
      },
      /**
       * @type {number | null}
       * @protected
       */
      _order: {
        type: Number,
        value: null,
        sync: true
      }
    };
  }
  static get observers() {
    return ["_pathOrDirectionChanged(path, direction)"];
  }
  /** @protected */
  ready() {
    super.ready();
    this.addEventListener("click", this._onClick.bind(this));
  }
  /** @protected */
  connectedCallback() {
    super.connectedCallback();
    if (this._grid) {
      this._grid.__applySorters();
    } else {
      this.__dispatchSorterChangedEvenIfPossible();
    }
  }
  /** @protected */
  disconnectedCallback() {
    super.disconnectedCallback();
    if (!this.parentNode && this._grid) {
      this._grid.__removeSorters([this]);
    } else if (this._grid) {
      this._grid.__applySorters();
    }
  }
  /** @private */
  _pathOrDirectionChanged() {
    this.__dispatchSorterChangedEvenIfPossible();
  }
  /** @private */
  __dispatchSorterChangedEvenIfPossible() {
    if (this.path === void 0 || this.direction === void 0 || !this.isConnected) {
      return;
    }
    this.dispatchEvent(
      new CustomEvent("sorter-changed", {
        detail: { shiftClick: Boolean(this._shiftClick), fromSorterClick: Boolean(this._fromSorterClick) },
        bubbles: true,
        composed: true
      })
    );
    this._fromSorterClick = false;
    this._shiftClick = false;
  }
  /** @private */
  _getDisplayOrder(order) {
    return order === null ? "" : order + 1;
  }
  /** @private */
  _onClick(e2) {
    if (e2.defaultPrevented) {
      return;
    }
    const activeElement = this.getRootNode().activeElement;
    if (this !== activeElement && this.contains(activeElement)) {
      return;
    }
    e2.preventDefault();
    this._shiftClick = e2.shiftKey;
    this._fromSorterClick = true;
    if (this.direction === "asc") {
      this.direction = "desc";
    } else if (this.direction === "desc") {
      this.direction = null;
    } else {
      this.direction = "asc";
    }
  }
};
/**
 * @license
 * Copyright (c) 2016 - 2025 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
class GridSorter extends GridSorterMixin(ThemableMixin(DirMixin(PolymerElement))) {
  static get template() {
    return html`
      <div part="content">
        <slot></slot>
      </div>
      <div part="indicators">
        <span part="order">[[_getDisplayOrder(_order)]]</span>
      </div>
    `;
  }
  static get is() {
    return "vaadin-grid-sorter";
  }
}
defineCustomElement(GridSorter);
/**
 * @license
 * Copyright (c) 2016 - 2025 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const GridSelectionColumnBaseMixin = (superClass) => class GridSelectionColumnBaseMixin extends superClass {
  static get properties() {
    return {
      /**
       * Width of the cells for this column.
       */
      width: {
        type: String,
        value: "58px",
        sync: true
      },
      /**
       * Override `autoWidth` to enable auto-width
       */
      autoWidth: {
        type: Boolean,
        value: true
      },
      /**
       * Flex grow ratio for the cell widths. When set to 0, cell width is fixed.
       * @attr {number} flex-grow
       * @type {number}
       */
      flexGrow: {
        type: Number,
        value: 0,
        sync: true
      },
      /**
       * When true, all the items are selected.
       * @attr {boolean} select-all
       * @type {boolean}
       */
      selectAll: {
        type: Boolean,
        value: false,
        notify: true,
        sync: true
      },
      /**
       * When true, the active gets automatically selected.
       * @attr {boolean} auto-select
       * @type {boolean}
       */
      autoSelect: {
        type: Boolean,
        value: false,
        sync: true
      },
      /**
       * When true, rows can be selected by dragging over the selection column.
       * @attr {boolean} drag-select
       * @type {boolean}
       */
      dragSelect: {
        type: Boolean,
        value: false,
        sync: true
      },
      /** @protected */
      _indeterminate: {
        type: Boolean,
        sync: true
      },
      /** @protected */
      _selectAllHidden: Boolean,
      /**
       * Indicates whether the shift key is currently pressed.
       *
       * @protected
       */
      _shiftKeyDown: {
        type: Boolean,
        value: false
      }
    };
  }
  static get observers() {
    return [
      "_onHeaderRendererOrBindingChanged(_headerRenderer, _headerCell, path, header, selectAll, _indeterminate, _selectAllHidden)"
    ];
  }
  constructor() {
    super();
    this.__onCellTrack = this.__onCellTrack.bind(this);
    this.__onCellClick = this.__onCellClick.bind(this);
    this.__onCellMouseDown = this.__onCellMouseDown.bind(this);
    this.__onGridInteraction = this.__onGridInteraction.bind(this);
    this.__onActiveItemChanged = this.__onActiveItemChanged.bind(this);
    this.__onSelectRowCheckboxChange = this.__onSelectRowCheckboxChange.bind(this);
    this.__onSelectAllCheckboxChange = this.__onSelectAllCheckboxChange.bind(this);
  }
  /** @protected */
  connectedCallback() {
    super.connectedCallback();
    if (this._grid) {
      this._grid.addEventListener("keyup", this.__onGridInteraction);
      this._grid.addEventListener("keydown", this.__onGridInteraction, { capture: true });
      this._grid.addEventListener("mousedown", this.__onGridInteraction);
      this._grid.addEventListener("active-item-changed", this.__onActiveItemChanged);
    }
  }
  /** @protected */
  disconnectedCallback() {
    super.disconnectedCallback();
    if (this._grid) {
      this._grid.removeEventListener("keyup", this.__onGridInteraction);
      this._grid.removeEventListener("keydown", this.__onGridInteraction, { capture: true });
      this._grid.removeEventListener("mousedown", this.__onGridInteraction);
      this._grid.removeEventListener("active-item-changed", this.__onActiveItemChanged);
    }
  }
  /**
   * Renders the Select All checkbox to the header cell.
   *
   * @override
   */
  _defaultHeaderRenderer(root2, _column) {
    let checkbox = root2.firstElementChild;
    if (!checkbox) {
      checkbox = document.createElement("vaadin-checkbox");
      checkbox.setAttribute("aria-label", "Select All");
      checkbox.classList.add("vaadin-grid-select-all-checkbox");
      checkbox.addEventListener("change", this.__onSelectAllCheckboxChange);
      root2.appendChild(checkbox);
    }
    const checked = this.__isChecked(this.selectAll, this._indeterminate);
    checkbox.checked = checked;
    checkbox.hidden = this._selectAllHidden;
    checkbox.indeterminate = this._indeterminate;
  }
  /**
   * Renders the Select Row checkbox to the body cell.
   *
   * @override
   */
  _defaultRenderer(root2, _column, { item: item2, selected }) {
    let checkbox = root2.firstElementChild;
    if (!checkbox) {
      checkbox = document.createElement("vaadin-checkbox");
      checkbox.setAttribute("aria-label", "Select Row");
      checkbox.addEventListener("change", this.__onSelectRowCheckboxChange);
      root2.appendChild(checkbox);
      addListener(root2, "track", this.__onCellTrack);
      root2.addEventListener("mousedown", this.__onCellMouseDown);
      root2.addEventListener("click", this.__onCellClick);
    }
    checkbox.__item = item2;
    checkbox.checked = selected;
    const isSelectable = this._grid.__isItemSelectable(item2);
    checkbox.readonly = !isSelectable;
    checkbox.hidden = !isSelectable && !selected;
  }
  /**
   * Updates the select all state when the Select All checkbox is switched.
   * The listener handles only user-fired events.
   *
   * @private
   */
  __onSelectAllCheckboxChange(e2) {
    if (this._indeterminate || e2.currentTarget.checked) {
      this._selectAll();
    } else {
      this._deselectAll();
    }
  }
  /** @private */
  __onGridInteraction(e2) {
    this._shiftKeyDown = e2.shiftKey;
    if (this.autoSelect) {
      this._grid.$.scroller.toggleAttribute("range-selecting", this._shiftKeyDown);
    }
  }
  /**
   * Selects or deselects the row when the Select Row checkbox is switched.
   * The listener handles only user-fired events.
   *
   * @private
   */
  __onSelectRowCheckboxChange(e2) {
    this.__toggleItem(e2.currentTarget.__item, e2.currentTarget.checked);
  }
  /** @private */
  __onCellTrack(event) {
    if (!this.dragSelect) {
      return;
    }
    this.__dragCurrentY = event.detail.y;
    this.__dragDy = event.detail.dy;
    if (event.detail.state === "start") {
      const renderedRows = this._grid._getRenderedRows();
      const dragStartRow = renderedRows.find((row) => row.contains(event.currentTarget.assignedSlot));
      this.__selectOnDrag = !this._grid._isSelected(dragStartRow._item);
      this.__dragStartIndex = dragStartRow.index;
      this.__dragStartItem = dragStartRow._item;
      this.__dragAutoScroller();
    } else if (event.detail.state === "end") {
      if (this.__dragStartItem) {
        this.__toggleItem(this.__dragStartItem, this.__selectOnDrag);
      }
      setTimeout(() => {
        this.__dragStartIndex = void 0;
      });
    }
  }
  /** @private */
  __onCellMouseDown(e2) {
    if (this.dragSelect) {
      e2.preventDefault();
    }
  }
  /** @private */
  __onCellClick(e2) {
    if (this.__dragStartIndex !== void 0) {
      e2.preventDefault();
    }
  }
  /** @private */
  _onCellKeyDown(e2) {
    const target = e2.composedPath()[0];
    if (e2.keyCode !== 32) {
      return;
    }
    if (target === this._headerCell) {
      if (this.selectAll) {
        this._deselectAll();
      } else {
        this._selectAll();
      }
    } else if (this._cells.includes(target) && !this.autoSelect) {
      const checkbox = target._content.firstElementChild;
      this.__toggleItem(checkbox.__item);
    }
  }
  /** @private */
  __onActiveItemChanged(e2) {
    const activeItem = e2.detail.value;
    if (this.autoSelect) {
      const item2 = activeItem || this.__previousActiveItem;
      if (item2) {
        this.__toggleItem(item2);
      }
    }
    this.__previousActiveItem = activeItem;
  }
  /** @private */
  __dragAutoScroller() {
    if (this.__dragStartIndex === void 0) {
      return;
    }
    const renderedRows = this._grid._getRenderedRows();
    const hoveredRow = renderedRows.find((row) => {
      const rowRect = row.getBoundingClientRect();
      return this.__dragCurrentY >= rowRect.top && this.__dragCurrentY <= rowRect.bottom;
    });
    let hoveredIndex = hoveredRow ? hoveredRow.index : void 0;
    const scrollableArea = this.__getScrollableArea();
    if (this.__dragCurrentY < scrollableArea.top) {
      hoveredIndex = this._grid._firstVisibleIndex;
    } else if (this.__dragCurrentY > scrollableArea.bottom) {
      hoveredIndex = this._grid._lastVisibleIndex;
    }
    if (hoveredIndex !== void 0) {
      renderedRows.forEach((row) => {
        if (hoveredIndex > this.__dragStartIndex && row.index >= this.__dragStartIndex && row.index <= hoveredIndex || hoveredIndex < this.__dragStartIndex && row.index <= this.__dragStartIndex && row.index >= hoveredIndex) {
          this.__toggleItem(row._item, this.__selectOnDrag);
          this.__dragStartItem = void 0;
        }
      });
    }
    const scrollTriggerArea = scrollableArea.height * 0.15;
    const maxScrollAmount = 10;
    if (this.__dragDy < 0 && this.__dragCurrentY < scrollableArea.top + scrollTriggerArea) {
      const dy = scrollableArea.top + scrollTriggerArea - this.__dragCurrentY;
      const percentage = Math.min(1, dy / scrollTriggerArea);
      this._grid.$.table.scrollTop -= percentage * maxScrollAmount;
    }
    if (this.__dragDy > 0 && this.__dragCurrentY > scrollableArea.bottom - scrollTriggerArea) {
      const dy = this.__dragCurrentY - (scrollableArea.bottom - scrollTriggerArea);
      const percentage = Math.min(1, dy / scrollTriggerArea);
      this._grid.$.table.scrollTop += percentage * maxScrollAmount;
    }
    setTimeout(() => this.__dragAutoScroller(), 10);
  }
  /**
   * Gets the scrollable area of the grid as a bounding client rect. The
   * scrollable area is the bounding rect of the grid minus the header and
   * footer.
   *
   * @private
   */
  __getScrollableArea() {
    const gridRect = this._grid.$.table.getBoundingClientRect();
    const headerRect = this._grid.$.header.getBoundingClientRect();
    const footerRect = this._grid.$.footer.getBoundingClientRect();
    return {
      top: gridRect.top + headerRect.height,
      bottom: gridRect.bottom - footerRect.height,
      left: gridRect.left,
      right: gridRect.right,
      height: gridRect.height - headerRect.height - footerRect.height,
      width: gridRect.width
    };
  }
  /**
   * Override to handle the user selecting all items.
   * @protected
   */
  _selectAll() {
  }
  /**
   * Override to handle the user deselecting all items.
   * @protected
   */
  _deselectAll() {
  }
  /**
   * Override to handle the user selecting an item.
   * @param {Object} item the item to select
   * @protected
   */
  _selectItem(_item) {
  }
  /**
   * Override to handle the user deselecting an item.
   * @param {Object} item the item to deselect
   * @protected
   */
  _deselectItem(_item) {
  }
  /**
   * Toggles the selected state of the given item.
   *
   * @param item the item to toggle
   * @param {boolean} [selected] whether to select or deselect the item
   * @private
   */
  __toggleItem(item2, selected = !this._grid._isSelected(item2)) {
    if (selected === this._grid._isSelected(item2)) {
      return;
    }
    if (selected) {
      this._selectItem(item2);
    } else {
      this._deselectItem(item2);
    }
  }
  /**
   * IOS needs indeterminate + checked at the same time
   * @private
   */
  __isChecked(selectAll, indeterminate) {
    return indeterminate || selectAll;
  }
};
class GridFlowSelectionColumn extends GridSelectionColumnBaseMixin(GridColumn) {
  static get is() {
    return "vaadin-grid-flow-selection-column";
  }
  static get properties() {
    return {
      /**
       * Override property to enable auto-width
       */
      autoWidth: {
        type: Boolean,
        value: true
      },
      /**
       * Override property to set custom width
       */
      width: {
        type: String,
        value: "56px"
      }
    };
  }
  /**
   * Override method from `GridSelectionColumnBaseMixin` to add ID to select all
   * checkbox
   *
   * @override
   */
  _defaultHeaderRenderer(root2, _column) {
    super._defaultHeaderRenderer(root2, _column);
    const checkbox = root2.firstElementChild;
    if (checkbox) {
      checkbox.id = "selectAllCheckbox";
    }
  }
  /**
   * Override a method from `GridSelectionColumnBaseMixin` to handle the user
   * selecting all items.
   *
   * @protected
   * @override
   */
  _selectAll() {
    this.selectAll = true;
    this.$server.selectAll();
  }
  /**
   * Override a method from `GridSelectionColumnBaseMixin` to handle the user
   * deselecting all items.
   *
   * @protected
   * @override
   */
  _deselectAll() {
    this.selectAll = false;
    this.$server.deselectAll();
  }
  /**
   * Override a method from `GridSelectionColumnBaseMixin` to handle the user
   * selecting an item.
   *
   * @param {Object} item the item to select
   * @protected
   * @override
   */
  _selectItem(item2) {
    this.$server.setShiftKeyDown(this._shiftKeyDown);
    this._grid.$connector.doSelection([item2], true);
  }
  /**
   * Override a method from `GridSelectionColumnBaseMixin` to handle the user
   * deselecting an item.
   *
   * @param {Object} item the item to deselect
   * @protected
   * @override
   */
  _deselectItem(item2) {
    this.$server.setShiftKeyDown(this._shiftKeyDown);
    this._grid.$connector.doDeselection([item2], true);
    this.selectAll = false;
  }
}
customElements.define(GridFlowSelectionColumn.is, GridFlowSelectionColumn);
window.Vaadin.Flow.gridConnector = {};
window.Vaadin.Flow.gridConnector.initLazy = (grid) => {
  if (grid.$connector) {
    return;
  }
  const dataProviderController = grid._dataProviderController;
  dataProviderController.ensureFlatIndexHierarchyOriginal = dataProviderController.ensureFlatIndexHierarchy;
  dataProviderController.ensureFlatIndexHierarchy = function(flatIndex) {
    const { item: item2 } = this.getFlatIndexContext(flatIndex);
    if (!item2 || !this.isExpanded(item2)) {
      return;
    }
    const isCached = grid.$connector.hasCacheForParentKey(grid.getItemId(item2));
    if (isCached) {
      this.ensureFlatIndexHierarchyOriginal(flatIndex);
    } else {
      grid.$connector.beforeEnsureFlatIndexHierarchy(flatIndex, item2);
    }
  };
  dataProviderController.isLoadingOriginal = dataProviderController.isLoading;
  dataProviderController.isLoading = function() {
    return grid.$connector.hasEnsureSubCacheQueue() || this.isLoadingOriginal();
  };
  dataProviderController.getItemSubCache = function(item2) {
    return this.getItemContext(item2)?.subCache;
  };
  let cache = {};
  const parentRequestDelay = 50;
  const parentRequestBatchMaxSize = 20;
  let parentRequestQueue = [];
  let parentRequestDebouncer;
  let ensureSubCacheQueue = [];
  let ensureSubCacheDebouncer;
  const rootRequestDelay = 150;
  let rootRequestDebouncer;
  let lastRequestedRanges = {};
  const root2 = "null";
  lastRequestedRanges[root2] = [0, 0];
  let currentUpdateClearRange = null;
  let currentUpdateSetRange = null;
  const validSelectionModes = ["SINGLE", "NONE", "MULTI"];
  let selectedKeys = {};
  let selectionMode = "SINGLE";
  let sorterDirectionsSetFromServer = false;
  grid.size = 0;
  grid.itemIdPath = "key";
  function createEmptyItemFromKey(key) {
    return { [grid.itemIdPath]: key };
  }
  grid.$connector = {};
  grid.$connector.hasCacheForParentKey = (parentKey) => cache[parentKey]?.size !== void 0;
  grid.$connector.hasEnsureSubCacheQueue = () => ensureSubCacheQueue.length > 0;
  grid.$connector.hasParentRequestQueue = () => parentRequestQueue.length > 0;
  grid.$connector.hasRootRequestQueue = () => {
    const { pendingRequests } = dataProviderController.rootCache;
    return Object.keys(pendingRequests).length > 0 || !!rootRequestDebouncer?.isActive();
  };
  grid.$connector.beforeEnsureFlatIndexHierarchy = function(flatIndex, item2) {
    ensureSubCacheQueue.push({
      flatIndex,
      itemkey: grid.getItemId(item2)
    });
    ensureSubCacheDebouncer = Debouncer2.debounce(ensureSubCacheDebouncer, animationFrame, () => {
      while (ensureSubCacheQueue.length) {
        grid.$connector.flushEnsureSubCache();
      }
    });
  };
  grid.$connector.doSelection = function(items, userOriginated) {
    if (selectionMode === "NONE" || !items.length || userOriginated && grid.hasAttribute("disabled")) {
      return;
    }
    if (selectionMode === "SINGLE") {
      selectedKeys = {};
    }
    let selectedItemsChanged = false;
    items.forEach((item2) => {
      const selectable = !userOriginated || grid.isItemSelectable(item2);
      selectedItemsChanged = selectedItemsChanged || selectable;
      if (item2 && selectable) {
        selectedKeys[item2.key] = item2;
        item2.selected = true;
        if (userOriginated) {
          grid.$server.select(item2.key);
        }
      }
      const isSelectedItemDifferentOrNull = !grid.activeItem || !item2 || item2.key != grid.activeItem.key;
      if (!userOriginated && selectionMode === "SINGLE" && isSelectedItemDifferentOrNull) {
        grid.activeItem = item2;
      }
    });
    if (selectedItemsChanged) {
      grid.selectedItems = Object.values(selectedKeys);
    }
  };
  grid.$connector.doDeselection = function(items, userOriginated) {
    if (selectionMode === "NONE" || !items.length || userOriginated && grid.hasAttribute("disabled")) {
      return;
    }
    const updatedSelectedItems = grid.selectedItems.slice();
    while (items.length) {
      const itemToDeselect = items.shift();
      const selectable = !userOriginated || grid.isItemSelectable(itemToDeselect);
      if (!selectable) {
        continue;
      }
      for (let i2 = 0; i2 < updatedSelectedItems.length; i2++) {
        const selectedItem = updatedSelectedItems[i2];
        if (itemToDeselect?.key === selectedItem.key) {
          updatedSelectedItems.splice(i2, 1);
          break;
        }
      }
      if (itemToDeselect) {
        delete selectedKeys[itemToDeselect.key];
        delete itemToDeselect.selected;
        if (userOriginated) {
          grid.$server.deselect(itemToDeselect.key);
        }
      }
    }
    grid.selectedItems = updatedSelectedItems;
  };
  grid.__activeItemChanged = function(newVal, oldVal) {
    if (selectionMode != "SINGLE") {
      return;
    }
    if (!newVal) {
      if (oldVal && selectedKeys[oldVal.key]) {
        if (grid.__deselectDisallowed) {
          grid.activeItem = oldVal;
        } else {
          oldVal = dataProviderController.getItemContext(oldVal).item;
          grid.$connector.doDeselection([oldVal], true);
        }
      }
    } else if (!selectedKeys[newVal.key]) {
      grid.$connector.doSelection([newVal], true);
    }
  };
  grid._createPropertyObserver("activeItem", "__activeItemChanged", true);
  grid.__activeItemChangedDetails = function(newVal, oldVal) {
    if (grid.__disallowDetailsOnClick) {
      return;
    }
    if (newVal == null && oldVal === void 0) {
      return;
    }
    if (newVal && !newVal.detailsOpened) {
      grid.$server.setDetailsVisible(newVal.key);
    } else {
      grid.$server.setDetailsVisible(null);
    }
  };
  grid._createPropertyObserver("activeItem", "__activeItemChangedDetails", true);
  grid.$connector._getSameLevelPage = function(parentKey, currentCache, currentCacheItemIndex) {
    const currentParentKey = currentCache.parentItem ? grid.getItemId(currentCache.parentItem) : root2;
    if (currentParentKey === parentKey) {
      return Math.floor(currentCacheItemIndex / grid.pageSize);
    }
    const { parentCache, parentCacheIndex } = currentCache;
    if (!parentCache) {
      return null;
    }
    return this._getSameLevelPage(parentKey, parentCache, parentCacheIndex);
  };
  grid.$connector.flushEnsureSubCache = function() {
    const pendingFetch = ensureSubCacheQueue.shift();
    if (pendingFetch) {
      dataProviderController.ensureFlatIndexHierarchyOriginal(pendingFetch.flatIndex);
      return true;
    }
    return false;
  };
  grid.$connector.debounceRootRequest = function(page) {
    const delay = grid._hasData ? rootRequestDelay : 0;
    rootRequestDebouncer = Debouncer2.debounce(rootRequestDebouncer, timeOut.after(delay), () => {
      grid.$connector.fetchPage((firstIndex, size) => grid.$server.setRequestedRange(firstIndex, size), page, root2);
    });
  };
  grid.$connector.flushParentRequests = function() {
    const pendingFetches = [];
    parentRequestQueue.splice(0, parentRequestBatchMaxSize).forEach(({ parentKey, page }) => {
      grid.$connector.fetchPage(
        (firstIndex, size) => pendingFetches.push({ parentKey, firstIndex, size }),
        page,
        parentKey
      );
    });
    if (pendingFetches.length) {
      grid.$server.setParentRequestedRanges(pendingFetches);
    }
  };
  grid.$connector.debounceParentRequest = function(parentKey, page) {
    parentRequestQueue = parentRequestQueue.filter((request) => request.parentKey !== parentKey);
    parentRequestQueue.push({ parentKey, page });
    parentRequestDebouncer = Debouncer2.debounce(parentRequestDebouncer, timeOut.after(parentRequestDelay), () => {
      while (parentRequestQueue.length) {
        grid.$connector.flushParentRequests();
      }
    });
  };
  grid.$connector.fetchPage = function(fetch2, page, parentKey) {
    if (parentKey === root2) {
      page = Math.min(page, Math.floor((grid.size - 1) / grid.pageSize));
    }
    const visibleRows = grid._getRenderedRows();
    let start = visibleRows.length > 0 ? visibleRows[0].index : 0;
    let end = visibleRows.length > 0 ? visibleRows[visibleRows.length - 1].index : 0;
    let buffer = end - start;
    let firstNeededIndex = Math.max(0, start - buffer);
    let lastNeededIndex = Math.min(end + buffer, grid._flatSize);
    let pageRange = [null, null];
    for (let idx = firstNeededIndex; idx <= lastNeededIndex; idx++) {
      const { cache: cache2, index } = dataProviderController.getFlatIndexContext(idx);
      const sameLevelPage = grid.$connector._getSameLevelPage(parentKey, cache2, index);
      if (sameLevelPage === null) {
        continue;
      }
      pageRange[0] = Math.min(pageRange[0] ?? sameLevelPage, sameLevelPage);
      pageRange[1] = Math.max(pageRange[1] ?? sameLevelPage, sameLevelPage);
    }
    if (pageRange.some((p) => p === null) || page < pageRange[0] || page > pageRange[1]) {
      pageRange = [page, page];
    }
    let lastRequestedRange = lastRequestedRanges[parentKey] || [-1, -1];
    if (lastRequestedRange[0] != pageRange[0] || lastRequestedRange[1] != pageRange[1]) {
      lastRequestedRanges[parentKey] = pageRange;
      let pageCount = pageRange[1] - pageRange[0] + 1;
      fetch2(pageRange[0] * grid.pageSize, pageCount * grid.pageSize);
    }
  };
  grid.dataProvider = function(params, callback) {
    if (params.pageSize != grid.pageSize) {
      throw "Invalid pageSize";
    }
    let page = params.page;
    if (params.parentItem) {
      let parentUniqueKey = grid.getItemId(params.parentItem);
      const parentItemSubCache = dataProviderController.getItemSubCache(params.parentItem);
      if (cache[parentUniqueKey]?.[page] && parentItemSubCache) {
        ensureSubCacheQueue = [];
        callback(cache[parentUniqueKey][page], cache[parentUniqueKey].size);
      } else {
        grid.$connector.debounceParentRequest(parentUniqueKey, page);
      }
    } else {
      if (grid.size === 0) {
        callback([], 0);
        return;
      }
      if (cache[root2]?.[page]) {
        callback(cache[root2][page]);
      } else {
        grid.$connector.debounceRootRequest(page);
      }
    }
  };
  grid.$connector.setSorterDirections = function(directions) {
    sorterDirectionsSetFromServer = true;
    setTimeout(() => {
      try {
        const sorters = Array.from(grid.querySelectorAll("vaadin-grid-sorter"));
        grid._sorters.forEach((sorter) => {
          if (!sorters.includes(sorter)) {
            sorters.push(sorter);
          }
        });
        sorters.forEach((sorter) => {
          sorter.direction = null;
        });
        if (grid.multiSortPriority !== "append") {
          directions = directions.reverse();
        }
        directions.forEach(({ column, direction }) => {
          sorters.forEach((sorter) => {
            if (sorter.getAttribute("path") === column) {
              sorter.direction = direction;
            }
          });
        });
        grid.__applySorters();
      } finally {
        sorterDirectionsSetFromServer = false;
      }
    });
  };
  grid._updateItem = function(row, item2) {
    Grid.prototype._updateItem.call(grid, row, item2);
    if (!row.hidden) {
      Array.from(row.children).forEach((cell) => {
        Array.from(cell?._content?.__templateInstance?.children || []).forEach((content) => {
          if (content._attachRenderedComponentIfAble) {
            content._attachRenderedComponentIfAble();
          }
          Array.from(content?.children || []).forEach((innerContent) => {
            if (innerContent._attachRenderedComponentIfAble) {
              innerContent._attachRenderedComponentIfAble();
            }
          });
        });
      });
    }
    if (selectionMode === validSelectionModes[1]) {
      row.removeAttribute("aria-selected");
      Array.from(row.children).forEach((cell) => cell.removeAttribute("aria-selected"));
    }
  };
  const itemExpandedChanged = function(item2, expanded) {
    if (item2 == void 0 || grid.$server.updateExpandedState == void 0) {
      return;
    }
    let parentKey = grid.getItemId(item2);
    grid.$server.updateExpandedState(parentKey, expanded);
  };
  grid.expandItem = function(item2) {
    itemExpandedChanged(item2, true);
    Grid.prototype.expandItem.call(grid, item2);
  };
  grid.collapseItem = function(item2) {
    itemExpandedChanged(item2, false);
    Grid.prototype.collapseItem.call(grid, item2);
  };
  const itemsUpdated = function(items) {
    if (!items || !Array.isArray(items)) {
      throw "Attempted to call itemsUpdated with an invalid value: " + JSON.stringify(items);
    }
    let detailsOpenedItems = Array.from(grid.detailsOpenedItems);
    for (let i2 = 0; i2 < items.length; ++i2) {
      const item2 = items[i2];
      if (!item2) {
        continue;
      }
      if (item2.detailsOpened) {
        if (grid._getItemIndexInArray(item2, detailsOpenedItems) < 0) {
          detailsOpenedItems.push(item2);
        }
      } else if (grid._getItemIndexInArray(item2, detailsOpenedItems) >= 0) {
        detailsOpenedItems.splice(grid._getItemIndexInArray(item2, detailsOpenedItems), 1);
      }
    }
    grid.detailsOpenedItems = detailsOpenedItems;
  };
  const updateGridCache = function(page, parentKey = root2) {
    const items = cache[parentKey][page];
    const parentItem = createEmptyItemFromKey(parentKey);
    let gridCache = parentKey === root2 ? dataProviderController.rootCache : dataProviderController.getItemSubCache(parentItem);
    if (gridCache && !gridCache.pendingRequests[page]) {
      gridCache.setPage(page, items || Array.from({ length: grid.pageSize }));
    }
    return items;
  };
  const updateAllGridRowsInDomBasedOnCache = function() {
    updateGridFlatSize();
    grid.__updateVisibleRows();
  };
  const updateGridFlatSize = function() {
    dataProviderController.recalculateFlatSize();
    grid._flatSize = dataProviderController.flatSize;
  };
  const updateGridItemsInDomBasedOnCache = function(items) {
    if (!items || !grid.$ || grid.$.items.childElementCount === 0) {
      return;
    }
    const itemKeys = items.map((item2) => item2.key);
    const indexes = grid._getRenderedRows().filter((row) => row._item && itemKeys.includes(row._item.key)).map((row) => row.index);
    if (indexes.length > 0) {
      grid.__updateVisibleRows(indexes[0], indexes[indexes.length - 1]);
    }
  };
  grid.$connector.set = function(index, items, parentKey) {
    if (index % grid.pageSize != 0) {
      throw "Got new data to index " + index + " which is not aligned with the page size of " + grid.pageSize;
    }
    let pkey = parentKey || root2;
    const firstPage = index / grid.pageSize;
    const updatedPageCount = Math.ceil(items.length / grid.pageSize);
    if (pkey === root2) {
      currentUpdateSetRange = [firstPage, firstPage + updatedPageCount - 1];
    }
    for (let i2 = 0; i2 < updatedPageCount; i2++) {
      let page = firstPage + i2;
      let slice = items.slice(i2 * grid.pageSize, (i2 + 1) * grid.pageSize);
      if (!cache[pkey]) {
        cache[pkey] = {};
      }
      cache[pkey][page] = slice;
      grid.$connector.doSelection(slice.filter((item2) => item2.selected));
      grid.$connector.doDeselection(slice.filter((item2) => !item2.selected && selectedKeys[item2.key]));
      const updatedItems = updateGridCache(page, pkey);
      if (updatedItems) {
        itemsUpdated(updatedItems);
        updateGridItemsInDomBasedOnCache(updatedItems);
      }
    }
  };
  const itemToCacheLocation = function(item2) {
    let parent = item2.parentUniqueKey || root2;
    if (cache[parent]) {
      for (let page in cache[parent]) {
        for (let index in cache[parent][page]) {
          if (grid.getItemId(cache[parent][page][index]) === grid.getItemId(item2)) {
            return { page, index, parentKey: parent };
          }
        }
      }
    }
    return null;
  };
  grid.$connector.updateHierarchicalData = function(updatedItems) {
    let pagesToUpdate = [];
    for (let i2 = 0; i2 < updatedItems.length; i2++) {
      let cacheLocation = itemToCacheLocation(updatedItems[i2]);
      if (cacheLocation) {
        cache[cacheLocation.parentKey][cacheLocation.page][cacheLocation.index] = updatedItems[i2];
        let key = cacheLocation.parentKey + ":" + cacheLocation.page;
        if (!pagesToUpdate[key]) {
          pagesToUpdate[key] = {
            parentKey: cacheLocation.parentKey,
            page: cacheLocation.page
          };
        }
      }
    }
    let keys = Object.keys(pagesToUpdate);
    for (let i2 = 0; i2 < keys.length; i2++) {
      let pageToUpdate = pagesToUpdate[keys[i2]];
      const affectedUpdatedItems = updateGridCache(pageToUpdate.page, pageToUpdate.parentKey);
      if (affectedUpdatedItems) {
        itemsUpdated(affectedUpdatedItems);
        updateGridItemsInDomBasedOnCache(affectedUpdatedItems);
      }
    }
  };
  grid.$connector.updateFlatData = function(updatedItems) {
    for (let i2 = 0; i2 < updatedItems.length; i2++) {
      let cacheLocation = itemToCacheLocation(updatedItems[i2]);
      if (cacheLocation) {
        cache[cacheLocation.parentKey][cacheLocation.page][cacheLocation.index] = updatedItems[i2];
        const index = parseInt(cacheLocation.page) * grid.pageSize + parseInt(cacheLocation.index);
        const { rootCache } = dataProviderController;
        if (rootCache.items[index]) {
          rootCache.items[index] = updatedItems[i2];
        }
      }
    }
    itemsUpdated(updatedItems);
    updateGridItemsInDomBasedOnCache(updatedItems);
  };
  grid.$connector.clearExpanded = function() {
    grid.expandedItems = [];
    ensureSubCacheQueue = [];
    parentRequestQueue = [];
  };
  const sanitizeLastRequestedRange = function() {
    const range = lastRequestedRanges[root2];
    if (!range || !currentUpdateClearRange) {
      return;
    }
    const numClearedPages = currentUpdateClearRange[1] - currentUpdateClearRange[0] + 1;
    const clearedPages = Array.from({ length: numClearedPages }, (_, i2) => currentUpdateClearRange[0] + i2);
    if (currentUpdateSetRange) {
      const [first, last] = currentUpdateSetRange;
      for (let page = first; page <= last; page++) {
        const index = clearedPages.indexOf(page);
        if (index >= 0) {
          clearedPages.splice(index, 1);
        }
      }
    }
    if (clearedPages.some((page) => page >= range[0] && page <= range[1])) {
      range[0] = -1;
      range[1] = -1;
    }
  };
  grid.$connector.clear = function(index, length, parentKey) {
    let pkey = parentKey || root2;
    if (!cache[pkey] || Object.keys(cache[pkey]).length === 0) {
      return;
    }
    if (index % grid.pageSize != 0) {
      throw "Got cleared data for index " + index + " which is not aligned with the page size of " + grid.pageSize;
    }
    let firstPage = Math.floor(index / grid.pageSize);
    let updatedPageCount = Math.ceil(length / grid.pageSize);
    if (pkey === root2) {
      currentUpdateClearRange = [firstPage, firstPage + updatedPageCount - 1];
    }
    for (let i2 = 0; i2 < updatedPageCount; i2++) {
      let page = firstPage + i2;
      let items = cache[pkey][page];
      grid.$connector.doDeselection(items.filter((item2) => selectedKeys[item2.key]));
      items.forEach((item2) => grid.closeItemDetails(item2));
      delete cache[pkey][page];
      updateGridCache(page, parentKey);
      updateGridItemsInDomBasedOnCache(items);
    }
    let cacheToClear = dataProviderController.rootCache;
    if (parentKey) {
      const parentItem = createEmptyItemFromKey(pkey);
      cacheToClear = dataProviderController.getItemSubCache(parentItem);
    }
    const endIndex = index + updatedPageCount * grid.pageSize;
    for (let itemIndex = index; itemIndex < endIndex; itemIndex++) {
      delete cacheToClear.items[itemIndex];
      cacheToClear.removeSubCache(itemIndex);
    }
    updateGridFlatSize();
  };
  grid.$connector.reset = function() {
    cache = {};
    dataProviderController.rootCache.items = [];
    lastRequestedRanges = {};
    if (ensureSubCacheDebouncer) {
      ensureSubCacheDebouncer.cancel();
    }
    if (parentRequestDebouncer) {
      parentRequestDebouncer.cancel();
    }
    if (rootRequestDebouncer) {
      rootRequestDebouncer.cancel();
    }
    ensureSubCacheDebouncer = void 0;
    parentRequestDebouncer = void 0;
    ensureSubCacheQueue = [];
    parentRequestQueue = [];
    updateAllGridRowsInDomBasedOnCache();
  };
  grid.$connector.updateSize = (newSize) => grid.size = newSize;
  grid.$connector.updateUniqueItemIdPath = (path) => grid.itemIdPath = path;
  grid.$connector.expandItems = function(items) {
    let newExpandedItems = Array.from(grid.expandedItems);
    items.filter((item2) => !grid._isExpanded(item2)).forEach((item2) => newExpandedItems.push(item2));
    grid.expandedItems = newExpandedItems;
  };
  grid.$connector.collapseItems = function(items) {
    let newExpandedItems = Array.from(grid.expandedItems);
    items.forEach((item2) => {
      let index = grid._getItemIndexInArray(item2, newExpandedItems);
      if (index >= 0) {
        newExpandedItems.splice(index, 1);
      }
    });
    grid.expandedItems = newExpandedItems;
    items.forEach((item2) => grid.$connector.removeFromQueue(item2));
  };
  grid.$connector.removeFromQueue = function(item2) {
    const itemSubCache = dataProviderController.getItemSubCache(item2);
    Object.values(itemSubCache?.pendingRequests || {}).forEach((callback) => callback([]));
    const itemId = grid.getItemId(item2);
    ensureSubCacheQueue = ensureSubCacheQueue.filter((item22) => item22.itemkey !== itemId);
    parentRequestQueue = parentRequestQueue.filter((item22) => item22.parentKey !== itemId);
  };
  grid.$connector.confirmParent = function(id, parentKey, levelSize) {
    if (!cache[parentKey]) {
      cache[parentKey] = {};
    }
    const hasSizeChanged = cache[parentKey].size !== levelSize;
    cache[parentKey].size = levelSize;
    if (levelSize === 0) {
      cache[parentKey][0] = [];
    }
    const parentItem = createEmptyItemFromKey(parentKey);
    const parentItemSubCache = dataProviderController.getItemSubCache(parentItem);
    if (parentItemSubCache) {
      const { pendingRequests } = parentItemSubCache;
      Object.entries(pendingRequests).forEach(([page, callback]) => {
        let lastRequestedRange = lastRequestedRanges[parentKey] || [0, 0];
        if (cache[parentKey] && cache[parentKey][page] || page < lastRequestedRange[0] || page > lastRequestedRange[1]) {
          let items = cache[parentKey][page] || new Array(levelSize);
          callback(items, levelSize);
        } else if (callback && levelSize === 0) {
          callback([], levelSize);
        }
      });
      if (hasSizeChanged && Object.keys(pendingRequests).length === 0) {
        parentItemSubCache.size = levelSize;
        updateGridFlatSize();
      }
    }
    grid.$server.confirmParentUpdate(id, parentKey);
  };
  grid.$connector.confirm = function(id) {
    const { pendingRequests } = dataProviderController.rootCache;
    Object.entries(pendingRequests).forEach(([page, callback]) => {
      const lastRequestedRange = lastRequestedRanges[root2] || [0, 0];
      const lastAvailablePage = grid.size ? Math.ceil(grid.size / grid.pageSize) - 1 : 0;
      const lastRequestedRangeEnd = Math.min(lastRequestedRange[1], lastAvailablePage);
      if (cache[root2]?.[page]) {
        callback(cache[root2][page]);
      } else if (page < lastRequestedRange[0] || +page > lastRequestedRangeEnd) {
        callback(new Array(grid.pageSize));
        grid.requestContentUpdate();
      } else if (callback && grid.size === 0) {
        callback([]);
      }
    });
    sanitizeLastRequestedRange();
    currentUpdateSetRange = null;
    currentUpdateClearRange = null;
    grid.$server.confirmUpdate(id);
  };
  grid.$connector.ensureHierarchy = function() {
    for (let parentKey in cache) {
      if (parentKey !== root2) {
        delete cache[parentKey];
      }
    }
    lastRequestedRanges = {};
    dataProviderController.rootCache.removeSubCaches();
    updateAllGridRowsInDomBasedOnCache();
  };
  grid.$connector.setSelectionMode = function(mode) {
    if ((typeof mode === "string" || mode instanceof String) && validSelectionModes.indexOf(mode) >= 0) {
      selectionMode = mode;
      selectedKeys = {};
      grid.selectedItems = [];
      grid.$connector.updateMultiSelectable();
    } else {
      throw "Attempted to set an invalid selection mode";
    }
  };
  grid.$connector.updateMultiSelectable = function() {
    if (!grid.$) {
      return;
    }
    if (selectionMode === validSelectionModes[0]) {
      grid.$.table.setAttribute("aria-multiselectable", false);
    } else if (selectionMode === validSelectionModes[1]) {
      grid.$.table.removeAttribute("aria-multiselectable");
    } else {
      grid.$.table.setAttribute("aria-multiselectable", true);
    }
  };
  grid._createPropertyObserver("isAttached", () => grid.$connector.updateMultiSelectable());
  const singleTimeRenderer = (renderer) => {
    return (root22) => {
      if (renderer) {
        renderer(root22);
        renderer = null;
      }
    };
  };
  grid.$connector.setHeaderRenderer = function(column, options) {
    const { content, showSorter, sorterPath } = options;
    if (content === null) {
      column.headerRenderer = null;
      return;
    }
    column.headerRenderer = singleTimeRenderer((root22) => {
      root22.innerHTML = "";
      let contentRoot = root22;
      if (showSorter) {
        const sorter = document.createElement("vaadin-grid-sorter");
        sorter.setAttribute("path", sorterPath);
        const ariaLabel = content instanceof Node ? content.textContent : content;
        if (ariaLabel) {
          sorter.setAttribute("aria-label", `Sort by ${ariaLabel}`);
        }
        root22.appendChild(sorter);
        contentRoot = sorter;
      }
      if (content instanceof Node) {
        contentRoot.appendChild(content);
      } else {
        contentRoot.textContent = content;
      }
    });
  };
  grid._getActiveSorters = function() {
    return this._sorters.filter((sorter) => sorter.direction);
  };
  grid.__applySorters = () => {
    const sorters = grid._mapSorters();
    const sortersChanged = JSON.stringify(grid._previousSorters) !== JSON.stringify(sorters);
    grid._previousSorters = sorters;
    Grid.prototype.__applySorters.call(grid);
    if (sortersChanged && !sorterDirectionsSetFromServer) {
      grid.$server.sortersChanged(sorters);
    }
  };
  grid.$connector.setFooterRenderer = function(column, options) {
    const { content } = options;
    if (content === null) {
      column.footerRenderer = null;
      return;
    }
    column.footerRenderer = singleTimeRenderer((root22) => {
      root22.innerHTML = "";
      if (content instanceof Node) {
        root22.appendChild(content);
      } else {
        root22.textContent = content;
      }
    });
  };
  grid.addEventListener("vaadin-context-menu-before-open", function(e2) {
    const { key, columnId } = e2.detail;
    grid.$server.updateContextMenuTargetItem(key, columnId);
  });
  grid.getContextMenuBeforeOpenDetail = function(event) {
    const sourceEvent = event.detail.sourceEvent || event;
    const eventContext = grid.getEventContext(sourceEvent);
    const key = eventContext.item?.key || "";
    const columnId = eventContext.column?.id || "";
    return { key, columnId };
  };
  grid.preventContextMenu = function(event) {
    const isLeftClick = event.type === "click";
    const { column } = grid.getEventContext(event);
    return isLeftClick && column instanceof GridFlowSelectionColumn;
  };
  grid.addEventListener("click", (e2) => _fireClickEvent(e2, "item-click"));
  grid.addEventListener("dblclick", (e2) => _fireClickEvent(e2, "item-double-click"));
  grid.addEventListener("column-resize", (e2) => {
    const cols = grid._getColumnsInOrder().filter((col) => !col.hidden);
    cols.forEach((col) => {
      col.dispatchEvent(new CustomEvent("column-drag-resize"));
    });
    grid.dispatchEvent(
      new CustomEvent("column-drag-resize", {
        detail: {
          resizedColumnKey: e2.detail.resizedColumn._flowId
        }
      })
    );
  });
  grid.addEventListener("column-reorder", (e2) => {
    const columns = grid._columnTree.slice(0).pop().filter((c2) => c2._flowId).sort((b2, a3) => b2._order - a3._order).map((c2) => c2._flowId);
    grid.dispatchEvent(
      new CustomEvent("column-reorder-all-columns", {
        detail: { columns }
      })
    );
  });
  grid.addEventListener("cell-focus", (e2) => {
    const eventContext = grid.getEventContext(e2);
    const expectedSectionValues = ["header", "body", "footer"];
    if (expectedSectionValues.indexOf(eventContext.section) === -1) {
      return;
    }
    grid.dispatchEvent(
      new CustomEvent("grid-cell-focus", {
        detail: {
          itemKey: eventContext.item ? eventContext.item.key : null,
          internalColumnId: eventContext.column ? eventContext.column._flowId : null,
          section: eventContext.section
        }
      })
    );
  });
  function _fireClickEvent(event, eventName) {
    if (event.defaultPrevented) {
      return;
    }
    const path = event.composedPath();
    const idx = path.findIndex((node) => node.localName === "td" || node.localName === "th");
    const cell = path[idx];
    const content = path.slice(0, idx);
    if (content.some((node) => {
      const focusable = cell?._focusButton !== node && isFocusable(node);
      return focusable || node instanceof HTMLLabelElement;
    })) {
      return;
    }
    const eventContext = grid.getEventContext(event);
    const section = eventContext.section;
    if (eventContext.item && section !== "details") {
      event.itemKey = eventContext.item.key;
      if (eventContext.column) {
        event.internalColumnId = eventContext.column._flowId;
      }
      grid.dispatchEvent(new CustomEvent(eventName, { detail: event }));
    }
  }
  grid.cellClassNameGenerator = function(column, rowData) {
    const style = rowData.item.style;
    if (!style) {
      return;
    }
    return (style.row || "") + " " + (column && style[column._flowId] || "");
  };
  grid.cellPartNameGenerator = function(column, rowData) {
    const part = rowData.item.part;
    if (!part) {
      return;
    }
    return (part.row || "") + " " + (column && part[column._flowId] || "");
  };
  grid.dropFilter = (rowData) => rowData.item && !rowData.item.dropDisabled;
  grid.dragFilter = (rowData) => rowData.item && !rowData.item.dragDisabled;
  grid.addEventListener("grid-dragstart", (e2) => {
    if (grid._isSelected(e2.detail.draggedItems[0])) {
      if (grid.__selectionDragData) {
        Object.keys(grid.__selectionDragData).forEach((type) => {
          e2.detail.setDragData(type, grid.__selectionDragData[type]);
        });
      } else {
        (grid.__dragDataTypes || []).forEach((type) => {
          e2.detail.setDragData(type, e2.detail.draggedItems.map((item2) => item2.dragData[type]).join("\n"));
        });
      }
      if (grid.__selectionDraggedItemsCount > 1) {
        e2.detail.setDraggedItemsCount(grid.__selectionDraggedItemsCount);
      }
    } else {
      (grid.__dragDataTypes || []).forEach((type) => {
        e2.detail.setDragData(type, e2.detail.draggedItems[0].dragData[type]);
      });
    }
  });
  grid.isItemSelectable = (item2) => {
    return item2?.selectable === void 0 || item2.selectable;
  };
};
registerStyles$1(
  "vaadin-icon",
  css`
    :host {
      width: var(--lumo-icon-size-m);
      height: var(--lumo-icon-size-m);
    }
  `,
  { moduleId: "lumo-icon" }
);
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const HTML_RESULT = 1;
class UnsafeHTMLDirective extends Directive {
  constructor(partInfo) {
    super(partInfo);
    this._value = nothing;
    if (partInfo.type !== PartType.CHILD) {
      throw new Error(`${this.constructor.directiveName}() can only be used in child bindings`);
    }
  }
  render(value) {
    if (value === nothing || value == null) {
      this._templateResult = void 0;
      return this._value = value;
    }
    if (value === noChange) {
      return value;
    }
    if (typeof value != "string") {
      throw new Error(`${this.constructor.directiveName}() called with a non-string value`);
    }
    if (value === this._value) {
      return this._templateResult;
    }
    this._value = value;
    const strings = [value];
    strings.raw = strings;
    return this._templateResult = {
      // Cast to a known set of integers that satisfy ResultType so that we
      // don't have to export ResultType and possibly encourage this pattern.
      // This property needs to remain unminified.
      ["_$litType$"]: this.constructor.resultType,
      strings,
      values: []
    };
  }
}
UnsafeHTMLDirective.directiveName = "unsafeHTML";
UnsafeHTMLDirective.resultType = HTML_RESULT;
/**
 * @license
 * Copyright 2017 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
const SVG_RESULT = 2;
class UnsafeSVGDirective extends UnsafeHTMLDirective {
}
UnsafeSVGDirective.directiveName = "unsafeSVG";
UnsafeSVGDirective.resultType = SVG_RESULT;
const unsafeSVG = directive(UnsafeSVGDirective);
/**
 * @license
 * Copyright (c) 2021 - 2025 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
function cloneSvgNode(source) {
  let result = nothing;
  if (source) {
    const content = source.cloneNode(true);
    content.removeAttribute("id");
    result = svg`${unsafeSVG(content.outerHTML)}`;
  }
  return result;
}
function isValidSvg(source) {
  return isTemplateResult(source, TemplateResultType.SVG) || source === nothing;
}
function ensureSvgLiteral(source) {
  let result = source == null || source === "" ? nothing : source;
  if (!isValidSvg(result)) {
    console.error("[vaadin-icon] Invalid svg passed, please use Lit svg literal.");
    result = nothing;
  }
  return result;
}
function renderSvg(source, container) {
  const result = ensureSvgLiteral(source);
  render(result, container);
}
function unsafeSvgLiteral(source) {
  return svg`${unsafeSVG(source)}`;
}
/**
 * @license
 * Copyright (c) 2021 - 2025 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const iconsetRegistry = {};
const attachedIcons = /* @__PURE__ */ new Set();
function getIconId(id, name) {
  return (id || "").replace(`${name}:`, "");
}
function getIconsetName(icon) {
  if (!icon) {
    return;
  }
  const parts = icon.split(":");
  return parts[0] || "vaadin";
}
function initIconsMap(iconset, name) {
  iconset._icons = [...iconset.querySelectorAll("[id]")].reduce((map, svg2) => {
    const key = getIconId(svg2.id, name);
    map[key] = svg2;
    return map;
  }, {});
}
const IconsetMixin = (superClass) => class extends superClass {
  static get observedAttributes() {
    return ["name", "size"];
  }
  /**
   * Set of the `vaadin-icon` instances in the DOM.
   *
   * @return {Set<Icon>}
   */
  static get attachedIcons() {
    return attachedIcons;
  }
  /**
   * Returns an instance of the iconset by its name.
   *
   * @param {string} name
   * @return {Iconset}
   */
  static getIconset(name) {
    return iconsetRegistry[name];
  }
  /**
   * Returns SVGTemplateResult for the `icon` ID matching `name` of the
   * iconset, or `nothing` literal if there is no matching icon found.
   *
   * @param {string} icon
   * @param {?string} name
   */
  static getIconSvg(icon, name) {
    const iconsetName = name || getIconsetName(icon);
    const iconset = this.getIconset(iconsetName);
    if (!icon || !iconset) {
      return {
        svg: cloneSvgNode(null)
      };
    }
    const iconId = getIconId(icon, iconsetName);
    const iconSvg = iconset._icons[iconId];
    return {
      preserveAspectRatio: iconSvg ? iconSvg.getAttribute("preserveAspectRatio") : null,
      svg: cloneSvgNode(iconSvg),
      size: iconset.size,
      viewBox: iconSvg ? iconSvg.getAttribute("viewBox") : null
    };
  }
  /**
   * Register an iconset without adding to the DOM.
   *
   * @param {string} name
   * @param {number} size
   * @param {?HTMLTemplateElement} template
   */
  static register(name, size, template2) {
    if (!iconsetRegistry[name]) {
      const iconset = document.createElement("vaadin-iconset");
      iconset.appendChild(template2.content.cloneNode(true));
      iconsetRegistry[name] = iconset;
      initIconsMap(iconset, name);
      iconset.size = size;
      iconset.name = name;
    }
  }
  /**
   * The name of the iconset. Every iconset is required to have its own unique name.
   * All the SVG icons in the iconset must have IDs conforming to its name.
   *
   * See also [`name`](#/elements/vaadin-icon#property-name) property of `vaadin-icon`.
   *
   * @return {string}
   */
  get name() {
    return this.__name;
  }
  /**
   * @type {string}
   */
  set name(name) {
    const oldName = this.__name;
    this.__name = name;
    this.__nameChanged(name, oldName);
  }
  /**
   * The size of an individual icon. Note that icons must be square.
   *
   * When using `vaadin-icon`, the size of the iconset will take precedence
   * over the size defined by the user to ensure correct appearance.
   *
   * @return {number}
   */
  get size() {
    return this.__size !== void 0 ? this.__size : 24;
  }
  /**
   * @type {number}
   */
  set size(size) {
    this.__size = size;
  }
  /** @protected */
  connectedCallback() {
    ["name", "size"].forEach((prop) => {
      if (this.hasOwnProperty(prop)) {
        const value = this[prop];
        delete this[prop];
        this[prop] = value;
      }
    });
    this.style.display = "none";
  }
  /** @protected */
  attributeChangedCallback(attr, _oldValue, newValue) {
    if (attr === "name") {
      this.name = newValue;
    } else if (attr === "size") {
      this.size = newValue == null ? null : Number(newValue);
    }
  }
  /**
   * Update all the icons instances in the DOM.
   *
   * @param {string} name
   * @private
   */
  __updateIcons(name) {
    attachedIcons.forEach((element) => {
      if (name === getIconsetName(element.icon)) {
        element._applyIcon();
      }
    });
  }
  /** @private */
  __nameChanged(name, oldName) {
    if (oldName) {
      delete iconsetRegistry[oldName];
    }
    if (name) {
      iconsetRegistry[name] = this;
      initIconsMap(this, name);
      this.__updateIcons(name);
    }
  }
};
/**
 * @license
 * Copyright (c) 2021 - 2025 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
let Iconset$1 = class Iconset extends IconsetMixin(HTMLElement) {
  static get is() {
    return "vaadin-iconset";
  }
};
defineCustomElement(Iconset$1);
/**
 * @license
 * Copyright (c) 2016 - 2025 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
function supportsCQUnitsForPseudoElements() {
  const testStyle = document.createElement("style");
  testStyle.textContent = `
    .vaadin-icon-test-element {
      container-type: size;
      height: 2px;
      visibility: hidden;
      position: fixed;
    }

    .vaadin-icon-test-element::before {
      content: '';
      display: block;
      height: 100cqh;
    `;
  const testElement = document.createElement("div");
  testElement.classList.add("vaadin-icon-test-element");
  document.body.append(testStyle, testElement);
  const { height } = getComputedStyle(testElement, "::before");
  testStyle.remove();
  testElement.remove();
  return height === "2px";
}
function needsFontIconSizingFallback() {
  if (!CSS.supports("container-type: inline-size")) {
    return true;
  }
  if (!isSafari) {
    return false;
  }
  return !supportsCQUnitsForPseudoElements();
}
/**
 * @license
 * Copyright (c) 2021 - 2025 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const usesFontIconSizingFallback = needsFontIconSizingFallback();
if (usesFontIconSizingFallback) {
  registerStyles$1(
    "vaadin-icon",
    css`
      :host::after,
      :host::before {
        font-size: var(--_vaadin-font-icon-size);
      }
    `,
    "vaadin-icon-font-size-mixin-styles"
  );
}
const IconFontSizeMixin = dedupingMixin(
  (superclass) => !usesFontIconSizingFallback ? superclass : class extends ResizeMixin(superclass) {
    static get observers() {
      return ["__iconFontSizeMixinfontChanged(iconClass, char, ligature)"];
    }
    /** @protected */
    ready() {
      super.ready();
      this.__updateFontIconSize();
    }
    /** @private */
    __iconFontSizeMixinfontChanged(_iconClass, _char, _ligature) {
      this.__updateFontIconSize();
    }
    /**
     * @protected
     * @override
     */
    _onResize() {
      this.__updateFontIconSize();
    }
    /**
     * Updates the --_vaadin-font-icon-size CSS variable value if font icons are used.
     *
     * @private
     */
    __updateFontIconSize() {
      if (this.char || this.iconClass || this.ligature) {
        const { paddingTop, paddingBottom, height } = getComputedStyle(this);
        const fontIconSize = parseFloat(height) - parseFloat(paddingTop) - parseFloat(paddingBottom);
        this.style.setProperty("--_vaadin-font-icon-size", `${fontIconSize}px`);
      }
    }
  }
);
/**
 * @license
 * Copyright (c) 2021 - 2025 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const srcCache = /* @__PURE__ */ new Map();
const Iconset2 = customElements.get("vaadin-iconset");
const IconMixin = (superClass) => class extends IconFontSizeMixin(SlotStylesMixin(superClass)) {
  static get properties() {
    return {
      /**
       * The name of the icon to use. The name should be of the form:
       * `iconset_name:icon_name`. When using `vaadin-icons` it is possible
       * to omit the first part and only use `icon_name` as a value.
       *
       * Setting the `icon` property updates the `svg` and `size` based on the
       * values provided by the corresponding `vaadin-iconset` element.
       *
       * See also [`name`](#/elements/vaadin-iconset#property-name) property of `vaadin-iconset`.
       *
       * @attr {string} icon
       * @type {string}
       */
      icon: {
        type: String,
        reflectToAttribute: true,
        observer: "__iconChanged",
        sync: true
      },
      /**
       * The SVG icon wrapped in a Lit template literal.
       */
      svg: {
        type: Object,
        sync: true
      },
      /**
       * The SVG source to be loaded as the icon. It can be:
       * - an URL to a file containing the icon
       * - an URL in the format "/path/to/file.svg#objectID", where the "objectID" refers to an ID attribute contained
       *   inside the SVG referenced by the path. Note that the file needs to follow the same-origin policy.
       * - a string in the format "data:image/svg+xml,<svg>...</svg>". You may need to use the "encodeURIComponent"
       *   function for the SVG content passed
       *
       * @type {string}
       */
      src: {
        type: String,
        sync: true
      },
      /**
       * The symbol identifier that references an ID of an element contained in the SVG element assigned to the
       * `src` property
       *
       * @type {string}
       */
      symbol: {
        type: String,
        sync: true
      },
      /**
       * Class names defining an icon font and/or a specific glyph inside an icon font.
       *
       * Example: "fa-solid fa-user"
       *
       * @attr {string} icon-class
       * @type {string}
       */
      iconClass: {
        type: String,
        reflectToAttribute: true,
        sync: true
      },
      /**
       * A hexadecimal code point that specifies a glyph from an icon font.
       *
       * Example: "e001"
       *
       * @type {string}
       */
      char: {
        type: String,
        sync: true
      },
      /**
       * A ligature name that specifies an icon from an icon font with support for ligatures.
       *
       * Example: "home".
       *
       * @type {string}
       */
      ligature: {
        type: String,
        sync: true
      },
      /**
       * The font family to use for the font icon.
       *
       * @attr {string} font-family
       * @type {string}
       */
      fontFamily: {
        type: String,
        observer: "__fontFamilyChanged",
        sync: true
      },
      /**
       * The size of an icon, used to set the `viewBox` attribute.
       */
      size: {
        type: Number,
        value: 24,
        sync: true
      },
      /** @private */
      __defaultPAR: {
        type: String,
        value: "xMidYMid meet"
      },
      /** @private */
      __preserveAspectRatio: String,
      /** @private */
      __useRef: Object,
      /** @private */
      __svgElement: String,
      /** @private */
      __viewBox: String,
      /** @private */
      __fill: String,
      /** @private */
      __stroke: String,
      /** @private */
      __strokeWidth: String,
      /** @private */
      __strokeLinecap: String,
      /** @private */
      __strokeLinejoin: String
    };
  }
  static get observers() {
    return [
      "__svgChanged(svg, __svgElement)",
      "__fontChanged(iconClass, char, ligature)",
      "__srcChanged(src, symbol)"
    ];
  }
  static get observedAttributes() {
    return [...super.observedAttributes, "class"];
  }
  constructor() {
    super();
    this.__fetch = fetch.bind(window);
  }
  /** @protected */
  get slotStyles() {
    const tag = this.localName;
    return [
      `
        ${tag}[icon-class] {
          display: inline-flex;
          vertical-align: middle;
          font-size: inherit;
        }
      `
    ];
  }
  /** @private */
  get __iconClasses() {
    return this.iconClass ? this.iconClass.split(" ") : [];
  }
  /** @protected */
  ready() {
    super.ready();
    this.__svgElement = this.shadowRoot.querySelector("#svg-group");
    this._tooltipController = new TooltipController(this);
    this.addController(this._tooltipController);
  }
  /** @protected */
  connectedCallback() {
    super.connectedCallback();
    Iconset2.attachedIcons.add(this);
  }
  /** @protected */
  disconnectedCallback() {
    super.disconnectedCallback();
    Iconset2.attachedIcons.delete(this);
  }
  /** @protected */
  _applyIcon() {
    const { preserveAspectRatio, svg: svg2, size, viewBox } = Iconset2.getIconSvg(this.icon);
    if (viewBox) {
      this.__viewBox = viewBox;
    }
    if (preserveAspectRatio) {
      this.__preserveAspectRatio = preserveAspectRatio;
    }
    if (size && size !== this.size) {
      this.size = size;
    }
    this.svg = svg2;
  }
  /** @private */
  __iconChanged(icon) {
    if (icon) {
      this._applyIcon();
    } else {
      this.svg = ensureSvgLiteral(null);
    }
  }
  /** @private */
  async __srcChanged(src, symbol) {
    if (!src) {
      this.svg = null;
      return;
    }
    this.icon = "";
    if (!src.startsWith("data:") && (symbol || src.includes("#"))) {
      const [path, iconId] = src.split("#");
      this.__useRef = `${path}#${symbol || iconId}`;
    } else {
      try {
        if (!srcCache.has(src)) {
          srcCache.set(
            src,
            this.__fetch(src, {
              mode: "cors"
            }).then((data) => {
              if (!data.ok) {
                throw new Error("Error loading icon");
              }
              return data.text();
            })
          );
        }
        const svgData = await srcCache.get(src);
        if (!superClass.__domParser) {
          superClass.__domParser = new DOMParser();
        }
        const parsedResponse = superClass.__domParser.parseFromString(svgData, "text/html");
        const svgElement = parsedResponse.querySelector("svg");
        if (!svgElement) {
          throw new Error(`SVG element not found on path: ${src}`);
        }
        this.svg = unsafeSvgLiteral(svgElement.innerHTML);
        if (symbol) {
          this.__useRef = `#${symbol}`;
        }
        this.__viewBox = svgElement.getAttribute("viewBox");
        this.__fill = svgElement.getAttribute("fill");
        this.__stroke = svgElement.getAttribute("stroke");
        this.__strokeWidth = svgElement.getAttribute("stroke-width");
        this.__strokeLinecap = svgElement.getAttribute("stroke-linecap");
        this.__strokeLinejoin = svgElement.getAttribute("stroke-linejoin");
      } catch (e2) {
        console.error(e2);
        this.svg = null;
      }
    }
  }
  /** @private */
  __svgChanged(svg2, svgElement) {
    if (!svgElement) {
      return;
    }
    renderSvg(svg2, svgElement);
  }
  /** @private */
  __computePAR(defaultPAR, preserveAspectRatio) {
    return preserveAspectRatio || defaultPAR;
  }
  /** @private */
  __computeVisibility(__useRef) {
    return __useRef ? "visible" : "hidden";
  }
  /** @private */
  __computeViewBox(size, viewBox) {
    return viewBox || `0 0 ${size} ${size}`;
  }
  /** @private */
  __fontChanged(iconClass, char, ligature) {
    this.classList.remove(...this.__addedIconClasses || []);
    if (iconClass) {
      this.__addedIconClasses = [...this.__iconClasses];
      this.classList.add(...this.__addedIconClasses);
    }
    if (char) {
      this.setAttribute("font-icon-content", char.length > 1 ? String.fromCodePoint(parseInt(char, 16)) : char);
    } else if (ligature) {
      this.setAttribute("font-icon-content", ligature);
    } else {
      this.removeAttribute("font-icon-content");
    }
    if ((iconClass || char || ligature) && !this.icon) {
      this.icon = "";
    }
  }
  /** @protected */
  attributeChangedCallback(name, oldValue, newValue) {
    super.attributeChangedCallback(name, oldValue, newValue);
    if (name === "class" && this.__iconClasses.some((className) => !this.classList.contains(className))) {
      this.classList.add(...this.__iconClasses);
    }
  }
  /** @private */
  __fontFamilyChanged(fontFamily) {
    this.style.fontFamily = `'${fontFamily}'`;
  }
};
/**
 * @license
 * Copyright (c) 2017 - 2025 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const iconStyles = css`
  :host {
    display: inline-flex;
    justify-content: center;
    align-items: center;
    box-sizing: border-box;
    vertical-align: middle;
    width: 24px;
    height: 24px;
    fill: currentColor;
    container-type: size;
  }

  :host::after,
  :host::before {
    line-height: 1;
    font-size: 100cqh;
    -webkit-font-smoothing: antialiased;
    text-rendering: optimizeLegibility;
    -moz-osx-font-smoothing: grayscale;
  }

  :host([hidden]) {
    display: none !important;
  }

  svg {
    display: block;
    width: 100%;
    height: 100%;
    /* prevent overflowing icon from clipping, see https://github.com/vaadin/flow-components/issues/5872 */
    overflow: visible;
  }

  :host(:is([icon-class], [font-icon-content])) svg {
    display: none;
  }

  :host([font-icon-content])::before {
    content: attr(font-icon-content);
  }
`;
/**
 * @license
 * Copyright (c) 2021 - 2025 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
registerStyles$1("vaadin-icon", iconStyles, { moduleId: "vaadin-icon-styles" });
class Icon extends IconMixin(ControllerMixin(ElementMixin(ThemableMixin(PolymerElement)))) {
  static get template() {
    return html`
      <svg
        version="1.1"
        xmlns="http://www.w3.org/2000/svg"
        xmlns:xlink="http://www.w3.org/1999/xlink"
        viewBox="[[__computeViewBox(size, __viewBox)]]"
        preserveAspectRatio="[[__computePAR(__defaultPAR, __preserveAspectRatio)]]"
        fill$="[[__fill]]"
        stroke$="[[__stroke]]"
        stroke-width$="[[__strokeWidth]]"
        stroke-linecap$="[[__strokeLinecap]]"
        stroke-linejoin$="[[__strokeLinejoin]]"
        aria-hidden="true"
      >
        <g id="svg-group"></g>
        <g id="use-group" visibility$="[[__computeVisibility(__useRef, svg)]]">
          <use href$="[[__useRef]]" />
        </g>
      </svg>

      <slot name="tooltip"></slot>
    `;
  }
  static get is() {
    return "vaadin-icon";
  }
}
defineCustomElement(Icon);
/**
 * @license
 * Copyright (c) 2015 - 2025 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const template$3 = document.createElement("template");
template$3.innerHTML = `<svg><defs>
<g id="vaadin:abacus"><path d="M0 0v16h16v-16h-16zM14 2v3h-0.1c-0.2-0.6-0.8-1-1.4-1s-1.2 0.4-1.4 1h-3.2c-0.2-0.6-0.7-1-1.4-1s-1.2 0.4-1.4 1h-0.2c-0.2-0.6-0.7-1-1.4-1s-1.2 0.4-1.4 1h-0.1v-3h12zM13.9 10c-0.2-0.6-0.8-1-1.4-1s-1.2 0.4-1.4 1h-0.2c-0.2-0.6-0.8-1-1.4-1s-1.2 0.4-1.4 1h-3.2c-0.2-0.6-0.7-1-1.4-1s-1.2 0.4-1.4 1h-0.1v-4h0.1c0.2 0.6 0.8 1 1.4 1s1.2-0.4 1.4-1h0.2c0.2 0.6 0.8 1 1.4 1s1.2-0.4 1.4-1h3.2c0.2 0.6 0.8 1 1.4 1s1.2-0.4 1.4-1h0.1l-0.1 4zM2 14v-3h0.1c0.2 0.6 0.8 1 1.4 1s1.2-0.4 1.4-1h3.2c0.2 0.6 0.8 1 1.4 1s1.2-0.4 1.4-1h0.2c0.2 0.6 0.8 1 1.4 1s1.2-0.4 1.4-1h0.1v3h-12z"></path></g>
<g id="vaadin:absolute-position"><path d="M0 0v16h16v-16h-16zM15 15h-14v-6h3v1l3-2-3-2v1h-3v-6h6v3h-1l2 3 2-3h-1v-3h6v14z"></path></g>
<g id="vaadin:academy-cap"><path d="M15.090 12.79c0.235-0.185 0.385-0.469 0.385-0.789 0-0.358-0.188-0.672-0.471-0.849l-0.004-5.822-1 0.67v5.15c-0.283 0.18-0.468 0.492-0.468 0.847 0 0.316 0.147 0.598 0.376 0.782l-0.378 0.502c-0.323 0.41-0.521 0.931-0.53 1.498l-0 1.222h0.81c0.002 0 0.004 0 0.005 0 0.411 0 0.757-0.282 0.853-0.664l0.331-1.336v2h1v-1.21c-0.009-0.569-0.207-1.090-0.534-1.505z"></path><path d="M8 0l-8 4 8 5 8-5-8-4z"></path><path d="M8 10l-5-3.33v1.71c0 0.91 2.94 3.62 5 3.62s5-2.71 5-3.62v-1.71z"></path></g>
<g id="vaadin:accessibility"><path d="M10.4 10h-0.5c0.1 0.3 0.1 0.7 0.1 1 0 2.2-1.8 4-4 4s-4-1.8-4-4c0-2.1 1.6-3.8 3.7-4l-0.2-1c-2.6 0.4-4.5 2.4-4.5 5 0 2.8 2.2 5 5 5 2.4 0 4.4-1.7 4.9-3.9l-0.5-2.1z"></path><path d="M13.1 13l-1.1-5h-4.1l-0.2-1h3.3v-1h-3.5l-0.6-2.5c0.9-0.1 1.6-0.8 1.6-1.7 0-1-0.8-1.8-1.8-1.8s-1.7 0.8-1.7 1.8c0 0.6 0.3 1.2 0.8 1.5l1.3 5.7h4.1l1.2 5h2.6v-1h-1.9z"></path></g>
<g id="vaadin:accordion-menu"><path d="M0 4v8h16v-8h-16zM15 11h-14v-4h14v4z"></path><path d="M0 0h16v3h-16v-3z"></path><path d="M0 13h16v3h-16v-3z"></path></g>
<g id="vaadin:add-dock"><path d="M0 11v5h16v-5h-16zM12 15h-3v-3h3v3z"></path><path d="M12 7v-2c0-5-8-5-8-5s5 0 5 5v2h-2l3.5 3 3.5-3h-2z"></path></g>
<g id="vaadin:adjust"><path d="M8 0c-4.4 0-8 3.6-8 8s3.6 8 8 8 8-3.6 8-8-3.6-8-8-8zM2 8c0-3.3 2.7-6 6-6v12c-3.3 0-6-2.7-6-6z"></path></g>
<g id="vaadin:adobe-flash"><path d="M0 0v16h16v-16h-16zM13 4.4c-3 0-3.3 2.6-3.3 2.6h1.3v2h-2.4c-1.8 5.8-5.6 5-5.6 5v-2.5c0 0 2.5 0.6 3.9-4 1.8-6.1 6.1-5.5 6.1-5.5v2.4z"></path></g>
<g id="vaadin:airplane"><path d="M12.3 6.5c0.5-0.5 0.9-0.8 1.2-1.1 1.6-1.6 3.2-4.1 2.2-5.1s-3.4 0.6-5 2.2c-0.3 0.3-0.6 0.7-1.1 1.2l-7-3.2c-0.7-0.3-1.5-0.2-2 0.3l-0.6 0.5 6.6 5.7c-1.3 1.6-2.7 3.1-3.4 4l-1.1-0.6c-0.5-0.3-1.2-0.3-1.6 0.2l-0.3 0.3 2.8 2.1 2 2.8 0.3-0.3c0.4-0.4 0.5-1.1 0.2-1.6l-0.5-1.1c0.9-0.7 2.4-2.1 4-3.4l5.7 6.6 0.5-0.5c0.5-0.5 0.6-1.3 0.3-2l-3.2-7z"></path></g>
<g id="vaadin:alarm"><path d="M8 5h-1v5h4v-1l-2.93 0.070-0.070-4.070z"></path><path d="M5.46 0.87c-0.387-0.522-1-0.856-1.692-0.856-0.41 0-0.793 0.118-1.117 0.321l-0.991 0.765c-0.41 0.384-0.666 0.929-0.666 1.534 0 0.496 0.172 0.951 0.459 1.31z"></path><path d="M14.34 1.1l-1-0.77c-0.315-0.198-0.698-0.316-1.108-0.316-0.692 0-1.305 0.334-1.688 0.85l3.996 3.076c0.287-0.356 0.46-0.813 0.46-1.312 0-0.602-0.253-1.145-0.659-1.528z"></path><path d="M12.87 14c1.308-1.268 2.122-3.038 2.13-4.998-0.028-3.856-3.145-6.973-6.997-7.002-3.857 0.028-6.975 3.145-7.003 6.997 0.008 1.965 0.822 3.735 2.128 5.001l-0.938 0.942c-0.075 0.102-0.12 0.231-0.12 0.37 0 0.348 0.282 0.63 0.63 0.63 0.139 0 0.268-0.045 0.372-0.122l0.998-0.999c1.092 0.758 2.446 1.211 3.905 1.211s2.813-0.453 3.928-1.226l0.977 1.015c0.102 0.075 0.231 0.12 0.37 0.12 0.348 0 0.63-0.282 0.63-0.63 0-0.139-0.045-0.268-0.122-0.372zM2.87 9c0.028-2.822 2.308-5.102 5.127-5.13 2.825 0.028 5.105 2.308 5.133 5.127-0.028 2.825-2.308 5.105-5.127 5.133-2.825-0.028-5.105-2.308-5.133-5.127z"></path></g>
<g id="vaadin:align-center"><path d="M5 0h6v3h-6v-3z"></path><path d="M1 4h14v3h-14v-3z"></path><path d="M3 8h10v3h-10v-3z"></path><path d="M0 12h16v3h-16v-3z"></path></g>
<g id="vaadin:align-justify"><path d="M0 0h16v3h-16v-3z"></path><path d="M0 4h16v3h-16v-3z"></path><path d="M0 12h16v3h-16v-3z"></path><path d="M0 8h16v3h-16v-3z"></path></g>
<g id="vaadin:align-left"><path d="M0 0h11v3h-11v-3z"></path><path d="M0 4h15v3h-15v-3z"></path><path d="M0 8h13v3h-13v-3z"></path><path d="M0 12h16v3h-16v-3z"></path></g>
<g id="vaadin:align-right"><path d="M5 0h11v3h-11v-3z"></path><path d="M1 4h15v3h-15v-3z"></path><path d="M3 8h13v3h-13v-3z"></path><path d="M0 12h16v3h-16v-3z"></path></g>
<g id="vaadin:alt-a"><path d="M14 7v-1h-1v-1h-1v1h-0.5v1h0.5v3.56c0 1 0.56 1.44 2 1.44v-1c-0.055 0.012-0.119 0.019-0.185 0.019-0.359 0-0.669-0.21-0.813-0.514l-0.002-3.505h1z"></path><path d="M9 3h1v9h-1v-9z"></path><path d="M3 12l0.57-2h2.82l0.61 2h1l-2.27-8h-1.46l-2.27 8h1zM5 5.1l1.11 3.9h-2.22z"></path></g>
<g id="vaadin:alt"><path d="M3.89 9h2.22l-1.11-3.9-1.11 3.9z"></path><path d="M0 0v16h16v-16h-16zM7 12l-0.61-2h-2.78l-0.61 2h-1l2.27-8h1.46l2.27 8h-1zM10 12h-1v-9h1v9zM14 7h-1v3.5s0 0.5 1 0.5v1c-1 0-2-0.44-2-1.44v-3.56h-0.5v-1h0.5v-1h1v1h1v1z"></path></g>
<g id="vaadin:ambulance"><path d="M6.18 14c0 1.105-0.895 2-2 2s-2-0.895-2-2c0-1.105 0.895-2 2-2s2 0.895 2 2z"></path><path d="M14 14c0 1.105-0.895 2-2 2s-2-0.895-2-2c0-1.105 0.895-2 2-2s2 0.895 2 2z"></path><path d="M5 6h-1v1h-1v1h1v1h1v-1h1v-1h-1v-1z"></path><path d="M15.76 8.64l-3-4.53c-0.455-0.673-1.215-1.11-2.078-1.11-0.008 0-0.015 0-0.023 0l-2.659-0v-1c0-0.552-0.448-1-1-1s-1 0.448-1 1v1h-4.5c-0.828 0-1.5 0.672-1.5 1.5v8.5h1.37c0.474-1.135 1.546-1.931 2.812-2 1.278 0.072 2.345 0.868 2.81 1.978l2.188 0.021c0.474-1.135 1.546-1.931 2.812-2 1.303 0.003 2.405 0.827 2.822 1.979l1.187 0.021v-3.57c-0.001-0.294-0.090-0.568-0.243-0.795zM6.92 8.12c-0.266 1.117-1.255 1.935-2.435 1.935-1.381 0-2.5-1.119-2.5-2.5 0-1.18 0.818-2.17 1.918-2.432 0.195-0.049 0.399-0.075 0.609-0.075 1.37 0 2.48 1.11 2.48 2.48 0 0.21-0.026 0.414-0.075 0.609zM10 8v-3h0.85c0.003-0 0.006-0 0.009-0 0.777 0 1.461 0.394 1.866 0.992l1.325 2.008z"></path></g>
<g id="vaadin:anchor"><path d="M13 9v2c0 0-0.8 1.7-4 1.9v-6.9h2.2c0.2 0.3 0.5 0.5 0.8 0.5 0.6 0 1-0.4 1-1s-0.4-1-1-1c-0.4 0-0.7 0.2-0.8 0.5h-2.2v-1.3c0.6-0.3 1-1 1-1.7 0-1.1-0.9-2-2-2s-2 0.9-2 2c0 0.7 0.4 1.4 1 1.7v1.3h-2.2c-0.1-0.3-0.4-0.5-0.8-0.5-0.6 0-1 0.4-1 1s0.4 1 1 1c0.4 0 0.7-0.2 0.8-0.5h2.2v7c-3.3-0.3-4-2-4-2v-2h-3c0 0 2.8 7 8 7 5 0 8-7 8-7h-3zM8 1c0.6 0 1 0.4 1 1s-0.4 1-1 1-1-0.4-1-1 0.4-1 1-1z"></path></g>
<g id="vaadin:angle-double-down"><path d="M3 2v2l5 5 5-5v-2l-5 5z"></path><path d="M3 7v2l5 5 5-5v-2l-5 5z"></path></g>
<g id="vaadin:angle-double-left"><path d="M14 3h-2l-5 5 5 5h2l-5-5z"></path><path d="M9 3h-2l-5 5 5 5h2l-5-5z"></path></g>
<g id="vaadin:angle-double-right"><path d="M2 13h2l5-5-5-5h-2l5 5z"></path><path d="M7 13h2l5-5-5-5h-2l5 5z"></path></g>
<g id="vaadin:angle-double-up"><path d="M13 14v-2l-5-5-5 5v2l5-5z"></path><path d="M13 9v-2l-5-5-5 5v2l5-5z"></path></g>
<g id="vaadin:angle-down"><path d="M13 4v2l-5 5-5-5v-2l5 5z"></path></g>
<g id="vaadin:angle-left"><path d="M12 13h-2l-5-5 5-5h2l-5 5z"></path></g>
<g id="vaadin:angle-right"><path d="M4 13h2l5-5-5-5h-2l5 5z"></path></g>
<g id="vaadin:angle-up"><path d="M3 12v-2l5-5 5 5v2l-5-5z"></path></g>
<g id="vaadin:archive"><path d="M0 1h16v3h-16v-3z"></path><path d="M1 5v11h14v-11h-14zM11 9h-6v-2h6v2z"></path></g>
<g id="vaadin:archives"><path d="M11 2h-6v4h6v-4zM9 4h-2v-1h2v1z"></path><path d="M3 0v16h2v-1h6v1h2v-16h-10zM12 14h-8v-6h8v6zM12 7h-8v-6h8v6z"></path><path d="M11 9h-6v4h6v-4zM9 11h-2v-1h2v1z"></path></g>
<g id="vaadin:area-select"><path d="M7.9 7.9l2.1 7.5 1.7-2.6 3.2 3.2 1.1-1.1-3.3-3.2 2.7-1.6z"></path><path d="M8 12h-7v-9h12v5.4l1 0.2v-6.6h-14v11h8.2z"></path></g>
<g id="vaadin:arrow-backward"><path d="M0 7.9l6-4.9v3c0 0 1.1 0 2 0 8 0 8 8 8 8s-1-4-7.8-4c-1.1 0-1.8 0-2.2 0v2.9l-6-5z"></path></g>
<g id="vaadin:arrow-circle-down-o"><path d="M1 8c0-3.9 3.1-7 7-7s7 3.1 7 7-3.1 7-7 7-7-3.1-7-7zM0 8c0 4.4 3.6 8 8 8s8-3.6 8-8-3.6-8-8-8-8 3.6-8 8v0z"></path><path d="M9 9.6l1.8-1.8 1.4 1.4-4.2 4.2-4.2-4.2 1.4-1.4 1.8 1.8v-6.6h2v6.6z"></path></g>
<g id="vaadin:arrow-circle-down"><path d="M0 8c0 4.4 3.6 8 8 8s8-3.6 8-8-3.6-8-8-8c-4.4 0-8 3.6-8 8zM9 9.6l1.8-1.8 1.4 1.4-4.2 4.2-4.2-4.2 1.4-1.4 1.8 1.8v-6.6h2v6.6z"></path></g>
<g id="vaadin:arrow-circle-left-o"><path d="M8 1c3.9 0 7 3.1 7 7s-3.1 7-7 7-7-3.1-7-7 3.1-7 7-7zM8 0c-4.4 0-8 3.6-8 8s3.6 8 8 8 8-3.6 8-8-3.6-8-8-8v0z"></path><path d="M6.4 9l1.8 1.8-1.4 1.4-4.2-4.2 4.2-4.2 1.4 1.4-1.8 1.8h6.6v2h-6.6z"></path></g>
<g id="vaadin:arrow-circle-left"><path d="M8 0c-4.4 0-8 3.6-8 8s3.6 8 8 8 8-3.6 8-8-3.6-8-8-8zM6.4 9l1.8 1.8-1.4 1.4-4.2-4.2 4.2-4.2 1.4 1.4-1.8 1.8h6.6v2h-6.6z"></path></g>
<g id="vaadin:arrow-circle-right-o"><path d="M8 15c-3.9 0-7-3.1-7-7s3.1-7 7-7 7 3.1 7 7-3.1 7-7 7zM8 16c4.4 0 8-3.6 8-8s-3.6-8-8-8-8 3.6-8 8 3.6 8 8 8v0z"></path><path d="M9.6 7l-1.8-1.8 1.4-1.4 4.2 4.2-4.2 4.2-1.4-1.4 1.8-1.8h-6.6v-2h6.6z"></path></g>
<g id="vaadin:arrow-circle-right"><path d="M8 16c4.4 0 8-3.6 8-8s-3.6-8-8-8-8 3.6-8 8 3.6 8 8 8zM9.6 7l-1.8-1.8 1.4-1.4 4.2 4.2-4.2 4.2-1.4-1.4 1.8-1.8h-6.6v-2h6.6z"></path></g>
<g id="vaadin:arrow-circle-up-o"><path d="M15 8c0 3.9-3.1 7-7 7s-7-3.1-7-7 3.1-7 7-7 7 3.1 7 7zM16 8c0-4.4-3.6-8-8-8s-8 3.6-8 8c0 4.4 3.6 8 8 8s8-3.6 8-8v0z"></path><path d="M7 6.4l-1.8 1.8-1.4-1.4 4.2-4.2 4.2 4.2-1.4 1.4-1.8-1.8v6.6h-2v-6.6z"></path></g>
<g id="vaadin:arrow-circle-up"><path d="M16 8c0-4.4-3.6-8-8-8s-8 3.6-8 8 3.6 8 8 8 8-3.6 8-8zM7 6.4l-1.8 1.8-1.4-1.4 4.2-4.2 4.2 4.2-1.4 1.4-1.8-1.8v6.6h-2v-6.6z"></path></g>
<g id="vaadin:arrow-down"><path d="M12.5 8.6l-3.5 3.6v-12.2h-2v12.2l-3.5-3.6-1.4 1.5 5.9 5.9 5.9-5.9z"></path></g>
<g id="vaadin:arrow-forward"><path d="M16 7.9l-6-4.9v3c-0.5 0-1.1 0-2 0-8 0-8 8-8 8s1-4 7.8-4c1.1 0 1.8 0 2.2 0v2.9l6-5z"></path></g>
<g id="vaadin:arrow-left"><path d="M7.4 12.5l-3.6-3.5h12.2v-2h-12.2l3.6-3.5-1.5-1.4-5.9 5.9 5.9 5.9z"></path></g>
<g id="vaadin:arrow-long-down"><path d="M7 1h2v11h2l-3 3-3-3h2z"></path></g>
<g id="vaadin:arrow-long-left"><path d="M15 7v2h-11v2l-3-3 3-3v2z"></path></g>
<g id="vaadin:arrow-right"><path d="M8.6 3.5l3.5 3.5h-12.1v2h12.1l-3.5 3.5 1.4 1.4 6-5.9-6-5.9z"></path></g>
<g id="vaadin:arrow-up"><path d="M3.4 7.4l3.6-3.6v12.2h2v-12.2l3.5 3.6 1.4-1.5-5.9-5.9-6 5.9z"></path></g>
<g id="vaadin:arrows-cross"><path d="M15 5v-4h-4l1.3 1.3-4.3 4.3-4.3-4.3 1.3-1.3h-4v4l1.3-1.3 4.3 4.3-4.3 4.3-1.3-1.3v4h4l-1.3-1.3 4.3-4.3 4.3 4.3-1.3 1.3h4v-4l-1.3 1.3-4.3-4.3 4.3-4.3z"></path></g>
<g id="vaadin:arrows-long-h"><path d="M16 8l-3-3v2h-10v-2l-3 3 3 3v-2h10v2z"></path></g>
<g id="vaadin:arrows-long-right"><path d="M1 9v-2h11v-2l3 3-3 3v-2z"></path></g>
<g id="vaadin:arrows-long-up"><path d="M9 15h-2v-11h-2l3-3 3 3h-2z"></path></g>
<g id="vaadin:arrows-long-v"><path d="M9 3h2l-3-3-3 3h2v10h-2l3 3 3-3h-2z"></path></g>
<g id="vaadin:arrows"><path d="M16 8l-3-3v2h-4v-4h2l-3-3-3 3h2v4h-4v-2l-3 3 3 3v-2h4v4h-2l3 3 3-3h-2v-4h4v2z"></path></g>
<g id="vaadin:asterisk"><path d="M15.9 5.7l-2-3.4-3.9 2.2v-4.5h-4v4.5l-4-2.2-2 3.4 3.9 2.3-3.9 2.3 2 3.4 4-2.2v4.5h4v-4.5l3.9 2.2 2-3.4-4-2.3z"></path></g>
<g id="vaadin:at"><path d="M7.5 12.2c-2.3 0-4.2-1.9-4.2-4.2s1.9-4.2 4.2-4.2 4.2 1.9 4.2 4.2c0.1 2.3-1.9 4.2-4.2 4.2zM7.5 5.2c-1.5 0-2.7 1.3-2.7 2.8s1.2 2.8 2.8 2.8 2.8-1.2 2.8-2.8-1.4-2.8-2.9-2.8z"></path><path d="M8 16c-4.4 0-8-3.6-8-8s3.6-8 8-8 8 3.6 8 8c0 1.5-0.4 3-1.2 4.2-0.3 0.5-1.1 1.2-2.3 1.2-0.8 0-1.3-0.3-1.6-0.6-0.7-0.7-0.6-1.8-0.6-1.9v-6.9h1.5v7c0 0.2 0 0.6 0.2 0.8 0 0 0.2 0.2 0.5 0.2 0.7 0 1.1-0.5 1.1-0.5 0.6-1 1-2.2 1-3.4 0-3.6-2.9-6.5-6.5-6.5s-6.6 2.8-6.6 6.4 2.9 6.5 6.5 6.5c0.7 0 1.3-0.1 1.9-0.3l0.4 1.4c-0.7 0.3-1.5 0.4-2.3 0.4z"></path></g>
<g id="vaadin:automation"><path d="M14 12c0 1.105-0.895 2-2 2s-2-0.895-2-2c0-1.105 0.895-2 2-2s2 0.895 2 2z"></path><path d="M11.7 16v0c-0.8 0-1.6-0.2-2.3-0.7l-6.2-3.3c-0.5-0.4-0.9-0.6-1.3-1-1.2-1.2-1.9-2.9-1.9-4.6s0.7-3.3 1.9-4.5c1.2-1.2 2.8-1.9 4.5-1.9s3.3 0.7 4.6 1.9c0.4 0.4 0.6 0.7 1 1.2l3.5 6.4c1 1.7 0.7 3.8-0.7 5.2-0.9 0.9-1.9 1.3-3.1 1.3zM6.4 1c-1.4 0-2.8 0.6-3.8 1.6s-1.6 2.4-1.6 3.8c0 1.5 0.6 2.8 1.6 3.8 0.3 0.3 0.6 0.5 1.1 0.8l6.3 3.4c0.6 0.4 1.2 0.5 1.8 0.5v0c0.9 0 1.7-0.3 2.3-1 1.1-1.1 1.3-2.7 0.5-4l-3.5-6.4c-0.3-0.4-0.5-0.7-0.8-1-1.1-0.9-2.4-1.5-3.9-1.5z"></path><path d="M11 7v-1l-1.4-0.5c-0.1-0.2-0.1-0.3-0.2-0.5l0.6-1.3-0.7-0.7-1.3 0.6c-0.2-0.1-0.3-0.1-0.5-0.2l-0.5-1.4h-1l-0.5 1.4c-0.2 0.1-0.3 0.1-0.5 0.2l-1.3-0.6-0.7 0.7 0.6 1.3c-0.1 0.2-0.1 0.3-0.2 0.5l-1.4 0.5v1l1.4 0.5c0.1 0.2 0.1 0.3 0.2 0.5l-0.6 1.3 0.7 0.7 1.3-0.6c0.2 0.1 0.3 0.2 0.5 0.2l0.5 1.4h1l0.5-1.4c0.2-0.1 0.3-0.1 0.5-0.2l1.3 0.6 0.7-0.7-0.6-1.3c0.1-0.2 0.2-0.3 0.2-0.5l1.4-0.5zM6.5 8c-0.8 0-1.5-0.7-1.5-1.5s0.7-1.5 1.5-1.5 1.5 0.7 1.5 1.5-0.7 1.5-1.5 1.5z"></path></g>
<g id="vaadin:backspace-a"><path d="M5 12l-5-4 5-4v2h11v4h-11v2z"></path></g>
<g id="vaadin:backspace"><path d="M0 2v12h16v-12h-16zM13 9h-7v2l-3-3 3-3v2h7v2z"></path></g>
<g id="vaadin:backwards"><path d="M16 15v-14l-8 7z"></path><path d="M8 15v-14l-8 7z"></path></g>
<g id="vaadin:ban"><path d="M8 0c-4.4 0-8 3.6-8 8s3.6 8 8 8 8-3.6 8-8-3.6-8-8-8zM8 2c1.3 0 2.5 0.4 3.5 1.1l-8.4 8.4c-0.7-1-1.1-2.2-1.1-3.5 0-3.3 2.7-6 6-6zM8 14c-1.3 0-2.5-0.4-3.5-1.1l8.4-8.4c0.7 1 1.1 2.2 1.1 3.5 0 3.3-2.7 6-6 6z"></path></g>
<g id="vaadin:bar-chart-h"><path d="M1 15v-15h-1v16h16v-1h-15z"></path><path d="M2 8h4v6h-4v-6z"></path><path d="M7 2h4v12h-4v-12z"></path><path d="M12 6h4v8h-4v-8z"></path></g>
<g id="vaadin:bar-chart-v"><path d="M1 15v-15h-1v16h16v-1h-15z"></path><path d="M8 0v4h-6v-4h6z"></path><path d="M14 5v4h-12v-4h12z"></path><path d="M10 10v4h-8v-4h8z"></path></g>
<g id="vaadin:bar-chart"><path d="M0 15h15v1h-15v-1z"></path><path d="M0 11h3v3h-3v-3z"></path><path d="M4 9h3v5h-3v-5z"></path><path d="M8 5h3v9h-3v-9z"></path><path d="M12 0h3v14h-3v-14z"></path></g>
<g id="vaadin:barcode"><path d="M0 3h1v10h-1v-10z"></path><path d="M8 3h2v10h-2v-10z"></path><path d="M11 3h1v10h-1v-10z"></path><path d="M13 3h1v10h-1v-10z"></path><path d="M15 3h1v10h-1v-10z"></path><path d="M2 3h3v10h-3v-10z"></path><path d="M6 3h1v10h-1v-10z"></path></g>
<g id="vaadin:bed"><path d="M4.28 7h2.72l-1.15-1.68c-0.542-0.725-1.36-1.216-2.295-1.319l-0.555-0.001v1.54c-0.011 0.063-0.018 0.136-0.018 0.211 0 0.69 0.56 1.25 1.25 1.25 0.017 0 0.034-0 0.050-0.001z"></path><path d="M13 7v-0.28c0-0.003 0-0.007 0-0.010 0-0.934-0.749-1.693-1.678-1.71l-4.692-0c0.5 0.62 1.37 2 1.37 2h5z"></path><path d="M15 5.1c-0.552 0-1 0.448-1 1v1.9h-12v-4c0-0.552-0.448-1-1-1s-1 0.448-1 1v9h2v-2h12v2h2v-6.9c0-0.552-0.448-1-1-1z"></path></g>
<g id="vaadin:bell-o"><path d="M12.7 11.4c-0.5-0.2-0.7-0.7-0.7-1.2v-5.2c0 0 0-2.4-3-2.9v-1.1c0 0 0.1-1-1-1s-1 1-1 1v1.1c-3 0.5-3 2.9-3 2.9v5.2c0 0.5-0.3 1-0.7 1.2l-1.3 0.6v2h4c0 0-0.1 2 2 2s2-2 2-2h4v-2l-1.3-0.6zM13 13h-10v-0.4l0.7-0.4c0.8-0.3 1.3-1.1 1.3-2v-5.2c0-0.1 0-1.6 2.2-1.9l0.8-0.2 0.8 0.1c2 0.4 2.2 1.7 2.2 2v5.2c0 0.9 0.5 1.7 1.3 2.1l0.7 0.4v0.3z"></path></g>
<g id="vaadin:bell-slash-o"><path d="M15.2 0l-3.6 3.6c-0.4-0.6-1.2-1.3-2.6-1.5v-1.1c0 0 0.1-1-1-1s-1 1-1 1v1.1c-3 0.5-3 2.9-3 2.9v5.2c0 0.5-0.3 1-0.7 1.2l-1.3 0.6v1.3l-2 2v0.7h0.7l15.3-15.4v-0.6h-0.8zM5 10.3c0-0.1 0-0.1 0 0v-5.3c0-0.1 0.1-1.6 2.2-1.9l0.8-0.2 0.8 0.1c1.2 0.2 1.8 0.8 2 1.3l-5.8 6z"></path><path d="M12 10.2v-4.6l-1 1v3.5c0 0.9 0.5 1.7 1.3 2.1l0.7 0.4v0.4h-8.3l-1 1h2.4c0 0-0.1 2 2 2s2-2 2-2h3.9v-2l-1.3-0.6c-0.4-0.3-0.7-0.7-0.7-1.2z"></path></g>
<g id="vaadin:bell-slash"><path d="M15.2 0l-3.6 3.6c-0.5-0.6-1.2-1.3-2.6-1.5v-1.1c0 0 0.1-1-1-1s-1 1-1 1v1.1c-2.8 0.5-3 2.9-3 2.9v5.2c0 0.5-0.3 1-0.7 1.2l-1.3 0.6v1h0.3l-2.3 2.3v0.7h0.7l15.3-15.4v-0.6h-0.8zM6 4.8v4.5l-1 1v-5.3c0 0 0-0.8 0.7-1.4 0.7-0.7 1.3-0.6 1.3-0.6s-1 0.7-1 1.8z"></path><path d="M8 16c2.1 0 2-2 2-2h-4c0 0-0.1 2 2 2z"></path><path d="M12 10.2v-4.6l-6 6-0.3 0.4-1 1h9.3v-1l-1.3-0.6c-0.4-0.3-0.7-0.7-0.7-1.2z"></path></g>
<g id="vaadin:bell"><path d="M6 14h4c0 0 0.1 2-2 2s-2-2-2-2z"></path><path d="M12.7 11.4c-0.5-0.2-0.7-0.7-0.7-1.2v-5.2c0 0-0.2-2.4-3-2.9v-1.1c0 0 0.1-1-1-1s-1 1-1 1v1.1c-2.8 0.5-3 2.9-3 2.9v5.2c0 0.5-0.3 1-0.7 1.2l-1.3 0.6v1h12v-1l-1.3-0.6zM6 4.8v7.2h-2c0.8 0 1-1 1-1v-6c0 0 0-0.8 0.7-1.4 0.7-0.7 1.3-0.6 1.3-0.6s-1 0.7-1 1.8z"></path></g>
<g id="vaadin:boat"><path d="M1.5 9.6c1.1 0.7 2.5 1.9 2.5 3.3 0 0.4 0 0.7 0 1.1 0 0 0.1 0 0.1 0s0.9 0 2-1c1 1 2 1 2 1s1 0 2-1c1 1 1.9 1 1.9 1s0.1 0 0.1 0c0-0.3 0-0.7 0-1.1 0-1.4 1.4-2.6 2.5-3.3 0.6-0.4 0.5-1.2-0.2-1.4l-1.4-0.4v-3.8h-1v-1h-3v-2h-2v2h-3v1h-1v3.8l-1.3 0.4c-0.8 0.2-0.8 1-0.2 1.4zM4 5h1v-1h6v1h1v2.5l-3.3-1c-0.5-0.1-1-0.1-1.5 0l-3.2 1v-2.5z"></path><path d="M14 14c-1 1-2 1-2 1s-1 0-2-1c-1 1-2 1-2 1s-1 0-2-1c-1 1-2 1-2 1s-1 0-2-1c-1 1-2 1-2 1v1h16v-1c0 0-1 0-2-1z"></path></g>
<g id="vaadin:bold"><path d="M11 7.5c0 0 2-0.8 2-3.6 0-4.1-5.1-3.9-7-3.9h-4v16h4c3.7 0 8 0 8-4.4 0-3.8-3-4.1-3-4.1zM9 4.4c0 1.8-1.5 1.6-3 1.6v-3c1.8 0 3 0.1 3 1.4zM6 13v-4c1.8 0 4-0.3 4 2.2 0 1.9-2.5 1.8-4 1.8z"></path></g>
<g id="vaadin:bolt"><path d="M7.99 0l-7.010 9.38 6.020-0.42-4.96 7.040 12.96-10-7.010 0.47 7.010-6.47h-7.010z"></path></g>
<g id="vaadin:bomb"><path d="M12 1h1v1h-1v-1z"></path><path d="M12 5h1v1h-1v-1z"></path><path d="M14 3h1v1h-1v-1z"></path><path d="M10 3h1v1h-1v-1z"></path><path d="M14.6 2.1l0.7-0.7-0.7-0.7-1.4 1.4 0.7 0.7z"></path><path d="M13.9 4.2l-0.7 0.7 1.4 1.4 0.7-0.7-0.7-0.7z"></path><path d="M11.1 2.8l0.7-0.7-1.4-1.4-0.7 0.7 0.7 0.7z"></path><path d="M10.4 6.4l2-2-0.7-0.7-2 2-0.7-0.7-0.7 0.8c-0.8-0.5-1.8-0.8-2.8-0.8-3 0-5.5 2.5-5.5 5.5s2.5 5.5 5.5 5.5 5.5-2.5 5.5-5.5c0-1-0.3-1.9-0.7-2.8l0.7-0.7-0.6-0.6zM6 7.2c-2 0-3.4 1.8-3.4 2.8h-1c0-2 2.4-3.8 4.4-3.8v1z"></path></g>
<g id="vaadin:book-dollar"><path d="M12.9 2.5c-1.6-1.2-1.4-2.5-1.4-2.5h-9.5v12.5c0 1.9 2.1 3.5 4 3.5h8v-13c0 0-0.8-0.2-1.1-0.5zM7 6.3c-0.9-0.3-2.3-0.8-2.3-1.9 0.1-0.8 1.3-1.4 1.3-1.6v-0.8h1v0.7c1 0.1 1.8 0.4 1.9 0.4l-0.3 0.9c0 0-0.7-0.3-1.5-0.3-0.7 0-1.1 0.3-1.2 0.8 0 0.3 0.5 0.6 1.3 0.9 1.5 0.5 1.9 1.1 1.9 1.9 0 0.7-0.1 1.6-2.1 1.8v0.9h-1v-0.8c0-0.1-1.4-0.5-1.5-0.5l0.5-0.9c0 0 1.1 0.5 2 0.4s1.3-0.6 1.3-1c0.1-0.3-0.4-0.6-1.3-0.9zM13 15h-7c-1 0-1.8-0.6-2-1.3-0.1-0.3 0-0.7 0.4-0.7h6.6v-10.3c1 0.6 2 1.1 2 1.3v11z"></path></g>
<g id="vaadin:book-percent"><path d="M12.6 2.5c-1.6-1.2-1.6-2.5-1.6-2.5h-9v12.5c0 1.9 1.6 3.5 3.5 3.5h8.5v-13c0 0-1-0.2-1.4-0.5zM5.5 3.2c0.8 0 1.5 0.7 1.5 1.6s-0.7 1.4-1.5 1.4-1.5-0.6-1.5-1.4 0.7-1.6 1.5-1.6zM9 3h1l-5 7h-1l5-7zM10 8.5c0 0.8-0.7 1.5-1.5 1.5s-1.5-0.7-1.5-1.5 0.7-1.5 1.5-1.5 1.5 0.7 1.5 1.5zM13 15h-7.5c-1 0-1.8-0.6-2-1.3-0.1-0.4 0-0.7 0.4-0.7h7.1v-10.3c0 0.6 1 1.1 2 1.3v11z"></path><path d="M9 8.5c0 0.276-0.224 0.5-0.5 0.5s-0.5-0.224-0.5-0.5c0-0.276 0.224-0.5 0.5-0.5s0.5 0.224 0.5 0.5z"></path><path d="M6 4.8c0 0.276-0.224 0.5-0.5 0.5s-0.5-0.224-0.5-0.5c0-0.276 0.224-0.5 0.5-0.5s0.5 0.224 0.5 0.5z"></path></g>
<g id="vaadin:book"><path d="M12.6 2.5c-1.6-1.2-1.6-2.5-1.6-2.5h-9v12.5c0 1.9 1.6 3.5 3.5 3.5h8.5v-13c0 0-1-0.2-1.4-0.5zM4 2h5v2h-5v-2zM13 15h-7.5c-1 0-1.8-0.6-2-1.3-0.1-0.4 0-0.7 0.4-0.7h7.1v-10.3c0.4 0.6 1.2 1.1 2 1.3v11z"></path></g>
<g id="vaadin:bookmark-o"><path d="M3 0v16l5-5 5 5v-16h-10zM12 13.7l-4-3.9-4 3.9v-10.7h8v10.7zM12 2h-8v-1h8v1z"></path></g>
<g id="vaadin:bookmark"><path d="M3 0v0 1h10l0.1-1z"></path><path d="M3 2h10v14l-5-5-5 5z"></path></g>
<g id="vaadin:briefcase"><path d="M11 3v-2h-6v2h-5v12h16v-12h-5zM10 3h-4v-1h4v1z"></path></g>
<g id="vaadin:browser"><path d="M15 1v-1h-15v15h1v1h15v-15h-1zM3 1h9v1h-9v-1zM1 1h1v1h-1v-1zM1 3h13v11h-13v-11z"></path></g>
<g id="vaadin:bug-o"><path d="M13 8v-1c1.216-1.124 1.981-2.721 2-4.497 0-0.28-0.224-0.503-0.5-0.503s-0.5 0.224-0.5 0.5c-0.018 1.112-0.431 2.125-1.105 2.906-0.876 0.978-2.15 1.594-3.569 1.594-0.020 0-0.040-0-0.059-0l-2.537 0c-0.022 0-0.049 0.001-0.075 0.001-1.414 0-2.684-0.612-3.561-1.586-0.669-0.781-1.079-1.793-1.094-2.901-0-0.279-0.224-0.503-0.5-0.503s-0.5 0.224-0.5 0.5c0.022 1.776 0.786 3.368 1.996 4.486l0.004 1.004c-3 0.060-3 1.42-3 3.47 0 0.276 0.224 0.5 0.5 0.5s0.5-0.224 0.5-0.5c0-1.72 0-2.4 2-2.47 0.031 1.11 0.245 2.161 0.612 3.136-0.383 0.006-0.696 0.176-0.942 0.414-0.445 0.624-0.711 1.402-0.711 2.242 0 0.2 0.015 0.397 0.044 0.589l-0.003 0.118c0 0.276 0.224 0.5 0.5 0.5s0.5-0.224 0.5-0.5v-0.14c-0.022-0.144-0.035-0.311-0.035-0.48 0-0.587 0.154-1.139 0.424-1.616 0.165-0.152 0.401-0.257 0.66-0.264 0.681 1.007 1.714 1.731 2.92 1.994l0.031-0.994h2v1c1.237-0.269 2.271-0.993 2.939-1.983 0.013-0.017 0.016-0.017 0.019-0.017 0.254 0 0.486 0.095 0.663 0.251 0.262 0.462 0.418 1.015 0.418 1.605 0 0.178-0.014 0.352-0.041 0.522l0.002 0.121c0 0.276 0.224 0.5 0.5 0.5s0.5-0.224 0.5-0.5v-0.14c0.025-0.165 0.039-0.356 0.039-0.551 0-0.839-0.266-1.616-0.717-2.251-0.238-0.226-0.551-0.396-0.9-0.466 0.336-0.917 0.55-1.975 0.578-3.080 2-0.012 2 0.708 2 2.458 0 0.276 0.224 0.5 0.5 0.5s0.5-0.224 0.5-0.5c0-2.030 0-3.39-3-3.47zM6 13.5c-0.44-0.253-0.805-0.589-1.083-0.989l-0.247-0.411-0.15-0.39c-0.302-0.802-0.49-1.73-0.52-2.697l-0-0.013v-1.65c0.578 0.326 1.254 0.556 1.973 0.647l0.027 5.573zM9 13h-2v-1h2v1zM9 11h-2v-1h2v1zM9 9h-2v-1h2v1zM12 9c-0.030 0.98-0.218 1.908-0.54 2.77l-0.13 0.33-0.24 0.4c-0.285 0.411-0.65 0.747-1.074 0.992l-0.016-5.492c0.743-0.081 1.421-0.297 2.029-0.624l-0.029 1.624z"></path><path d="M8 6.2c1.433-0.018 2.767-0.429 3.903-1.129 0.046-0.036 0.098-0.126 0.098-0.229 0-0.008-0-0.016-0.001-0.023-0.066-1.142-0.781-2.103-1.781-2.522-0.137-0.050-0.219-0.16-0.219-0.29 0-0.002 0-0.005 0-0.008v-1.5c0-0.276-0.224-0.5-0.5-0.5s-0.5 0.224-0.5 0.5v1.2c0 0.166-0.134 0.3-0.3 0.3 0 0 0 0 0 0h-1.4c-0.166 0-0.3-0.134-0.3-0.3v-1.2c0-0.276-0.224-0.5-0.5-0.5s-0.5 0.224-0.5 0.5v1.5c-0.006 0.125-0.086 0.229-0.198 0.269-1.026 0.43-1.744 1.4-1.802 2.544-0.001 0.014-0.001 0.021-0.001 0.029 0 0.102 0.051 0.193 0.13 0.247 0.959 0.703 2.161 1.125 3.462 1.125 0.144 0 0.287-0.005 0.428-0.015zM10 3c0.552 0 1 0.448 1 1s-0.448 1-1 1c-0.552 0-1-0.448-1-1s0.448-1 1-1zM6 3c0.552 0 1 0.448 1 1s-0.448 1-1 1c-0.552 0-1-0.448-1-1s0.448-1 1-1z"></path></g>
<g id="vaadin:bug"><path d="M8 6.2c1.433-0.018 2.767-0.429 3.903-1.129 0.046-0.036 0.098-0.126 0.098-0.229 0-0.008-0-0.016-0.001-0.023-0.066-1.142-0.781-2.103-1.781-2.522-0.137-0.050-0.219-0.16-0.219-0.29 0-0.002 0-0.005 0-0.008v-1.5c0-0.276-0.224-0.5-0.5-0.5s-0.5 0.224-0.5 0.5v1.2c0 0.166-0.134 0.3-0.3 0.3 0 0 0 0 0 0h-1.4c-0.166 0-0.3-0.134-0.3-0.3v-1.2c0-0.276-0.224-0.5-0.5-0.5s-0.5 0.224-0.5 0.5v1.5c-0.006 0.125-0.086 0.229-0.198 0.269-1.026 0.43-1.744 1.4-1.802 2.544-0.001 0.014-0.001 0.021-0.001 0.029 0 0.102 0.051 0.193 0.13 0.247 0.959 0.703 2.161 1.125 3.462 1.125 0.144 0 0.287-0.005 0.428-0.015zM10 3c0.552 0 1 0.448 1 1s-0.448 1-1 1c-0.552 0-1-0.448-1-1s0.448-1 1-1zM6 3c0.552 0 1 0.448 1 1s-0.448 1-1 1c-0.552 0-1-0.448-1-1s0.448-1 1-1z"></path><path d="M13 8v-1c1.216-1.124 1.981-2.721 2-4.497 0-0.28-0.224-0.503-0.5-0.503s-0.5 0.224-0.5 0.5c-0.018 1.112-0.431 2.125-1.105 2.906-0.876 0.978-2.15 1.594-3.569 1.594-0.020 0-0.040-0-0.059-0l-2.537 0c-0.022 0-0.049 0.001-0.075 0.001-1.414 0-2.684-0.612-3.561-1.586-0.669-0.781-1.079-1.793-1.094-2.901-0-0.279-0.224-0.503-0.5-0.503s-0.5 0.224-0.5 0.5c0.022 1.776 0.786 3.368 1.996 4.486l0.004 1.004c-3 0.060-3 1.42-3 3.47 0 0.276 0.224 0.5 0.5 0.5s0.5-0.224 0.5-0.5c0-1.72 0-2.4 2-2.47 0.031 1.11 0.245 2.161 0.612 3.136-0.383 0.006-0.696 0.176-0.942 0.414-0.445 0.624-0.711 1.402-0.711 2.242 0 0.2 0.015 0.397 0.044 0.589l-0.003 0.118c0 0.276 0.224 0.5 0.5 0.5s0.5-0.224 0.5-0.5v-0.14c-0.022-0.144-0.035-0.311-0.035-0.48 0-0.587 0.154-1.139 0.424-1.616 0.165-0.152 0.401-0.257 0.66-0.264 0.588 1.095 1.667 1.859 2.934 1.998l0.017-0.998h2v1c1.284-0.141 2.364-0.905 2.94-1.98 0.012-0.020 0.015-0.020 0.018-0.020 0.254 0 0.486 0.095 0.663 0.251 0.262 0.462 0.418 1.015 0.418 1.605 0 0.178-0.014 0.352-0.041 0.522l0.002 0.121c0 0.276 0.224 0.5 0.5 0.5s0.5-0.224 0.5-0.5v-0.14c0.025-0.165 0.039-0.356 0.039-0.551 0-0.839-0.266-1.616-0.717-2.251-0.238-0.226-0.551-0.396-0.9-0.466 0.336-0.917 0.55-1.975 0.578-3.080 2-0.012 2 0.708 2 2.458 0 0.276 0.224 0.5 0.5 0.5s0.5-0.224 0.5-0.5c0-2.030 0-3.39-3-3.47zM9 13h-2v-1h2v1zM9 11h-2v-1h2v1zM9 9h-2v-1h2v1z"></path></g>
<g id="vaadin:building-o"><path d="M2 0v16h12v-16h-12zM13 15h-4v-3h-2v3h-4v-14h10v14z"></path><path d="M4 9h2v2h-2v-2z"></path><path d="M7 9h2v2h-2v-2z"></path><path d="M10 9h2v2h-2v-2z"></path><path d="M4 6h2v2h-2v-2z"></path><path d="M7 6h2v2h-2v-2z"></path><path d="M10 6h2v2h-2v-2z"></path><path d="M4 3h2v2h-2v-2z"></path><path d="M7 3h2v2h-2v-2z"></path><path d="M10 3h2v2h-2v-2z"></path></g>
<g id="vaadin:building"><path d="M3 0v16h4v-3h2v3h4v-16h-10zM6 12h-2v-2h2v2zM6 9h-2v-2h2v2zM6 6h-2v-2h2v2zM6 3h-2v-2h2v2zM9 12h-2v-2h2v2zM9 9h-2v-2h2v2zM9 6h-2v-2h2v2zM9 3h-2v-2h2v2zM12 12h-2v-2h2v2zM12 9h-2v-2h2v2zM12 6h-2v-2h2v2zM12 3h-2v-2h2v2z"></path></g>
<g id="vaadin:bullets"><path d="M0 2.5v0c0 0.8 0.7 1.5 1.5 1.5v0c0.8 0 1.5-0.7 1.5-1.5v0c0-0.8-0.7-1.5-1.5-1.5v0c-0.8 0-1.5 0.7-1.5 1.5z"></path><path d="M0 7.5v0c0 0.8 0.7 1.5 1.5 1.5v0c0.8 0 1.5-0.7 1.5-1.5v0c0-0.8-0.7-1.5-1.5-1.5v0c-0.8 0-1.5 0.7-1.5 1.5z"></path><path d="M0 12.5v0c0 0.8 0.7 1.5 1.5 1.5v0c0.8 0 1.5-0.7 1.5-1.5v0c0-0.8-0.7-1.5-1.5-1.5v0c-0.8 0-1.5 0.7-1.5 1.5z"></path><path d="M5 1h11v3h-11v-3z"></path><path d="M5 6h11v3h-11v-3z"></path><path d="M5 11h11v3h-11v-3z"></path></g>
<g id="vaadin:bullseye"><path d="M8 0c-4.4 0-8 3.6-8 8s3.6 8 8 8 8-3.6 8-8-3.6-8-8-8zM8 14.9c-3.8 0-6.9-3.1-6.9-6.9s3.1-6.9 6.9-6.9 6.9 3.1 6.9 6.9-3.1 6.9-6.9 6.9z"></path><path d="M8 2.3c-3.2 0-5.7 2.5-5.7 5.7s2.6 5.7 5.7 5.7 5.7-2.6 5.7-5.7-2.5-5.7-5.7-5.7zM8 12.6c-2.5 0-4.6-2.1-4.6-4.6s2.1-4.6 4.6-4.6 4.6 2.1 4.6 4.6c0 2.5-2.1 4.6-4.6 4.6z"></path><path d="M8 4.6c-1.9 0-3.4 1.5-3.4 3.4s1.5 3.4 3.4 3.4c1.9 0 3.4-1.5 3.4-3.4s-1.5-3.4-3.4-3.4z"></path></g>
<g id="vaadin:bus"><path d="M14.67 4h-0.67v-2c0-1.105-0.895-2-2-2h-8c-1.105 0-2 0.895-2 2v2h-0.68c-0 0-0 0-0 0-0.177 0-0.32 0.143-0.32 0.32 0 0.004 0 0.007 0 0.011l-0 2.339c-0 0.003-0 0.006-0 0.010 0 0.177 0.143 0.32 0.32 0.32 0 0 0 0 0 0h0.68v6c0 0.55 0 1 1 1v1.5c0 0.276 0.224 0.5 0.5 0.5h2c0.276 0 0.5-0.224 0.5-0.5v-1.5h4v1.5c0 0.276 0.224 0.5 0.5 0.5h2c0.276 0 0.5-0.224 0.5-0.5v-1.5c1 0 1-0.45 1-1v-6h0.67c0.182 0 0.33-0.148 0.33-0.33s-0.148-0.33-0.33-0.33c-0.182 0-0.33 0.148-0.33 0.33s0.148 0.33 0.33 0.33c0.182 0 0.33-0.148 0.33-0.33v-2.34c0-0.182-0.148-0.33-0.33-0.33 0 0 0 0 0 0zM6 1h4v1h-4v-1zM4 12c-0.552 0-1-0.448-1-1s0.448-1 1-1c0.552 0 1 0.448 1 1s-0.448 1-1 1zM3 8v-5h10v5h-10zM12 12c-0.552 0-1-0.448-1-1s0.448-1 1-1c0.552 0 1 0.448 1 1s-0.448 1-1 1z"></path></g>
<g id="vaadin:button"><path d="M15.7 5.3l-1-1c-0.2-0.2-0.4-0.3-0.7-0.3h-13c-0.6 0-1 0.4-1 1v5c0 0.3 0.1 0.6 0.3 0.7l1 1c0.2 0.2 0.4 0.3 0.7 0.3h13c0.6 0 1-0.4 1-1v-5c0-0.3-0.1-0.5-0.3-0.7zM14 10h-13v-5h13v5z"></path></g>
<g id="vaadin:calc-book"><path d="M11.9 0c-1.3 0-2 0.4-2.4 0.8-0.4-0.4-1.1-0.8-2.5-0.8-3.4 0-4 2-4 2v0 0 4h-3v10h7v-4.6l1.5-0.2c0 0 0.2-0.3 0.3 0.7h1.3c0.1-1 0.4-0.7 0.4-0.7l5.5 0.7v-9.8c0 0-0.6-2.1-4.1-2.1zM1 7h5v2h-5v-2zM6 10v1h-1v-1h1zM4 10v1h-1v-1h1zM2 15h-1v-1h1v1zM2 13h-1v-1h1v1zM2 11h-1v-1h1v1zM4 15h-1v-1h1v1zM4 13h-1v-1h1v1zM6 15h-1v-1h1v1zM6 13h-1v-1h1v1zM9 9.5c-0.9-0.1-1.3-0.3-2-0.3v-3.2h-3v-3.9c0-0.4 0.8-1.5 3-1.5 1.8 0 1.9 0.8 1.9 1 0 0 0 0 0 0v7.9zM15 9.9c-1-0.4-1.1-0.7-2.5-0.7-0.1 0-0.2 0-0.2 0-1 0-1.3 0.2-2.3 0.4v-7.6c0 0 0-0.1 0-0.1s0-0.1 0-0.1c0-0.2 0.2-1.1 1.9-1.1 2.3 0 3.1 0.9 3.1 1.4v7.8z"></path></g>
<g id="vaadin:calc"><path d="M9 3h6v2h-6v-2z"></path><path d="M9 11h6v2h-6v-2z"></path><path d="M5 1h-2v2h-2v2h2v2h2v-2h2v-2h-2z"></path><path d="M7 10.4l-1.4-1.4-1.6 1.6-1.6-1.6-1.4 1.4 1.6 1.6-1.6 1.6 1.4 1.4 1.6-1.6 1.6 1.6 1.4-1.4-1.6-1.6z"></path><path d="M13 14.5c0 0.552-0.448 1-1 1s-1-0.448-1-1c0-0.552 0.448-1 1-1s1 0.448 1 1z"></path><path d="M13 9.5c0 0.552-0.448 1-1 1s-1-0.448-1-1c0-0.552 0.448-1 1-1s1 0.448 1 1z"></path></g>
<g id="vaadin:calendar-briefcase"><path d="M3 0h1v3h-1v-3z"></path><path d="M11 0h1v3h-1v-3z"></path><path d="M13 1v3h-3v-3h-5v3h-3v-3h-2v14h5v-1h-4v-8h13v3h1v-8z"></path><path d="M13 10v-2h-4v2h-3v6h10v-6h-3zM10 9h2v1h-2v-1z"></path></g>
<g id="vaadin:calendar-clock"><path d="M3 0h1v3h-1v-3z"></path><path d="M11 0h1v3h-1v-3z"></path><path d="M6.6 14h-5.6v-8h13v0.6c0.4 0.2 0.7 0.4 1 0.7v-6.3h-2v3h-3v-3h-5v3h-3v-3h-2v14h7.3c-0.3-0.3-0.5-0.6-0.7-1z"></path><path d="M14 12h-3v-3h1v2h2z"></path><path d="M11.5 8c1.9 0 3.5 1.6 3.5 3.5s-1.6 3.5-3.5 3.5-3.5-1.6-3.5-3.5 1.6-3.5 3.5-3.5zM11.5 7c-2.5 0-4.5 2-4.5 4.5s2 4.5 4.5 4.5 4.5-2 4.5-4.5-2-4.5-4.5-4.5v0z"></path></g>
<g id="vaadin:calendar-envelope"><path d="M3 0h1v2h-1v-2z"></path><path d="M9 0h1v2h-1v-2z"></path><path d="M13 7v-6h-2v2h-3v-2h-3v2h-3v-2h-2v12h4v3h12v-9h-3zM4 12h-3v-7h11v2h-8v5zM5 10.2l2.6 1.5-2.6 2.6v-4.1zM5.7 15l2.8-2.8 1.5 0.9 1.5-0.8 2.8 2.8h-8.6zM15 14.3l-2.6-2.6 2.6-1.4v4zM15 9.2l-5 2.7-5-2.9v-1h10v1.2zM15.4 9.6v0 0 0z"></path></g>
<g id="vaadin:calendar-o"><path d="M14 1v3h-3v-3h-6v3h-3v-3h-2v15h16v-15h-2zM15 15h-14v-9h14v9z"></path><path d="M3 0h1v3h-1v-3z"></path><path d="M12 0h1v3h-1v-3z"></path></g>
<g id="vaadin:calendar-user"><path d="M3 0h1v3h-1v-3z"></path><path d="M11 0h1v3h-1v-3z"></path><path d="M9 14.1c0-0.1 0-0.1 0 0l-8-0.1v-8h13v1.2c0.4 0.1 0.7 0.3 1 0.6v-6.8h-2v3h-3v-3h-5v3h-3v-3h-2v14h9v-0.9z"></path><path d="M15 10c0 1.105-0.895 2-2 2s-2-0.895-2-2c0-1.105 0.895-2 2-2s2 0.895 2 2z"></path><path d="M13.9 12h-1.8c-1.1 0-2.1 0.9-2.1 2.1v1.9h6v-1.9c0-1.2-0.9-2.1-2.1-2.1z"></path></g>
<g id="vaadin:calendar"><path d="M14 1v3h-3v-3h-6v3h-3v-3h-2v15h16v-15h-2zM3 15h-2v-2h2v2zM3 12h-2v-2h2v2zM3 9h-2v-2h2v2zM6 15h-2v-2h2v2zM6 12h-2v-2h2v2zM6 9h-2v-2h2v2zM9 15h-2v-2h2v2zM9 12h-2v-2h2v2zM9 9h-2v-2h2v2zM12 15h-2v-2h2v2zM12 12h-2v-2h2v2zM12 9h-2v-2h2v2zM15 15h-2v-2h2v2zM15 12h-2v-2h2v2zM15 9h-2v-2h2v2z"></path><path d="M3 0h1v3h-1v-3z"></path><path d="M12 0h1v3h-1v-3z"></path></g>
<g id="vaadin:camera"><path d="M11 9c0 1.657-1.343 3-3 3s-3-1.343-3-3c0-1.657 1.343-3 3-3s3 1.343 3 3z"></path><path d="M11 4v-3h-6v3h-5v9h5c0.8 0.6 1.9 1 3 1s2.2-0.4 3-1h5v-9h-5zM6 2h4v2h-4v-2zM8 13c-2.2 0-4-1.8-4-4s1.8-4 4-4c2.2 0 4 1.8 4 4s-1.8 4-4 4zM15 6h-2v-1h2v1z"></path></g>
<g id="vaadin:car"><path d="M15 6.1l-1.4-2.9c-0.4-0.7-1.1-1.2-1.9-1.2h-7.4c-0.8 0-1.5 0.5-1.9 1.2l-1.4 2.9c-0.6 0.1-1 0.6-1 1.1v3.5c0 0.6 0.4 1.1 1 1.2v2c0 0.6 0.5 1.1 1.1 1.1h0.9c0.5 0 1-0.5 1-1.1v-1.9h8v1.9c0 0.6 0.5 1.1 1.1 1.1h0.9c0.6 0 1.1-0.5 1.1-1.1v-2c0.6-0.1 1-0.6 1-1.2v-3.5c-0.1-0.5-0.5-1-1.1-1.1zM4 8.4c0 0.3-0.3 0.6-0.6 0.6h-1.8c-0.3 0-0.6-0.3-0.6-0.6v-0.8c0-0.3 0.3-0.6 0.6-0.6h1.8c0.3 0 0.6 0.3 0.6 0.6v0.8zM10 11h-4v-1h4v1zM2.1 6l1.2-2.4c0.2-0.4 0.6-0.6 1-0.6h7.4c0.4 0 0.8 0.2 1 0.6l1.2 2.4h-11.8zM15 8.4c0 0.3-0.3 0.6-0.6 0.6h-1.8c-0.3 0-0.6-0.3-0.6-0.6v-0.8c0-0.3 0.3-0.6 0.6-0.6h1.8c0.3 0 0.6 0.3 0.6 0.6v0.8z"></path></g>
<g id="vaadin:caret-down"><path d="M3 4h10l-5 7z"></path></g>
<g id="vaadin:caret-left"><path d="M11 3v10l-7-5z"></path></g>
<g id="vaadin:caret-right"><path d="M5 13v-10l7 5z"></path></g>
<g id="vaadin:caret-square-down-o"><path d="M15 1h-14v14h14v-14zM14 14h-12v-12h12v12z"></path><path d="M4 6h8l-4 5z"></path></g>
<g id="vaadin:caret-square-left-o"><path d="M15 1h-14v14h14v-14zM14 14h-12v-12h12v12z"></path><path d="M10 4v8l-5-4z"></path></g>
<g id="vaadin:caret-square-right-o"><path d="M15 1h-14v14h14v-14zM14 14h-12v-12h12v12z"></path><path d="M5.9 12v-8l5 4z"></path></g>
<g id="vaadin:caret-square-up-o"><path d="M15 1h-14v14h14v-14zM14 14h-12v-12h12v12z"></path><path d="M12 10h-8l4-5z"></path></g>
<g id="vaadin:caret-up"><path d="M13 12h-10l5-7z"></path></g>
<g id="vaadin:cart-o"><path d="M14 13.1v-1.1h-9.4l0.6-1.1 9.2-0.9 1.6-6h-12.3l-0.7-3h-3v1h2.2l2.1 8.4-1.3 2.6v1.5c0 0.8 0.7 1.5 1.5 1.5s1.5-0.7 1.5-1.5-0.7-1.5-1.5-1.5h7.5v1.5c0 0.8 0.7 1.5 1.5 1.5s1.5-0.7 1.5-1.5c0-0.7-0.4-1.2-1-1.4zM4 5h10.7l-1.1 4-8.4 0.9-1.2-4.9z"></path></g>
<g id="vaadin:cart"><path d="M14 13.1v-1.1h-9.4l0.6-1.1 9.2-0.9 1.6-6h-12.3l-0.7-3h-3v1h2.2l2.1 8.4-1.3 2.6v1.5c0 0.8 0.7 1.5 1.5 1.5s1.5-0.7 1.5-1.5-0.7-1.5-1.5-1.5h7.5v1.5c0 0.8 0.7 1.5 1.5 1.5s1.5-0.7 1.5-1.5c0-0.7-0.4-1.2-1-1.4z"></path></g>
<g id="vaadin:cash"><path d="M16 14h-14v-1h13v-7h1v8z"></path><path d="M13 4v7h-12v-7h12zM14 3h-14v9h14v-9z"></path><path d="M3 6h-1v3h1v1h4c-1.381 0-2.5-1.119-2.5-2.5s1.119-2.5 2.5-2.5h-4v1z"></path><path d="M11 6v-1h-4c1.381 0 2.5 1.119 2.5 2.5s-1.119 2.5-2.5 2.5h4v-1h1v-3h-1z"></path></g>
<g id="vaadin:chart-3d"><path d="M12 4v-2l-4-2-4 2v1l-4 2v5l12 6 4-2v-8zM4 10.88l-3-1.5v-3.3l3 1.53v3.27zM4 6.49l-2.34-1.2 2.34-1.17v2.37zM8 12.88l-3-1.5v-8.31l3 1.54v8.27zM5.66 2.29l2.34-1.17 2.34 1.17-2.34 1.2zM12 14.88l-3-1.5v-6.31l3 1.54v6.27zM12 7.49l-2.34-1.2 2.34-1.17 2.34 1.17z"></path></g>
<g id="vaadin:chart-grid"><path d="M0 9v7h16v-7h-16zM5 15h-4v-1h4v1zM5 13h-4v-1h4v1zM5 11h-4v-1h4v1zM10 15h-4v-1h4v1zM10 13h-4v-1h4v1zM10 11h-4v-1h4v1zM15 15h-4v-1h4v1zM15 13h-4v-1h4v1zM15 11h-4v-1h4v1z"></path><path d="M16 8h-16v-8h1v7h15v1z"></path><path d="M15 1.57l-5.020 2.86-3.96-1.98-4.020 1.61v1.080l3.98-1.59 4.040 2.020 4.98-2.85v-1.15z"></path></g>
<g id="vaadin:chart-line"><path d="M0 16h16v-16h-1v2.6l-4 3.4v-6h-1v6.4l-4-0.9v-5.5h-1v5.7l-4 2.9v-8.6h-1zM5 14h-4v-1.7l4-2.9v4.6zM10 14h-4v-5.3l0.1-0.1 3.9 0.9v4.5zM15 14h-4v-4.3h0.1l3.9-3.2v7.5z"></path></g>
<g id="vaadin:chart-timeline"><path d="M16 13v-1h-15v-12h-1v13h5v2h-5v1h16v-1h-5v-2h5z"></path><path d="M9 7l-3-3-4 4v3h14v-11l-7 7z"></path></g>
<g id="vaadin:chart"><path d="M0 15h16v1h-16v-1z"></path><path d="M0 0h1v16h-1v-16z"></path><path d="M9 8l-2.9-3-4.1 4v5h14v-13.1z"></path></g>
<g id="vaadin:chat"><path d="M14 14.2c0 0 0 0 0 0 0-0.6 2-1.8 2-3.1 0-1.5-1.4-2.7-3.1-3.2 0.7-0.8 1.1-1.7 1.1-2.8 0-2.8-2.9-5.1-6.6-5.1-3.5 0-7.4 2.1-7.4 5.1 0 2.1 1.6 3.6 2.3 4.2-0.1 1.2-0.6 1.7-0.6 1.7l-1.2 1h1.5c1.6 0 2.9-0.5 3.7-1.1 0 0.1 0 0.1 0 0.2 0 2 2.2 3.6 5 3.6 0.2 0 0.4 0 0.6 0 0.4 0.5 1.7 1.4 3.4 1.4 0.1-0.1-0.7-0.5-0.7-1.9zM7.4 1c3.1 0 5.6 1.9 5.6 4.1s-2.6 4.1-5.8 4.1c-0.2 0-0.6 0-0.8 0h-0.3l-0.1 0.2c-0.3 0.4-1.5 1.2-3.1 1.5 0.1-0.4 0.1-1 0.1-1.8v-0.3c-1-0.8-2.1-2.2-2.1-3.6 0-2.2 3.2-4.2 6.5-4.2z"></path></g>
<g id="vaadin:check-circle-o"><path d="M8 1c3.9 0 7 3.1 7 7s-3.1 7-7 7-7-3.1-7-7 3.1-7 7-7zM8 0c-4.4 0-8 3.6-8 8s3.6 8 8 8 8-3.6 8-8-3.6-8-8-8v0z"></path><path d="M7.1 11.7l-4.2-4.1 1.4-1.4 2.8 2.7 4.9-4.9 1.4 1.4z"></path></g>
<g id="vaadin:check-circle"><path d="M8 0c-4.4 0-8 3.6-8 8s3.6 8 8 8 8-3.6 8-8-3.6-8-8-8zM7.1 11.7l-4.2-4.1 1.4-1.4 2.7 2.7 5-4.9 1.4 1.4-6.3 6.3z"></path></g>
<g id="vaadin:check-square-o"><path d="M14 6.2v7.8h-12v-12h10.5l1-1h-12.5v14h14v-9.8z"></path><path d="M7.9 10.9l-4.2-4.2 1.5-1.4 2.7 2.8 6.7-6.7 1.4 1.4z"></path></g>
<g id="vaadin:check-square"><path d="M13 0.9l-1 1.1h-12v14h14v-10.5l1.7-2-2.7-2.6zM6.5 11.7l-4.2-4.2 1.4-1.4 2.7 2.7 6.6-6.6 1.4 1.4-7.9 8.1z"></path></g>
<g id="vaadin:check"><path d="M7.3 14.2l-7.1-5.2 1.7-2.4 4.8 3.5 6.6-8.5 2.3 1.8z"></path></g>
<g id="vaadin:chevron-circle-down-o"><path d="M13 6.6l-5 5-5-5 1.4-1.4 3.6 3.6 3.6-3.6z"></path><path d="M1 8c0-3.9 3.1-7 7-7s7 3.1 7 7-3.1 7-7 7-7-3.1-7-7zM0 8c0 4.4 3.6 8 8 8s8-3.6 8-8-3.6-8-8-8-8 3.6-8 8v0z"></path></g>
<g id="vaadin:chevron-circle-down"><path d="M0 8c0 4.4 3.6 8 8 8s8-3.6 8-8-3.6-8-8-8-8 3.6-8 8zM11.6 5.2l1.4 1.4-5 5-5-5 1.4-1.4 3.6 3.6 3.6-3.6z"></path></g>
<g id="vaadin:chevron-circle-left-o"><path d="M9.4 13l-5-5 5-5 1.4 1.4-3.6 3.6 3.6 3.6z"></path><path d="M8 1c3.9 0 7 3.1 7 7s-3.1 7-7 7-7-3.1-7-7 3.1-7 7-7zM8 0c-4.4 0-8 3.6-8 8s3.6 8 8 8 8-3.6 8-8-3.6-8-8-8v0z"></path></g>
<g id="vaadin:chevron-circle-left"><path d="M8 0c-4.4 0-8 3.6-8 8s3.6 8 8 8 8-3.6 8-8-3.6-8-8-8zM10.8 11.6l-1.4 1.4-5-5 5-5 1.4 1.4-3.6 3.6 3.6 3.6z"></path></g>
<g id="vaadin:chevron-circle-right-o"><path d="M6.6 13l5-5-5-5-1.4 1.4 3.6 3.6-3.6 3.6z"></path><path d="M8 1c3.9 0 7 3.1 7 7s-3.1 7-7 7-7-3.1-7-7 3.1-7 7-7zM8 0c-4.4 0-8 3.6-8 8s3.6 8 8 8 8-3.6 8-8-3.6-8-8-8v0z"></path></g>
<g id="vaadin:chevron-circle-right"><path d="M8 16c4.4 0 8-3.6 8-8s-3.6-8-8-8-8 3.6-8 8 3.6 8 8 8zM5.2 4.4l1.4-1.4 5 5-5 5-1.4-1.4 3.6-3.6-3.6-3.6z"></path></g>
<g id="vaadin:chevron-circle-up-o"><path d="M3 9.4l5-5 5 5-1.4 1.4-3.6-3.6-3.6 3.6z"></path><path d="M15 8c0 3.9-3.1 7-7 7s-7-3.1-7-7 3.1-7 7-7 7 3.1 7 7zM16 8c0-4.4-3.6-8-8-8s-8 3.6-8 8 3.6 8 8 8 8-3.6 8-8v0z"></path></g>
<g id="vaadin:chevron-circle-up"><path d="M16 8c0-4.4-3.6-8-8-8s-8 3.6-8 8 3.6 8 8 8 8-3.6 8-8zM4.4 10.8l-1.4-1.4 5-5 5 5-1.4 1.4-3.6-3.6-3.6 3.6z"></path></g>
<g id="vaadin:chevron-down-small"><path d="M8 12l-6.32-6.32 1.67-1.68 4.65 4.65 4.65-4.65 1.67 1.68-6.32 6.32z"></path></g>
<g id="vaadin:chevron-down"><path d="M8 13.1l-8-8 2.1-2.2 5.9 5.9 5.9-5.9 2.1 2.2z"></path></g>
<g id="vaadin:chevron-left-small"><path d="M4 8l6.32-6.32 1.68 1.67-4.65 4.65 4.65 4.65-1.68 1.67-6.32-6.32z"></path></g>
<g id="vaadin:chevron-left"><path d="M2.9 8l8-8 2.2 2.1-5.9 5.9 5.9 5.9-2.2 2.1z"></path></g>
<g id="vaadin:chevron-right-small"><path d="M12 8l-6.32-6.32-1.68 1.67 4.65 4.65-4.65 4.65 1.68 1.67 6.32-6.32z"></path></g>
<g id="vaadin:chevron-right"><path d="M13.1 8l-8 8-2.2-2.1 5.9-5.9-5.9-5.9 2.2-2.1z"></path></g>
<g id="vaadin:chevron-up-small"><path d="M8 4l-6.32 6.32 1.67 1.68 4.65-4.65 4.65 4.65 1.67-1.68-6.32-6.32z"></path></g>
<g id="vaadin:chevron-up"><path d="M8 2.9l8 8-2.1 2.2-5.9-5.9-5.9 5.9-2.1-2.2z"></path></g>
<g id="vaadin:child"><path d="M10 5c0 1.105-0.895 2-2 2s-2-0.895-2-2c0-1.105 0.895-2 2-2s2 0.895 2 2z"></path><path d="M12.79 10.32l-2.6-2.63c-0.421-0.426-1.004-0.69-1.65-0.69h-1.070c-0 0-0 0-0.001 0-0.648 0-1.235 0.264-1.659 0.69l-2.6 2.63c-0.216 0.129-0.358 0.362-0.358 0.628 0 0.403 0.327 0.73 0.73 0.73 0.266 0 0.499-0.142 0.626-0.355l1.792-1.793v6.47h1.5v-4h1v4h1.5v-6.47l1.75 1.8c0.135 0.175 0.344 0.287 0.58 0.287 0.403 0 0.73-0.327 0.73-0.73 0-0.228-0.105-0.432-0.269-0.566z"></path></g>
<g id="vaadin:circle-thin"><path d="M8 1c3.9 0 7 3.1 7 7s-3.1 7-7 7-7-3.1-7-7 3.1-7 7-7zM8 0c-4.4 0-8 3.6-8 8s3.6 8 8 8 8-3.6 8-8-3.6-8-8-8v0z"></path></g>
<g id="vaadin:circle"><path d="M8 0c-4.4 0-8 3.6-8 8s3.6 8 8 8 8-3.6 8-8-3.6-8-8-8z"></path></g>
<g id="vaadin:clipboard-check"><path d="M11 1v-1h-6v1h-2v1h-1v14h12v-1h1v-14h-4zM6 1h4v2h-4v-2zM13 15h-10v-12h2v1h6v-1h2v12z"></path><path d="M7.39 12.47l-3-2.73 1.35-1.48 1.58 1.44 2.87-2.9 1.42 1.4-4.22 4.27z"></path></g>
<g id="vaadin:clipboard-cross"><path d="M11 1v-1h-6v1h-2v1h-1v14h12v-1h1v-14h-4zM6 1h4v2h-4v-2zM13 15h-10v-12h2v1h6v-1h2v12z"></path><path d="M11 8h-2v-2h-2v2h-2v2h2v2h2v-2h2z"></path></g>
<g id="vaadin:clipboard-heart"><path d="M9.5 7c0 0 0 0 0 0-0.6 0-1.1 0.6-1.5 1-0.4-0.4-0.9-1-1.5-1 0 0 0 0 0 0-1.5 0-2.1 1.9-1 2.9l2.5 2.1 2.5-2.1c1.1-1 0.5-2.9-1-2.9z"></path><path d="M11 1v-1h-6v1h-2v1h-1v14h12v-1h1v-14h-4zM6 1h4v2h-4v-2zM13 15h-10v-12h2v1h6v-1h2v12z"></path></g>
<g id="vaadin:clipboard-pulse"><path d="M11 1v-1h-6v1h-2v1h-1v14h12v-1h1v-14h-4zM6 1h4v2h-4v-2zM13 15h-10v-12h2v1h6v-1h2v12z"></path><path d="M9.3 13c0 0 0 0 0 0-0.2 0-0.3-0.1-0.4-0.3l-0.8-4.8-0.7 3.1c0 0.1-0.1 0.2-0.3 0.3-0.1 0-0.3 0-0.4-0.1l-1-1.3h-1.3c-0.2 0-0.4-0.2-0.4-0.4s0.2-0.4 0.4-0.4h1.6c0.1 0 0.2 0.1 0.3 0.1l0.6 0.8 0.9-4.3c0-0.2 0.2-0.3 0.4-0.3 0 0 0 0 0 0 0.2 0 0.3 0.2 0.3 0.4l0.9 5.3 0.6-1.7c0.1-0.1 0.2-0.2 0.3-0.2h1.3c0.2 0 0.4 0.2 0.4 0.4s-0.2 0.4-0.4 0.4h-1l-1 2.9c0 0-0.2 0.1-0.3 0.1z"></path></g>
<g id="vaadin:clipboard-text"><path d="M4 6h8v1h-8v-1z"></path><path d="M4 8h8v1h-8v-1z"></path><path d="M4 10h5v1h-5v-1z"></path><path d="M11 1v-1h-6v1h-2v1h-1v14h12v-1h1v-14h-4zM6 1h4v2h-4v-2zM13 15h-10v-12h2v1h6v-1h2v12z"></path></g>
<g id="vaadin:clipboard-user"><path d="M11 1v-1h-6v1h-2v1h-1v14h12v-1h1v-14h-4zM6 1h4v2h-4v-2zM13 15h-10v-12h2v1h6v-1h2v12z"></path><path d="M8 6c-2.5 0-1.3 3.2-1.3 3.2 0.3 0.4 0.7 0.4 0.7 0.6 0 0.3-0.3 0.3-0.6 0.4-0.5 0.1-0.9-0.1-1.4 0.8-0.3 0.4-0.4 2-0.4 2h6c0 0-0.1-1.6-0.4-2-0.4-0.8-0.9-0.7-1.4-0.8-0.3 0-0.6-0.1-0.6-0.4s0.3-0.2 0.6-0.6c0.1 0 1.3-3.2-1.2-3.2z"></path></g>
<g id="vaadin:clipboard"><path d="M11 1v-1h-6v1h-2v1h-1v14h12v-1h1v-14h-4zM6 1h4v2h-4v-2zM13 15h-10v-12h2v1h6v-1h2v12z"></path></g>
<g id="vaadin:clock"><path d="M8 0c-4.4 0-8 3.6-8 8s3.6 8 8 8 8-3.6 8-8-3.6-8-8-8zM8 14c-3.3 0-6-2.7-6-6s2.7-6 6-6 6 2.7 6 6-2.7 6-6 6z"></path><path d="M8 3h-1v6h5v-1h-4z"></path></g>
<g id="vaadin:close-big"><path d="M16 0l-1 0.010-7 6.99-7-6.99-1-0.010v1l7 7-7 7v1h1l7-7 7 7h1v-1l-7-7 7-7v-1z"></path></g>
<g id="vaadin:close-circle-o"><path d="M8 1c3.9 0 7 3.1 7 7s-3.1 7-7 7-7-3.1-7-7 3.1-7 7-7zM8 0c-4.4 0-8 3.6-8 8s3.6 8 8 8 8-3.6 8-8-3.6-8-8-8v0z"></path><path d="M12.2 10.8l-2.8-2.8 2.8-2.8-1.4-1.4-2.8 2.8-2.8-2.8-1.4 1.4 2.8 2.8-2.8 2.8 1.4 1.4 2.8-2.8 2.8 2.8z"></path></g>
<g id="vaadin:close-circle"><path d="M8 0c-4.4 0-8 3.6-8 8s3.6 8 8 8 8-3.6 8-8-3.6-8-8-8zM12.2 10.8l-1.4 1.4-2.8-2.8-2.8 2.8-1.4-1.4 2.8-2.8-2.8-2.8 1.4-1.4 2.8 2.8 2.8-2.8 1.4 1.4-2.8 2.8 2.8 2.8z"></path></g>
<g id="vaadin:close-small"><path d="M12.96 4.46l-1.42-1.42-3.54 3.55-3.54-3.55-1.42 1.42 3.55 3.54-3.55 3.54 1.42 1.42 3.54-3.55 3.54 3.55 1.42-1.42-3.55-3.54 3.55-3.54z"></path></g>
<g id="vaadin:close"><path d="M15.1 3.1l-2.2-2.2-4.9 5-4.9-5-2.2 2.2 5 4.9-5 4.9 2.2 2.2 4.9-5 4.9 5 2.2-2.2-5-4.9z"></path></g>
<g id="vaadin:cloud-download-o"><path d="M14.1 9.8c0-0.2 0-0.4 0-0.6 0-2.4-1.9-4.3-4.2-4.3-0.3 0.1-0.6 0.1-0.9 0.1v-3h-2v2.4c-0.4-0.3-0.9-0.4-1.3-0.4-1.6 0-2.9 1.3-2.9 2.9 0 0.3 0.1 0.6 0.2 0.9-1.6 0.2-3 1.8-3 3.6 0 1.9 1.5 3.6 3.3 3.6h10.3c1.4 0 2.4-1.5 2.4-2.7s-0.8-2.3-1.9-2.5zM13.6 14h-10.3c-1.2 0-2.3-1.3-2.3-2.6s1.1-2.6 2.3-2.6c0.1 0 0.3 0 0.4 0l1.4 0.2-0.9-1c-0.2-0.3-0.4-0.7-0.4-1.2 0-1 0.8-1.8 1.8-1.8 0.5 0 1 0.2 1.3 0.6v2.4h-1.9l3 4 3-4h-2v-1.9c0.3-0.1 0.6-0.1 0.9-0.1 1.8 0 3.2 1.5 3.2 3.3 0 0.3 0 0.6-0.1 0.9l-0.2 0.6 0.8 0.1c0.7 0 1.4 0.7 1.4 1.5 0 0.7-0.6 1.6-1.4 1.6z"></path></g>
<g id="vaadin:cloud-download"><path d="M14 10c0 0-0.1 0-0.1 0 0-0.3 0.1-0.6 0.1-1 0-2.2-1.8-4-4-4v-4h-4v3.1c-0.2-0.1-0.3-0.1-0.5-0.1-1.4 0-2.5 1.1-2.5 2.5 0 0.6 0.2 1.1 0.6 1.6-0.2-0.1-0.4-0.1-0.6-0.1-1.7 0-3 1.3-3 3s1.3 3 3 3h11c1.1 0 2-0.9 2-2s-0.9-2-2-2zM8 11.4l-2.9-3.4h1.9v-6h2v6h1.9l-2.9 3.4z"></path></g>
<g id="vaadin:cloud-o"><path d="M14.1 8.9c0-0.2 0-0.4 0-0.6 0-2.4-1.9-4.3-4.2-4.3-0.6 0-1.2 0.1-1.8 0.4-0.5-0.7-1.5-1.2-2.4-1.2-1.6 0-2.9 1.2-2.9 2.8 0 0.3 0.1 0.6 0.2 0.9-1.6 0.2-3 1.8-3 3.5 0 1.9 1.5 3.6 3.3 3.6h10.3c1.4 0 2.4-1.4 2.4-2.6s-0.8-2.2-1.9-2.5zM13.6 13h-10.3c-1.2 0-2.3-1.2-2.3-2.5s1.1-2.5 2.3-2.5c0.1 0 0.3 0 0.4 0l1.3 0.3-0.8-1.2c-0.2-0.3-0.4-0.7-0.4-1.1 0-1 0.8-1.8 1.8-1.8 0.8 0 1.5 0.5 1.7 1.2l0.3 0.6 0.5-0.3c0.5-0.3 1.1-0.5 1.8-0.5 1.8 0 3.2 1.5 3.2 3.3 0 0.3 0 0.6-0.1 0.9l-0.2 0.6h0.8c0.7 0 1.4 0.7 1.4 1.5 0 0.6-0.6 1.5-1.4 1.5z"></path></g>
<g id="vaadin:cloud-upload-o"><path d="M14.1 10.9c0-0.2 0-0.4 0-0.6 0-2.4-1.9-4.3-4.2-4.3-0.3 0-0.6 0-0.9 0.1v-2.1h2l-3-4-3 4h2v1.5c-0.4-0.2-0.9-0.3-1.3-0.3-1.6 0-2.9 1.2-2.9 2.8 0 0.3 0.1 0.6 0.2 0.9-1.6 0.2-3 1.8-3 3.5 0 1.9 1.5 3.6 3.3 3.6h10.3c1.4 0 2.4-1.4 2.4-2.6s-0.8-2.2-1.9-2.5zM13.6 15h-10.3c-1.2 0-2.3-1.2-2.3-2.5s1.1-2.5 2.3-2.5c0.1 0 0.3 0 0.4 0l1.3 0.3-0.8-1.2c-0.2-0.3-0.4-0.7-0.4-1.1 0-1 0.8-1.8 1.8-1.8 0.5 0 1 0.2 1.3 0.6v3.2h2v-2.8c0.3-0.1 0.6-0.1 0.9-0.1 1.8 0 3.2 1.5 3.2 3.3 0 0.3 0 0.6-0.1 0.9l-0.2 0.6h0.8c0.7 0 1.4 0.7 1.4 1.5 0.1 0.7-0.5 1.6-1.3 1.6z"></path></g>
<g id="vaadin:cloud-upload"><path d="M14 10c0 0-0.1 0-0.1 0 0-0.3 0.1-0.6 0.1-1 0-1.6-1-3-2.4-3.6l-3.6-4.4-2.5 3c-1.4 0-2.5 1.1-2.5 2.5 0 0.6 0.2 1.1 0.6 1.6-0.2-0.1-0.4-0.1-0.6-0.1-1.7 0-3 1.3-3 3s1.3 3 3 3h11c1.1 0 2-0.9 2-2s-0.9-2-2-2zM9 6v6h-2v-6h-1.9l2.9-3.4 2.9 3.4h-1.9z"></path></g>
<g id="vaadin:cloud"><path d="M14 13c1.1 0 2-0.9 2-2s-0.9-2-2-2c0 0-0.1 0-0.1 0 0-0.3 0.1-0.6 0.1-1 0-2.2-1.8-4-4-4-0.8 0-1.5 0.2-2.2 0.6-0.3-0.9-1.2-1.6-2.3-1.6-1.4 0-2.5 1.1-2.5 2.5 0 0.6 0.2 1.1 0.6 1.6-0.2-0.1-0.4-0.1-0.6-0.1-1.7 0-3 1.3-3 3s1.3 3 3 3h11z"></path></g>
<g id="vaadin:cluster"><path d="M14 12c-0.372 0.011-0.716 0.121-1.008 0.305l-2.212-2.155c0.434-0.547 0.708-1.239 0.74-1.993l1.57-0.157c0.225 0.556 0.76 0.941 1.385 0.941 0.823 0 1.49-0.667 1.49-1.49s-0.667-1.49-1.49-1.49c-0.749 0-1.368 0.552-1.474 1.271l-1.591 0.128c-0.224-1.136-0.973-2.060-1.978-2.521l0.308-0.839h0.26c1.099-0.008 1.986-0.9 1.986-2 0-1.105-0.895-2-2-2s-2 0.895-2 2c0 0.742 0.404 1.39 1.004 1.735l-0.27 0.855c-0.227-0.054-0.487-0.084-0.754-0.084-0.83 0-1.59 0.296-2.181 0.789l-2.994-3.004c0.141-0.224 0.225-0.497 0.225-0.79 0-0.828-0.672-1.5-1.5-1.5s-1.5 0.672-1.5 1.5c0 0.823 0.663 1.492 1.484 1.5 0.281-0.001 0.544-0.079 0.767-0.214l2.993 3.004c-0.474 0.588-0.76 1.344-0.76 2.168 0 0.015 0 0.030 0 0.045-0 0.058-0 0.108-0 0.158l-0.66 0.11c-0.313-0.72-1.019-1.214-1.839-1.214-1.105 0-2 0.895-2 2s0.895 2 2 2c1.105 0 2-0.895 2-2 0-0.020-0-0.039-0.001-0.059l0.63-0.097c0.242 0.843 0.768 1.538 1.466 1.992l-0.556 1.188c-0.161-0.049-0.347-0.078-0.539-0.080-0.006-0-0.012-0-0.017-0-1.105 0-2 0.895-2 2s0.895 2 2 2c1.105 0 2-0.895 2-2 0-0.64-0.301-1.211-0.769-1.577l0.566-1.153c0.364 0.146 0.787 0.231 1.229 0.231 0.847 0 1.621-0.311 2.216-0.824l2.176 2.124c-0.25 0.33-0.4 0.748-0.4 1.2 0 1.105 0.895 2 2 2s2-0.895 2-2c0-1.105-0.895-2-2-2 0 0 0 0 0 0zM5 15c-0.552 0-1-0.448-1-1s0.448-1 1-1c0.552 0 1 0.448 1 1s-0.448 1-1 1zM8 10.5c-1.381 0-2.5-1.119-2.5-2.5s1.119-2.5 2.5-2.5c1.381 0 2.5 1.119 2.5 2.5s-1.119 2.5-2.5 2.5z"></path></g>
<g id="vaadin:code"><path d="M5.2 14l4.5-12h1.1l-4.5 12z"></path><path d="M11.1 13h1.2l3.7-5-3.7-5h-1.3l3.8 5z"></path><path d="M4.9 13h-1.2l-3.7-5 3.7-5h1.3l-3.8 5z"></path></g>
<g id="vaadin:coffee"><path d="M14 13l-4 1h-6l-4-1v-1h14z"></path><path d="M14.7 3h-1.7v-1h-12v5c0 1.5 0.8 2.8 2 3.4v0.6h8v-0.6c0.9-0.5 1.6-1.4 1.9-2.4 0 0 0.1 0 0.1 0 2.3 0 2.9-2 3-3.5 0.1-0.8-0.5-1.5-1.3-1.5zM13 7v-3h1.7c0.1 0 0.2 0.1 0.2 0.1s0.1 0.1 0.1 0.3c-0.2 2.6-1.6 2.6-2 2.6z"></path></g>
<g id="vaadin:cog-o"><path d="M15.2 6l-1.1-0.2c-0.1-0.2-0.1-0.4-0.2-0.6l0.6-0.9 0.5-0.7-2.6-2.6-0.7 0.5-0.9 0.6c-0.2-0.1-0.4-0.1-0.6-0.2l-0.2-1.1-0.2-0.8h-3.6l-0.2 0.8-0.2 1.1c-0.2 0.1-0.4 0.1-0.6 0.2l-0.9-0.6-0.7-0.4-2.5 2.5 0.5 0.7 0.6 0.9c-0.2 0.2-0.2 0.4-0.3 0.6l-1.1 0.2-0.8 0.2v3.6l0.8 0.2 1.1 0.2c0.1 0.2 0.1 0.4 0.2 0.6l-0.6 0.9-0.5 0.7 2.6 2.6 0.7-0.5 0.9-0.6c0.2 0.1 0.4 0.1 0.6 0.2l0.2 1.1 0.2 0.8h3.6l0.2-0.8 0.2-1.1c0.2-0.1 0.4-0.1 0.6-0.2l0.9 0.6 0.7 0.5 2.6-2.6-0.5-0.7-0.6-0.9c0.1-0.2 0.2-0.4 0.2-0.6l1.1-0.2 0.8-0.2v-3.6l-0.8-0.2zM15 9l-1.7 0.3c-0.1 0.5-0.3 1-0.6 1.5l0.9 1.4-1.4 1.4-1.4-0.9c-0.5 0.3-1 0.5-1.5 0.6l-0.3 1.7h-2l-0.3-1.7c-0.5-0.1-1-0.3-1.5-0.6l-1.4 0.9-1.4-1.4 0.9-1.4c-0.3-0.5-0.5-1-0.6-1.5l-1.7-0.3v-2l1.7-0.3c0.1-0.5 0.3-1 0.6-1.5l-1-1.4 1.4-1.4 1.4 0.9c0.5-0.3 1-0.5 1.5-0.6l0.4-1.7h2l0.3 1.7c0.5 0.1 1 0.3 1.5 0.6l1.4-0.9 1.4 1.4-0.9 1.4c0.3 0.5 0.5 1 0.6 1.5l1.7 0.3v2z"></path><path d="M8 4.5c-1.9 0-3.5 1.6-3.5 3.5s1.6 3.5 3.5 3.5 3.5-1.6 3.5-3.5c0-1.9-1.6-3.5-3.5-3.5zM8 10.5c-1.4 0-2.5-1.1-2.5-2.5s1.1-2.5 2.5-2.5 2.5 1.1 2.5 2.5c0 1.4-1.1 2.5-2.5 2.5z"></path></g>
<g id="vaadin:cog"><path d="M16 9v-2l-1.7-0.6c-0.2-0.6-0.4-1.2-0.7-1.8l0.8-1.6-1.4-1.4-1.6 0.8c-0.5-0.3-1.1-0.6-1.8-0.7l-0.6-1.7h-2l-0.6 1.7c-0.6 0.2-1.2 0.4-1.7 0.7l-1.6-0.8-1.5 1.5 0.8 1.6c-0.3 0.5-0.5 1.1-0.7 1.7l-1.7 0.6v2l1.7 0.6c0.2 0.6 0.4 1.2 0.7 1.8l-0.8 1.6 1.4 1.4 1.6-0.8c0.5 0.3 1.1 0.6 1.8 0.7l0.6 1.7h2l0.6-1.7c0.6-0.2 1.2-0.4 1.8-0.7l1.6 0.8 1.4-1.4-0.8-1.6c0.3-0.5 0.6-1.1 0.7-1.8l1.7-0.6zM8 12c-2.2 0-4-1.8-4-4s1.8-4 4-4 4 1.8 4 4-1.8 4-4 4z"></path><path d="M10.6 7.9c0 1.381-1.119 2.5-2.5 2.5s-2.5-1.119-2.5-2.5c0-1.381 1.119-2.5 2.5-2.5s2.5 1.119 2.5 2.5z"></path></g>
<g id="vaadin:cogs"><path d="M12 7v-2l-1.2-0.4c-0.1-0.3-0.2-0.7-0.4-1l0.6-1.2-1.5-1.3-1.1 0.5c-0.3-0.2-0.6-0.3-1-0.4l-0.4-1.2h-2l-0.4 1.2c-0.3 0.1-0.7 0.2-1 0.4l-1.1-0.5-1.4 1.4 0.6 1.2c-0.2 0.3-0.3 0.6-0.4 1l-1.3 0.3v2l1.2 0.4c0.1 0.3 0.2 0.7 0.4 1l-0.5 1.1 1.4 1.4 1.2-0.6c0.3 0.2 0.6 0.3 1 0.4l0.3 1.3h2l0.4-1.2c0.3-0.1 0.7-0.2 1-0.4l1.2 0.6 1.4-1.4-0.6-1.2c0.2-0.3 0.3-0.6 0.4-1l1.2-0.4zM3 6c0-1.7 1.3-3 3-3s3 1.3 3 3c0 1.7-1.3 3-3 3s-3-1.3-3-3z"></path><path d="M7.5 6c0 0.828-0.672 1.5-1.5 1.5s-1.5-0.672-1.5-1.5c0-0.828 0.672-1.5 1.5-1.5s1.5 0.672 1.5 1.5z"></path><path d="M16 3v-1h-0.6c0-0.2-0.1-0.4-0.2-0.5l0.4-0.4-0.7-0.7-0.4 0.4c-0.2-0.1-0.3-0.2-0.5-0.2v-0.6h-1v0.6c-0.2 0-0.4 0.1-0.5 0.2l-0.4-0.4-0.7 0.7 0.4 0.4c-0.1 0.2-0.2 0.3-0.2 0.5h-0.6v1h0.6c0 0.2 0.1 0.4 0.2 0.5l-0.4 0.4 0.7 0.7 0.4-0.4c0.2 0.1 0.3 0.2 0.5 0.2v0.6h1v-0.6c0.2 0 0.4-0.1 0.5-0.2l0.4 0.4 0.7-0.7-0.4-0.4c0.1-0.2 0.2-0.3 0.2-0.5h0.6zM13.5 3.5c-0.6 0-1-0.4-1-1s0.4-1 1-1 1 0.4 1 1c0 0.6-0.4 1-1 1z"></path><path d="M15.4 11.8c-0.1-0.3-0.2-0.6-0.4-0.9l0.3-0.6-0.7-0.7-0.5 0.4c-0.3-0.2-0.6-0.3-0.9-0.4l-0.2-0.6h-1l-0.2 0.6c-0.3 0.1-0.6 0.2-0.9 0.4l-0.6-0.3-0.7 0.7 0.3 0.6c-0.2 0.3-0.3 0.6-0.4 0.9l-0.5 0.1v1l0.6 0.2c0.1 0.3 0.2 0.6 0.4 0.9l-0.3 0.6 0.7 0.7 0.6-0.3c0.3 0.2 0.6 0.3 0.9 0.4l0.1 0.5h1l0.2-0.6c0.3-0.1 0.6-0.2 0.9-0.4l0.6 0.3 0.7-0.7-0.4-0.5c0.2-0.3 0.3-0.6 0.4-0.9l0.6-0.2v-1l-0.6-0.2zM12.5 14c-0.8 0-1.5-0.7-1.5-1.5s0.7-1.5 1.5-1.5 1.5 0.7 1.5 1.5-0.7 1.5-1.5 1.5z"></path></g>
<g id="vaadin:coin-piles"><path d="M10.5 0c-3.040 0-5.5 0.88-5.5 2 0 0 0 0 0 0v2c-3 0.1-5 0.94-5 2 0 0 0 0 0 0v2s0 0 0 0v2s0 0 0 0v2c0 1.090 2.46 2 5.5 2 0.020 0 0.043 0 0.067 0 0.732 0 1.45-0.055 2.153-0.16 0.698 1.305 2.094 2.158 3.69 2.158 2.017 0 3.715-1.363 4.224-3.217 0.209-0.199 0.344-0.442 0.367-0.717l0-2.064v-8c0-1.12-2.46-2-5.5-2zM5.5 5c2.5 0 4.5 0.45 4.5 1s-2 1-4.5 1-4.5-0.45-4.5-1 2-1 4.5-1zM5.5 13c-2.71 0-4.25-0.71-4.5-1v-0.8c1.199 0.512 2.595 0.809 4.060 0.809 0.155 0 0.309-0.003 0.462-0.010 0.508-0.001 1.030-0.030 1.544-0.085-0.043 0.371 0.022 0.712 0.123 1.037-0.452 0.021-0.967 0.051-1.488 0.051-0.070 0-0.141-0.001-0.211-0.002zM7.070 10.91c-0.467 0.057-1.008 0.090-1.556 0.090-0.005 0-0.010 0-0.014 0-2.709 0-4.249-0.71-4.499-1v-0.84c1.223 0.535 2.649 0.846 4.147 0.846 0.124 0 0.248-0.002 0.371-0.006 0.632-0.001 1.271-0.044 1.897-0.128-0.197 0.306-0.291 0.654-0.342 1.015zM5.5 9c-2.71 0-4.25-0.71-4.5-1v-0.9c1.223 0.535 2.649 0.846 4.147 0.846 0.124 0 0.248-0.002 0.371-0.006 0.088 0.004 0.212 0.006 0.337 0.006 1.498 0 2.923-0.311 4.214-0.872l-0.068 0.366c-0.777 0.265-1.432 0.717-1.935 1.304-0.752 0.165-1.611 0.256-2.491 0.256-0.026 0-0.052-0-0.077-0zM11.41 15c-1.883 0-3.41-1.527-3.41-3.41s1.527-3.41 3.41-3.41c1.883 0 3.41 1.527 3.41 3.41s-1.527 3.41-3.41 3.41zM15 8c-0.175 0.167-0.385 0.3-0.617 0.386-0.288-0.244-0.6-0.46-0.938-0.634 0.575-0.153 1.101-0.352 1.593-0.61l-0.038 0.858zM15 6c-0.24 0.31-1.61 0.94-4 1v-1c0.003 0 0.007 0 0.011 0 1.443 0 2.814-0.305 4.053-0.855l-0.064 0.855zM15 4c-0.25 0.33-1.79 1-4.5 1h-0.23c-1.213-0.63-2.648-1-4.169-1-0.014 0-0.029 0-0.043 0l-0.058-0v-0.9c1.223 0.535 2.649 0.846 4.147 0.846 0.124 0 0.248-0.002 0.371-0.006 0.088 0.004 0.212 0.006 0.337 0.006 1.498 0 2.923-0.311 4.214-0.872l-0.068 0.926zM10.5 3c-2.5 0-4.5-0.45-4.5-1s2-1 4.5-1 4.5 0.45 4.5 1-2 1-4.5 1z"></path><path d="M10.5 11h0.5v3h1v-5h-0.5l-1 2z"></path></g>
<g id="vaadin:coins"><path d="M11.5 0c-2.485 0-4.5 2.015-4.5 4.5 0.004 0.261 0.029 0.513 0.074 0.758-0.479-0.176-1.025-0.261-1.591-0.261-3.043 0-5.51 2.467-5.51 5.51s2.467 5.51 5.51 5.51c3.043 0 5.51-2.467 5.51-5.51 0-0.566-0.085-1.112-0.244-1.626 0.23 0.077 0.484 0.099 0.742 0.099 2.48 0 4.49-2.010 4.49-4.49 0-2.477-2.005-4.485-4.481-4.49zM10 10.5c0 2.485-2.015 4.5-4.5 4.5s-4.5-2.015-4.5-4.5c0-2.485 2.015-4.5 4.5-4.5 2.483 0.006 4.494 2.017 4.5 4.499zM12.5 7h-2v-0.5h0.5v-3h-0.5l1-1.5h0.5v4.5h0.5v0.5z"></path><path d="M5.63 8c0.033-0.003 0.072-0.005 0.111-0.005 0.696 0 1.26 0.564 1.26 1.26 0 0.016-0 0.031-0.001 0.047 0 1.698-1.86 2.698-1.86 2.698h1.37v-0.5h0.49v1.5h-3v-1s2-1.27 2-2.33c0-0.37 0-0.67-0.42-0.67-0.69 0-0.65 1-0.65 1h-0.93s-0.23-2 1.63-2z"></path></g>
<g id="vaadin:combobox"><path d="M15 4h-14c-0.6 0-1 0.4-1 1v6c0 0.6 0.4 1 1 1h14c0.6 0 1-0.4 1-1v-6c0-0.6-0.4-1-1-1zM10 11h-9v-6h9v6zM13 8.4l-2-1.4h4l-2 1.4z"></path><path d="M2 6h1v4h-1v-4z"></path></g>
<g id="vaadin:comment-ellipsis-o"><path d="M3 11.2c0 0.1 0 0.1 0 0 0 0.1 0 0.1 0 0 0 0 0 0 0 0z"></path><path d="M8.3 1c-4.4 0-8.3 2.6-8.3 5.6 0 2 1.1 3.7 3 4.7 0 0 0 0 0 0s0 0.1 0 0.1c-0.1 1.3-0.9 1.7-0.9 1.7l-1.8 0.9h2c2.5 0 4.3-1.1 5.1-1.9 0.3 0 0.6 0 0.8 0 4.3 0 7.8-2.5 7.8-5.6s-3.4-5.5-7.7-5.5zM8.2 11.1c-0.3 0-0.7 0-0.9 0h-0.2l-0.2 0.2c-0.5 0.5-1.6 1.4-3.3 1.7 0.3-0.5 0.5-1.1 0.5-2v-0.3l-0.3-0.1c-1.8-0.9-2.8-2.3-2.8-4 0-2.4 3.5-4.6 7.3-4.6 3.7 0 6.7 2 6.7 4.6 0 2.4-3.1 4.5-6.8 4.5z"></path><path d="M6 7c0 0.552-0.448 1-1 1s-1-0.448-1-1c0-0.552 0.448-1 1-1s1 0.448 1 1z"></path><path d="M9 7c0 0.552-0.448 1-1 1s-1-0.448-1-1c0-0.552 0.448-1 1-1s1 0.448 1 1z"></path><path d="M12 7c0 0.552-0.448 1-1 1s-1-0.448-1-1c0-0.552 0.448-1 1-1s1 0.448 1 1z"></path></g>
<g id="vaadin:comment-ellipsis"><path d="M8 1c-4.4 0-8 2.5-8 5.5 0 2 2 3.8 4 4.8 0 0 0 0 0 0 0 2.1-2 2.8-2 2.8 2.8 0 4.4-1.3 5.1-2.1 0.3 0 0.6 0 0.9 0 4.4 0 8-2.5 8-5.5s-3.6-5.5-8-5.5zM5 8c-0.6 0-1-0.4-1-1s0.4-1 1-1 1 0.4 1 1c0 0.6-0.4 1-1 1zM8 8c-0.6 0-1-0.4-1-1s0.4-1 1-1 1 0.4 1 1c0 0.6-0.4 1-1 1zM11 8c-0.6 0-1-0.4-1-1s0.4-1 1-1 1 0.4 1 1c0 0.6-0.4 1-1 1z"></path></g>
<g id="vaadin:comment-o"><path d="M3 11.2c0 0.1 0 0.1 0 0 0 0.1 0 0.1 0 0 0 0 0 0 0 0z"></path><path d="M8.3 1c-4.4 0-8.3 2.6-8.3 5.6 0 2 1.1 3.7 3 4.7 0 0 0 0 0 0s0 0.1 0 0.1c-0.1 1.3-0.9 1.7-0.9 1.7l-1.8 0.9h2c2.5 0 4.3-1.1 5.1-1.9 0.3 0 0.5 0 0.8 0 4.3 0 7.8-2.5 7.8-5.6s-3.4-5.5-7.7-5.5zM8.2 11.1c-0.3 0-0.7 0-0.9 0h-0.3l-0.2 0.2c-0.5 0.5-1.6 1.4-3.3 1.7 0.3-0.5 0.5-1.1 0.5-2v-0.3l-0.3-0.1c-1.8-0.9-2.7-2.3-2.7-4 0-2.4 3.5-4.6 7.3-4.6 3.7 0 6.7 2 6.7 4.6 0 2.4-3.1 4.5-6.8 4.5z"></path></g>
<g id="vaadin:comment"><path d="M8 1c-4.4 0-8 2.5-8 5.5 0 2 2 3.8 4 4.8 0 0 0 0 0 0 0 2.1-2 2.8-2 2.8 2.8 0 4.4-1.3 5.1-2.1 0.3 0 0.6 0 0.9 0 4.4 0 8-2.5 8-5.5s-3.6-5.5-8-5.5z"></path></g>
<g id="vaadin:comments-o"><path d="M14.2 14c0.6-0.5 1.8-1.6 1.8-3.2 0-1.4-1.2-2.6-2.8-3.3 0.5-0.6 0.8-1.5 0.8-2.4 0-2.8-2.9-5.1-6.6-5.1-3.5 0-7.4 2.1-7.4 5.1 0 2.1 1.6 3.6 2.3 4.2-0.1 1.2-0.6 1.7-0.6 1.7l-1.2 1h1.5c1.2 0 2.2-0.3 3-0.7 0.3 1.9 2.5 3.4 5.3 3.4 0.1 0 0.3 0 0.5 0 0.6 0.5 1.8 1.3 3.5 1.3h1.4l-1.1-0.9c0 0-0.3-0.3-0.4-1.1zM10.3 13.7c-2.3 0-4.3-1.3-4.3-2.8 0-0.1 0-0.1 0-0.2 0.2-0.2 0.4-0.3 0.5-0.5 0.2 0 0.5 0 0.7 0 2.1 0 4-0.7 5.2-1.9 1.5 0.5 2.6 1.5 2.6 2.5s-0.9 2-1.7 2.5l-0.3 0.2v0.3c0 0.5 0.2 0.8 0.3 1.1-1-0.2-1.7-0.7-1.9-1l-0.1-0.2h-0.2c-0.3 0-0.6 0-0.8 0zM7.4 1c3.1 0 5.6 1.9 5.6 4.1s-2.6 4.1-5.8 4.1c-0.2 0-0.6 0-0.8 0h-0.3l-0.1 0.2c-0.3 0.4-1.5 1.2-3.1 1.5 0.1-0.4 0.1-1 0.1-1.8v-0.3c-1-0.8-2.1-2.2-2.1-3.6 0-2.2 3.2-4.2 6.5-4.2z"></path></g>
<g id="vaadin:comments"><path d="M16 11.1c0-1.5-1.5-2.8-3.2-3.3-1.3 1.5-3.9 2.4-6.4 2.4-0.1 0-0.3 0-0.4 0 0 0 0 0-0.1 0-0.1 0.3-0.1 0.5-0.1 0.8 0 2 2.2 3.6 5 3.6 0.2 0 0.4 0 0.6 0 0.4 0.5 1.7 1.4 3.4 1.4 0 0-0.8-0.4-0.8-1.8 0 0 0 0 0 0 0-0.6 2-1.8 2-3.1z"></path><path d="M13 4.6c0-2.5-2.8-4.6-6.4-4.6s-6.6 2.1-6.6 4.6c0 1.7 2 3.2 3 4 0 0 0 0 0 0 0 1.8-1.4 2.4-1.4 2.4 2.3 0 3.6-1.1 4.2-1.8 0.2 0 0.5 0 0.8 0 3.5 0.1 6.4-2 6.4-4.6z"></path></g>
<g id="vaadin:compile"><path d="M1 12h4v4h-4v-4z"></path><path d="M6 12h4v4h-4v-4z"></path><path d="M11 12h4v4h-4v-4z"></path><path d="M1 7h4v4h-4v-4z"></path><path d="M1 2h4v4h-4v-4z"></path><path d="M6 7h4v4h-4v-4z"></path><path d="M7 1h4v4h-4v-4z"></path><path d="M11 7h4v4h-4v-4z"></path><path d="M13 0h3v3h-3v-3z"></path></g>
<g id="vaadin:compress-square"><path d="M12 0h-12v12l1-1v-10h10z"></path><path d="M4 16h12v-12l-1 1v10h-10z"></path><path d="M7 9h-5l1.8 1.8-3.8 3.8 1.4 1.4 3.8-3.8 1.8 1.8z"></path><path d="M16 1.4l-1.4-1.4-3.8 3.8-1.8-1.8v5h5l-1.8-1.8z"></path></g>
<g id="vaadin:compress"><path d="M5.3 9.3l-5 5 1.4 1.4 5-5 1.3 1.3v-4h-4z"></path><path d="M15.7 1.7l-1.4-1.4-4 4-1.3-1.3v4h4l-1.3-1.3z"></path></g>
<g id="vaadin:connect-o"><path d="M12.5 9c-1 0-1.8 0.4-2.4 1l-3.2-1.7c0.1-0.3 0.1-0.5 0.1-0.8 0-0.2 0-0.3 0-0.4l2.9-1.3c0.6 0.7 1.5 1.2 2.6 1.2 1.9 0 3.5-1.6 3.5-3.5s-1.6-3.5-3.5-3.5-3.5 1.6-3.5 3.5c0 0.2 0 0.3 0 0.4l-2.9 1.3c-0.6-0.7-1.5-1.2-2.6-1.2-1.9 0-3.5 1.6-3.5 3.5s1.6 3.5 3.5 3.5c1 0 1.8-0.4 2.4-1l3.1 1.7c0 0.3 0 0.5 0 0.8 0 1.9 1.6 3.5 3.5 3.5s3.5-1.6 3.5-3.5-1.6-3.5-3.5-3.5zM12.5 1c1.4 0 2.5 1.1 2.5 2.5s-1.1 2.5-2.5 2.5-2.5-1.1-2.5-2.5c0-1.4 1.1-2.5 2.5-2.5zM3.5 10c-1.4 0-2.5-1.1-2.5-2.5s1.1-2.5 2.5-2.5 2.5 1.1 2.5 2.5c0 1.4-1.1 2.5-2.5 2.5zM12.5 15c-1.4 0-2.5-1.1-2.5-2.5s1.1-2.5 2.5-2.5 2.5 1.1 2.5 2.5c0 1.4-1.1 2.5-2.5 2.5z"></path></g>
<g id="vaadin:connect"><path d="M12 10c-0.8 0-1.4 0.3-2 0.8l-3.2-1.8c0.1-0.3 0.2-0.7 0.2-1s-0.1-0.7-0.2-1l3.2-1.8c0.6 0.5 1.2 0.8 2 0.8 1.7 0 3-1.3 3-3s-1.3-3-3-3-3 1.3-3 3c0 0.2 0 0.3 0 0.5l-3.5 1.9c-0.4-0.2-0.9-0.4-1.5-0.4-1.6 0-3 1.3-3 3v0c0 1.6 1.4 3 3 3 0.6 0 1.1-0.2 1.5-0.4l3.5 1.9c0 0.2 0 0.3 0 0.5 0 1.7 1.3 3 3 3s3-1.3 3-3-1.3-3-3-3z"></path></g>
<g id="vaadin:controller"><path d="M5.951 0.249l0.981-0.195 0.195 0.981-0.981 0.195-0.195-0.981z"></path><path d="M8.877 14.966l0.981-0.195 0.195 0.981-0.981 0.195-0.195-0.981z"></path><path d="M0.055 9.071l0.981-0.195 0.195 0.981-0.981 0.195-0.195-0.981z"></path><path d="M14.773 6.145l0.981-0.195 0.195 0.981-0.981 0.195-0.195-0.981z"></path><path d="M11.471 1.897l0.556-0.831 0.831 0.556-0.556 0.831-0.831-0.556z"></path><path d="M3.139 14.441l0.56-0.83 0.83 0.56-0.56 0.83-0.83-0.56z"></path><path d="M1.069 3.989l0.56-0.83 0.83 0.56-0.56 0.83-0.83-0.56z"></path><path d="M13.547 12.299l0.556-0.831 0.831 0.556-0.556 0.831-0.831-0.556z"></path><path d="M8.875 1.039l0.195-0.981 0.981 0.195-0.195 0.981-0.981-0.195z"></path><path d="M5.953 15.745l0.195-0.981 0.981 0.195-0.195 0.981-0.981-0.195z"></path><path d="M0.061 6.931l0.195-0.981 0.981 0.195-0.195 0.981-0.981-0.195z"></path><path d="M14.767 9.854l0.195-0.981 0.981 0.195-0.195 0.981-0.981-0.195z"></path><path d="M3.139 1.628l0.831-0.556 0.556 0.831-0.831 0.556-0.556-0.831z"></path><path d="M11.477 14.101l0.831-0.556 0.556 0.831-0.831 0.556-0.556-0.831z"></path><path d="M1.071 12.033l0.831-0.556 0.556 0.831-0.831 0.556-0.556-0.831z"></path><path d="M13.539 3.63l0.83-0.56 0.56 0.83-0.83 0.56-0.56-0.83z"></path><path d="M14 8c-0.003-1.895-0.884-3.583-2.258-4.681l-3.322 4.991-0.84-0.59 3.32-5c-0.836-0.47-1.836-0.747-2.9-0.747-3.314 0-6 2.686-6 6s2.686 6 6 6c3.304 0 5.984-2.671 6-5.971z"></path></g>
<g id="vaadin:copy-o"><path d="M13 3h-3l-3-3h-7v13h6v3h10v-10l-3-3zM7 1l2 2h-2v-2zM1 12v-11h5v3h3v8h-8zM15 15h-8v-2h3v-9h2v3h3v8zM13 6v-2l2 2h-2z"></path></g>
<g id="vaadin:copy"><path d="M6 0v3h3z"></path><path d="M9 4h-4v-4h-5v12h9z"></path><path d="M13 4v3h3z"></path><path d="M12 4h-2v9h-3v3h9v-8h-4z"></path></g>
<g id="vaadin:copyright"><path d="M8 1.5c3.6 0 6.5 2.9 6.5 6.5s-2.9 6.5-6.5 6.5-6.5-2.9-6.5-6.5 2.9-6.5 6.5-6.5zM8 0c-4.4 0-8 3.6-8 8s3.6 8 8 8 8-3.6 8-8-3.6-8-8-8v0z"></path><path d="M9.9 10.3c-0.5 0.4-1.2 0.7-1.9 0.7-1.7 0-3-1.3-3-3s1.3-3 3-3c0.8 0 1.6 0.3 2.1 0.9l1.1-1.1c-0.8-0.8-2-1.3-3.2-1.3-2.5 0-4.5 2-4.5 4.5s2 4.5 4.5 4.5c1.1 0 2-0.4 2.8-1l-0.9-1.2z"></path></g>
<g id="vaadin:corner-lower-left"><path d="M16 16l-16-16v16z"></path></g>
<g id="vaadin:corner-lower-right"><path d="M16 16h-16l16-16z"></path></g>
<g id="vaadin:corner-upper-left"><path d="M0 16l16-16h-16z"></path></g>
<g id="vaadin:corner-upper-right"><path d="M16 16l-16-16h16z"></path></g>
<g id="vaadin:credit-card"><path d="M0 2v12h16v-12h-16zM15 13h-14v-5h14v5zM15 5h-14v-2h14v2z"></path><path d="M10 11h3v1h-3v-1z"></path><path d="M2 11h6v1h-6v-1z"></path></g>
<g id="vaadin:crop"><path d="M16 0.7v-0.7h-0.7l-3 3h-7.3v-3h-2v3h-3v2h3v8h8v3h2v-3h3v-2h-3v-7.3l3-3zM5 5h5.3l-5.3 5.3v-5.3zM11 11h-5.3l5.3-5.3v5.3z"></path></g>
<g id="vaadin:cross-cutlery"><path d="M10.9 8.6c0 0 0 0 0 0 0.6-0.1 1.2-0.4 1.6-0.9l3.1-3.1c0.4-0.4 0.4-1 0-1.4l-0.1-0.2-3 3c-0.2 0.2-0.6 0.2-0.9 0s-0.2-0.6 0-0.9l2.6-2.6c0.2-0.2 0.2-0.6 0-0.9-0.2-0.2-0.6-0.2-0.9 0l-2.6 2.6c-0.2 0.2-0.6 0.2-0.9 0-0.2-0.2-0.2-0.6 0-0.9l3-3-0.1-0.1c-0.4-0.4-1-0.4-1.4 0l-3.1 3.3c-0.4 0.4-0.7 1-0.8 1.6l-4.9-4.8c-0.4-0.4-1-0.3-1.3 0l-0.2 0.2c-1.4 1.4-0.9 4.2 1.5 6.6l0.8 0.8c0.4 0.4 0.9 0.7 1.5 0.8-0.5 0.4-0.8 0.8-0.8 0.8l-3.4 3.4c-0.7 0.7-0.7 1.9 0 2.6s1.9 0.7 2.6 0l3.3-3.5c0.2-0.2 0.7-0.8 1.3-1.5 0.3 0.4 0.5 0.6 0.5 0.6l4.3 4.3c0.7 0.7 1.9 0.7 2.6 0s0.7-1.9 0-2.6l-4.3-4.2z"></path></g>
<g id="vaadin:crosshairs"><path d="M7.5 0h1v4l-0.5 2-0.5-2v-4z"></path><path d="M8.5 16h-1v-4l0.5-2 0.5 2v4z"></path><path d="M16 7.5v1h-4l-2-0.5 2-0.5h4z"></path><path d="M0 8.5v-1h4l2 0.5-2 0.5h-4z"></path><path d="M8 2.5c3.038 0 5.5 2.462 5.5 5.5s-2.462 5.5-5.5 5.5c-3.038 0-5.5-2.462-5.5-5.5 0.006-3.035 2.465-5.494 5.499-5.5zM8 1c-3.866 0-7 3.134-7 7s3.134 7 7 7c3.866 0 7-3.134 7-7s-3.134-7-7-7v0z"></path></g>
<g id="vaadin:css"><path d="M4.1 11c1.4 0 1.9-1 1.9-1l-0.8-0.5c0 0-0.3 0.5-1 0.5s-1.2-0.9-1.2-2.2c0-1.2 0.6-1.8 1.2-1.8 0.5 0 0.9 0.4 0.9 0.4l0.8-0.6c0 0-0.7-0.8-1.7-0.8-1.1 0-2.2 0.9-2.2 2.8s0.9 3.2 2.1 3.2zM8.7 9.9c-0.3 0.1-0.7 0-1-0.4l-0.8 0.5c0.4 0.6 1 1 1.6 1 0.1 0 0.3 0 0.4-0.1 0.7-0.2 1.1-0.8 1.1-1.6 0-1.2-0.8-1.6-1.3-1.8-0.5-0.3-0.7-0.4-0.7-0.8s0.1-0.7 0.6-0.7c0.3 0 0.6 0.4 0.6 0.4l0.8-0.6c-0.2-0.3-0.7-0.8-1.4-0.8-0.9 0-1.6 0.6-1.6 1.6 0 1.1 0.7 1.5 1.2 1.8 0.6 0.2 0.8 0.4 0.8 0.9 0 0.3 0 0.6-0.3 0.6zM12.7 9.9c-0.3 0.1-0.7 0-1-0.4l-0.8 0.5c0.4 0.6 1 1 1.6 1 0.1 0 0.3 0 0.4-0.1 0.7-0.2 1.1-0.8 1.1-1.6 0-1.2-0.8-1.6-1.3-1.8-0.5-0.3-0.7-0.4-0.7-0.8s0.1-0.7 0.6-0.7c0.3 0 0.6 0.4 0.6 0.4l0.8-0.6c-0.2-0.3-0.7-0.8-1.4-0.8-0.9 0-1.6 0.6-1.6 1.6 0 1.1 0.7 1.5 1.2 1.8 0.6 0.2 0.8 0.4 0.8 0.9 0 0.3 0 0.6-0.3 0.6zM0 0v16h16v-16h-16zM15 15h-14v-14h14v14z"></path></g>
<g id="vaadin:ctrl-a"><path d="M9 7v-1h-1v-1h-1v1h-0.5v1h0.5v3.56c0.176 0.835 0.907 1.453 1.783 1.453 0.077 0 0.152-0.005 0.226-0.014l-0.009-0.999c-0.055 0.012-0.119 0.019-0.185 0.019-0.359 0-0.669-0.21-0.813-0.514l-0.002-3.505h1z"></path><path d="M14 3h1v9h-1v-9z"></path><path d="M13 6c-0.025-0.001-0.055-0.001-0.085-0.001-0.773 0-1.462 0.358-1.911 0.917l-0.004-0.915h-1v6h1v-3c-0.003-0.037-0.004-0.080-0.004-0.124 0-1.038 0.842-1.88 1.88-1.88 0.044 0 0.087 0.001 0.13 0.004l-0.006-1z"></path><path d="M4.19 12c-2.030 0-3.19-1.46-3.19-4s1.16-4 3.19-4c0.009-0 0.019-0 0.029-0 0.539 0 1.052 0.114 1.515 0.32l-0.424 0.901c-0.319-0.139-0.69-0.22-1.080-0.22-0.014 0-0.028 0-0.042 0-1.808-0-2.188 1.63-2.188 3s0.38 3 2.19 3c0.497-0.013 0.96-0.145 1.366-0.368l0.444 0.898c-0.524 0.285-1.146 0.458-1.806 0.47z"></path></g>
<g id="vaadin:ctrl"><path d="M0 0v16h16v-16h-16zM4.19 12c-2.030 0-3.19-1.46-3.19-4s1.16-4 3.19-4c0.009-0 0.019-0 0.029-0 0.539 0 1.052 0.114 1.515 0.32l-0.424 0.901c-0.319-0.139-0.69-0.22-1.080-0.22-0.014 0-0.028 0-0.042 0-1.808-0-2.188 1.63-2.188 3s0.38 3 2.19 3c0.497-0.013 0.96-0.145 1.366-0.368l0.444 0.898c-0.524 0.285-1.146 0.458-1.806 0.47zM9 7h-1v3.5c0.147 0.309 0.457 0.519 0.815 0.519 0.065 0 0.129-0.007 0.19-0.020l-0.006 1.001c-0.065 0.008-0.141 0.013-0.217 0.013-0.875 0-1.606-0.618-1.781-1.441l-0.002-3.572h-0.51v-1h0.51v-1h1v1h1v1zM11 9v3h-1v-6h1v0.92c0.453-0.564 1.142-0.921 1.915-0.921 0.030 0 0.060 0.001 0.090 0.002l-0.004 1c-0.037-0.003-0.080-0.004-0.124-0.004-1.038 0-1.88 0.842-1.88 1.88 0 0.044 0.001 0.087 0.004 0.13zM15 12h-1v-9h1v9z"></path></g>
<g id="vaadin:cube"><path d="M8 0l-8 2v10l8 4 8-4v-10l-8-2zM14.4 2.6l-5.9 2.2-6.6-2.2 6.1-1.6 6.4 1.6zM1 11.4v-8.1l7 2.4v9.2l-7-3.5z"></path></g>
<g id="vaadin:cubes"><path d="M12 6v-4l-4-2-4 2v4l-4 2v5l4 2 4-2 4 2 4-2v-5zM8.090 1.12l2.91 1.44-2.6 1.3-2.91-1.44zM5 2.78l3 1.5v3.6l-3-1.5v-3.6zM4 13.88l-3-1.5v-3.6l3 1.5v3.6zM4.28 9.88l-2.88-1.46 2.6-1.3 2.88 1.44zM12 13.88l-3-1.5v-3.6l3 1.5v3.6zM12.28 9.88l-2.88-1.46 2.6-1.3 2.88 1.44z"></path></g>
<g id="vaadin:curly-brackets"><path d="M2.1 3.1c0.2 1.3 0.4 1.6 0.4 2.9 0 0.8-1.5 1.5-1.5 1.5v1c0 0 1.5 0.7 1.5 1.5 0 1.3-0.2 1.6-0.4 2.9-0.3 2.1 0.8 3.1 1.8 3.1s2.1 0 2.1 0v-2c0 0-1.8 0.2-1.8-1 0-0.9 0.2-0.9 0.4-2.9 0.1-0.9-0.5-1.6-1.1-2.1 0.6-0.5 1.2-1.1 1.1-2-0.3-2-0.4-2-0.4-2.9 0-1.2 1.8-1.1 1.8-1.1v-2c0 0-1 0-2.1 0s-2.1 1-1.8 3.1z"></path><path d="M13.9 3.1c-0.2 1.3-0.4 1.6-0.4 2.9 0 0.8 1.5 1.5 1.5 1.5v1c0 0-1.5 0.7-1.5 1.5 0 1.3 0.2 1.6 0.4 2.9 0.3 2.1-0.8 3.1-1.8 3.1s-2.1 0-2.1 0v-2c0 0 1.8 0.2 1.8-1 0-0.9-0.2-0.9-0.4-2.9-0.1-0.9 0.5-1.6 1.1-2.1-0.6-0.5-1.2-1.1-1.1-2 0.2-2 0.4-2 0.4-2.9 0-1.2-1.8-1.1-1.8-1.1v-2c0 0 1 0 2.1 0s2.1 1 1.8 3.1z"></path></g>
<g id="vaadin:cursor-o"><path d="M5 2.6l5.75 6.4h-2.46l0.63 1.41 1.8 4-0.91 0.34-1.88-4.3-0.5-1.11-1 0.71-1.43 1.020v-8.47zM4 0v13l3-2.14 2.26 5.14 2.8-1-2.23-5h3.17l-9-10z"></path></g>
<g id="vaadin:cursor"><path d="M4 0v13l3.31-3.47 2.69 6.47 1.37-0.63-2.72-6.37h4.35l-9-9z"></path></g>
<g id="vaadin:cutlery"><path d="M13 0.8c0-0.5-0.4-0.8-0.8-0.8h-0.2c-1.7 0-3 1.9-3 4.7v0.9c0 1 0.5 1.9 1.4 2.4-0.3 1.2-0.4 2.5-0.4 2.5v4c0 0.8 0.7 1.5 1.5 1.5s1.5-0.7 1.5-1.5v-4c0-0.4-0.1-1.4-0.3-2.3 0.2-0.2 0.3-0.4 0.3-0.7v-6.7z"></path><path d="M7.2 0h-0.2v3.5c0 0.3-0.2 0.5-0.5 0.5s-0.5-0.2-0.5-0.5v-3c0-0.3-0.2-0.5-0.5-0.5s-0.5 0.2-0.5 0.5v3c0 0.3-0.2 0.5-0.5 0.5s-0.5-0.2-0.5-0.5v-3.5h-0.2c-0.4 0-0.8 0.4-0.8 0.8v3.7c0 1 0.6 1.9 1.5 2.3-0.4 1.6-0.5 3.7-0.5 3.7v4c0 0.8 0.7 1.5 1.5 1.5s1.5-0.7 1.5-1.5v-4c0-0.5-0.1-2.3-0.4-3.7 0.8-0.4 1.4-1.3 1.4-2.3v-3.7c0-0.4-0.4-0.8-0.8-0.8z"></path></g>
<g id="vaadin:dashboard"><path d="M16 10.1c0-4.4-3.6-8.1-8-8.1s-8 3.7-8 8.1c0 1.4 0.3 2.9 0.9 3.9h4.9c0.5 0.6 1.3 1 2.2 1s1.7-0.4 2.2-1h4.9c0.6-1 0.9-2.5 0.9-3.9zM14 7v1l-4.1 3.5c0 0.1 0.1 0.3 0.1 0.5 0 1.1-0.9 2-2 2s-2-0.9-2-2 0.9-2 2-2c0.3 0 0.6 0.1 0.8 0.2l4.2-3.2h1zM10 4h1v1h-1v-1zM5 4h1v1h-1v-1zM2 12h-1v-1h1v1zM3 8h-1v-1h1v1zM15 12h-1v-1h1v1z"></path><path d="M9 12c0 0.552-0.448 1-1 1s-1-0.448-1-1c0-0.552 0.448-1 1-1s1 0.448 1 1z"></path></g>
<g id="vaadin:database"><path d="M14 2.5c0 0.828-2.686 1.5-6 1.5s-6-0.672-6-1.5c0-0.828 2.686-1.5 6-1.5s6 0.672 6 1.5z"></path><path d="M8 5c-3.3 0-6-0.7-6-1.5v3c0 0.8 2.7 1.5 6 1.5s6-0.7 6-1.5v-3c0 0.8-2.7 1.5-6 1.5z"></path><path d="M8 9c-3.3 0-6-0.7-6-1.5v3c0 0.8 2.7 1.5 6 1.5s6-0.7 6-1.5v-3c0 0.8-2.7 1.5-6 1.5z"></path><path d="M8 13c-3.3 0-6-0.7-6-1.5v3c0 0.8 2.7 1.5 6 1.5s6-0.7 6-1.5v-3c0 0.8-2.7 1.5-6 1.5z"></path></g>
<g id="vaadin:date-input"><path d="M14 1v3h-3v-3h-6v3h-3v-3h-2v15h16v-15h-2zM15 15h-14v-9h14v9z"></path><path d="M3 0h1v3h-1v-3z"></path><path d="M12 0h1v3h-1v-3z"></path><path d="M3 8h1v5h-1v-5z"></path></g>
<g id="vaadin:deindent"><path d="M4 10.5v-6l-4 3z"></path><path d="M0 0h16v3h-16v-3z"></path><path d="M6 4h10v3h-10v-3z"></path><path d="M6 8h10v3h-10v-3z"></path><path d="M0 12h16v3h-16v-3z"></path></g>
<g id="vaadin:del-a"><path d="M14 3h1v9h-1v-9z"></path><path d="M3 12h-2v-9h2c2.23 0.051 4.019 1.871 4.019 4.109 0 0.138-0.007 0.274-0.020 0.408 0.013 0.1 0.020 0.236 0.020 0.374 0 2.238-1.788 4.058-4.014 4.109zM2 11h1c0.31 0 3-0.12 3-3.5s-2.88-3.5-3-3.5h-1v7z"></path><path d="M13 9v-0.5c-0.017-0.77-0.31-1.468-0.783-2.003-0.419-0.412-0.999-0.668-1.638-0.668-0.031 0-0.063 0.001-0.094 0.002-0.013-0.001-0.034-0.001-0.054-0.001-0.594 0-1.132 0.241-1.521 0.631-0.566 0.685-0.91 1.572-0.91 2.54 0 0.003-0 0.006-0 0.009 0 0.881 0.322 1.686 0.854 2.306 0.43 0.429 1.030 0.697 1.692 0.697 0.030 0 0.059-0.001 0.089-0.002 0.861-0.026 1.642-0.372 2.228-0.922l-0.712-0.708c-0.401 0.368-0.931 0.603-1.515 0.63-0.026 0.001-0.051 0.002-0.076 0.002-0.385 0-0.734-0.153-0.99-0.402-0.355-0.435-0.57-0.997-0.57-1.61l4-0zM10.5 6.8c0.020-0.001 0.043-0.002 0.066-0.002 0.362 0 0.691 0.141 0.935 0.372 0.209 0.224 0.361 0.505 0.427 0.818l-2.778 0.011c0.11-0.661 0.661-1.165 1.337-1.2z"></path></g>
<g id="vaadin:del"><path d="M0 0v16h16v-16h-16zM3 12h-2v-9h2c2.23 0.051 4.019 1.871 4.019 4.109 0 0.138-0.007 0.274-0.020 0.408 0.013 0.1 0.020 0.236 0.020 0.374 0 2.238-1.788 4.058-4.014 4.109zM13 9h-4c-0 0.004-0 0.008-0 0.012 0 0.607 0.211 1.164 0.564 1.603 0.252 0.244 0.601 0.397 0.986 0.397 0.025 0 0.049-0.001 0.074-0.002 0.586-0.027 1.115-0.261 1.518-0.631l0.708 0.712c-0.584 0.548-1.364 0.893-2.225 0.92-0.030 0.001-0.060 0.002-0.090 0.002-0.662 0-1.261-0.268-1.696-0.702-0.522-0.613-0.84-1.414-0.84-2.289 0-0.007 0-0.014 0-0.022-0-0.005-0-0.012-0-0.019 0-0.968 0.344-1.855 0.915-2.547 0.384-0.383 0.922-0.624 1.516-0.624 0.021 0 0.041 0 0.062 0.001 0.024-0.001 0.055-0.002 0.086-0.002 0.639 0 1.219 0.256 1.641 0.672 0.47 0.532 0.762 1.23 0.78 1.996l0 0.524zM15 12h-1v-9h1v9z"></path><path d="M3 4h-1v7h1c0.31 0 3-0.12 3-3.5s-2.88-3.5-3-3.5z"></path><path d="M10.49 6.8c-0.679 0.035-1.23 0.539-1.339 1.192l2.779 0.008c-0.069-0.324-0.22-0.606-0.431-0.831-0.242-0.229-0.571-0.371-0.934-0.371-0.027 0-0.053 0.001-0.079 0.002z"></path></g>
<g id="vaadin:dental-chair"><path d="M11.5 8.2c-0.3-0.1-0.6-0.2-0.8-0.2h-2.7v-1h3c0-0.6-0.4-1-1-1h-4c0 0.6 0.4 1 1 1v1c-0.5 0-1-0.2-1.2-0.6l-1.1-1.8c-0.3-0.4-0.7-0.6-1.1-0.6h-0.6v-0.7c0-0.3-0.1-0.5-0.2-0.8l-0.3-0.7c-0.3-0.5-0.9-0.8-1.5-0.8h-1l5 7c0.4 0.6 1.1 1 1.8 1h1.2v1h-1v2h-0.6c-0.9 0-1.8 0.4-2.4 1v0h-1v1h11v-1h-1c-0.6-0.6-1.5-1-2.4-1h-0.6v-2h-1v-1h1.6c0.2 0 0.5 0.1 0.7 0.2l1.7 0.9c0.9 0.5 2 0.5 2.9 0h0.1l-4.5-2.9z"></path></g>
<g id="vaadin:desktop"><path d="M16 0h-16v13h6v2h-2v1h8v-1h-2v-2h6v-13zM9 12h-2v-1h2v1zM15 10h-14v-8.9c0-0.1 0-0.1 0-0.1h14c0 0 0 0 0 0.1v8.9z"></path></g>
<g id="vaadin:diamond-o"><path d="M13 2h-10l-3 3.5 8 9.5 8-9.5zM4.64 5h-2.89l1.52-1.78zM6.42 5l1.58-1.84 1.58 1.84h-3.16zM10 6l-2 6.68-2-6.68h4zM5.26 6l1.89 6.44-5.42-6.44h3.53zM10.75 6h3.53l-5.43 6.44zM11.37 5l1.37-1.78 1.51 1.78h-2.9zM12 3l-1.44 1.81-1.46-1.81h2.9zM5.43 4.83l-1.43-1.83h2.9z"></path></g>
<g id="vaadin:diamond"><path d="M0 6h4l3 8.6-7-8.6z"></path><path d="M16 6h-4l-3 8.6 7-8.6z"></path><path d="M8 15l-3-9h6l-3 9z"></path><path d="M4 5h-4l2-3 2 3z"></path><path d="M16 5h-4l2-3 2 3z"></path><path d="M10 5h-4l2-3 2 3z"></path><path d="M3.34 2h3.66l-2 3-1.66-3z"></path><path d="M9 2h4l-2 3-2-3z"></path></g>
<g id="vaadin:diploma-scroll"><path d="M12.61 8.41c-0.53-0.079-1.008-0.223-1.454-0.424 2.104-1.876 4.424-3.536 4.454-3.556l0.1-0.070 0.060-0.11c0.177-0.367 0.281-0.797 0.281-1.252 0-0.901-0.407-1.707-1.046-2.244-0.523-0.482-1.219-0.776-1.983-0.776-0.538 0-1.043 0.146-1.476 0.4l-0.126 0.133c-1.578 2.181-3.182 4.099-4.908 5.899-1.836 1.638-3.87 3.195-6.018 4.592l-0.394 0.248v0.23c-0.077 0.314-0.122 0.675-0.122 1.046 0 0.97 0.304 1.87 0.822 2.609 0.507 0.53 1.237 0.87 2.045 0.87 0.055 0 0.109-0.002 0.162-0.005 0.026 0.002 0.065 0.003 0.104 0.003 0.701 0 1.317-0.36 1.674-0.905 0.245-0.308 2.065-2.608 4.005-4.708 0.268 0.464 0.476 1.003 0.594 1.575 0.032 0.249 0.046 0.496 0.046 0.747 0 0.823-0.158 1.61-0.445 2.331l1.685-2.043 1.33 1c-0.041-1.174-0.243-2.286-0.584-3.336-0.227-0.416-0.542-0.845-0.915-1.214 0.406 0.346 0.871 0.643 1.372 0.874 0.94 0.338 1.989 0.572 3.076 0.672l-0.949-1.266 2-1.73c-0.83 0.273-1.785 0.431-2.777 0.431-0.216 0-0.43-0.007-0.642-0.022zM12.16 1.18c0.246-0.123 0.536-0.194 0.842-0.194 0.506 0 0.966 0.196 1.309 0.516 0.441 0.356 0.721 0.897 0.721 1.504 0 0.242-0.045 0.474-0.126 0.688-0.486 0.307-2.346 1.717-4.146 3.307-0.055-0.521-0.302-0.975-0.668-1.298-0.28-0.239-0.643-0.384-1.039-0.384-0.068 0-0.135 0.004-0.201 0.012 1.568-1.771 2.978-3.691 3.308-4.151zM2.7 11.81c0.073-0.051 0.164-0.082 0.262-0.082 0.014 0 0.027 0.001 0.040 0.002l0.068-0c0.179 0.052 0.334 0.142 0.461 0.261l-0.871 0.719c-0.081-0.165-0.128-0.358-0.128-0.563 0-0.052 0.003-0.103 0.009-0.153 0.027-0.077 0.084-0.144 0.158-0.183zM4 14.5c-0.175 0.306-0.499 0.508-0.871 0.508-0.046 0-0.090-0.003-0.134-0.009-0.046 0.006-0.106 0.008-0.167 0.008-0.515 0-0.981-0.209-1.318-0.548-0.365-0.54-0.583-1.206-0.583-1.922 0-0.251 0.027-0.495 0.077-0.73l0.706-0.457c-0.094 0.14-0.164 0.304-0.199 0.481-0.007 0.076-0.010 0.154-0.010 0.234 0 0.642 0.202 1.237 0.545 1.724l0.354 0.44 1.7-1.4c0.066 0.209 0.104 0.45 0.104 0.7 0 0.351-0.075 0.685-0.21 0.985zM4.86 12.050c-0.345-0.6-0.889-1.053-1.54-1.274-0.071-0.012-0.13-0.016-0.19-0.016s-0.119 0.004-0.177 0.010c-0.046-0.007-0.106-0.011-0.168-0.011s-0.122 0.004-0.182 0.011c1.489-1.018 2.766-2.003 3.988-3.052 0.398 0.071 0.812 0.25 1.131 0.533 0.297 0.313 0.48 0.739 0.48 1.209 0 0.032-0.001 0.063-0.002 0.094-1.14 1.226-2.25 2.536-3 3.506-0.054-0.379-0.177-0.719-0.357-1.023z"></path></g>
<g id="vaadin:diploma"><path d="M14 10.58c0.024-0.048 0.038-0.105 0.038-0.165s-0.014-0.117-0.039-0.167l-0.479-0.698c-0.009-0.013-0.014-0.028-0.014-0.045s0.005-0.032 0.014-0.045l0.48-0.7c0.024-0.048 0.038-0.105 0.038-0.165s-0.014-0.117-0.039-0.167c-0.040-0.11-0.127-0.196-0.236-0.237l-0.823-0.301c-0.031-0.011-0.054-0.037-0.060-0.069l-0-0.841c-0.007-0.125-0.072-0.233-0.169-0.299-0.066-0.045-0.145-0.071-0.231-0.071-0.004 0-0.007 0-0.011 0l-0.159-0-0.85 0.22c-0.010 0.004-0.022 0.007-0.035 0.007s-0.025-0.003-0.036-0.007l-0.549-0.65c-0.079-0.085-0.191-0.137-0.315-0.137s-0.236 0.053-0.315 0.137l-0.55 0.65c-0.010 0.004-0.022 0.007-0.035 0.007s-0.025-0.003-0.036-0.007l0.001 0-0.9-0.23h-0.1c-0.002-0-0.005-0-0.008-0-0.087 0-0.167 0.026-0.234 0.071-0.096 0.066-0.161 0.174-0.168 0.298l-0 0.841c-0.006 0.033-0.029 0.059-0.059 0.070l-0.821 0.3c-0.134 0.023-0.245 0.11-0.299 0.228-0.025 0.051-0.039 0.107-0.039 0.167s0.014 0.117 0.039 0.167l0.479 0.698c0.009 0.013 0.014 0.028 0.014 0.045s-0.005 0.032-0.014 0.045l-0.48 0.7c-0.024 0.048-0.038 0.105-0.038 0.165s0.014 0.117 0.039 0.167c0.040 0.11 0.127 0.196 0.236 0.237l0.823 0.301c0.031 0.011 0.054 0.037 0.060 0.069l0 0.841c0.007 0.125 0.072 0.233 0.169 0.299 0.067 0.045 0.147 0.071 0.234 0.071 0.003 0 0.005-0 0.008-0h0.16l0.31-0.070v3.69l1.53-2 1.47 2v-3.69l0.31 0.080h0.11c0.002 0 0.005 0 0.008 0 0.087 0 0.167-0.026 0.234-0.071 0.096-0.066 0.161-0.174 0.168-0.298l0-0.841c0.006-0.033 0.029-0.059 0.059-0.070l0.821-0.3c0.13-0.026 0.236-0.112 0.289-0.227z"></path><path d="M0 1v12h8l-0.11-0.050c-0.282-0.195-0.469-0.508-0.49-0.867l-0-0.083h-6.4v-10h14v10h-1.43v0.080c-0.021 0.361-0.208 0.675-0.486 0.868l-0.084 0.052h3v-12h-16z"></path><path d="M7.43 6.91c0.007-0.377 0.198-0.708 0.486-0.908 0.016-0.005 0.030-0.006 0.044-0.006s0.028 0.001 0.041 0.004l-5.001-0v1h4.43v-0.090z"></path><path d="M6.42 8h-3.42v1h3.36c-0.074-0.136-0.117-0.298-0.117-0.47 0-0.13 0.025-0.253 0.070-0.367 0.014-0.063 0.054-0.122 0.107-0.163z"></path><path d="M3 4h10v1h-10v-1z"></path></g>
<g id="vaadin:disc"><path d="M8 0c-4.4 0-8 3.6-8 8s3.6 8 8 8 8-3.6 8-8-3.6-8-8-8zM15 8c0 1.1-0.2 2.1-0.7 3l-2.7-1.2c0.2-0.6 0.4-1.2 0.4-1.8 0-2.2-1.8-4-4-4-0.5 0-0.9 0.1-1.4 0.3l-1.2-2.8c0.6-0.2 1.2-0.4 1.8-0.5l0.3 3h0.5v-3c3.9 0 7 3.1 7 7zM8 5c1.7 0 3 1.3 3 3s-1.3 3-3 3-3-1.3-3-3 1.3-3 3-3zM1 8c0-1.1 0.2-2.1 0.7-3l2.7 1.2c-0.2 0.6-0.4 1.2-0.4 1.8 0 2.2 1.8 4 4 4 0.5 0 0.9-0.1 1.4-0.3l1.2 2.8c-0.6 0.2-1.2 0.4-1.8 0.5l-0.3-3h-0.5v3c-3.9 0-7-3.1-7-7z"></path><path d="M10 8c0 1.105-0.895 2-2 2s-2-0.895-2-2c0-1.105 0.895-2 2-2s2 0.895 2 2z"></path></g>
<g id="vaadin:doctor-briefcase"><path d="M16 12l-1.4-6.7c-0.2-0.7-0.9-1.3-1.7-1.3h-1.9v-1.2c0-1-0.8-1.8-1.8-1.8h-2.4c-1 0-1.8 0.8-1.8 1.8v1.2h-1.9c-0.8 0-1.5 0.6-1.7 1.3l-1.4 6.7c-0.2 1 0.6 2 1.7 2h12.5c1.2 0 2-1 1.8-2zM6 2.8c0-0.4 0.4-0.8 0.8-0.8h2.4c0.4 0 0.8 0.4 0.8 0.8v1.2h-4v-1.2zM11 10h-2v2h-2v-2h-2v-2h2v-2h2v2h2v2z"></path></g>
<g id="vaadin:doctor"><path d="M14 11.3c-1-1.9-2-1.6-3.1-1.7 0.1 0.3 0.1 0.6 0.1 1 1.6 0.4 2 2.3 2 3.4v1h-2v-1h1c0 0 0-2.5-1.5-2.5s-1.5 2.4-1.5 2.5h1v1h-2v-1c0-1.1 0.4-3.1 2-3.4 0-0.6-0.1-1.1-0.2-1.3-0.2-0.1-0.4-0.3-0.4-0.6 0-0.6 0.8-0.4 1.4-1.5 0 0 0.9-2.3 0.6-4.3h-1c0-0.2 0.1-0.3 0.1-0.5s0-0.3-0.1-0.5h0.8c-0.3-1-1.3-1.9-3.2-1.9 0 0 0 0 0 0s0 0 0 0 0 0 0 0c-1.9 0-2.9 0.9-3.3 2h0.8c0 0.2-0.1 0.3-0.1 0.5s0 0.3 0.1 0.5h-1c-0.2 2 0.6 4.3 0.6 4.3 0.6 1 1.4 0.8 1.4 1.5 0 0.5-0.5 0.7-1.1 0.8-0.2 0.2-0.4 0.6-0.4 1.4 0 0.4 0 0.8 0 1.2 0.6 0.2 1 0.8 1 1.4 0 0.7-0.7 1.4-1.5 1.4s-1.5-0.7-1.5-1.5c0-0.7 0.4-1.2 1-1.4 0-0.3 0-0.7 0-1.2s0.1-0.9 0.2-1.3c-0.7 0.1-1.5 0.4-2.2 1.7-0.6 1.1-0.9 4.7-0.9 4.7h13.7c0.1 0-0.2-3.6-0.8-4.7zM6.5 2.5c0-0.8 0.7-1.5 1.5-1.5s1.5 0.7 1.5 1.5-0.7 1.5-1.5 1.5-1.5-0.7-1.5-1.5z"></path><path d="M5 13.5c0 0.276-0.224 0.5-0.5 0.5s-0.5-0.224-0.5-0.5c0-0.276 0.224-0.5 0.5-0.5s0.5 0.224 0.5 0.5z"></path></g>
<g id="vaadin:dollar"><path d="M8.2 6.8c-0.1 0-0.1-0.1-0.2-0.1v-3.1c1.2 0.1 2.2 0.6 2.2 0.6l0.9-1.8c-0.1 0-1.5-0.8-3.1-0.8v-1.6h-1v1.6c-0.8 0.2-1.4 0.5-2 0.9-0.6 0.6-1 1.4-1 2.3 0 0.7 0.2 2.3 3 3.6v3.9c-0.9-0.2-2-0.7-2.4-0.9l-1 1.7c0.2 0.1 1.8 1 3.4 1.2v1.7h1v-1.7c0 0 0 0 0 0 2.3-0.3 3.6-2.1 3.6-3.8 0-1.5-1-2.7-3.4-3.7zM7 6.2c-0.8-0.5-1-1-1-1.3 0-0.4 0.1-0.7 0.4-0.9 0.2-0.1 0.4-0.2 0.6-0.3v2.5zM8 12.3v-3.4c1.1 0.5 1.6 1.1 1.6 1.6 0 0.6-0.3 1.6-1.6 1.8z"></path></g>
<g id="vaadin:dot-circle"><path d="M8 4c-2.2 0-4 1.8-4 4s1.8 4 4 4 4-1.8 4-4-1.8-4-4-4z"></path><path d="M8 1c3.9 0 7 3.1 7 7s-3.1 7-7 7-7-3.1-7-7 3.1-7 7-7zM8 0c-4.4 0-8 3.6-8 8s3.6 8 8 8 8-3.6 8-8-3.6-8-8-8v0z"></path></g>
<g id="vaadin:download-alt"><path d="M0 14h16v2h-16v-2z"></path><path d="M8 13l5-5h-3v-8h-4v8h-3z"></path></g>
<g id="vaadin:download"><path d="M16 10h-5.5l-2.5 2.5-2.5-2.5h-5.5v6h16v-6zM4 14h-2v-2h2v2z"></path><path d="M10 6v-6h-4v6h-3l5 5 5-5z"></path></g>
<g id="vaadin:drop"><path d="M8 0c0 0-5 8.2-5 11s2.2 5 5 5 5-2.2 5-5-5-11-5-11zM8.9 14.9l-0.2-1c1.4-0.3 2.4-1.7 2.4-3.2 0-0.3-0.1-1.1-0.8-2.6l0.9-0.4c0.6 1.4 0.8 2.4 0.8 3 0 2-1.3 3.8-3.1 4.2z"></path></g>
<g id="vaadin:edit"><path d="M16 4c0 0 0-1-1-2s-1.9-1-1.9-1l-1.1 1.1v-2.1h-12v16h12v-8l4-4zM6.3 11.4l-0.6-0.6 0.3-1.1 1.5 1.5-1.2 0.2zM7.2 9.5l-0.6-0.6 5.2-5.2c0.2 0.1 0.4 0.3 0.6 0.5zM14.1 2.5l-0.9 1c-0.2-0.2-0.4-0.3-0.6-0.5l0.9-0.9c0.1 0.1 0.3 0.2 0.6 0.4zM11 15h-10v-14h10v2.1l-5.9 5.9-1.1 4.1 4.1-1.1 2.9-3v6z"></path></g>
<g id="vaadin:eject"><path d="M1 11h14l-7-10z"></path><path d="M1 12h14v3h-14v-3z"></path></g>
<g id="vaadin:elastic"><path d="M4.7 16v0c-1.7 0-3.1-0.8-4-2.1-1.1-1.7-0.9-4 0.4-5.8 0.9-1.3 2.1-2.1 3.6-2.4 1.2-0.3 2.2-1.1 2.5-2.2 0.2-0.8 0.7-1.5 1.3-2 0.9-1 2.2-1.5 3.5-1.5 1.1 0 2.2 0.4 2.9 1.2 1.5 1.6 1.5 4.2-0.1 6-0.5 0.6-1.2 1.1-2 1.4-1.2 0.5-2.2 1.6-2.6 3-0.3 1-0.8 1.9-1.5 2.6-1.1 1.2-2.6 1.8-4 1.8zM12 1c-1 0-2 0.4-2.8 1.2-0.5 0.5-0.8 1-1 1.6-0.5 1.5-1.8 2.5-3.3 2.9-1.2 0.2-2.2 0.9-3 2-1.1 1.5-1.2 3.3-0.3 4.7 0.6 1 1.8 1.6 3.1 1.6v0c1.2 0 2.4-0.5 3.3-1.4 0.6-0.6 1.1-1.4 1.3-2.2 0.4-1.7 1.6-3 3.2-3.6 0.6-0.2 1.2-0.7 1.6-1.2 1.2-1.4 1.3-3.5 0.1-4.7-0.6-0.6-1.4-0.9-2.2-0.9z"></path></g>
<g id="vaadin:ellipsis-circle-o"><path d="M8 1c3.9 0 7 3.1 7 7s-3.1 7-7 7-7-3.1-7-7 3.1-7 7-7zM8 0c-4.4 0-8 3.6-8 8s3.6 8 8 8 8-3.6 8-8-3.6-8-8-8v0z"></path><path d="M4 7h2v2h-2v-2z"></path><path d="M7 7h2v2h-2v-2z"></path><path d="M10 7h2v2h-2v-2z"></path></g>
<g id="vaadin:ellipsis-circle"><path d="M8 0c-4.4 0-8 3.6-8 8s3.6 8 8 8 8-3.6 8-8-3.6-8-8-8zM6 9h-2v-2h2v2zM9 9h-2v-2h2v2zM12 9h-2v-2h2v2z"></path></g>
<g id="vaadin:ellipsis-dots-h"><path d="M4 8c0 1.105-0.895 2-2 2s-2-0.895-2-2c0-1.105 0.895-2 2-2s2 0.895 2 2z"></path><path d="M10 8c0 1.105-0.895 2-2 2s-2-0.895-2-2c0-1.105 0.895-2 2-2s2 0.895 2 2z"></path><path d="M16 8c0 1.105-0.895 2-2 2s-2-0.895-2-2c0-1.105 0.895-2 2-2s2 0.895 2 2z"></path></g>
<g id="vaadin:ellipsis-dots-v"><path d="M10 2c0 1.105-0.895 2-2 2s-2-0.895-2-2c0-1.105 0.895-2 2-2s2 0.895 2 2z"></path><path d="M10 8c0 1.105-0.895 2-2 2s-2-0.895-2-2c0-1.105 0.895-2 2-2s2 0.895 2 2z"></path><path d="M10 14c0 1.105-0.895 2-2 2s-2-0.895-2-2c0-1.105 0.895-2 2-2s2 0.895 2 2z"></path></g>
<g id="vaadin:ellipsis-h"><path d="M0 6h4v4h-4v-4z"></path><path d="M6 6h4v4h-4v-4z"></path><path d="M12 6h4v4h-4v-4z"></path></g>
<g id="vaadin:ellipsis-v"><path d="M6 0h4v4h-4v-4z"></path><path d="M6 6h4v4h-4v-4z"></path><path d="M6 12h4v4h-4v-4z"></path></g>
<g id="vaadin:enter-arrow"><path d="M0 9l7 4v-3h9v-7l-3 2v2h-6v-3l-7 5z"></path></g>
<g id="vaadin:enter"><path d="M4 0v6h-3v10h14v-16h-11zM12 11h-5v2l-3-2.5 3-2.5v2h4v-3h1v4z"></path></g>
<g id="vaadin:envelope-o"><path d="M0 3v11h16v-11h-16zM1 7.1l3.9 2-3.9 3.4v-5.4zM1.9 13l4-3.5 2.1 1.1 2.1-1.1 4 3.5h-12.2zM15 12.5l-3.9-3.5 3.9-2v5.5zM15 5.9l-7 3.5-7-3.5v-1.9h14v1.9z"></path></g>
<g id="vaadin:envelope-open-o"><path d="M14 3.7v-0.7h-1.5l-4.5-3-4.6 3h-1.4v0.7l-2 1.3v11h16v-10.9l-2-1.4zM8 1.2l2.7 1.8h-5.5l2.8-1.8zM3 4h10v3.7l-3.5 1.7-1.5-1.3-1.5 1.4-3.5-1.7v-3.8zM1 5.5l1-0.7v2.4l-1-0.4v-1.3zM1 7.9l4.6 2.3-4.6 4v-6.3zM1.9 15l6.1-5.3 6.1 5.3h-12.2zM15 14.2l-4.7-4.1 4.7-2.3v6.4zM15 6.7l-1 0.5v-2.3l1 0.7v1.1z"></path></g>
<g id="vaadin:envelope-open"><path d="M14 3.7v3.7l2-1v-1.4z"></path><path d="M2 3.8l-2 1.2v1.5l2 1z"></path><path d="M11.2 2l-3.2-2-3.2 2z"></path><path d="M13 3h-10v4.9l3.4 1.7 1.6-1.2 1.6 1.2 3.4-1.7z"></path><path d="M16 7.6l-5.5 2.7 5.5 4.4z"></path><path d="M8 9.6l-8 6.4h16z"></path><path d="M5.5 10.3l-5.5-2.7v7.1z"></path></g>
<g id="vaadin:envelope"><path d="M0 3h16v2.4l-8 4-8-4z"></path><path d="M0 14l5.5-4.8 2.5 1.4 2.5-1.4 5.5 4.8z"></path><path d="M4.6 8.8l-4.6-2.3v6.5z"></path><path d="M11.4 8.8l4.6-2.3v6.5z"></path></g>
<g id="vaadin:envelopes-o"><path d="M14 2h-14v10h14v-10zM5.71 8l1.29 0.55 1.29-0.55 4.71 3h-12zM1 9.83v-4l3.64 1.63zM9.36 7.46l3.64-1.68v4zM13 3v1.68l-6 2.77-6-2.77v-1.68h12z"></path><path d="M15 4v9h-13v1h14v-10h-1z"></path></g>
<g id="vaadin:envelopes"><path d="M16 14h-14v-1h13v-9h1v10z"></path><path d="M14 10.77v-5.48l-4.68 2.18 4.68 3.3z"></path><path d="M8.28 7.96l-1.28 0.59-1.28-0.59-5.72 4.030v0.010l14-0.010-5.72-4.030z"></path><path d="M7 7.45l7-3.27v-2.18h-14v2.18l7 3.27z"></path><path d="M4.68 7.47l-4.68-2.18v5.48l4.68-3.3z"></path></g>
<g id="vaadin:eraser"><path d="M8.1 14l6.4-7.2c0.6-0.7 0.6-1.8-0.1-2.5l-2.7-2.7c-0.3-0.4-0.8-0.6-1.3-0.6h-1.8c-0.5 0-1 0.2-1.4 0.6l-6.7 7.6c-0.6 0.7-0.6 1.9 0.1 2.5l2.7 2.7c0.3 0.4 0.8 0.6 1.3 0.6h11.4v-1h-7.9zM6.8 13.9c0 0 0-0.1 0 0l-2.7-2.7c-0.4-0.4-0.4-0.9 0-1.3l3.4-3.9h-1l-3 3.3c-0.6 0.7-0.6 1.7 0.1 2.4l2.3 2.3h-1.3c-0.2 0-0.4-0.1-0.6-0.2l-2.8-2.8c-0.3-0.3-0.3-0.8 0-1.1l3.5-3.9h1.8l3.5-4h1l-3.5 4 3.1 3.7-3.5 4c-0.1 0.1-0.2 0.1-0.3 0.2z"></path></g>
<g id="vaadin:esc-a"><path d="M8 12c-0.726-0.029-1.409-0.177-2.043-0.425l0.403-0.915c0.435 0.202 0.945 0.319 1.482 0.319 0.326 0 0.643-0.043 0.943-0.125 0.121-0.109 0.215-0.285 0.215-0.484 0-0 0-0 0-0 0.070-0.43-0.22-0.62-1.17-1-0.83-0.29-2.040-0.76-1.83-2.080 0.072-0.594 0.46-1.082 0.989-1.296 0.223-0.053 0.466-0.081 0.715-0.081 0.724 0 1.393 0.235 1.934 0.633l-0.569 0.754c-0.366-0.248-0.817-0.396-1.302-0.396-0.123 0-0.243 0.009-0.361 0.028-0.215 0.084-0.377 0.296-0.387 0.547-0.080 0.401 0.14 0.581 1.15 1.001 0.85 0.33 2 0.77 1.8 2.080-0.067 0.511-0.364 0.94-0.782 1.186-0.323 0.163-0.696 0.256-1.090 0.256-0.034 0-0.069-0.001-0.103-0.002z"></path><path d="M13.71 12c-0.027 0.001-0.058 0.001-0.089 0.001-0.583 0-1.124-0.18-1.57-0.488-0.646-0.548-1.059-1.37-1.059-2.289 0-0.079 0.003-0.157 0.009-0.235-0.011-0.079-0.016-0.183-0.016-0.288 0-0.899 0.413-1.701 1.060-2.228 0.5-0.282 1.091-0.446 1.72-0.446 0.443 0 0.868 0.081 1.259 0.23l-0.374 0.922c-0.276-0.111-0.595-0.176-0.93-0.176-0.388 0-0.756 0.087-1.086 0.242-0.395 0.361-0.652 0.893-0.652 1.485 0 0.095 0.007 0.188 0.019 0.279-0.010 0.063-0.016 0.148-0.016 0.234 0 0.599 0.255 1.138 0.663 1.514 0.346 0.177 0.754 0.28 1.185 0.28 0.292 0 0.573-0.047 0.835-0.134l0.331 0.905c-0.383 0.121-0.823 0.19-1.279 0.19-0.004 0-0.008 0-0.012-0z"></path><path d="M5 4v-1h-4v9h4v-1h-3v-3h3v-1h-3v-3h3z"></path></g>
<g id="vaadin:esc"><path d="M0 0v16h16v-16h-16zM5 4h-3v3h3v1h-3v3h3v1h-4v-9h4v1zM10 10.54c-0.067 0.511-0.364 0.94-0.782 1.186-0.333 0.175-0.719 0.276-1.129 0.276-0.031 0-0.062-0.001-0.093-0.002-0.722-0.029-1.405-0.177-2.038-0.425l0.403-0.915c0.435 0.202 0.945 0.319 1.482 0.319 0.326 0 0.643-0.043 0.943-0.125 0.121-0.109 0.215-0.285 0.215-0.484 0-0 0-0 0-0 0.070-0.43-0.22-0.62-1.17-1-0.83-0.29-2.040-0.76-1.83-2.080 0.072-0.594 0.46-1.082 0.989-1.296 0.223-0.053 0.466-0.081 0.715-0.081 0.724 0 1.393 0.235 1.934 0.633l-0.569 0.754c-0.366-0.248-0.817-0.396-1.302-0.396-0.123 0-0.243 0.009-0.361 0.028-0.215 0.084-0.377 0.296-0.387 0.547-0.080 0.401 0.14 0.581 1.15 1.001 0.83 0.3 2.020 0.75 1.83 2.060zM12.67 10.72c0.345 0.176 0.752 0.279 1.183 0.279 0.292 0 0.573-0.047 0.835-0.134l0.311 0.945c-0.383 0.121-0.823 0.19-1.279 0.19-0 0-0.001 0-0.001 0-0.027 0.001-0.058 0.001-0.089 0.001-0.583 0-1.124-0.18-1.57-0.488-0.651-0.548-1.069-1.374-1.069-2.297 0-0.076 0.003-0.152 0.008-0.227-0.010-0.079-0.016-0.183-0.016-0.288 0-0.899 0.413-1.701 1.060-2.228 0.5-0.282 1.091-0.446 1.72-0.446 0.443 0 0.868 0.081 1.259 0.23l-0.374 0.922c-0.276-0.111-0.595-0.176-0.93-0.176-0.388 0-0.756 0.087-1.086 0.242-0.395 0.361-0.652 0.893-0.652 1.485 0 0.095 0.007 0.188 0.019 0.279-0.008 0.055-0.013 0.13-0.013 0.206 0 0.592 0.25 1.126 0.65 1.502z"></path></g>
<g id="vaadin:euro"><path d="M10.89 3c1.166 0.009 2.244 0.383 3.127 1.011l-0.017-2.321c-0.918-0.433-1.994-0.686-3.129-0.686-3.606 0-6.616 2.551-7.323 5.947l-1.548 0.049v1h1.41c0 0.17 0 0.33 0 0.5-0.005 0.075-0.008 0.162-0.008 0.25s0.003 0.175 0.008 0.262l-1.411-0.012v1h1.54c0.882 3.353 3.805 5.818 7.331 5.999 1.149-0.002 2.218-0.256 3.175-0.708l-0.045-2.291c-0.866 0.617-1.944 0.991-3.108 1-2.461-0.128-4.512-1.744-5.28-3.959l6.388-0.041v-1h-6.59c-0.006-0.075-0.009-0.162-0.009-0.25s0.003-0.175 0.010-0.261c-0.001-0.159-0.001-0.319-0.001-0.489h6.59v-1h-6.4c0.678-2.325 2.788-3.996 5.29-4z"></path></g>
<g id="vaadin:exchange"><path d="M16 5v2h-13v2l-3-3 3-3v2z"></path><path d="M0 12v-2h13v-2l3 3-3 3v-2z"></path></g>
<g id="vaadin:exclamation-circle-o"><path d="M8 1c3.9 0 7 3.1 7 7s-3.1 7-7 7-7-3.1-7-7 3.1-7 7-7zM8 0c-4.4 0-8 3.6-8 8s3.6 8 8 8 8-3.6 8-8-3.6-8-8-8v0z"></path><path d="M7 3h2v7h-2v-7z"></path><path d="M7 11h2v2h-2v-2z"></path></g>
<g id="vaadin:exclamation-circle"><path d="M8 0c-4.4 0-8 3.6-8 8s3.6 8 8 8 8-3.6 8-8-3.6-8-8-8zM9 13h-2v-2h2v2zM9 10h-2v-7h2v7z"></path></g>
<g id="vaadin:exclamation"><path d="M6 0h4v4l-1 7h-2l-1-7z"></path><path d="M10 14c0 1.105-0.895 2-2 2s-2-0.895-2-2c0-1.105 0.895-2 2-2s2 0.895 2 2z"></path></g>
<g id="vaadin:exit-o"><path d="M10 0c1.1 0 2 0.9 2 2 0 0.9-0.6 1.7-1.5 1.9 0 0 0 0.1 0 0.1 0.4 0 0.7 0.2 1 0.5l1.3 1.3c0.1 0.1 0.3 0.2 0.5 0.2h1.7v-6h-5z"></path><path d="M11.8 14.5l-3.8-4.5v2.5c0 0.8-0.7 1.5-1.5 1.5h-3.5c-0.6 0-1-0.4-1-1s0.4-1 1-1h2.5c0.3 0 0.5-0.2 0.5-0.5v-2c0-0.7 0.1-1.3 0.4-2l0.7-1.5h-0.8c-0.5 0-0.9 0.2-1.2 0.6l-0.5 0.7c-0.2 0.4-0.7 0.5-1.2 0.3-0.4-0.3-0.6-0.9-0.2-1.3l0.6-0.8c0.7-1 1.9-1.5 3.1-1.5h2l0.1-0.3c-0.6-0.3-1-1-1-1.7 0-1.1 0.9-2 2-2h-7v4.9l-0.6 0.8c-0.3 0.4-0.5 0.9-0.4 1.5 0.1 0.5 0.4 1 0.9 1.3 0 0 0 0 0 0v2.5c-1.1 0-2 0.9-2 2s0.9 2 2 2v1h11.6c-1.1 0-2.1-0.6-2.7-1.5z"></path><path d="M11.4 7.3l-0.7-0.8-0.6 1.5c-0.2 0.5-0.3 0.9 0 1.3l4.9 6.1v-7.4h-2.1c-0.6 0-1.1-0.2-1.5-0.7z"></path></g>
<g id="vaadin:exit"><path d="M14 6h-1.7c-0.2 0-0.4-0.1-0.6-0.2l-1.3-1.3c-0.2-0.3-0.6-0.5-1.1-0.5h-0.3c1.1 0 2-0.9 2-2s-0.9-2-2-2-2 0.9-2 2c0 0.7 0.4 1.4 1 1.7l-0.2 0.3h-2c-1.1 0-2.3 0.5-3 1.5l-0.6 0.8c-0.4 0.4-0.2 1 0.2 1.3 0.4 0.2 0.9 0.1 1.2-0.3l0.5-0.7c0.3-0.4 0.7-0.6 1.2-0.6h0.8l-0.7 1.6c-0.3 0.6-0.4 1.2-0.4 1.9v2c0 0.3-0.2 0.5-0.5 0.5h-2.5c-0.6 0-1 0.4-1 1s0.4 1 1 1h3.5c0.8 0 1.5-0.7 1.5-1.5v-2.5l3.8 4.5c0.6 0.9 1.7 1.5 2.8 1.5h0.9l-5.4-6.7c-0.3-0.4-0.2-0.8 0-1.3l0.6-1.5 0.7 0.8c0.4 0.4 1 0.7 1.6 0.7h2c0.6 0 1-0.4 1-1s-0.4-1-1-1z"></path></g>
<g id="vaadin:expand-full"><path d="M5.3 6.7l1.4-1.4-3-3 1.3-1.3h-4v4l1.3-1.3z"></path><path d="M6.7 10.7l-1.4-1.4-3 3-1.3-1.3v4h4l-1.3-1.3z"></path><path d="M10.7 9.3l-1.4 1.4 3 3-1.3 1.3h4v-4l-1.3 1.3z"></path><path d="M11 1l1.3 1.3-3 3 1.4 1.4 3-3 1.3 1.3v-4z"></path></g>
<g id="vaadin:expand-square"><path d="M11 2h-9v9l1-1v-7h7z"></path><path d="M5 14h9v-9l-1 1v7h-7z"></path><path d="M16 0h-5l1.8 1.8-4.5 4.5 1.4 1.4 4.5-4.5 1.8 1.8z"></path><path d="M7.7 9.7l-1.4-1.4-4.5 4.5-1.8-1.8v5h5l-1.8-1.8z"></path></g>
<g id="vaadin:expand"><path d="M15 1h-4l1.3 1.3-4.5 4.5 1.4 1.4 4.5-4.5 1.3 1.3z"></path><path d="M6.8 7.8l-4.5 4.5-1.3-1.3v4h4l-1.3-1.3 4.5-4.5z"></path></g>
<g id="vaadin:external-browser"><path d="M11 10l-2.9-3.2-3.3 3.2h2.2v1.8c0 1.7-0.9 4.2-4 4.2 4.8 0 6-1.4 6-4.3v-1.7h2z"></path><path d="M0 0v13h6v-1h-5v-9h14v9h-5v1h6v-13h-16zM2 2h-1v-1h1v1zM13 2h-10v-1h10v1z"></path></g>
<g id="vaadin:external-link"><path d="M14 16v-11l-1 1v9h-12v-12h9l1-1h-11v14z"></path><path d="M16 0h-5l1.8 1.8-6.8 6.8 1.4 1.4 6.8-6.8 1.8 1.8z"></path></g>
<g id="vaadin:eye-slash"><path d="M12.9 5.2l-0.8 0.8c1.7 0.9 2.5 2.3 2.8 3-0.7 0.9-2.8 3.1-7 3.1-0.7 0-1.2-0.1-1.8-0.2l-0.8 0.8c0.8 0.3 1.7 0.4 2.6 0.4 5.7 0 8.1-4 8.1-4s-0.6-2.4-3.1-3.9z"></path><path d="M12 7.1c0-0.3 0-0.6-0.1-0.8l-4.8 4.7c0.3 0 0.6 0.1 0.9 0.1 2.2 0 4-1.8 4-4z"></path><path d="M15.3 0l-4.4 4.4c-0.8-0.2-1.8-0.4-2.9-0.4-6.7 0-8 5.1-8 5.1s1 1.8 3.3 3l-3.3 3.2v0.7h0.7l15.3-15.3v-0.7h-0.7zM4 11.3c-1.6-0.7-2.5-1.8-2.9-2.3 0.3-0.7 1.1-2.2 3.1-3.2-0.1 0.4-0.2 0.8-0.2 1.3 0 1.1 0.5 2.2 1.3 2.9l-1.3 1.3zM6.2 7.9l-1 0.2c0 0-0.3-0.5-0.3-1.2 0-0.8 0.4-1.5 0.4-1.5 0.5-0.3 1.3-0.3 1.3-0.3s-0.5 0.9-0.5 1.7c-0.1 0.7 0.1 1.1 0.1 1.1z"></path></g>
<g id="vaadin:eye"><path d="M8 3.9c-6.7 0-8 5.1-8 5.1s2.2 4.1 7.9 4.1 8.1-4 8.1-4-1.3-5.2-8-5.2zM5.3 5.4c0.5-0.3 1.3-0.3 1.3-0.3s-0.5 0.9-0.5 1.6c0 0.7 0.2 1.1 0.2 1.1l-1.1 0.2c0 0-0.3-0.5-0.3-1.2 0-0.8 0.4-1.4 0.4-1.4zM7.9 12.1c-4.1 0-6.2-2.3-6.8-3.2 0.3-0.7 1.1-2.2 3.1-3.2-0.1 0.4-0.2 0.8-0.2 1.3 0 2.2 1.8 4 4 4s4-1.8 4-4c0-0.5-0.1-0.9-0.2-1.3 2 0.9 2.8 2.5 3.1 3.2-0.7 0.9-2.8 3.2-7 3.2z"></path></g>
<g id="vaadin:eyedropper"><path d="M15 1c-1.8-1.8-3.7-0.7-4.6 0.1-0.4 0.4-0.7 0.9-0.7 1.5v0c0 1.1-1.1 1.8-2.1 1.5l-0.1-0.1-0.7 0.8 0.7 0.7-6 6-0.8 2.3-0.7 0.7 1.5 1.5 0.8-0.8 2.3-0.8 6-6 0.7 0.7 0.7-0.6-0.1-0.2c-0.3-1 0.4-2.1 1.5-2.1v0c0.6 0 1.1-0.2 1.4-0.6 0.9-0.9 2-2.8 0.2-4.6zM3.9 13.6l-2 0.7-0.2 0.1 0.1-0.2 0.7-2 5.8-5.8 1.5 1.5-5.9 5.7z"></path></g>
<g id="vaadin:facebook-square"><path d="M0 0v16h16v-16h-16zM12.9 8.4h-2.1v5.6h-2.1v-5.6h-1.5v-2h1.5c0 0 0-0.8 0-1.7 0-1.5 0.9-2.7 2.9-2.7 0.8 0 1.4 0.1 1.4 0.1v1.9c0 0-0.6 0-1.3 0s-0.8 0.3-0.8 0.9c0 0.1 0 0.1 0 0.1 0 0.2 0 0.5 0 1.4h2.1l-0.1 2z"></path></g>
<g id="vaadin:facebook"><path d="M7.2 16v-7.5h-2v-2.7h2c0 0 0-1.1 0-2.3 0-1.8 1.2-3.5 3.9-3.5 1.1 0 1.9 0.1 1.9 0.1l-0.1 2.5c0 0-0.8 0-1.7 0-1 0-1.1 0.4-1.1 1.2 0 0.6 0-1.3 0 2h2.9l-0.1 2.7h-2.8v7.5h-2.9z"></path></g>
<g id="vaadin:factory"><path d="M4.4 1.3c-0.6 0.3-0.8 1.1-0.4 1.5 0.5-0.9 1.3-0.6 2.5 0.4 0.8 0.7 1.9 0.1 1.9 0.1s0.2 1.2 1.7 1.4c1.7 0.2 2.3-0.8 2.3-0.8s0.4 1 1.9 0.4c1.1-0.4 0.7-1.1 0.7-1.1s1 0 1-0.7c0-0.9-1.1-0.8-1.1-0.8s0.2-1-0.9-1.1c-1-0.1-1.3 0.5-1.3 0.5s-0.3-1.1-1.8-1.1c-1.4 0-1.9 1.3-1.9 1.3s-0.4-0.6-1.6-0.6c-0.9 0-1.3 0.7-1.3 0.7s-1.1-0.5-1.7-0.1z"></path><path d="M12 12.1v-2.1l-4 2.1v-2.1h-2.4l-0.6-7h-2l-0.6 7h-2.4v6h16v-6l-4 2.1zM6 14h-4v-2h4v2z"></path></g>
<g id="vaadin:family"><path d="M9.5 7.5c0 0.828-0.672 1.5-1.5 1.5s-1.5-0.672-1.5-1.5c0-0.828 0.672-1.5 1.5-1.5s1.5 0.672 1.5 1.5z"></path><path d="M14.27 4h-2.54c0 0 0 0 0 0-0.955 0-1.73 0.775-1.73 1.73v3.27c0 0.552 0.448 1 1 1v6h4v-6c0.552 0 1-0.448 1-1v-3.27c0-0.955-0.775-1.73-1.73-1.73 0 0 0 0 0 0z"></path><path d="M15 2c0 1.105-0.895 2-2 2s-2-0.895-2-2c0-1.105 0.895-2 2-2s2 0.895 2 2z"></path><path d="M4.27 5h-2.54c-0.955 0-1.73 0.775-1.73 1.73s0.775 1.73 1.73 1.73c0.955 0 1.73-0.775 1.73-1.73s-0.775-1.73-1.73-1.73c-0.955 0-1.73 0.775-1.73 1.73v2.27c0 0.552 0.448 1 1 1l-1 3h1v3h4v-3h1l-1-3c0.552 0 1-0.448 1-1v-2.27c0-0.955-0.775-1.73-1.73-1.73 0 0 0 0 0 0z"></path><path d="M5 3c0 1.105-0.895 2-2 2s-2-0.895-2-2c0-1.105 0.895-2 2-2s2 0.895 2 2z"></path><path d="M7 13v3h2v-3c0.552 0 1-0.448 1-1v-1.54c0-0.806-0.654-1.46-1.46-1.46 0 0 0 0 0 0h-1.080c-0.806 0-1.46 0.654-1.46 1.46 0 0 0 0 0 0v1.54c0 0.552 0.448 1 1 1z"></path></g>
<g id="vaadin:fast-backward"><path d="M16 15v-14l-7 7z"></path><path d="M9 15v-14l-7 7z"></path><path d="M0 1h2v14h-2v-14z"></path></g>
<g id="vaadin:fast-forward"><path d="M0 1v14l7-7z"></path><path d="M7 1v14l7-7z"></path><path d="M14 1h2v14h-2v-14z"></path></g>
<g id="vaadin:female"><path d="M10 2c0 1.105-0.895 2-2 2s-2-0.895-2-2c0-1.105 0.895-2 2-2s2 0.895 2 2z"></path><path d="M10 8v-1.5l1.8 1.8c0.3 0.3 0.7 0.3 1 0s0.3-0.8 0-1l-2.6-2.6c-0.4-0.5-1-0.7-1.7-0.7h-1c-0.7 0-1.3 0.2-1.7 0.7l-2.6 2.6c-0.3 0.3-0.3 0.8 0 1 0.3 0.3 0.7 0.3 1 0l1.8-1.8v1.5l-4 5h4v3h4v-3h4l-4-5z"></path></g>
<g id="vaadin:file-add"><path d="M12 15h-10v-14h6v4h4v1h1v-2l-4-4h-8v16h12v-2h-1v1zM9 1l3 3h-3v-3z"></path><path d="M13 7h-2v2h-2v2h2v2h2v-2h2v-2h-2v-2z"></path></g>
<g id="vaadin:file-code"><path d="M10 0h-8v16h12v-12l-4-4zM9 5h4v10h-10v-14h6v4zM10 4v-3l3 3h-3z"></path><path d="M6.2 13h-0.7l-2-2.5 2-2.5h0.7l-2 2.5z"></path><path d="M9.8 13h0.7l2-2.5-2-2.5h-0.7l2 2.5z"></path><path d="M6.7 14h0.6l2.1-7h-0.8z"></path></g>
<g id="vaadin:file-font"><path d="M10 0h-8v16h12v-12l-4-4zM9 5h4v10h-10v-14h6v4zM10 4v-3l3 3h-3z"></path><path d="M5 7v2h2v5h2v-5h2v-2z"></path></g>
<g id="vaadin:file-movie"><path d="M10 0h-8v16h12v-12l-4-4zM9 5h4v10h-10v-14h6v4zM10 4v-3l3 3h-3z"></path><path d="M10 10v-2h-6v5h6v-2l2 2v-5z"></path></g>
<g id="vaadin:file-o"><path d="M10 0h-8v16h12v-12l-4-4zM9 5h4v10h-10v-14h6v4zM10 4v-3l3 3h-3z"></path></g>
<g id="vaadin:file-picture"><path d="M10 0h-8v16h12v-12l-4-4zM9 5h4v10h-10v-14h6v4zM10 4v-3l3 3h-3z"></path><path d="M4 11.5v2.5h8v-1.7c0 0 0.1-1.3-1.3-1.5-1.3-0.2-1.5 0.4-2.5 0.5-0.8 0-0.6-1.3-2.2-1.3-1.2 0-2 1.5-2 1.5z"></path><path d="M12 8.5c0 0.828-0.672 1.5-1.5 1.5s-1.5-0.672-1.5-1.5c0-0.828 0.672-1.5 1.5-1.5s1.5 0.672 1.5 1.5z"></path></g>
<g id="vaadin:file-presentation"><path d="M10 0h-8v16h12v-12l-4-4zM13 15h-10v-14h6v4h4v10zM10 4v-3l3 3h-3z"></path><path d="M9 6h-2v1h-3v6h2v1h1v-1h2v1h1v-1h2v-6h-3v-1zM11 8v4h-6v-4h6z"></path><path d="M7 9v2l2-1z"></path></g>
<g id="vaadin:file-process"><path d="M12 0h-7v6h0.7l0.2 0.7 0.1 0.1v-5.8h5v4h4v9h-6l0.3 0.5-0.5 0.5h7.2v-11l-4-4zM12 4v-3l3 3h-3z"></path><path d="M5.5 11.5c0 0.552-0.448 1-1 1s-1-0.448-1-1c0-0.552 0.448-1 1-1s1 0.448 1 1z"></path><path d="M7.9 12.4l1.1-0.4v-1l-1.1-0.4c-0.1-0.3-0.2-0.6-0.4-0.9l0.5-1-0.7-0.7-1 0.5c-0.3-0.2-0.6-0.3-0.9-0.4l-0.4-1.1h-1l-0.4 1.1c-0.3 0.1-0.6 0.2-0.9 0.4l-1-0.5-0.7 0.7 0.5 1.1c-0.2 0.3-0.3 0.6-0.4 0.9l-1.1 0.3v1l1.1 0.4c0.1 0.3 0.2 0.6 0.4 0.9l-0.5 1 0.7 0.7 1.1-0.5c0.3 0.2 0.6 0.3 0.9 0.4l0.3 1.1h1l0.4-1.1c0.3-0.1 0.6-0.2 0.9-0.4l1 0.5 0.7-0.7-0.5-1.1c0.2-0.2 0.3-0.5 0.4-0.8zM4.5 13.5c-1.1 0-2-0.9-2-2s0.9-2 2-2 2 0.9 2 2c0 1.1-0.9 2-2 2z"></path></g>
<g id="vaadin:file-refresh"><path d="M10 0h-8v16h12v-12l-4-4zM13 15h-10v-14h6v4h4v10zM10 4v-3l3 3h-3z"></path><path d="M4.7 7.7l-0.7-0.7v3h3l-1.2-1.2c0.4-0.8 1.3-1.3 2.2-1.3 1.4 0 2.5 1.1 2.5 2.5h1.5c0-2.2-1.8-4-4-4-1.3 0-2.5 0.7-3.3 1.7z"></path><path d="M9.8 11.8c-0.5 0.5-1.1 0.8-1.8 0.7-1 0-1.9-0.6-2.3-1.5h-1.6c0.4 1.7 2 3 3.8 3 1.1 0 2.1-0.5 2.8-1.2l1.3 1.2v-3h-3l0.8 0.8z"></path></g>
<g id="vaadin:file-remove"><path d="M12 15h-10v-14h6v4h4v2.59l1-1v-2.59l-4-4h-8v16h12v-2.59l-1-1v2.59zM9 1l3 3h-3v-3z"></path><path d="M15 8l-1-1-2 2-2-2-1 1 2 2-2 2 1 1 2-2 2 2 1-1-2-2 2-2z"></path></g>
<g id="vaadin:file-search"><path d="M12 13.47v1.53h-10v-14h6v4h4v0.56c0.386 0.229 0.716 0.504 0.996 0.825l0.004-2.385-4-4h-8v16h12v-1.53zM9 1l3 3h-3v-3z"></path><path d="M14.78 12.72l-1.92-1.92c-0.089-0.085-0.201-0.148-0.325-0.179 0.292-0.458 0.468-1.018 0.468-1.618 0-1.657-1.343-3-3-3s-3 1.343-3 3c0 1.657 1.343 3 3 3 0.6 0 1.16-0.176 1.629-0.48 0.020 0.136 0.083 0.248 0.169 0.337l1.92 1.92c0.134 0.125 0.313 0.201 0.511 0.201 0.414 0 0.75-0.336 0.75-0.75 0-0.198-0.077-0.378-0.202-0.512zM10 11c-1.105 0-2-0.895-2-2s0.895-2 2-2c1.105 0 2 0.895 2 2s-0.895 2-2 2z"></path></g>
<g id="vaadin:file-sound"><path d="M11.4 10.5c0 1.2-0.4 2.2-1 3l0.4 0.5c0.7-0.9 1.2-2.1 1.2-3.5s-0.5-2.6-1.2-3.5l-0.4 0.5c0.6 0.8 1 1.9 1 3z"></path><path d="M9.9 8l-0.4 0.5c0.4 0.5 0.7 1.2 0.7 2s-0.3 1.5-0.7 2l0.4 0.5c0.5-0.6 0.8-1.5 0.8-2.5s-0.3-1.8-0.8-2.5z"></path><path d="M9.1 9l-0.4 0.5c0.2 0.3 0.3 0.6 0.3 1s-0.1 0.7-0.3 1l0.4 0.5c0.3-0.4 0.5-0.9 0.5-1.5s-0.2-1.1-0.5-1.5z"></path><path d="M10 0h-8v16h12v-12l-4-4zM9 5h4v10h-10v-14h6v4zM10 4v-3l3 3h-3z"></path><path d="M6 9h-2v3h2l2 2v-7z"></path></g>
<g id="vaadin:file-start"><path d="M10 0h-8v16h12v-12l-4-4zM13 15h-10v-14h6v4h4v10zM10 4v-3l3 3h-3z"></path><path d="M5 6v6l6-3z"></path></g>
<g id="vaadin:file-table"><path d="M10 0h-8v16h12v-12l-4-4zM9 5h4v10h-10v-14h6v4zM10 4v-3l3 3h-3z"></path><path d="M4 7v6h8v-6h-8zM6 12h-1v-1h1v1zM6 10h-1v-1h1v1zM9 12h-2v-1h2v1zM9 10h-2v-1h2v1zM11 12h-1v-1h1v1zM11 10h-1v-1h1v1z"></path></g>
<g id="vaadin:file-text-o"><path d="M10 0h-8v16h12v-12l-4-4zM9 5h4v10h-10v-14h6v4zM10 4v-3l3 3h-3z"></path><path d="M4 7h8v1h-8v-1z"></path><path d="M4 9h8v1h-8v-1z"></path><path d="M4 11h8v1h-8v-1z"></path></g>
<g id="vaadin:file-text"><path d="M10 0v4h4z"></path><path d="M9 0h-7v16h12v-11h-5v-5zM12 12h-8v-1h8v1zM12 10h-8v-1h8v1zM12 7v1h-8v-1h8z"></path></g>
<g id="vaadin:file-tree-small"><path d="M5 12v2h11v-5h-11v2h-2v-4h9v-5h-12v5h2v5z"></path></g>
<g id="vaadin:file-tree-sub"><path d="M8 11v1h-1v-2h5v-4h-8v1h-1v-2h6v-4h-9v4h2v3h2v2h2v3h2v2h8v-4z"></path></g>
<g id="vaadin:file-tree"><path d="M16 10v-4h-11v1h-2v-3h9v-4h-12v4h2v10h3v2h11v-4h-11v1h-2v-5h2v2z"></path></g>
<g id="vaadin:file-zip"><path d="M10 0h-8v16h12v-12l-4-4zM9 15h-4v-2.8l0.7-2.2h2.4l0.9 2.2v2.8zM13 15h-3v-3l-1-3h-2v-1h-2v1l-1 3v3h-1v-14h4v1h2v1h-2v1h2v1h4v10zM10 4v-3l3 3h-3z"></path><path d="M5 6h2v1h-2v-1z"></path><path d="M5 2h2v1h-2v-1z"></path><path d="M5 4h2v1h-2v-1z"></path><path d="M7 5h2v1h-2v-1z"></path><path d="M7 7h2v1h-2v-1z"></path><path d="M6 12h2v2h-2v-2z"></path></g>
<g id="vaadin:file"><path d="M9 5h5v11h-12v-16h7v5zM10 4v-4l4 4h-4z"></path></g>
<g id="vaadin:fill"><path d="M13 14.5c0.468-2.207 0.985-4.050 1.604-5.846 0.411 1.796 0.928 3.638 1.337 5.521 0.059 1.153-0.612 1.825-1.441 1.825s-1.5-0.672-1.5-1.5z"></path><path d="M8 1l-1.44 1.44-2-2c-0.276-0.262-0.649-0.423-1.060-0.423s-0.784 0.161-1.061 0.423c-0.27 0.271-0.438 0.645-0.438 1.059s0.168 0.789 0.439 1.060l2 2-4.44 4.44 7 7 8-8zM8 2.41l5.59 5.59h-11.18l2.75-2.75c0.071 0.042 0.156 0.067 0.247 0.067 0.271 0 0.49-0.219 0.49-0.49 0-0.091-0.025-0.176-0.068-0.249l0.721-0.718 1.54 1.53c0.091 0.091 0.216 0.147 0.355 0.147 0.277 0 0.502-0.225 0.502-0.502 0-0.139-0.056-0.264-0.147-0.355l-1.53-1.53zM3.15 1.85c-0.091-0.091-0.148-0.216-0.148-0.355s0.057-0.264 0.148-0.355c0.092-0.089 0.217-0.144 0.355-0.144s0.263 0.055 0.355 0.144l2 2-0.71 0.71z"></path></g>
<g id="vaadin:film"><path d="M0 0v16h1v-1h1v1h12v-1h1v1h1v-16h-16zM2 14h-1v-1h1v1zM2 12h-1v-1h1v1zM2 10h-1v-1h1v1zM2 8h-1v-1h1v1zM2 6h-1v-1h1v1zM2 4h-1v-1h1v1zM2 2h-1v-1h1v1zM13 15h-10v-6h10v6zM13 7h-10v-6h10v6zM15 14h-1v-1h1v1zM15 12h-1v-1h1v1zM15 10h-1v-1h1v1zM15 8h-1v-1h1v1zM15 6h-1v-1h1v1zM15 4h-1v-1h1v1zM15 2h-1v-1h1v1z"></path></g>
<g id="vaadin:filter"><path d="M1 2h14v2l-6 5v7l-2-2v-5l-6-5v-2z"></path><path d="M1 0h14v1h-14v-1z"></path></g>
<g id="vaadin:fire"><path d="M4.9 15.8c0 0-3.9-0.4-3.9-5.7 0-4.1 3.1-6.5 3.1-6.5s1.3 1.4 2.3 1.9c1 0.6 1.4-5.5 1.4-5.5s7.2 3.9 7.2 9.8c0 6.1-4 5.9-4 5.9s1.8-2.4 1.8-5.2c0-3-3.9-6.7-3.9-6.7s-0.5 4.4-2.1 5c-1.6-0.9-2.5-2.3-2.5-2.3s-3.7 5.8 0.6 9.3z"></path><path d="M8.2 16.1c-2-0.1-3.7-1.4-3.7-3.2s0.7-2.6 0.7-2.6 0.5 1 1.1 1.5 1.8 0.8 2.4 0.1c0.6-0.6 0.8-2.3 0.8-2.3s1.4 1.1 1.2 3c-0.1 2-0.9 3.5-2.5 3.5z"></path></g>
<g id="vaadin:flag-checkered"><path d="M2 0c-1.1 0-2 0.9-2 2 0 0.7 0.4 1.4 1 1.7v12.3h2v-12.3c0.6-0.3 1-1 1-1.7 0-1.1-0.9-2-2-2z"></path><path d="M12 2c-2.1 0-1.8-1-4.4-1s-3.6 3-3.6 3v8c0 0 0.7-2 3-2 2.7 0 2.8 1 5 1 3.3 0 4-2 4-2v-8c0 0-1.6 1-4 1zM15 4.5c-0.2 0.2-0.8 0.4-2 0.6v-2.2c0.8-0.1 1.5-0.2 2-0.4v2zM5 7.9v-2.6c0.4-0.6 1.1-1.1 2-1.1v-2.1c0.2-0.1 0.4-0.1 0.6-0.1 1.2 0 1.6 0.2 2.1 0.4 0.1 0.1 0.2 0.2 0.3 0.2v2.2c0.5 0.2 1.1 0.4 2 0.4 0.4 0 0.7 0 1-0.1v2.6c-0.3 0-0.6 0.1-1 0.1-1.1 0-1.5-0.2-2-0.5v2.3c-0.7-0.3-1.5-0.6-3-0.6v-2.2c-0.9 0.2-1.5 0.6-2 1.1zM13 9.9v-2.2c1.1-0.2 1.7-0.6 2-0.8v1.8c-0.2 0.3-0.7 1-2 1.2z"></path><path d="M10 7.2v-2.4c0 0-1.2-0.6-3-0.6v2.6c1.7-0.4 3 0.4 3 0.4z"></path></g>
<g id="vaadin:flag-o"><path d="M4 2c0-1.1-0.9-2-2-2s-2 0.9-2 2c0 0.7 0.4 1.4 1 1.7v12.3h2v-12.3c0.6-0.3 1-1 1-1.7z"></path><path d="M7.6 2c1.2 0 1.6 0.2 2.1 0.4 0.5 0.3 1.1 0.6 2.3 0.6s2.2-0.2 3-0.5v6.3c-0.2 0.3-0.9 1.2-3 1.2-0.9 0-1.3-0.2-1.9-0.4-0.7-0.3-1.5-0.6-3.1-0.6-0.8 0-1.5 0.2-2 0.5v-5.3c0.2-0.5 1-2.2 2.6-2.2zM16 1c0 0-1.6 1-4 1-2.1 0-1.8-1-4.4-1s-3.6 3-3.6 3v8c0 0 0.7-2 3-2 2.7 0 2.8 1 5 1 3.3 0 4-2 4-2v-8z"></path></g>
<g id="vaadin:flag"><path d="M4 2c0-1.1-0.9-2-2-2s-2 0.9-2 2c0 0.7 0.4 1.4 1 1.7v12.3h2v-12.3c0.6-0.3 1-1 1-1.7z"></path><path d="M4 4c0 0 1-3 3.6-3 2.7 0 2.3 1 4.4 1 2.4 0 4-1 4-1v8c0 0-0.7 2-4 2-2.2 0-2.3-1-5-1-2.3 0-3 2-3 2v-8z"></path></g>
<g id="vaadin:flash"><path d="M16 8l-2.2-1.6 1.1-2.4-2.7-0.2-0.2-2.7-2.4 1.1-1.6-2.2-1.6 2.2-2.4-1.1-0.2 2.7-2.7 0.2 1.1 2.4-2.2 1.6 2.2 1.6-1.1 2.4 2.7 0.2 0.2 2.7 2.4-1.1 1.6 2.2 1.6-2.2 2.4 1.1 0.2-2.7 2.7-0.2-1.1-2.4 2.2-1.6z"></path></g>
<g id="vaadin:flask"><path d="M2 16h12l-4-8v-7h1v-1h-6v1h1v7l-4 8zM9 1v7.2l1.9 3.8h-5.8l1.9-3.8v-7.2h2z"></path></g>
<g id="vaadin:flight-landing"><path d="M13.64 7c-0.71-0.2-1.89-0.43-3.23-0.67l-3.82-4.24c-0.209-0.23-0.462-0.416-0.746-0.544l-1.194-0.546c-0.090 0-0.15 0-0.1 0.11s1.45 2.89 2.29 4.59c-1.84-0.29-3.5-0.53-4.23-0.63-0.258-0.047-0.474-0.198-0.608-0.406l-0.722-1.074c-0.115-0.168-0.28-0.294-0.474-0.358l-0.806-0.232 0.61 3.26c0.067 0.34 0.318 0.609 0.644 0.699 1.326 0.381 4.816 1.341 7.526 1.921 6 1.28 6.8 1.28 7.12 0.91s-0.67-2.38-2.26-2.79z"></path><path d="M0 13h16v1h-16v-1z"></path></g>
<g id="vaadin:flight-takeoff"><path d="M12.57 2.26c-0.65 0.29-1.66 0.85-2.8 1.5l-5.46-0.76c-0.093-0.014-0.2-0.022-0.309-0.022-0.211 0-0.414 0.030-0.607 0.086l-1.185 0.336c-0.1 0-0.1 0.1 0 0.14l4.56 2c-1.54 0.92-2.91 1.76-3.51 2.14-0.13 0.082-0.288 0.13-0.458 0.13-0.094 0-0.184-0.015-0.268-0.042l-1.194-0.378c-0.086-0.031-0.186-0.049-0.29-0.049s-0.204 0.018-0.296 0.051l-0.754 0.308 2.52 2.1c0.152 0.127 0.349 0.205 0.565 0.205 0.129 0 0.251-0.028 0.361-0.077 1.204-0.538 4.374-1.998 6.734-3.228 5.24-2.78 5.82-3.26 5.82-3.7 0-0.69-2-1.4-3.43-0.74z"></path><path d="M0 13h16v1h-16v-1z"></path></g>
<g id="vaadin:flip-h"><path d="M0 15l6-5-6-4.9z"></path><path d="M9 10.1l6 4.9v-10l-6 5.1zM14 12.9l-3.4-2.8 3.4-3v5.8z"></path><path d="M7 5h1v1h-1v-1z"></path><path d="M7 3h1v1h-1v-1z"></path><path d="M7 7h1v1h-1v-1z"></path><path d="M7 9h1v1h-1v-1z"></path><path d="M7 11h1v1h-1v-1z"></path><path d="M7 13h1v1h-1v-1z"></path><path d="M7 15h1v1h-1v-1z"></path><path d="M7.5 1v0c1.3 0 2.6 0.7 3.6 1.9l-1.1 1.1h3v-3l-1.2 1.2c-1.2-1.4-2.7-2.2-4.3-2.2 0 0 0 0 0 0-1.9 0-3.6 1-4.9 2.9l0.8 0.6c1.1-1.6 2.5-2.5 4.1-2.5z"></path></g>
<g id="vaadin:flip-v"><path d="M1 1l5 6 4.94-6h-9.94z"></path><path d="M5.94 10l-4.94 6h10zM3.12 15l2.83-3.44 3 3.44h-5.83z"></path><path d="M10 8h1v1h-1v-1z"></path><path d="M12 8h1v1h-1v-1z"></path><path d="M8 8h1v1h-1v-1z"></path><path d="M6 8h1v1h-1v-1z"></path><path d="M4 8h1v1h-1v-1z"></path><path d="M2 8h1v1h-1v-1z"></path><path d="M0 8h1v1h-1v-1z"></path><path d="M15 8.47v0c-0.059 1.485-0.782 2.789-1.879 3.632l-1.121-1.102v3h3l-1.18-1.18c1.293-1.031 2.128-2.588 2.18-4.342l0-0.008c-0.092-2.083-1.223-3.883-2.884-4.905l-0.596 0.805c1.423 0.857 2.383 2.357 2.479 4.087z"></path></g>
<g id="vaadin:folder-add"><path d="M14 6v-2h-7l-1-2h-4l-1 2h-1v11h14v-1h-13v-9h0.62l1-2h2.57l1.19 2h6.62v1h1z"></path><path d="M14 7h-2v2h-2v2h2v2h2v-2h2v-2h-2v-2z"></path></g>
<g id="vaadin:folder-o"><path d="M7 4l-1-2h-4l-1 2h-1v11h16v-11h-9zM15 14h-14v-9h0.6l1-2h2.6l1.2 2h8.6v9z"></path></g>
<g id="vaadin:folder-open-o"><path d="M14 6v-2h-7l-1-2h-4l-1 2h-1v11h14l2-9h-2zM14.9 7l-1.6 7-11.9-0.1 2.3-6.9h11.2zM1 5h0.6l1-2h2.6l1.2 2h6.6v1h-10l-2 5.9v-6.9z"></path></g>
<g id="vaadin:folder-open"><path d="M14 6v-2h-7l-1-2h-4l-1 2h-1v9.5l3-7.5z"></path><path d="M3.7 7l-3.2 8h12.8l2.5-8z"></path></g>
<g id="vaadin:folder-remove"><path d="M13 12.41v1.59h-12v-9h0.62l1-2h2.57l1.19 2h6.62v2.59l1-1v-2.59h-7l-1-2h-4l-1 2h-1v11h14v-1.59l-1-1z"></path><path d="M16 8l-1-1-2 2-2-2-1 1 2 2-2 2 1 1 2-2 2 2 1-1-2-2 2-2z"></path></g>
<g id="vaadin:folder-search"><path d="M13 13.47v0.53h-12v-9h0.62l1-2h2.57l1.19 2h6.62v0.91c0.385 0.179 0.716 0.407 1.001 0.681l-0.001-2.591h-7l-1-2h-4l-1 2h-1v11h14v-0.53z"></path><path d="M15.78 12.72l-1.92-1.92c-0.089-0.085-0.201-0.148-0.325-0.179 0.292-0.458 0.468-1.018 0.468-1.618 0-1.657-1.343-3-3-3s-3 1.343-3 3c0 1.657 1.343 3 3 3 0.6 0 1.16-0.176 1.629-0.48 0.020 0.136 0.083 0.248 0.169 0.337l1.92 1.92c0.134 0.125 0.313 0.201 0.511 0.201 0.414 0 0.75-0.336 0.75-0.75 0-0.198-0.077-0.378-0.202-0.512zM11 11c-1.105 0-2-0.895-2-2s0.895-2 2-2c1.105 0 2 0.895 2 2s-0.895 2-2 2z"></path></g>
<g id="vaadin:folder"><path d="M16 15h-16v-11h1l1-2h4l1 2h9z"></path></g>
<g id="vaadin:font"><path d="M12 16h3l-6-16h-2l-6 16h3l1.9-5h4.2l1.9 5zM6.7 9l1.3-3.6 1.3 3.6h-2.6z"></path></g>
<g id="vaadin:form"><path d="M15 2v2h-9v-2h9zM16 1h-11v4h11v-4z"></path><path d="M0 1h4v4h-4v-4z"></path><path d="M15 7v2h-9v-2h9zM16 6h-11v4h11v-4z"></path><path d="M0 6h4v4h-4v-4z"></path><path d="M15 12v2h-9v-2h9zM16 11h-11v4h11v-4z"></path><path d="M0 11h4v4h-4v-4z"></path></g>
<g id="vaadin:forward"><path d="M0 1v14l8-7z"></path><path d="M8 1v14l8-7z"></path></g>
<g id="vaadin:frown-o"><path d="M8 1c3.9 0 7 3.1 7 7s-3.1 7-7 7-7-3.1-7-7 3.1-7 7-7zM8 0c-4.4 0-8 3.6-8 8s3.6 8 8 8 8-3.6 8-8-3.6-8-8-8v0z"></path><path d="M7 6c0 0.552-0.448 1-1 1s-1-0.448-1-1c0-0.552 0.448-1 1-1s1 0.448 1 1z"></path><path d="M11 6c0 0.552-0.448 1-1 1s-1-0.448-1-1c0-0.552 0.448-1 1-1s1 0.448 1 1z"></path><path d="M11.3 12.3c-0.7-1.1-2-1.8-3.3-1.8s-2.6 0.7-3.3 1.8l-0.8-0.6c0.9-1.4 2.4-2.2 4.1-2.2s3.2 0.8 4.1 2.2l-0.8 0.6z"></path></g>
<g id="vaadin:function"><path d="M10 0c0 0-2.1 0-2.7 3l-0.4 2h-1.9l-0.5 1h2.2l-1.4 7c-0.4 2-1.9 2-1.9 2h-1l-0.4 1h3c0 0 2.1 0 2.7-3l1.4-7h2.4l0.5-1h-2.7l0.4-2c0.4-2 1.8-2 1.8-2h1l0.5-1h-3z"></path></g>
<g id="vaadin:funnel"><path d="M6 11h4v4h-4v-4z"></path><path d="M13.6 5l2.4-4h-16l2.4 4h11.2z"></path><path d="M3 6l2.4 4h5.2l2.4-4h-10z"></path></g>
<g id="vaadin:gamepad"><path d="M12.16 2c-1.215 0.603-2.641 0.968-4.149 1-1.53-0.032-2.956-0.397-4.229-1.026-2.611 0.026-3.781 1.196-3.781 3.866v6c0.017 1.197 0.991 2.16 2.19 2.16 0 0 0 0 0 0h0.23c0 0 0.001 0 0.002 0 0.963 0 1.78-0.621 2.074-1.485 0.305-0.915 1.145-2.515 2.085-2.515h2.84c0.94 0 1.78 1.6 2.080 2.5 0.298 0.879 1.116 1.5 2.078 1.5 0.001 0 0.001 0 0.002 0h0.23c1.21 0 2.19-0.98 2.19-2.19v-6c0-2.64-1.17-3.81-3.84-3.81zM5 7h-1v1h-1v-1h-1v-1h1v-1h1v1h1v1zM10.060 8.11c-0.585 0-1.060-0.475-1.060-1.060s0.475-1.060 1.060-1.060c0.585 0 1.060 0.475 1.060 1.060s-0.475 1.060-1.060 1.060zM13 8c-0.552 0-1-0.448-1-1s0.448-1 1-1c0.552 0 1 0.448 1 1s-0.448 1-1 1z"></path></g>
<g id="vaadin:gavel"><path d="M6.4 4.1v0c-0.4-0.4-0.4-0.9-0.1-1.2l2.6-2.6c0.3-0.3 0.8-0.3 1.2 0l0.1 0.1c0.3 0.3 0.3 0.8 0 1.2l-2.6 2.5c-0.3 0.3-0.9 0.3-1.2 0z"></path><path d="M12 9.7v0c-0.4-0.4-0.4-0.9-0.1-1.3l2.6-2.6c0.3-0.3 0.8-0.3 1.2 0l0.1 0.1c0.3 0.3 0.3 0.8 0 1.2l-2.6 2.6c-0.4 0.3-0.9 0.3-1.2 0z"></path><path d="M10 7.7l-1.7-1.7c-0.4-0.4-0.4-1 0-1.4l2.3-2.3c0.4-0.4 1-0.4 1.4 0l1.7 1.7c0.4 0.4 0.4 1 0 1.4l-2.3 2.3c-0.4 0.4-1 0.4-1.4 0z"></path><path d="M4 14.2c0.6-0.6 4-5.6 4.5-5.3 0.4 0.2 1-0.5 1-0.5l-1.9-1.9c0 0-0.7 0.6-0.5 1 0.3 0.5-4.7 3.9-5.3 4.5 0 0-2.8 2.2-1.4 3.6s3.6-1.4 3.6-1.4z"></path></g>
<g id="vaadin:gift"><path d="M10.1 5c2-0.3 3.9-1.1 2.2-3.6-0.7-1-1.4-1.4-2-1.4-1 0-1.7 1.1-2.3 2.2-0.6-1.1-1.3-2.2-2.3-2.2-0.6 0-1.3 0.4-2 1.4-1.8 2.5 0.2 3.3 2.2 3.6h-5.9v3h16v-3h-5.9zM10.3 1c0.1 0 0.5 0.1 1.2 1 0.5 0.7 0.6 1.1 0.5 1.3-0.2 0.3-1.3 0.7-3.3 0.8 0-0.2-0.1-0.4-0.2-0.6 0.6-1.4 1.3-2.5 1.8-2.5zM4 3.3c-0.1-0.2 0-0.6 0.5-1.3 0.7-0.9 1.1-1 1.2-1 0.5 0 1.2 1.1 1.8 2.5-0.1 0.2-0.2 0.4-0.2 0.6-2-0.1-3.1-0.5-3.3-0.8zM7 7v-2h2v2h-2z"></path><path d="M9 15h-2v-6h-6v7h14v-7h-6z"></path></g>
<g id="vaadin:glass"><path d="M11 15h-2v-8l6-7h-15l6 7v8h-2c-2 0-2 1-2 1h11c0 0 0-1-2-1zM12.9 1l-1.8 2h-7.2l-1.7-2h10.7zM7 15v-8h1v8h-1z"></path></g>
<g id="vaadin:glasses"><path d="M15.5 7h-0.5c-0.1 0-0.1 0-0.2 0-0.4-1.2-1.5-2-2.8-2s-2.4 0.9-2.8 2.1c-0.3-0.4-0.7-0.6-1.2-0.6s-0.9 0.2-1.2 0.6c-0.4-1.2-1.5-2.1-2.8-2.1s-2.4 0.9-2.8 2c-0.1 0-0.1 0-0.2 0h-0.5c-0.3 0-0.5 0.2-0.5 0.5s0.2 0.5 0.5 0.5h0.5c0 1.7 1.3 3 3 3 1.5 0 2.7-1.1 3-2.5 0 0 0 0 0 0 0.3 0 0.5-0.2 0.5-0.5s0.2-0.5 0.5-0.5 0.5 0.2 0.5 0.5c0 0.3 0.2 0.5 0.5 0.5 0 0 0 0 0 0 0.2 1.4 1.5 2.5 3 2.5 1.7 0 3-1.3 3-3h0.5c0.3 0 0.5-0.2 0.5-0.5s-0.2-0.5-0.5-0.5zM4 10c-1.1 0-2-0.9-2-2s0.9-2 2-2 2 0.9 2 2-0.9 2-2 2zM12 10c-1.1 0-2-0.9-2-2s0.9-2 2-2 2 0.9 2 2-0.9 2-2 2z"></path></g>
<g id="vaadin:globe-wire"><path d="M8 0c-4.418 0-8 3.582-8 8s3.582 8 8 8c4.418 0 8-3.582 8-8s-3.582-8-8-8zM14.8 9.5c0 0.5-0.7 0.66-2 1 0.124-0.589 0.206-1.277 0.229-1.98l2.001-0.020c0 0.36-0.080 0.5-0.16 1v0zM1.2 9.5v0c-0.1-0.5-0.15-0.64-0.2-1h2c0.024 0.723 0.106 1.411 0.244 2.079-1.344-0.419-2.044-0.579-2.044-1.079zM1.2 6.5c0-0.5 0.7-0.66 2-1-0.115 0.594-0.187 1.284-0.2 1.989l-2 0.011c0-0.36 0.080-0.5 0.16-1v0zM8.5 5c1.13 0.013 2.226 0.107 3.298 0.277 0.047 0.643 0.165 1.41 0.201 2.199l-3.499 0.025v-2.5zM8.5 4v-2.94c1.17 0.27 2.2 1.47 2.84 3.15-0.836-0.116-1.819-0.192-2.817-0.21zM7.5 1.060v2.94c-1.017 0.015-2.001 0.087-2.968 0.214 0.768-1.684 1.798-2.884 2.968-3.154zM7.5 5v2.5h-3.5c0.031-0.806 0.142-1.571 0.326-2.307 0.932-0.080 2.035-0.177 3.158-0.193zM4 8.5h3.5v2.5c-1.13-0.013-2.226-0.107-3.298-0.277-0.047-0.643-0.165-1.41-0.201-2.199zM7.5 12v2.94c-1.17-0.27-2.2-1.47-2.84-3.15 0.836 0.116 1.819 0.192 2.817 0.21zM8.5 14.94v-2.94c1.017-0.015 2.001-0.087 2.968-0.214-0.768 1.684-1.798 2.884-2.968 3.154zM8.5 11v-2.5h3.5c-0.031 0.806-0.142 1.571-0.326 2.307-0.932 0.080-2.035 0.177-3.158 0.193zM15 7.5h-2c-0.024-0.723-0.106-1.411-0.244-2.079 1.354 0.399 2.014 0.559 2.014 1.079v0c0.13 0.5 0.18 0.64 0.23 1zM14.3 4.91c-0.506-0.204-1.106-0.38-1.726-0.5-0.361-1.019-0.809-1.898-1.389-2.672 1.355 0.726 2.413 1.811 3.067 3.131zM4.84 1.76c-0.568 0.752-1.019 1.631-1.305 2.581-0.699 0.189-1.299 0.365-1.874 0.593 0.751-1.39 1.823-2.475 3.139-3.156zM1.73 11.090c0.506 0.204 1.106 0.38 1.726 0.5 0.361 1.019 0.809 1.898 1.389 2.672-1.367-0.722-2.436-1.807-3.097-3.131zM11.17 14.24c0.564-0.753 1.012-1.631 1.295-2.581 0.699-0.189 1.299-0.365 1.874-0.593-0.751 1.39-1.823 2.475-3.139 3.156z"></path></g>
<g id="vaadin:globe"><path d="M8 0c-4.4 0-8 3.6-8 8s3.6 8 8 8 8-3.6 8-8-3.6-8-8-8zM13.2 5.3c0.4 0 0.7 0.3 1.1 0.3-0.3 0.4-1.6 0.4-2-0.1 0.3-0.1 0.5-0.2 0.9-0.2zM1 8c0-0.4 0-0.8 0.1-1.3 0.1 0 0.2 0.1 0.3 0.1 0 0 0.1 0.1 0.1 0.2 0 0.3 0.3 0.5 0.5 0.5 0.8 0.1 1.1 0.8 1.8 1 0.2 0.1 0.1 0.3 0 0.5-0.6 0.8-0.1 1.4 0.4 1.9 0.5 0.4 0.5 0.8 0.6 1.4 0 0.7 0.1 1.5 0.4 2.2-2.5-1.2-4.2-3.6-4.2-6.5zM8 15c-0.7 0-1.5-0.1-2.1-0.3-0.1-0.2-0.1-0.4 0-0.6 0.4-0.8 0.8-1.5 1.3-2.2 0.2-0.2 0.4-0.4 0.4-0.7 0-0.2 0.1-0.5 0.2-0.7 0.3-0.5 0.2-0.8-0.2-0.9-0.8-0.2-1.2-0.9-1.8-1.2s-1.2-0.5-1.7-0.2c-0.2 0.1-0.5 0.2-0.5-0.1 0-0.4-0.5-0.7-0.4-1.1-0.1 0-0.2 0-0.3 0.1s-0.2 0.2-0.4 0.1c-0.2-0.2-0.1-0.4-0.1-0.6 0.1-0.2 0.2-0.3 0.4-0.4 0.4-0.1 0.8-0.1 1 0.4 0.3-0.9 0.9-1.4 1.5-1.8 0 0 0.8-0.7 0.9-0.7s0.2 0.2 0.4 0.3c0.2 0 0.3 0 0.3-0.2 0.1-0.5-0.2-1.1-0.6-1.2 0-0.1 0.1-0.1 0.1-0.1 0.3-0.1 0.7-0.3 0.6-0.6 0-0.4-0.4-0.6-0.8-0.6-0.2 0-0.4 0-0.6 0.1-0.4 0.2-0.9 0.4-1.5 0.4 1.1-0.8 2.5-1.2 3.9-1.2 0.3 0 0.5 0 0.8 0-0.6 0.1-1.2 0.3-1.6 0.5 0.6 0.1 0.7 0.4 0.5 0.9-0.1 0.2 0 0.4 0.2 0.5s0.4 0.1 0.5-0.1c0.2-0.3 0.6-0.4 0.9-0.5 0.4-0.1 0.7-0.3 1-0.7 0-0.1 0.1-0.1 0.2-0.2 0.6 0.2 1.2 0.6 1.8 1-0.1 0-0.1 0.1-0.2 0.1-0.2 0.2-0.5 0.3-0.2 0.7 0.1 0.2 0 0.3-0.1 0.4-0.2 0.1-0.3 0-0.4-0.1s-0.1-0.3-0.4-0.3c-0.1 0.2-0.4 0.3-0.4 0.6 0.5 0 0.4 0.4 0.5 0.7-0.6 0.1-0.8 0.4-0.5 0.9 0.1 0.2-0.1 0.3-0.2 0.4-0.4 0.6-0.8 1-0.8 1.7s0.5 1.4 1.3 1.3c0.9-0.1 0.9-0.1 1.2 0.7 0 0.1 0.1 0.2 0.1 0.3 0.1 0.2 0.2 0.4 0.1 0.6-0.3 0.8 0.1 1.4 0.4 2 0.1 0.2 0.2 0.3 0.3 0.4-1.3 1.4-3 2.2-5 2.2z"></path></g>
<g id="vaadin:golf"><path d="M7 2c0 1.105-0.895 2-2 2s-2-0.895-2-2c0-1.105 0.895-2 2-2s2 0.895 2 2z"></path><path d="M9.8 1.8c-0.2-0.5-1.7-0.1-2 0.5-0.2 0.3-0.2 1.2-1.2 1.9-0.8 0.5-1.6 0.5-1.6 0.5-0.3 0.6-0.1 1.1 0.2 1.6 0.5 0.9 0.6 1.8 0.7 2.8 0.1 1.3-0.5 2.4-2.3 3.2-0.8 0.3-1.3 0.9-1 1.9 0 0 2-0.3 3.1-1.2 1.5-1.2 1.8-2.3 1.8-2.3s0.1 0.7 0 1.9c-0.1 1-0.2 1.5-0.4 2.2s0.3 1.2 0.9 1.2 1-0.4 1-1l0.3-1.9c0.3-2.1 0-4.3-0.8-6.3 0-0.1-0.1-0.1-0.1-0.2-0.6-1.6 0.2-2.6 0.6-3 0.3-0.4 1.2-1.2 0.8-1.8z"></path><path d="M12 0v10h1v-6l3-2z"></path><path d="M16 10c0 0.552-0.448 1-1 1s-1-0.448-1-1c0-0.552 0.448-1 1-1s1 0.448 1 1z"></path><path d="M1 8.4l3.7-3.7-0.7-0.3-3.8 3.6c0 0-0.4 0.7 0.1 1.7s1.6 0.3 1.6 0.3c0.4-0.2 0.2-0.4 0-0.6s-0.9-1-0.9-1z"></path></g>
<g id="vaadin:google-plus-square"><path d="M5 3.4c-0.8 0-1.3 0.8-1.2 1.8 0.1 1.1 0.9 1.9 1.7 2 0.8 0 1.3-0.8 1.2-1.9-0.1-1-0.9-1.9-1.7-1.9z"></path><path d="M5.4 9.3c-1.2 0-2.3 0.7-2.3 1.6s0.9 1.7 2.1 1.7c1.7 0 2.3-0.7 2.3-1.6 0-0.1 0-0.2 0-0.3-0.1-0.5-0.6-0.8-1.3-1.2-0.2-0.2-0.5-0.2-0.8-0.2z"></path><path d="M0 0v16h16v-16h-16zM7.9 5.3c0 0.7-0.4 1.2-0.9 1.6s-0.6 0.6-0.6 0.9c0 0.3 0.5 0.8 0.8 1 0.8 0.6 1.1 1.1 1.1 2 0 1.1-1.1 2.3-3.1 2.3-1.7 0-3.2-0.7-3.2-1.8 0-1.2 1.3-2.3 3.1-2.3 0.2 0 0.4 0 0.5 0-0.2-0.3-0.4-0.6-0.4-0.9 0-0.2 0.1-0.4 0.2-0.6-0.1 0-0.2 0-0.3 0-1.4 0-2.4-1-2.4-2.3 0-1.2 1.3-2.3 2.7-2.3 0.8 0 3.1 0 3.1 0l-0.7 0.6h-1c0.7 0.2 1.1 1 1.1 1.8zM14 5.5h-2.1v2h-0.5v-2h-2v-0.5h2v-2h0.5v2h2.1v0.5z"></path></g>
<g id="vaadin:google-plus"><path d="M16 3.9h-2.8v-2.6h-0.6v2.6h-2.7v0.8h2.7v2.6h0.6v-2.6h2.8z"></path><path d="M6.9 9c-0.4-0.2-1.1-0.9-1.1-1.3s0.1-0.7 0.8-1.2c0.7-0.5 1.2-1.2 1.2-2.1 0-1.1-0.5-2.1-1.3-2.4h1.3l0.9-0.7c0 0-3.1 0-4.2 0-1.9 0-3.6 1.4-3.6 3.1s1.3 3 3.2 3c0.1 0 0.3 0 0.4 0-0.2 0.2-0.2 0.4-0.2 0.7 0 0.5 0.3 0.8 0.6 1.2-0.2 0-0.5 0-0.7 0-2.3 0-4.1 1.5-4.1 3s2 2.5 4.3 2.5c2.6 0 4.1-1.5 4.1-3-0.1-1.3-0.5-2-1.6-2.8zM4.7 6.9c-1.1 0-2.1-1.2-2.3-2.6s0.5-2.5 1.6-2.5c1.1 0 2.1 1.2 2.3 2.6s-0.5 2.6-1.6 2.5zM4.3 14.1c-1.6 0-2.8-1-2.8-2.2s1.4-2.2 3-2.2c0.4 0 0.7 0.1 1 0.2 0.9 0.6 1.5 0.9 1.7 1.6 0 0.1 0.1 0.3 0.1 0.4 0 1.2-0.8 2.2-3 2.2z"></path></g>
<g id="vaadin:grab"><path d="M12.6 4c-0.2 0-0.4 0-0.6 0 0-0.2-0.2-0.6-0.4-0.8s-0.5-0.4-1.1-0.4c-0.2 0-0.4 0-0.6 0.1-0.1-0.2-0.2-0.3-0.3-0.5-0.2-0.2-0.5-0.4-1.1-0.4-0.8 0-1.2 0.5-1.4 1-0.1 0-0.3-0.1-0.5-0.1-0.5 0-0.8 0.2-1.1 0.4-0.5 0.6-0.5 1.4-0.5 1.5v0.4c-0.6 0-1.1 0.2-1.4 0.5-0.6 0.7-0.6 1.6-0.6 2.8 0 0.2 0 0.5 0 0.7 0 1.4 0.7 2.1 1.4 2.8l0.3 0.4c1.3 1.2 2.5 1.6 5.1 1.6 2.9 0 4.2-1.6 4.2-5.1v-2.5c0-0.7-0.2-2.1-1.4-2.4zM10.5 3.8c0.4 0 0.5 0.4 0.5 0.6v0.8c0 0.3 0.2 0.5 0.4 0.5 0.3 0 0.5-0.1 0.5-0.4 0 0 0-0.4 0.4-0.3 0.6 0.2 0.7 1.1 0.7 1.3 0 0 0 0 0 0v2.6c0 3.4-1.3 4.1-3.2 4.1-2.4 0-3.3-0.3-4.3-1.3-0.1-0.1-0.2-0.2-0.4-0.4-0.7-0.7-1.1-1.1-1.1-2.1 0-0.2 0-0.3 0-0.6 0-1 0-1.8 0.3-2.1 0.1-0.2 0.4-0.3 0.7-0.3v0.8l-0.3 1.2c0 0.1 0 0.1 0.1 0.1 0.1 0.1 0.2 0 0.2 0l1-1.2c0 0 0-0.1 0-0.1v-2c0-0.1 0-0.6 0.2-0.8 0.1-0.1 0.2-0.2 0.4-0.2 0.3 0 0.4 0.2 0.4 0.4v0.4c0 0.2 0.2 0.5 0.5 0.5s0.5-0.3 0.5-0.5v-1.3c0-0.1 0-0.5 0.5-0.5 0.3 0 0.5 0.2 0.5 0.5v1.2c0 0.3 0.2 0.6 0.5 0.6s0.5-0.3 0.5-0.5v-0.5c0-0.3 0.2-0.5 0.5-0.5z"></path></g>
<g id="vaadin:grid-bevel"><path d="M14 2v-1h-13v13h1v1h13v-13h-1zM5 13h-3v-3h3v3zM5 9h-3v-3h3v3zM5 5h-3v-3h3v3zM9 13h-3v-3h3v3zM9 9h-3v-3h3v3zM9 5h-3v-3h3v3zM13 13h-3v-3h3v3zM13 9h-3v-3h3v3zM13 5h-3v-3h3v3z"></path></g>
<g id="vaadin:grid-big-o"><path d="M0 7h7v-7h-7v7zM1 1h5v5h-5v-5z"></path><path d="M9 0v7h7v-7h-7zM15 6h-5v-5h5v5z"></path><path d="M0 16h7v-7h-7v7zM1 10h5v5h-5v-5z"></path><path d="M9 16h7v-7h-7v7zM10 10h5v5h-5v-5z"></path></g>
<g id="vaadin:grid-big"><path d="M0 0h7v7h-7v-7z"></path><path d="M9 0h7v7h-7v-7z"></path><path d="M0 9h7v7h-7v-7z"></path><path d="M9 9h7v7h-7v-7z"></path></g>
<g id="vaadin:grid-h"><path d="M0 0v16h16v-16h-16zM5 15h-4v-14h4v14zM10 15h-4v-14h4v14zM15 15h-4v-14h4v14z"></path></g>
<g id="vaadin:grid-small-o"><path d="M0 4h4v-4h-4v4zM1 1h2v2h-2v-2z"></path><path d="M0 10h4v-4h-4v4zM1 7h2v2h-2v-2z"></path><path d="M0 16h4v-4h-4v4zM1 13h2v2h-2v-2z"></path><path d="M6 4h4v-4h-4v4zM7 1h2v2h-2v-2z"></path><path d="M6 10h4v-4h-4v4zM7 7h2v2h-2v-2z"></path><path d="M6 16h4v-4h-4v4zM7 13h2v2h-2v-2z"></path><path d="M12 0v4h4v-4h-4zM15 3h-2v-2h2v2z"></path><path d="M12 10h4v-4h-4v4zM13 7h2v2h-2v-2z"></path><path d="M12 16h4v-4h-4v4zM13 13h2v2h-2v-2z"></path></g>
<g id="vaadin:grid-small"><path d="M0 0h4v4h-4v-4z"></path><path d="M0 6h4v4h-4v-4z"></path><path d="M0 12h4v4h-4v-4z"></path><path d="M6 0h4v4h-4v-4z"></path><path d="M6 6h4v4h-4v-4z"></path><path d="M6 12h4v4h-4v-4z"></path><path d="M12 0h4v4h-4v-4z"></path><path d="M12 6h4v4h-4v-4z"></path><path d="M12 12h4v4h-4v-4z"></path></g>
<g id="vaadin:grid-v"><path d="M16 0h-16v16h16v-16zM1 5v-4h14v4h-14zM1 10v-4h14v4h-14zM1 15v-4h14v4h-14z"></path></g>
<g id="vaadin:grid"><path d="M0 0v16h16v-16h-16zM5 15h-4v-4h4v4zM5 10h-4v-4h4v4zM5 5h-4v-4h4v4zM10 15h-4v-4h4v4zM10 10h-4v-4h4v4zM10 5h-4v-4h4v4zM15 15h-4v-4h4v4zM15 10h-4v-4h4v4zM15 5h-4v-4h4v4z"></path></g>
<g id="vaadin:group"><path d="M5 16v-5.3c-0.6-0.3-1-1-1-1.7v-4c0-0.7 0.4-1.3 1-1.7 0-0.1 0-0.2 0-0.3 0-1.1-0.9-2-2-2s-2 0.9-2 2c0 1.1 0.9 2 2 2h-2c-0.5 0-1 0.5-1 1v4c0 0.5 0.5 1 1 1v5h4z"></path><path d="M15 5h-2c1.1 0 2-0.9 2-2s-0.9-2-2-2-2 0.9-2 2c0 0.1 0 0.2 0 0.3 0.6 0.4 1 1 1 1.7v4c0 0.7-0.4 1.4-1 1.7v5.3h4v-5c0.5 0 1-0.5 1-1v-4c0-0.5-0.5-1-1-1z"></path><path d="M10 2c0 1.105-0.895 2-2 2s-2-0.895-2-2c0-1.105 0.895-2 2-2s2 0.895 2 2z"></path><path d="M10 4h-4c-0.5 0-1 0.5-1 1v4c0 0.5 0.5 1 1 1v6h4v-6c0.5 0 1-0.5 1-1v-4c0-0.5-0.5-1-1-1z"></path></g>
<g id="vaadin:hammer"><path d="M6 2l7 7 3-3-4.48-4.48s-2.97 1.030-4.52-0.52z"></path><path d="M8.8 5.79l-8.53 8.52c-0.165 0.178-0.267 0.417-0.267 0.68s0.101 0.502 0.267 0.681c0.181 0.183 0.433 0.297 0.711 0.297 0.253 0 0.484-0.094 0.66-0.248l8.569-8.519z"></path></g>
<g id="vaadin:hand"><path d="M13.5 2.4c-0.4-0.4-1-0.5-1.5-0.3 0-0.3-0.1-0.6-0.4-0.9-0.2-0.2-0.6-0.4-1.1-0.4-0.3 0-0.5 0.1-0.7 0.1 0-0.2-0.1-0.3-0.2-0.5-0.5-0.6-1.5-0.6-2 0-0.2 0.2-0.4 0.4-0.4 0.6-0.2 0-0.4-0.1-0.6-0.1-0.5 0-0.8 0.2-1.1 0.5-0.5 0.5-0.5 1.3-0.5 1.3v3.8c-0.3-0.3-0.8-0.8-1.5-0.8-0.2 0-0.5 0.1-0.7 0.2-0.4 0.2-0.6 0.5-0.7 0.9-0.3 1 0.6 2.4 0.6 2.5 0.1 0.1 1.2 2.7 2.2 3.8 1 1.2 2.1 1.9 4.9 1.9 2.9 0 4.2-1.6 4.2-5.1v-5.5c0-0.1 0.1-1.3-0.5-2zM8 2c0-0.3-0.1-1 0.5-1 0.5 0 0.5 0.5 0.5 1v4c0 0.3 0.2 0.5 0.5 0.5s0.5-0.2 0.5-0.5v-3.8c0 0 0-0.4 0.5-0.4 0.6 0 0.5 0.9 0.5 0.9v3.3c0 0.3 0.2 0.5 0.5 0.5s0.5-0.2 0.5-0.5v-2.4c0-0.1 0-0.6 0.5-0.6s0.5 1 0.5 1v5.9c0 3.4-1.3 4.1-3.2 4.1-2.4 0-3.3-0.5-4.1-1.6-0.9-1-2.1-3.6-2.1-3.7-0.3-0.3-0.7-1.2-0.6-1.6 0-0.1 0.1-0.2 0.2-0.3 0.1 0 0.2-0.1 0.2-0.1 0.4 0 0.8 0.5 0.9 0.7l0.6 0.9c0.1 0.2 0.4 0.3 0.6 0.2 0.4 0 0.5-0.2 0.5-0.4v-5.2c0-0.4 0-1 0.5-1 0.4 0 0.5 0.3 0.5 0.8v3.3c0 0.3 0.2 0.5 0.5 0.5s0.5-0.2 0.5-0.5z"></path></g>
<g id="vaadin:handle-corner"><path d="M6.7 16l9.3-9.3v-1.4l-10.7 10.7z"></path><path d="M9.7 16l6.3-6.3v-1.4l-7.7 7.7z"></path><path d="M12.7 16l3.3-3.3v-1.4l-4.7 4.7z"></path><path d="M15.7 16l0.3-0.3v-1.4l-1.7 1.7z"></path></g>
<g id="vaadin:hands-up"><path d="M10 2c0 1.105-0.895 2-2 2s-2-0.895-2-2c0-1.105 0.895-2 2-2s2 0.895 2 2z"></path><path d="M6 16h1.5v-5h1v5h1.5v-9c-0-0.016-0.001-0.034-0.001-0.052 0-0.521 0.194-0.997 0.513-1.36l3.278-3.318c0.216-0.129 0.358-0.362 0.358-0.628 0-0.403-0.327-0.73-0.73-0.73-0.266 0-0.499 0.142-0.626 0.355l-2.362 2.383c-0.212 0.216-0.508 0.35-0.835 0.35-0.002 0-0.004 0-0.006-0h-3.18c-0.002 0-0.004 0-0.005 0-0.327 0-0.622-0.134-0.834-0.35l-2.32-2.39c-0.129-0.216-0.362-0.358-0.628-0.358-0.403 0-0.73 0.327-0.73 0.73 0 0.266 0.142 0.499 0.355 0.626l3.243 3.332c0.317 0.361 0.511 0.836 0.511 1.358 0 0.018-0 0.037-0.001 0.055l0 8.997z"></path></g>
<g id="vaadin:handshake"><path d="M13 3c-0.538 0.515-1.185 0.92-1.902 1.178-0.748 0.132-2.818-0.828-3.838 0.152-0.17 0.17-0.38 0.34-0.6 0.51-0.48-0.21-1.22-0.53-1.76-0.84s-1.9-1-1.9-1l-3 3.5s0.74 1 1.2 1.66c0.3 0.44 0.67 1.11 0.91 1.56l-0.34 0.4c-0.058 0.115-0.093 0.25-0.093 0.393 0 0.235 0.092 0.449 0.243 0.607 0.138 0.103 0.311 0.165 0.5 0.165s0.362-0.062 0.502-0.167c-0.094 0.109-0.149 0.249-0.149 0.402 0 0.193 0.088 0.365 0.226 0.479 0.144 0.085 0.317 0.135 0.501 0.135s0.357-0.050 0.505-0.137c-0.112 0.139-0.177 0.313-0.177 0.503s0.065 0.364 0.174 0.502c0.099 0.035 0.214 0.056 0.334 0.056 0.207 0 0.399-0.063 0.558-0.17-0.043 0.095-0.065 0.203-0.065 0.317 0 0.234 0.096 0.445 0.252 0.595 0.13 0.059 0.283 0.093 0.443 0.093 0.226 0 0.437-0.068 0.611-0.185l0.516-0.467c0.472 0.47 1.123 0.761 1.842 0.761 0.020 0 0.041-0 0.061-0.001 0.494-0.042 0.908-0.356 1.094-0.791 0.146 0.056 0.312 0.094 0.488 0.094 0.236 0 0.455-0.068 0.64-0.185 0.585-0.387 0.445-0.687 0.445-0.687 0.125 0.055 0.27 0.087 0.423 0.087 0.321 0 0.61-0.142 0.806-0.366 0.176-0.181 0.283-0.427 0.283-0.697 0-0.19-0.053-0.367-0.145-0.518 0.008 0.005 0.015 0.005 0.021 0.005 0.421 0 0.787-0.232 0.978-0.574 0.068-0.171 0.105-0.363 0.105-0.563 0-0.342-0.11-0.659-0.296-0.917l0.003 0.005c0.82-0.16 0.79-0.57 1.19-1.17 0.384-0.494 0.852-0.902 1.387-1.208zM12.95 10.060c-0.44 0.44-0.78 0.25-1.53-0.32s-2.24-1.64-2.24-1.64c0.061 0.305 0.202 0.57 0.401 0.781 0.319 0.359 1.269 1.179 1.719 1.599 0.28 0.26 1 0.78 0.58 1.18s-0.75 0-1.44-0.56-2.23-1.94-2.23-1.94c-0.001 0.018-0.002 0.038-0.002 0.059 0 0.258 0.104 0.491 0.272 0.661 0.17 0.2 1.12 1.12 1.52 1.54s0.75 0.67 0.41 1-1.030-0.19-1.41-0.58c-0.59-0.57-1.76-1.63-1.76-1.63-0.001 0.016-0.001 0.034-0.001 0.053 0 0.284 0.098 0.544 0.263 0.75 0.288 0.378 0.848 0.868 1.188 1.248s0.54 0.7 0 1-1.34-0.44-1.69-0.8c0-0.001 0-0.001 0-0.002 0-0.103-0.038-0.197-0.1-0.269-0.159-0.147-0.374-0.238-0.609-0.238-0.104 0-0.204 0.018-0.297 0.050 0.128-0.114 0.204-0.274 0.204-0.452s-0.076-0.338-0.198-0.45c-0.126-0.095-0.284-0.152-0.455-0.152s-0.33 0.057-0.457 0.153c0.117-0.113 0.189-0.268 0.189-0.441 0-0.213-0.109-0.4-0.274-0.509-0.153-0.097-0.336-0.153-0.532-0.153-0.244 0-0.468 0.088-0.642 0.233 0.095-0.114 0.151-0.26 0.151-0.42 0-0.195-0.085-0.37-0.219-0.491-0.178-0.165-0.417-0.266-0.679-0.266-0.185 0-0.358 0.050-0.507 0.138l-0.665-1.123c-0.46-0.73-1-1.49-1-1.49l2.28-2.77s0.81 0.5 1.48 0.88c0.33 0.19 0.9 0.44 1.33 0.64-0.68 0.51-1.25 1-1.080 1.34 0.297 0.214 0.668 0.343 1.069 0.343 0.376 0 0.726-0.113 1.018-0.307 0.373-0.251 0.84-0.403 1.343-0.403 0.347 0 0.677 0.072 0.976 0.203 0.554 0.374 1.574 1.294 2.504 1.874v0c1.17 0.85 1.4 1.4 1.12 1.68z"></path></g>
<g id="vaadin:harddrive-o"><path d="M2 12h1v1h-1v-1z"></path><path d="M4 12h3v1h-3v-1z"></path><path d="M13 1h-10l-3 9v5h16v-5l-3-9zM3.7 2h8.6l2.7 8h-13.9l2.6-8zM1 14v-3h14v3h-14z"></path></g>
<g id="vaadin:harddrive"><path d="M13 1h-10l-2.7 8h15.4z"></path><path d="M0 10v5h16v-5h-16zM3 13h-1v-1h1v1zM7 13h-3v-1h3v1z"></path></g>
<g id="vaadin:hash"><path d="M15 6v-2h-2.6l0.6-2.8-2-0.4-0.7 3.2h-3l0.7-2.8-2-0.4-0.7 3.2h-3.3v2h2.9l-0.9 4h-3v2h2.6l-0.6 2.8 2 0.4 0.7-3.2h3l-0.7 2.8 2 0.4 0.7-3.2h3.3v-2h-2.9l0.9-4h3zM9 10h-3l1-4h3l-1 4z"></path></g>
<g id="vaadin:header"><path d="M11 0v7h-6v-7h-3v16h3v-7h6v7h3v-16z"></path></g>
<g id="vaadin:headphones"><path d="M14 8.3v-2.3c0-3.3-2.7-6-6-6s-6 2.7-6 6v2.3c-1.2 0.5-2 1.7-2 3.1v1.2c0 1.8 1.3 3.2 3 3.4h2v-8h-1v-2c0-2.2 1.8-4 4-4s4 1.8 4 4v2h-1v8h2c1.7-0.2 3-1.7 3-3.4v-1.2c0-1.4-0.8-2.6-2-3.1zM4 15h-1v-6h1v6zM13 15h-1v-6h1v6z"></path></g>
<g id="vaadin:headset"><path d="M14.82 8c-0.309-0.851-0.969-1.511-1.799-1.813l-0.021-1.687c0-2.5-2.47-4.5-5.5-4.5s-5.5 2-5.5 4.5v1.68c-1.173 0.423-1.996 1.525-2 2.82v1c0 1.657 1.343 3 3 3h1v-7h-1v-1.5c0-1.93 2-3.5 4.5-3.5s4.5 1.57 4.5 3.5v1.5h-1v7h1c1.657 0 3-1.343 3-3v1.73c0 1.806-1.464 3.27-3.27 3.27h-1.73c0-0.552-0.448-1-1-1h-1c-0.552 0-1 0.448-1 1s0.448 1 1 1h3.73c2.358 0 4.27-1.912 4.27-4.27v-3.73h-1.18z"></path></g>
<g id="vaadin:health-card"><path d="M15 3v10h-14v-10h14zM16 2h-16v12h16v-12z"></path><path d="M9 5h5v1h-5v-1z"></path><path d="M9 7h5v1h-5v-1z"></path><path d="M9 9h2v1h-2v-1z"></path><path d="M6.5 5c0 0 0 0 0 0-0.6 0-1.1 0.6-1.5 1-0.4-0.4-0.9-1-1.5-1 0 0 0 0 0 0-1.5 0-2.1 1.9-1 2.9l2.5 2.1 2.5-2.1c1.1-1 0.5-2.9-1-2.9z"></path></g>
<g id="vaadin:heart-o"><path d="M11.7 2c-0.9 0-2.7 0.5-3.7 2.1-1-1.6-2.8-2.1-3.8-2.1-2.3 0-4.2 1.9-4.2 4.2 0 4 7.4 8.5 7.7 8.7l0.3 0.2 0.3-0.2c0.3-0.2 7.7-4.8 7.7-8.7 0-2.3-1.9-4.2-4.3-4.2zM8 13.9c-2.2-1.4-7-5-7-7.7 0-1.8 1.5-3.2 3.2-3.2 0.1 0 2.5 0.1 3.3 2.4l0.5 1.4 0.5-1.4c0.8-2.3 3.2-2.4 3.3-2.4 1.7 0 3.2 1.4 3.2 3.2 0 2.7-4.8 6.3-7 7.7z"></path></g>
<g id="vaadin:heart"><path d="M12 2c0 0-3 0-4 3-1-3-4-3-4-3-2.2 0-4 1.8-4 4 0 4.1 8 9 8 9s8-5 8-9c0-2.2-1.8-4-4-4z"></path></g>
<g id="vaadin:home-o"><path d="M16 6.6l-8-5.2-2 1.3v-1.7h-2v3l-4 2.6 1.9 2.7 0.1-0.1v5.8h5v-4h2v4h5v-5.8l0.1 0.1 1.9-2.7zM1.4 6.9l6.6-4.3 6.6 4.3-0.7 1-5.9-3.9-5.9 3.9-0.7-1zM13 14h-3v-4h-4v4h-3v-5.4l5-3.3 5 3.3v5.4z"></path></g>
<g id="vaadin:home"><path d="M8 1.4l-2 1.3v-1.7h-2v3l-4 2.6 0.6 0.8 7.4-4.8 7.4 4.8 0.6-0.8z"></path><path d="M8 4l-6 4v7h5v-3h2v3h5v-7z"></path></g>
<g id="vaadin:hospital"><path d="M15 4v-4h-7v4h-8v12h6v-3h4v3h6v-12h-1zM4 11h-2v-2h2v2zM4 8h-2v-2h2v2zM7 11h-2v-2h2v2zM7 8h-2v-2h2v2zM10 3v-1h1v-1h1v1h1v1h-1v1h-1v-1h-1zM11 11h-2v-2h2v2zM11 8h-2v-2h2v2zM14 11h-2v-2h2v2zM14 8h-2v-2h2v2z"></path></g>
<g id="vaadin:hourglass-empty"><path d="M11.18 6.060c1.107-0.808 1.819-2.101 1.82-3.56v-0.5h1v-2h-12v2h1v0.5c0.001 1.459 0.713 2.752 1.808 3.551 0.672 0.43 1.121 1.13 1.192 1.939-0.093 0.848-0.551 1.564-1.209 2.003-1.081 0.814-1.772 2.078-1.79 3.503l-0 0.503h-1v2h12v-2h-1v-0.5c-0.018-1.429-0.709-2.692-1.769-3.492-0.68-0.454-1.138-1.169-1.23-1.996 0.071-0.831 0.52-1.532 1.169-1.946zM9 8c0.072 1.142 0.655 2.136 1.519 2.763 0.877 0.623 1.445 1.61 1.481 2.732l0 0.505h-8v-0.5c0.036-1.127 0.604-2.114 1.459-2.723 0.886-0.642 1.468-1.635 1.54-2.766-0.063-1.124-0.641-2.091-1.498-2.683-0.914-0.633-1.499-1.662-1.502-2.827v-0.5h8v0.5c-0.003 1.166-0.587 2.195-1.479 2.813-0.88 0.607-1.458 1.574-1.521 2.678z"></path></g>
<g id="vaadin:hourglass-end"><path d="M11.18 6.060c1.107-0.808 1.819-2.101 1.82-3.56v-0.5h1v-2h-12v2h1v0.5c0.001 1.459 0.713 2.752 1.808 3.551 0.672 0.43 1.121 1.13 1.192 1.939-0.093 0.848-0.551 1.564-1.209 2.003-1.081 0.814-1.772 2.078-1.79 3.503l-0 0.503h-1v2h12v-2h-1v-0.5c-0.018-1.429-0.709-2.692-1.769-3.492-0.68-0.454-1.138-1.169-1.23-1.996 0.071-0.831 0.52-1.532 1.169-1.946zM9 8c0.072 1.142 0.655 2.136 1.519 2.763 0.877 0.623 1.445 1.61 1.481 2.732l0 0.505h-1s-1.62-3.5-3-3.5-3 3.5-3 3.5h-1v-0.5c0.036-1.127 0.604-2.114 1.459-2.723 0.886-0.642 1.468-1.635 1.54-2.766-0.063-1.124-0.641-2.091-1.498-2.683-0.914-0.633-1.499-1.662-1.502-2.827v-0.5h8v0.5c-0.003 1.166-0.587 2.195-1.479 2.813-0.88 0.607-1.458 1.574-1.521 2.678z"></path></g>
<g id="vaadin:hourglass-start"><path d="M6.16 4.6c1.114 0.734 1.84 1.979 1.84 3.394 0 0.002 0 0.004 0 0.006v-0c0-0.002 0-0.004 0-0.006 0-1.415 0.726-2.66 1.825-3.384 0.573-0.385 0.984-0.939 1.17-1.589l-5.995-0.020c0.191 0.67 0.603 1.225 1.15 1.594z"></path><path d="M11.18 6.060c1.107-0.808 1.819-2.101 1.82-3.56v-0.5h1v-2h-12v2h1v0.5c0.001 1.459 0.713 2.752 1.808 3.551 0.672 0.43 1.121 1.13 1.192 1.939-0.093 0.848-0.551 1.564-1.209 2.003-1.081 0.814-1.772 2.078-1.79 3.503l-0 0.503h-1v2h12v-2h-1v-0.5c-0.018-1.429-0.709-2.692-1.769-3.492-0.68-0.454-1.138-1.169-1.23-1.996 0.071-0.831 0.52-1.532 1.169-1.946zM9 8c0.072 1.142 0.655 2.136 1.519 2.763 0.877 0.623 1.445 1.61 1.481 2.732l0 0.505h-8v-0.5c0.036-1.127 0.604-2.114 1.459-2.723 0.886-0.642 1.468-1.635 1.54-2.766-0.063-1.124-0.641-2.091-1.498-2.683-0.914-0.633-1.499-1.662-1.502-2.827v-0.5h8v0.5c-0.003 1.166-0.587 2.195-1.479 2.813-0.88 0.607-1.458 1.574-1.521 2.678z"></path></g>
<g id="vaadin:hourglass"><path d="M6.16 4.6c1.114 0.734 1.84 1.979 1.84 3.394 0 0.002 0 0.004 0 0.006v-0c0-0.002 0-0.004 0-0.006 0-1.415 0.726-2.66 1.825-3.384 0.23-0.199 0.426-0.395 0.609-0.602l-4.874-0.007c0.19 0.214 0.386 0.41 0.593 0.594z"></path><path d="M11.18 6.060c1.107-0.808 1.819-2.101 1.82-3.56v-0.5h1v-2h-12v2h1v0.5c0.001 1.459 0.713 2.752 1.808 3.551 0.672 0.43 1.121 1.13 1.192 1.939-0.093 0.848-0.551 1.564-1.209 2.003-1.081 0.814-1.772 2.078-1.79 3.503l-0 0.503h-1v2h12v-2h-1v-0.5c-0.018-1.429-0.709-2.692-1.769-3.492-0.68-0.454-1.138-1.169-1.23-1.996 0.071-0.831 0.52-1.532 1.169-1.946zM9 8c0.072 1.142 0.655 2.136 1.519 2.763 0.877 0.623 1.445 1.61 1.481 2.732l0 0.505h-1.77c-0.7-0.87-1.71-2-2.23-2s-1.53 1.13-2.23 2h-1.77v-0.5c0.036-1.127 0.604-2.114 1.459-2.723 0.886-0.642 1.468-1.635 1.54-2.766-0.063-1.124-0.641-2.091-1.498-2.683-0.914-0.633-1.499-1.662-1.502-2.827v-0.5h8v0.5c-0.003 1.166-0.587 2.195-1.479 2.813-0.88 0.607-1.458 1.574-1.521 2.678z"></path></g>
<g id="vaadin:inbox"><path d="M10 6v-6h-4v6h-2l4 5 4-5z"></path><path d="M13 1h-2v1h1.3l2.6 8h-3.9v2h-6v-2h-3.9l2.6-8h1.3v-1h-2l-3 9v5h16v-5z"></path></g>
<g id="vaadin:indent"><path d="M0 0h16v3h-16v-3z"></path><path d="M6 4h10v3h-10v-3z"></path><path d="M6 8h10v3h-10v-3z"></path><path d="M0 12h16v3h-16v-3z"></path><path d="M0 4.5v6l4-3z"></path></g>
<g id="vaadin:info-circle-o"><path d="M8 1c3.9 0 7 3.1 7 7s-3.1 7-7 7-7-3.1-7-7 3.1-7 7-7zM8 0c-4.4 0-8 3.6-8 8s3.6 8 8 8 8-3.6 8-8-3.6-8-8-8v0z"></path><path d="M7 6h2v7h-2v-7z"></path><path d="M7 3h2v2h-2v-2z"></path></g>
<g id="vaadin:info-circle"><path d="M8 0c-4.4 0-8 3.6-8 8s3.6 8 8 8 8-3.6 8-8-3.6-8-8-8zM9 13h-2v-7h2v7zM9 5h-2v-2h2v2z"></path></g>
<g id="vaadin:info"><path d="M6 5h4v11h-4v-11z"></path><path d="M10 2c0 1.105-0.895 2-2 2s-2-0.895-2-2c0-1.105 0.895-2 2-2s2 0.895 2 2z"></path></g>
<g id="vaadin:input"><path d="M16 5c0-0.6-0.4-1-1-1h-14c-0.6 0-1 0.4-1 1v6c0 0.6 0.4 1 1 1h14c0.6 0 1-0.4 1-1v-6zM15 11h-14v-6h14v6z"></path><path d="M2 6h1v4h-1v-4z"></path></g>
<g id="vaadin:insert"><path d="M14 16v-11l-1 1v9h-12v-12h9l1-1h-11v14z"></path><path d="M16 1.4l-1.4-1.4-6.8 6.8-1.8-1.8v5h5l-1.8-1.8z"></path></g>
<g id="vaadin:institution"><path d="M8 0l-8 3v2h16v-2z"></path><path d="M0 14h16v2h-16v-2z"></path><path d="M16 7v-1h-16v1h1v5h-1v1h16v-1h-1v-5h1zM4 12h-1v-5h1v5zM7 12h-1v-5h1v5zM10 12h-1v-5h1v5zM13 12h-1v-5h1v5z"></path></g>
<g id="vaadin:invoice"><path d="M4.4 10.2c-0.6 0.1-1.4-0.3-1.7-0.4l-0.5 0.9c0 0 0.9 0.4 1.7 0.5v0.8h1v-0.9c0.9-0.3 1.4-1.1 1.5-1.8 0-0.8-0.6-1.4-1.9-1.9-0.4-0.2-1.1-0.5-1.1-0.9 0-0.5 0.4-0.8 1-0.8 0.7 0 1.4 0.3 1.4 0.3l0.4-0.9c0 0-0.5-0.2-1.2-0.4v-0.7h-1v0.7c-0.9 0.2-1.5 0.8-1.6 1.7 0 1.2 1.3 1.7 1.8 1.9 0.6 0.2 1.3 0.6 1.3 0.9 0 0.4-0.4 0.9-1.1 1z"></path><path d="M0 2v12h16v-12h-16zM15 13h-14v-10h14v10z"></path><path d="M8 5h6v1h-6v-1z"></path><path d="M8 7h6v1h-6v-1z"></path><path d="M8 9h3v1h-3v-1z"></path></g>
<g id="vaadin:italic"><path d="M8 0h3l-3 16h-3z"></path></g>
<g id="vaadin:key-o"><path d="M13 0l-7 6.1c-0.3-0.1-0.6-0.1-1-0.1-2.8 0-5 2.2-5 5s2.3 5 5 5 5-2.2 5-5c0-0.3 0-0.6-0.1-0.9l1.1-1.1v-2h2v-2h2l1-1v-4h-3zM12 6h-1.7l1.7-1.4v1.4zM15 3.6l-0.4 0.4h-1.9l2.3-2v1.6zM7.3 7.6l0.7 0.4 2-1.7v2.3l-0.8 0.8-0.3 0.4 0.1 0.5c0 0.2 0.1 0.5 0.1 0.7 0 2.2-1.8 4-4 4s-4-1.8-4-4 1.8-4 4-4c0.3 0 0.5 0 0.8 0.1l0.5 0.1 0.4-0.3 6.6-5.9h1.6l-7.7 6.6z"></path><path d="M6 11.5c0 0.828-0.672 1.5-1.5 1.5s-1.5-0.672-1.5-1.5c0-0.828 0.672-1.5 1.5-1.5s1.5 0.672 1.5 1.5z"></path></g>
<g id="vaadin:key"><path d="M8.1 7c-0.2-0.1-0.4-0.2-0.6-0.3l7.5-6.7h-2l-7 6.1c-0.3-0.1-0.6-0.1-1-0.1-2.8 0-5 2.2-5 5s2.3 5 5 5 5-2.2 5-5c0-0.6-0.1-1.2-0.3-1.7l1.3-1.3v-2h2v-2h2l1-1v-3l-7.9 7zM4 13.2c-0.7 0-1.2-0.6-1.2-1.2s0.6-1.2 1.2-1.2 1.2 0.6 1.2 1.2-0.5 1.2-1.2 1.2z"></path></g>
<g id="vaadin:keyboard-o"><path d="M15 5v7h-14v-7h14zM16 4h-16v9h16v-9z"></path><path d="M4 10h8v1h-8v-1z"></path><path d="M2 10h1v1h-1v-1z"></path><path d="M13 10h1v1h-1v-1z"></path><path d="M11 8h1v1h-1v-1z"></path><path d="M9 8h1v1h-1v-1z"></path><path d="M7 8h1v1h-1v-1z"></path><path d="M5 8h1v1h-1v-1z"></path><path d="M3 8h1v1h-1v-1z"></path><path d="M10 6h1v1h-1v-1z"></path><path d="M12 6v1h1v2h1v-3z"></path><path d="M8 6h1v1h-1v-1z"></path><path d="M6 6h1v1h-1v-1z"></path><path d="M4 6h1v1h-1v-1z"></path><path d="M2 6h1v1h-1v-1z"></path></g>
<g id="vaadin:keyboard"><path d="M0 4v9h16v-9h-16zM10 6h1v1h-1v-1zM8 6h1v1h-1v-1zM10 8v1h-1v-1h1zM6 6h1v1h-1v-1zM8 8v1h-1v-1h1zM4 6h1v1h-1v-1zM6 8v1h-1v-1h1zM2 6h1v1h-1v-1zM3 11h-1v-1h1v1zM3 8h1v1h-1v-1zM12 11h-8v-1h8v1zM12 9h-1v-1h1v1zM14 11h-1v-1h1v1zM14 9h-1v-2h-1v-1h2v3z"></path></g>
<g id="vaadin:laptop"><path d="M14 11v-9h-12v9h-2v2h16v-2h-2zM10 12h-4v-1h4v1zM13 10h-10v-7h10v7z"></path></g>
<g id="vaadin:layout"><path d="M0 0v16h16v-16h-16zM1 3h4v12h-4v-12zM15 15h-9v-12h9v12z"></path></g>
<g id="vaadin:level-down-bold"><path d="M9 16l4-7h-3v-9h-7l2 3h2v6h-3z"></path></g>
<g id="vaadin:level-down"><path d="M5 1h6v11h2l-3 3-3-3h2v-9h-6z"></path></g>
<g id="vaadin:level-left-bold"><path d="M0 7l7-4v3h9v7l-3-2v-2h-6v3z"></path></g>
<g id="vaadin:level-left"><path d="M15 12v-6h-11v-2l-3 3 3 3v-2h9v6z"></path></g>
<g id="vaadin:level-right-bold"><path d="M16 7l-7-4v3h-9v7l3-2v-2h6v3z"></path></g>
<g id="vaadin:level-right"><path d="M1 12v-6h11v-2l3 3-3 3v-2h-9v6z"></path></g>
<g id="vaadin:level-up-bold"><path d="M9 0l4 7h-3v9h-7l2-3h2v-6h-3z"></path></g>
<g id="vaadin:level-up"><path d="M11 15h-6v-11h-2l3-3 3 3h-2v9h6z"></path></g>
<g id="vaadin:lifebuoy"><path d="M8 0c-4.4 0-8 3.6-8 8s3.6 8 8 8 8-3.6 8-8-3.6-8-8-8zM4 8c0-2.2 1.8-4 4-4s4 1.8 4 4c0 2.2-1.8 4-4 4s-4-1.8-4-4zM12.6 9.8c0.3-0.5 0.4-1.2 0.4-1.8s-0.1-1.3-0.4-1.8l1.5-1.5c0.6 1 0.9 2.1 0.9 3.3s-0.3 2.3-0.8 3.3l-1.6-1.5zM11.3 1.8l-1.5 1.6c-0.5-0.3-1.2-0.4-1.8-0.4s-1.3 0.1-1.8 0.4l-1.5-1.6c1-0.5 2.1-0.8 3.3-0.8s2.3 0.3 3.3 0.8zM1.8 4.7l1.5 1.5c-0.2 0.5-0.3 1.2-0.3 1.8s0.1 1.3 0.4 1.8l-1.5 1.5c-0.6-1-0.9-2.1-0.9-3.3s0.3-2.3 0.8-3.3zM4.7 14.2l1.5-1.5c0.5 0.2 1.2 0.3 1.8 0.3s1.3-0.1 1.8-0.4l1.5 1.5c-1 0.6-2.1 0.9-3.3 0.9s-2.3-0.3-3.3-0.8z"></path></g>
<g id="vaadin:lightbulb"><path d="M8 0c-2.761 0-5 2.239-5 5 0.013 1.672 0.878 3.138 2.182 3.989l0.818 2.011c-0.276 0-0.5 0.224-0.5 0.5s0.224 0.5 0.5 0.5c-0.276 0-0.5 0.224-0.5 0.5s0.224 0.5 0.5 0.5c-0.276 0-0.5 0.224-0.5 0.5s0.224 0.5 0.5 0.5c-0.276 0-0.5 0.224-0.5 0.5s0.224 0.5 0.5 0.5h0.41c0.342 0.55 0.915 0.929 1.581 0.999 0.684-0.071 1.258-0.449 1.594-0.99l0.415-0.009c0.276 0 0.5-0.224 0.5-0.5s-0.224-0.5-0.5-0.5c0.276 0 0.5-0.224 0.5-0.5s-0.224-0.5-0.5-0.5c0.276 0 0.5-0.224 0.5-0.5s-0.224-0.5-0.5-0.5c0.276 0 0.5-0.224 0.5-0.5s-0.224-0.5-0.5-0.5l0.8-2c1.322-0.862 2.187-2.328 2.2-3.998 0-2.763-2.239-5.002-5-5.002zM10.25 8.21l-0.25 0.17-0.11 0.29-0.89 2.14c-0.042 0.111-0.147 0.189-0.27 0.19h-1.51c-0.103-0.020-0.186-0.093-0.219-0.188l-0.871-2.142-0.13-0.29-0.25-0.18c-1.045-0.7-1.729-1.868-1.75-3.197-0-2.212 1.791-4.003 4-4.003s4 1.791 4 4c-0.017 1.336-0.702 2.509-1.736 3.201z"></path><path d="M10.29 3c-0.574-0.612-1.387-0.995-2.289-1l-0.001 1c0.585 0.002 1.115 0.238 1.5 0.62 0.278 0.386 0.459 0.858 0.499 1.37l1.001 0.009c-0.045-0.756-0.305-1.443-0.718-2.011z"></path></g>
<g id="vaadin:line-bar-chart"><path d="M5 11h3v5h-3v-5z"></path><path d="M1 14h3v2h-3v-2z"></path><path d="M13 12h3v4h-3v-4z"></path><path d="M9 9h3v7h-3v-7z"></path><path d="M16 0.070l-5.68 4.97-5.47-1.7-4.85 3.76v1.9l5.15-4 5.53 1.72 5.32-4.66v-1.99z"></path></g>
<g id="vaadin:line-chart"><path d="M1 15v-15h-1v16h16v-1h-15z"></path><path d="M9 8l-3-3-4 4v2l4-4 3 3 7-7v-2z"></path></g>
<g id="vaadin:line-h"><path d="M0 7h16v1h-16v-1z"></path></g>
<g id="vaadin:line-v"><path d="M8 0h1v16h-1v-16z"></path></g>
<g id="vaadin:lines-list"><path d="M0 1h3v2h-3v-2z"></path><path d="M0 5h3v2h-3v-2z"></path><path d="M0 9h3v2h-3v-2z"></path><path d="M0 13h3v2h-3v-2z"></path><path d="M4 1h12v2h-12v-2z"></path><path d="M4 5h12v2h-12v-2z"></path><path d="M4 9h12v2h-12v-2z"></path><path d="M4 13h12v2h-12v-2z"></path></g>
<g id="vaadin:lines"><path d="M0 1h16v2h-16v-2z"></path><path d="M0 5h16v2h-16v-2z"></path><path d="M0 9h16v2h-16v-2z"></path><path d="M0 13h16v2h-16v-2z"></path></g>
<g id="vaadin:link"><path d="M14.9 1.1c-1.4-1.4-3.7-1.4-5.1 0l-4.4 4.3c-1.4 1.5-1.4 3.7 0 5.2 0.1 0.1 0.3 0.2 0.4 0.3l1.5-1.5c-0.1-0.1-0.3-0.2-0.4-0.3-0.6-0.6-0.6-1.6 0-2.2l4.4-4.4c0.6-0.6 1.6-0.6 2.2 0s0.6 1.6 0 2.2l-1.3 1.3c0.4 0.8 0.5 1.7 0.4 2.5l2.3-2.3c1.5-1.4 1.5-3.7 0-5.1z"></path><path d="M10.2 5.1l-1.5 1.5c0 0 0.3 0.2 0.4 0.3 0.6 0.6 0.6 1.6 0 2.2l-4.4 4.4c-0.6 0.6-1.6 0.6-2.2 0s-0.6-1.6 0-2.2l1.3-1.3c-0.4-0.8-0.1-1.3-0.4-2.5l-2.3 2.3c-1.4 1.4-1.4 3.7 0 5.1s3.7 1.4 5.1 0l4.4-4.4c1.4-1.4 1.4-3.7 0-5.1-0.2-0.1-0.4-0.3-0.4-0.3z"></path></g>
<g id="vaadin:list-ol"><path d="M4 0h12v4h-12v-4z"></path><path d="M4 6h12v4h-12v-4z"></path><path d="M4 12h12v4h-12v-4z"></path><path d="M1 0l-0.9 0.5 0.2 0.7 0.7-0.3v3.1h1v-4z"></path><path d="M2.2 13.9c0.3-0.2 0.5-0.5 0.5-0.8 0-0.5-0.4-1-1.3-1-0.5 0-1 0.1-1.2 0.3h-0.1l0.2 0.8 0.1-0.1c0.1-0.1 0.4-0.2 0.7-0.2s0.4 0.1 0.4 0.3c0 0.4-0.5 0.4-0.6 0.4h-0.4v0.7h0.4c0.3 0 0.6 0.1 0.6 0.4 0 0.2-0.2 0.4-0.6 0.4s-0.7-0.2-0.8-0.2l-0.1-0.1v0.9h0.1c0.2 0.2 0.6 0.3 1.1 0.3 1 0 1.6-0.5 1.6-1.2 0-0.4-0.2-0.8-0.6-0.9z"></path><path d="M0.1 6.4l0.3 1c0 0 0.7-0.6 1.2-0.3 1.1 0.8-1.6 2.4-1.6 2.4v0.5h3v-1h-1.2c0.6-0.5 1.2-1.2 1-1.9-0.5-1.9-2.7-0.7-2.7-0.7z"></path></g>
<g id="vaadin:list-select"><path d="M1 0h12v2h-12v-2z"></path><path d="M1 8h13v2h-13v-2z"></path><path d="M1 11h11v2h-11v-2z"></path><path d="M1 14h14v2h-14v-2z"></path><path d="M0 3v4h16v-4h-16zM11 6h-10v-2h10v2z"></path></g>
<g id="vaadin:list-ul"><path d="M0 1h3v3h-3v-3z"></path><path d="M0 6h3v3h-3v-3z"></path><path d="M0 11h3v3h-3v-3z"></path><path d="M5 1h11v3h-11v-3z"></path><path d="M5 6h11v3h-11v-3z"></path><path d="M5 11h11v3h-11v-3z"></path></g>
<g id="vaadin:list"><path d="M0 0h4v3h-4v-3z"></path><path d="M0 4h4v3h-4v-3z"></path><path d="M0 12h4v3h-4v-3z"></path><path d="M0 8h4v3h-4v-3z"></path><path d="M5 0h11v3h-11v-3z"></path><path d="M5 4h11v3h-11v-3z"></path><path d="M5 12h11v3h-11v-3z"></path><path d="M5 8h11v3h-11v-3z"></path></g>
<g id="vaadin:location-arrow-circle-o"><path d="M1 8c0-3.9 3.1-7 7-7s7 3.1 7 7-3.1 7-7 7-7-3.1-7-7zM0 8c0 4.4 3.6 8 8 8s8-3.6 8-8-3.6-8-8-8-8 3.6-8 8v0z"></path><path d="M2 9l10-5-5 10v-5z"></path></g>
<g id="vaadin:location-arrow-circle"><path d="M8 0c-4.4 0-8 3.6-8 8s3.6 8 8 8 8-3.6 8-8-3.6-8-8-8zM7 14v-5h-5l10-5-5 10z"></path></g>
<g id="vaadin:location-arrow"><path d="M0 9l16-9-9 16v-7z"></path></g>
<g id="vaadin:lock"><path d="M12 8v-3.1c0-2.2-1.6-3.9-3.8-3.9h-0.3c-2.1 0-3.9 1.7-3.9 3.9v3.1h-1l0.1 5c0 0-0.1 3 4.9 3s5-3 5-3v-5h-1zM9 14h-1v-2c-0.6 0-1-0.4-1-1s0.4-1 1-1 1 0.4 1 1v3zM10 8h-4v-3.1c0-1.1 0.9-1.9 1.9-1.9h0.3c1 0 1.8 0.8 1.8 1.9v3.1z"></path></g>
<g id="vaadin:magic"><path d="M0 5h3v1h-3v-1z"></path><path d="M5 0h1v3h-1v-3z"></path><path d="M6 11h-1v-2.5l1 1z"></path><path d="M11 6h-1.5l-1-1h2.5z"></path><path d="M3.131 7.161l0.707 0.707-2.97 2.97-0.707-0.707 2.97-2.97z"></path><path d="M10.131 0.161l0.707 0.707-2.97 2.97-0.707-0.707 2.97-2.97z"></path><path d="M0.836 0.199l3.465 3.465-0.707 0.707-3.465-3.465 0.707-0.707z"></path><path d="M6.1 4.1l-2.1 2 9.8 9.9 2.2-2.1-9.9-9.8zM6.1 5.5l2.4 2.5-0.6 0.6-2.5-2.5 0.7-0.6z"></path></g>
<g id="vaadin:magnet"><path d="M11 0h5v4h-5v-4z"></path><path d="M11 5v3c0 1.6-1.4 3-3 3s-3-1.4-3-3v-3h-5v3c0 4.4 3.6 8 8 8s8-3.6 8-8v-3h-5z"></path><path d="M0 0h5v4h-5v-4z"></path></g>
<g id="vaadin:mailbox"><path d="M13 1h-10l-3 9v5h16v-5l-3-9zM11 10v2h-6v-2h-3.9l2.7-8h8.6l2.7 8h-4.1z"></path></g>
<g id="vaadin:male"><path d="M10 2c0 1.105-0.895 2-2 2s-2-0.895-2-2c0-1.105 0.895-2 2-2s2 0.895 2 2z"></path><path d="M12.79 7.32l-2.6-2.63c-0.421-0.426-1.004-0.69-1.65-0.69h-1.070c-0 0-0 0-0.001 0-0.648 0-1.235 0.264-1.659 0.69l-2.6 2.63c-0.216 0.129-0.358 0.362-0.358 0.628 0 0.403 0.327 0.73 0.73 0.73 0.266 0 0.499-0.142 0.626-0.355l1.792-1.793v9.47h1.5v-5h1v5h1.5v-9.47l1.75 1.8c0.135 0.175 0.344 0.287 0.58 0.287 0.403 0 0.73-0.327 0.73-0.73 0-0.228-0.105-0.432-0.269-0.566z"></path></g>
<g id="vaadin:map-marker"><path d="M8 0c-2.8 0-5 2.2-5 5s4 11 5 11c1 0 5-8.2 5-11s-2.2-5-5-5zM8 8c-1.7 0-3-1.3-3-3s1.3-3 3-3 3 1.3 3 3-1.3 3-3 3z"></path></g>
<g id="vaadin:margin-bottom"><path d="M0 0v14h1v-1h1v1h1v-1h1v1h1v-1h1v1h1v-1h1v1h1v-1h1v1h1v-1h1v1h1v-1h1v1h1v-1h1v-13h-16zM15 12h-14v-11h14v11z"></path><path d="M0 15h1v1h-1v-1z"></path><path d="M1 14h1v1h-1v-1z"></path><path d="M2 15h1v1h-1v-1z"></path><path d="M3 14h1v1h-1v-1z"></path><path d="M4 15h1v1h-1v-1z"></path><path d="M5 14h1v1h-1v-1z"></path><path d="M6 15h1v1h-1v-1z"></path><path d="M7 14h1v1h-1v-1z"></path><path d="M8 15h1v1h-1v-1z"></path><path d="M9 14h1v1h-1v-1z"></path><path d="M10 15h1v1h-1v-1z"></path><path d="M11 14h1v1h-1v-1z"></path><path d="M12 15h1v1h-1v-1z"></path><path d="M13 14h1v1h-1v-1z"></path><path d="M14 15h1v1h-1v-1z"></path><path d="M15 14h1v1h-1v-1z"></path></g>
<g id="vaadin:margin-left"><path d="M2 0v1h1v1h-1v1h1v1h-1v1h1v1h-1v1h1v1h-1v1h1v1h-1v1h1v1h-1v1h1v1h-1v1h1v1h13v-16h-14zM15 15h-11v-14h11v14z"></path><path d="M0 0h1v1h-1v-1z"></path><path d="M1 1h1v1h-1v-1z"></path><path d="M0 2h1v1h-1v-1z"></path><path d="M1 3h1v1h-1v-1z"></path><path d="M0 4h1v1h-1v-1z"></path><path d="M1 5h1v1h-1v-1z"></path><path d="M0 6h1v1h-1v-1z"></path><path d="M1 7h1v1h-1v-1z"></path><path d="M0 8h1v1h-1v-1z"></path><path d="M1 9h1v1h-1v-1z"></path><path d="M0 10h1v1h-1v-1z"></path><path d="M1 11h1v1h-1v-1z"></path><path d="M0 12h1v1h-1v-1z"></path><path d="M1 13h1v1h-1v-1z"></path><path d="M0 14h1v1h-1v-1z"></path><path d="M1 15h1v1h-1v-1z"></path></g>
<g id="vaadin:margin-right"><path d="M14 2v-1h-1v-1h-13v16h14v-1h-1v-1h1v-1h-1v-1h1v-1h-1v-1h1v-1h-1v-1h1v-1h-1v-1h1v-1h-1v-1h1v-1h-1v-1h1zM12 15h-11v-14h11v14z"></path><path d="M15 15h1v1h-1v-1z"></path><path d="M14 14h1v1h-1v-1z"></path><path d="M15 13h1v1h-1v-1z"></path><path d="M14 12h1v1h-1v-1z"></path><path d="M15 11h1v1h-1v-1z"></path><path d="M14 10h1v1h-1v-1z"></path><path d="M15 9h1v1h-1v-1z"></path><path d="M14 8h1v1h-1v-1z"></path><path d="M15 7h1v1h-1v-1z"></path><path d="M14 6h1v1h-1v-1z"></path><path d="M15 5h1v1h-1v-1z"></path><path d="M14 4h1v1h-1v-1z"></path><path d="M15 3h1v1h-1v-1z"></path><path d="M14 2h1v1h-1v-1z"></path><path d="M15 1h1v1h-1v-1z"></path><path d="M14 0h1v1h-1v-1z"></path></g>
<g id="vaadin:margin-top"><path d="M15 2v1h-1v-1h-1v1h-1v-1h-1v1h-1v-1h-1v1h-1v-1h-1v1h-1v-1h-1v1h-1v-1h-1v1h-1v-1h-1v1h-1v13h16v-14h-1zM15 15h-14v-11h14v11z"></path><path d="M15 0h1v1h-1v-1z"></path><path d="M14 1h1v1h-1v-1z"></path><path d="M13 0h1v1h-1v-1z"></path><path d="M12 1h1v1h-1v-1z"></path><path d="M11 0h1v1h-1v-1z"></path><path d="M10 1h1v1h-1v-1z"></path><path d="M9 0h1v1h-1v-1z"></path><path d="M8 1h1v1h-1v-1z"></path><path d="M7 0h1v1h-1v-1z"></path><path d="M6 1h1v1h-1v-1z"></path><path d="M5 0h1v1h-1v-1z"></path><path d="M4 1h1v1h-1v-1z"></path><path d="M3 0h1v1h-1v-1z"></path><path d="M2 1h1v1h-1v-1z"></path><path d="M1 0h1v1h-1v-1z"></path><path d="M0 1h1v1h-1v-1z"></path></g>
<g id="vaadin:margin"><path d="M0 0h1v1h-1v-1z"></path><path d="M2 0h1v1h-1v-1z"></path><path d="M1 1h1v1h-1v-1z"></path><path d="M0 2h1v1h-1v-1z"></path><path d="M2 2h1v1h-1v-1z"></path><path d="M1 3h1v1h-1v-1z"></path><path d="M0 4h1v1h-1v-1z"></path><path d="M1 5h1v1h-1v-1z"></path><path d="M0 6h1v1h-1v-1z"></path><path d="M1 7h1v1h-1v-1z"></path><path d="M0 8h1v1h-1v-1z"></path><path d="M1 9h1v1h-1v-1z"></path><path d="M0 10h1v1h-1v-1z"></path><path d="M1 11h1v1h-1v-1z"></path><path d="M0 12h1v1h-1v-1z"></path><path d="M1 13h1v1h-1v-1z"></path><path d="M0 14h1v1h-1v-1z"></path><path d="M2 14h1v1h-1v-1z"></path><path d="M1 15h1v1h-1v-1z"></path><path d="M3 15h1v1h-1v-1z"></path><path d="M5 15h1v1h-1v-1z"></path><path d="M4 0h1v1h-1v-1z"></path><path d="M3 1h1v1h-1v-1z"></path><path d="M5 1h1v1h-1v-1z"></path><path d="M4 14h1v1h-1v-1z"></path><path d="M6 0h1v1h-1v-1z"></path><path d="M8 0h1v1h-1v-1z"></path><path d="M7 1h1v1h-1v-1z"></path><path d="M6 14h1v1h-1v-1z"></path><path d="M8 14h1v1h-1v-1z"></path><path d="M7 15h1v1h-1v-1z"></path><path d="M9 15h1v1h-1v-1z"></path><path d="M11 15h1v1h-1v-1z"></path><path d="M10 0h1v1h-1v-1z"></path><path d="M9 1h1v1h-1v-1z"></path><path d="M11 1h1v1h-1v-1z"></path><path d="M10 14h1v1h-1v-1z"></path><path d="M12 0h1v1h-1v-1z"></path><path d="M14 0h1v1h-1v-1z"></path><path d="M13 1h1v1h-1v-1z"></path><path d="M13 2h-1v1h-1v-1h-1v1h-1v-1h-1v1h-1v-1h-1v1h-1v-1h-1v1h-1v1h-1v1h1v1h-1v1h1v1h-1v1h1v1h-1v1h1v1h-1v1h1v1h1v-1h1v1h1v-1h1v1h1v-1h1v1h1v-1h1v1h1v-1h1v-1h1v-1h-1v-1h1v-1h-1v-1h1v-1h-1v-1h1v-1h-1v-1h1v-1h-1v-1zM12 12h-8v-8h8v8z"></path><path d="M14 2h1v1h-1v-1z"></path><path d="M14 4h1v1h-1v-1z"></path><path d="M14 6h1v1h-1v-1z"></path><path d="M14 8h1v1h-1v-1z"></path><path d="M14 10h1v1h-1v-1z"></path><path d="M14 12h1v1h-1v-1z"></path><path d="M13 13h1v1h-1v-1z"></path><path d="M12 14h1v1h-1v-1z"></path><path d="M14 14h1v1h-1v-1z"></path><path d="M13 15h1v1h-1v-1z"></path><path d="M15 15h1v1h-1v-1z"></path><path d="M15 1h1v1h-1v-1z"></path><path d="M15 3h1v1h-1v-1z"></path><path d="M15 5h1v1h-1v-1z"></path><path d="M15 7h1v1h-1v-1z"></path><path d="M15 9h1v1h-1v-1z"></path><path d="M15 11h1v1h-1v-1z"></path><path d="M15 13h1v1h-1v-1z"></path></g>
<g id="vaadin:medal"><path d="M10 12.2c-0.3 0-0.5-0.1-0.8-0.2l-1.2-0.5-1.2 0.5c-0.2 0.1-0.5 0.2-0.8 0.2-0.2 0-0.3 0-0.5-0.1l-0.5 3.9 3-2 3 2-0.6-3.9c-0.1 0.1-0.3 0.1-0.4 0.1z"></path><path d="M12.9 5.9c-0.1-0.2-0.1-0.5 0-0.7l0.6-1.2c0.2-0.4 0-0.9-0.5-1.1l-1.3-0.5c-0.2-0.1-0.4-0.3-0.5-0.5l-0.5-1.3c-0.1-0.4-0.4-0.6-0.7-0.6-0.1 0-0.3 0-0.4 0.1l-1.3 0.6c-0.1 0-0.2 0-0.3 0s-0.2 0-0.3-0.1l-1.3-0.5c-0.1-0.1-0.3-0.1-0.4-0.1-0.3 0-0.6 0.2-0.8 0.5l-0.5 1.4c0 0.2-0.2 0.4-0.4 0.5l-1.4 0.5c-0.4 0.1-0.6 0.6-0.4 1.1l0.6 1.3c0.1 0.2 0.1 0.5 0 0.7l-0.6 1.2c-0.2 0.4 0 0.9 0.5 1.1l1.3 0.5c0.2 0.1 0.4 0.3 0.5 0.5l0.5 1.3c0.1 0.4 0.4 0.6 0.7 0.6 0.1 0 0.2 0 0.3-0.1l1.3-0.6c0.1 0 0.2-0.1 0.3-0.1s0.2 0 0.3 0.1l1.3 0.6c0.1 0.1 0.2 0.1 0.3 0.1 0.3 0 0.6-0.2 0.8-0.5l0.5-1.3c0.1-0.2 0.3-0.4 0.5-0.5l1.3-0.5c0.4-0.2 0.7-0.7 0.5-1.1l-0.5-1.4zM8 9.6c-2.2 0-4-1.8-4-4s1.8-4 4-4 4 1.8 4 4c0 2.2-1.8 4-4 4z"></path><path d="M11 5.6c0 1.657-1.343 3-3 3s-3-1.343-3-3c0-1.657 1.343-3 3-3s3 1.343 3 3z"></path></g>
<g id="vaadin:megaphone"><path d="M15.5 5.4l-0.5-0.4v-4c0-0.6-0.4-1-1-1s-1 0.4-1 1v0.5c-2 0.9-5 2.5-8 2.5h-2.5c-1.4 0-2.5 1.2-2.5 2.5 0 0.9 0.5 1.7 1.2 2.1l1.1 5.9c0 0.3 0.3 0.5 0.7 0.5 0.1 0 0.1 0 0.2 0l3.6-0.7c0.4-0.1 0.6-0.4 0.5-0.7-0.3-0.6-0.8-1.5-1.2-1.8-0.2-0.1-0.5-0.9-0.7-1.8h0.6v-0.9c2.7 0.3 6 1.6 7 2.4v0.5c0 0.6 0.4 1 1 1s1-0.4 1-1v-4l0.4-0.3c0.4-0.3 0.6-0.7 0.6-1.1v-0.2c0-0.4-0.2-0.7-0.5-1zM2 5h3v1h-3v-1zM5.6 12.6c0.1 0 0.3 0.3 0.5 0.7l-2.8 0.7-1-5h1.9c0.2 1.3 0.6 3.2 1.4 3.6zM13 10.3c-1.6-0.8-4.4-2-7-2.3v-3c2.6-0.3 5.4-1.4 7-2.3v7.6z"></path></g>
<g id="vaadin:meh-o"><path d="M8 1c3.9 0 7 3.1 7 7s-3.1 7-7 7-7-3.1-7-7 3.1-7 7-7zM8 0c-4.4 0-8 3.6-8 8s3.6 8 8 8 8-3.6 8-8-3.6-8-8-8v0z"></path><path d="M7 6c0 0.552-0.448 1-1 1s-1-0.448-1-1c0-0.552 0.448-1 1-1s1 0.448 1 1z"></path><path d="M11 6c0 0.552-0.448 1-1 1s-1-0.448-1-1c0-0.552 0.448-1 1-1s1 0.448 1 1z"></path><path d="M4 10h8v1h-8v-1z"></path></g>
<g id="vaadin:menu"><path d="M0 1h16v3h-16v-3z"></path><path d="M0 6h16v3h-16v-3z"></path><path d="M0 11h16v3h-16v-3z"></path></g>
<g id="vaadin:microphone"><path d="M8 10v0c-1.7 0-3-1.3-3-3v-4c0-1.6 1.3-3 3-3v0c1.6 0 3 1.3 3 3v4c0 1.6-1.4 3-3 3z"></path><path d="M12 5v2.5c0 1.9-1.8 3.5-3.8 3.5h-0.4c-2 0-3.8-1.6-3.8-3.5v-2.5c-0.6 0-1 0.4-1 1v1.5c0 2.2 1.8 4.1 4 4.4v2.1c-3 0-2.5 2-2.5 2h7c0 0 0.5-2-2.5-2v-2.1c2.2-0.4 4-2.2 4-4.4v-1.5c0-0.6-0.4-1-1-1z"></path></g>
<g id="vaadin:minus-circle-o"><path d="M8 1c3.9 0 7 3.1 7 7s-3.1 7-7 7-7-3.1-7-7 3.1-7 7-7zM8 0c-4.4 0-8 3.6-8 8s3.6 8 8 8 8-3.6 8-8-3.6-8-8-8v0z"></path><path d="M3 7h10v2h-10v-2z"></path></g>
<g id="vaadin:minus-circle"><path d="M8 0c-4.4 0-8 3.6-8 8s3.6 8 8 8 8-3.6 8-8-3.6-8-8-8zM13 9h-10v-2h10v2z"></path></g>
<g id="vaadin:minus-square-o"><path d="M4 7h8v2h-8v-2z"></path><path d="M15 1h-14v14h14v-14zM14 14h-12v-12h12v12z"></path></g>
<g id="vaadin:minus"><path d="M2 7h12v2h-12v-2z"></path></g>
<g id="vaadin:mobile-browser"><path d="M16 0h-13v5h-3v11h7v-3h9v-13zM6 1h9v1h-9v-1zM4 1h1v1h-1v-1zM4 15h-1v-1h1v1zM6 13h-5v-7h5v7zM15 12h-8v-7h-3v-2h11v9z"></path></g>
<g id="vaadin:mobile-retro"><path d="M11 0h-1v2h-6v14h7v-16zM6 14h-1v-1h1v1zM6 12h-1v-1h1v1zM6 10h-1v-1h1v1zM8 14h-1v-1h1v1zM8 12h-1v-1h1v1zM8 10h-1v-1h1v1zM10 14h-1v-1h1v1zM10 12h-1v-1h1v1zM10 10h-1v-1h1v1zM10 8h-5v-4h5v4z"></path></g>
<g id="vaadin:mobile"><path d="M4 1v14h8v-14h-8zM9 14h-2v-1h2v1zM11 12h-6v-9h6v9z"></path></g>
<g id="vaadin:modal-list"><path d="M3 6h2v1h-2v-1z"></path><path d="M6 6h7v1h-7v-1z"></path><path d="M3 8h2v1h-2v-1z"></path><path d="M6 8h7v1h-7v-1z"></path><path d="M3 10h2v1h-2v-1z"></path><path d="M6 10h7v1h-7v-1z"></path><path d="M0 1v14h16v-14h-16zM15 14h-14v-10h14v10zM15 3h-1v-1h1v1z"></path></g>
<g id="vaadin:modal"><path d="M0 1v14h16v-14h-16zM15 14h-14v-10h14v10zM15 3h-1v-1h1v1z"></path></g>
<g id="vaadin:money-deposit"><path d="M8 16l-2-3h1v-2h2v2h1l-2 3z"></path><path d="M15 1v8h-14v-8h14zM16 0h-16v10h16v-10z"></path><path d="M8 2c1.657 0 3 1.343 3 3s-1.343 3-3 3h5v-1h1v-4h-1v-1h-5z"></path><path d="M5 5c0-1.657 1.343-3 3-3h-5v1h-1v4h1v1h5c-1.657 0-3-1.343-3-3z"></path></g>
<g id="vaadin:money-exchange"><path d="M16 14l-3 2v-1h-4.75l2-2h2.75v-1l3 2z"></path><path d="M0 2l3-2v1h4.75l-2 2h-2.75v1l-3-2z"></path><path d="M9.74 0l-9.74 9.74 6.26 6.26 9.74-9.74zM1.39 9.74l8.35-8.35 4.87 4.87-8.35 8.35z"></path><path d="M4.17 9.74l-0.7 0.7 2.090 2.090 0.7-0.7 0.74 0.69 2.74-2.78c-0.445 0.445-1.060 0.721-1.74 0.721-1.359 0-2.461-1.102-2.461-2.461 0-0.68 0.275-1.295 0.721-1.74l-2.78 2.74z"></path><path d="M12.52 5.57l-2.090-2.090-0.7 0.7-0.73-0.7-2.74 2.78c0.445-0.445 1.060-0.721 1.74-0.721 1.359 0 2.461 1.102 2.461 2.461 0 0.68-0.275 1.295-0.721 1.74l2.78-2.74-0.7-0.7z"></path></g>
<g id="vaadin:money-withdraw"><path d="M8 0l2 3h-1v2h-2v-2h-1l2-3z"></path><path d="M15 7v8h-14v-8h14zM16 6h-16v10h16v-10z"></path><path d="M8 8c1.657 0 3 1.343 3 3s-1.343 3-3 3h5v-1h1v-4h-1v-1h-5z"></path><path d="M5 11c0-1.657 1.343-3 3-3h-5v1h-1v4h1v1h5c-1.657 0-3-1.343-3-3z"></path></g>
<g id="vaadin:money"><path d="M15 4v8h-14v-8h14zM16 3h-16v10h16v-10z"></path><path d="M8 5c1.7 0 3 1.3 3 3s-1.3 3-3 3h5v-1h1v-4h-1v-1h-5z"></path><path d="M5 8c0-1.7 1.3-3 3-3h-5v1h-1v4h1v1h5c-1.7 0-3-1.3-3-3z"></path></g>
<g id="vaadin:moon-o"><path d="M13.2 11.9c-4.5 0-8.1-3.6-8.1-8.1 0-1.4 0.3-2.7 0.9-3.8-3.4 0.9-6 4.1-6 7.9 0 4.5 3.6 8.1 8.1 8.1 3.1 0 5.8-1.8 7.2-4.4-0.6 0.2-1.3 0.3-2.1 0.3zM8.1 15c-3.9 0-7.1-3.2-7.1-7.1 0-2.5 1.3-4.7 3.3-6-0.2 0.6-0.2 1.2-0.2 1.9 0 5 4.1 9.1 9.1 9.2-1.4 1.2-3.2 2-5.1 2z"></path></g>
<g id="vaadin:moon"><path d="M8 0c-4.4 0-8 3.6-8 8s3.6 8 8 8 8-3.6 8-8-3.6-8-8-8zM8 15c-3.9 0-7-3.1-7-7 0-2.4 1.2-4.6 3.2-5.9-0.1 0.6-0.2 1.3-0.2 1.9 0 4.9 4 8.9 8.9 9-1.3 1.3-3 2-4.9 2z"></path></g>
<g id="vaadin:morning"><path d="M14 10l-1.58-1.18 0.78-1.82-2-0.23-0.2-1.97-1.82 0.78-1.18-1.58-1.18 1.58-1.82-0.78-0.23 2-1.97 0.2 0.78 1.82-1.58 1.18h-2v1h16v-1h-2zM4 10c0.075-2.178 1.822-3.925 3.993-4 2.185 0.075 3.932 1.821 4.007 3.993l-8 0.007z"></path></g>
<g id="vaadin:movie"><path d="M12 7v-3h-12v9h12v-3l4 2v-7l-4 2zM9 11h-7v-5h7v5z"></path><path d="M5 8.4c0 0.552-0.448 1-1 1s-1-0.448-1-1c0-0.552 0.448-1 1-1s1 0.448 1 1z"></path><path d="M8 8.4c0 0.552-0.448 1-1 1s-1-0.448-1-1c0-0.552 0.448-1 1-1s1 0.448 1 1z"></path></g>
<g id="vaadin:music"><path d="M4 3v9.4c-0.4-0.2-0.9-0.4-1.5-0.4-1.4 0-2.5 0.9-2.5 2s1.1 2 2.5 2 2.5-0.9 2.5-2v-7.3l7-2.3v5.1c-0.4-0.3-0.9-0.5-1.5-0.5-1.4 0-2.5 0.9-2.5 2s1.1 2 2.5 2 2.5-0.9 2.5-2v-11l-9 3z"></path></g>
<g id="vaadin:mute"><path d="M15.2 0l-4.2 4.2v-1.2c0-1.7-1.3-3-3-3s-3 1.3-3 3v4c0 0.9 0.4 1.7 1 2.2l-0.8 0.8c-0.7-0.6-1.2-1.5-1.2-2.5v-2.5c-0.6 0-1 0.4-1 1v1.5c0 1.3 0.6 2.4 1.5 3.2l-4.5 4.6v0.7h0.7l15.3-15.4v-0.6h-0.8z"></path><path d="M12.5 5.1l-0.5 0.5v1.9c0 1.9-1.8 3.5-3.8 3.5h-0.4c-0.3 0-0.6-0.1-0.9-0.1l-0.9 0.7c0.3 0.1 0.6 0.2 1 0.3v2.1c-3 0-2.5 2-2.5 2h7c0 0 0.5-2-2.5-2v-2.1c2.2-0.4 4-2.2 4-4.4v-1.5c0-0.4-0.2-0.7-0.5-0.9z"></path><path d="M11 7v-0.4l-3.3 3.4c0.1 0 0.2 0 0.3 0 1.7 0 3-1.4 3-3z"></path></g>
<g id="vaadin:native-button"><path d="M15 12h-14c-0.6 0-1-0.4-1-1v-6c0-0.6 0.4-1 1-1h14c0.6 0 1 0.4 1 1v6c0 0.6-0.4 1-1 1z"></path></g>
<g id="vaadin:newspaper"><path d="M2 4h11v4h-11v-4z"></path><path d="M2 2h11v1h-11v-1z"></path><path d="M8 13h3v1h-3v-1z"></path><path d="M8 11h5v1h-5v-1z"></path><path d="M8 9h5v1h-5v-1z"></path><path d="M2 13h5v1h-5v-1z"></path><path d="M2 11h5v1h-5v-1z"></path><path d="M2 9h5v1h-5v-1z"></path><path d="M15 2v-2h-15v14.5c0 0.828 0.672 1.5 1.5 1.5h13c0.828 0 1.5-0.672 1.5-1.5v-12.5h-1zM1.5 15c-0.276 0-0.5-0.224-0.5-0.5v-13.5h13v12.5c0 1.5 1 1.5 1 1.5h-13.5z"></path></g>
<g id="vaadin:notebook"><path d="M2 0v1h-0.52c-0.265 0-0.48 0.215-0.48 0.48v0c-0.001 0.012-0.002 0.026-0.002 0.040 0 0.265 0.215 0.48 0.48 0.48 0.001 0 0.001 0 0.002 0h0.52v1h-0.52c-0.265 0-0.48 0.215-0.48 0.48v0c-0.001 0.012-0.002 0.026-0.002 0.040 0 0.265 0.215 0.48 0.48 0.48 0.001 0 0.001 0 0.002 0h0.52v1h-0.52c-0.265 0-0.48 0.215-0.48 0.48 0 0 0 0 0 0v0c-0.001 0.012-0.002 0.026-0.002 0.040 0 0.265 0.215 0.48 0.48 0.48 0.001 0 0.001 0 0.002 0h0.52v1h-0.52c-0.265 0-0.48 0.215-0.48 0.48 0 0 0 0 0 0v0c-0.001 0.012-0.002 0.026-0.002 0.040 0 0.265 0.215 0.48 0.48 0.48 0.001 0 0.001 0 0.002 0h0.52v1h-0.52c-0.265 0-0.48 0.215-0.48 0.48 0 0 0 0 0 0v0c0 0.265 0.215 0.48 0.48 0.48 0 0 0 0 0 0h0.52v1h-0.52c-0.265 0-0.48 0.215-0.48 0.48 0 0 0 0 0 0v0c0 0.265 0.215 0.48 0.48 0.48 0 0 0 0 0 0h0.52v1h-0.52c-0.265 0-0.48 0.215-0.48 0.48 0 0 0 0 0 0v0c0 0.265 0.215 0.48 0.48 0.48 0 0 0 0 0 0h0.52v2h12v-15.88h-12zM3.5 14c-0.276 0-0.5-0.224-0.5-0.5s0.224-0.5 0.5-0.5c0.276 0 0.5 0.224 0.5 0.5s-0.224 0.5-0.5 0.5zM3.5 12c-0.276 0-0.5-0.224-0.5-0.5s0.224-0.5 0.5-0.5c0.276 0 0.5 0.224 0.5 0.5s-0.224 0.5-0.5 0.5zM3.5 10c-0.276 0-0.5-0.224-0.5-0.5s0.224-0.5 0.5-0.5c0.276 0 0.5 0.224 0.5 0.5s-0.224 0.5-0.5 0.5zM3.5 8c-0.276 0-0.5-0.224-0.5-0.5s0.224-0.5 0.5-0.5c0.276 0 0.5 0.224 0.5 0.5s-0.224 0.5-0.5 0.5zM3.5 6c-0.276 0-0.5-0.224-0.5-0.5s0.224-0.5 0.5-0.5c0.276 0 0.5 0.224 0.5 0.5s-0.224 0.5-0.5 0.5zM3.5 4c-0.276 0-0.5-0.224-0.5-0.5s0.224-0.5 0.5-0.5c0.276 0 0.5 0.224 0.5 0.5s-0.224 0.5-0.5 0.5zM3.5 2c-0.276 0-0.5-0.224-0.5-0.5s0.224-0.5 0.5-0.5c0.276 0 0.5 0.224 0.5 0.5s-0.224 0.5-0.5 0.5zM12 6h-6v-3h6v3z"></path></g>
<g id="vaadin:nurse"><path d="M15.2 12c-0.658-1.414-2.067-2.376-3.701-2.376-0.077 0-0.154 0.002-0.23 0.006l-3.269 3.9-3.28-3.9c-0.049-0.002-0.106-0.003-0.163-0.003-1.648 0-3.072 0.958-3.746 2.348-0.422 0.9-0.707 1.917-0.808 2.988l1.997 0.037v1h12v-1h2c-0.104-1.107-0.388-2.124-0.824-3.057z"></path><path d="M6.57 8.73c-0.038 0.374-0.322 0.671-0.685 0.729l2.115 2.541 2.12-2.52c-0.368-0.059-0.652-0.356-0.69-0.727-0-0.613 0.8-0.413 1.43-1.453 0-0.030 2.88-7.3-2.86-7.3s-2.86 7.27-2.86 7.27c0.63 1.050 1.44 0.85 1.43 1.46z"></path></g>
<g id="vaadin:office"><path d="M14 15v-11h-3v-3h-9v14h-2v1h7v-3h2v3h7v-1h-2zM6 11h-2v-2h2v2zM6 8h-2v-2h2v2zM6 5h-2v-2h2v2zM9 11h-2v-2h2v2zM9 8h-2v-2h2v2zM9 5h-2v-2h2v2zM13 11h-2v-2h2v2zM13 8h-2v-2h2v2z"></path></g>
<g id="vaadin:open-book"><path d="M15 4.7v-0.7c-1.159-1.163-2.734-1.91-4.484-1.999-0.112-0.012-0.222-0.018-0.334-0.018-0.874 0-1.657 0.394-2.179 1.013-0.556-0.617-1.357-1.007-2.249-1.007-0.090 0-0.178 0.004-0.266 0.012-1.754 0.089-3.33 0.836-4.488 1.999l-0 0.7-1 0.3v10l6.7-1.4 0.3 0.4h2l0.3-0.4 6.7 1.4v-10zM5.48 11.31c-1.275 0.037-2.467 0.358-3.526 0.902l0.046-7.792c0.885-0.835 2.066-1.365 3.369-1.42 0.806 0.054 1.534 0.303 2.159 0.701l-0.019 7.869c-0.555-0.166-1.193-0.262-1.854-0.262-0.062 0-0.124 0.001-0.185 0.003zM14 12.19c-1.013-0.522-2.205-0.843-3.468-0.88-0.056-0.001-0.108-0.002-0.161-0.002-0.66 0-1.297 0.096-1.899 0.274l0.047-7.902c0.601-0.381 1.322-0.627 2.096-0.679 1.324 0.055 2.501 0.586 3.386 1.422l-0.003 7.768z"></path></g>
<g id="vaadin:option-a"><path d="M12.5 10h-1.5v-4h1.5c1.381 0 2.5-1.119 2.5-2.5s-1.119-2.5-2.5-2.5c-1.381 0-2.5 1.119-2.5 2.5v1.5h-4v-1.5c0-1.381-1.119-2.5-2.5-2.5s-2.5 1.119-2.5 2.5c0 1.381 1.119 2.5 2.5 2.5h1.5v4h-1.5c-1.381 0-2.5 1.119-2.5 2.5s1.119 2.5 2.5 2.5c1.381 0 2.5-1.119 2.5-2.5v-1.5h4v1.5c0 1.381 1.119 2.5 2.5 2.5s2.5-1.119 2.5-2.5c0-1.381-1.119-2.5-2.5-2.5zM11 3.5c0-0.828 0.672-1.5 1.5-1.5s1.5 0.672 1.5 1.5c0 0.828-0.672 1.5-1.5 1.5h-1.5v-1.5zM5 12.5c0 0.828-0.672 1.5-1.5 1.5s-1.5-0.672-1.5-1.5c0-0.828 0.672-1.5 1.5-1.5h1.5v1.5zM5 5h-1.5c-0.828 0-1.5-0.672-1.5-1.5s0.672-1.5 1.5-1.5c0.828 0 1.5 0.672 1.5 1.5v1.5zM10 10h-4v-4h4v4zM12.5 14c-0.828 0-1.5-0.672-1.5-1.5v-1.5h1.5c0.828 0 1.5 0.672 1.5 1.5s-0.672 1.5-1.5 1.5z"></path></g>
<g id="vaadin:option"><path d="M4 11c0 0.552 0.448 1 1 1s1-0.448 1-1v-1h-1c-0.552 0-1 0.448-1 1z"></path><path d="M0 0v16h16v-16h-16zM11 9c1.105 0 2 0.895 2 2s-0.895 2-2 2c-1.105 0-2-0.895-2-2v-1h-2v1c0 1.105-0.895 2-2 2s-2-0.895-2-2c0-1.105 0.895-2 2-2h1v-2h-1c-1.105 0-2-0.895-2-2s0.895-2 2-2c1.105 0 2 0.895 2 2v1h2v-1c0-1.105 0.895-2 2-2s2 0.895 2 2c0 1.105-0.895 2-2 2h-1v2h1z"></path><path d="M12 5c0-0.552-0.448-1-1-1s-1 0.448-1 1v1h1c0.552 0 1-0.448 1-1z"></path><path d="M5 4c-0.552 0-1 0.448-1 1s0.448 1 1 1h1v-1c0-0.552-0.448-1-1-1z"></path><path d="M7 7h2v2h-2v-2z"></path><path d="M10 11c0 0.552 0.448 1 1 1s1-0.448 1-1c0-0.552-0.448-1-1-1h-1v1z"></path></g>
<g id="vaadin:options"><path d="M5 3.5c0 0.828-0.672 1.5-1.5 1.5s-1.5-0.672-1.5-1.5c0-0.828 0.672-1.5 1.5-1.5s1.5 0.672 1.5 1.5z"></path><path d="M3.5 0c-1.9 0-3.5 1.6-3.5 3.5s1.6 3.5 3.5 3.5 3.5-1.6 3.5-3.5-1.6-3.5-3.5-3.5zM3.5 6c-1.4 0-2.5-1.1-2.5-2.5s1.1-2.5 2.5-2.5 2.5 1.1 2.5 2.5c0 1.4-1.1 2.5-2.5 2.5z"></path><path d="M3.5 8c-1.9 0-3.5 1.6-3.5 3.5s1.6 3.5 3.5 3.5 3.5-1.6 3.5-3.5c0-1.9-1.6-3.5-3.5-3.5zM3.5 14c-1.4 0-2.5-1.1-2.5-2.5s1.1-2.5 2.5-2.5 2.5 1.1 2.5 2.5c0 1.4-1.1 2.5-2.5 2.5z"></path><path d="M8 2h8v3h-8v-3z"></path><path d="M8 10h8v3h-8v-3z"></path></g>
<g id="vaadin:orientation"><path d="M11 2.1c2 0 3 1.3 3 2.9h-1l1.5 2 1.5-2h-1c0-2.2-2-3.9-4-3.9v-1.1l-2 1.5 2 1.5v-0.9z"></path><path d="M9 9h6v6h-7v-15h-8v16h16v-8h-7v1zM7 8h-1v1h1v6h-6v-14h6v7z"></path><path d="M2 8h1v1h-1v-1z"></path><path d="M4 8h1v1h-1v-1z"></path></g>
<g id="vaadin:out"><path d="M3.5 8c0.3 0 0.5 0.2 0.5 0.5v2c0 0.3-0.2 0.5-0.5 0.5s-0.5-0.2-0.5-0.5v-2c0-0.3 0.2-0.5 0.5-0.5v0zM3.5 7v0c-0.8 0-1.5 0.7-1.5 1.5v2c0 0.8 0.7 1.5 1.5 1.5v0c0.8 0 1.5-0.7 1.5-1.5v-2c0-0.8-0.7-1.5-1.5-1.5v0z"></path><path d="M8 7v3.5c0 0.3-0.2 0.5-0.5 0.5s-0.5-0.2-0.5-0.5v-3.5h-1v3.5c0 0.8 0.7 1.5 1.5 1.5v0c0.8 0 1.5-0.7 1.5-1.5v-3.5h-1z"></path><path d="M13 7h-3v1h1v4h1v-4h1z"></path><path d="M15 6v-1h-2.4l-3.7-3c0.1-0.2 0.1-0.3 0.1-0.5 0-0.8-0.7-1.5-1.5-1.5s-1.5 0.7-1.5 1.5c0 0.2 0 0.3 0.1 0.5l-3.7 3h-2.4v9h1v1h15v-9h-1zM6.7 2.8c0.3 0.1 0.5 0.2 0.8 0.2s0.5-0.1 0.8-0.2l2.7 2.2h-7l2.7-2.2zM14 13h-13v-7h13v7z"></path></g>
<g id="vaadin:outbox"><path d="M6 5v6h4v-6h2l-4-5-4 5z"></path><path d="M13 2h-2l0.9 1h0.4l2.6 8h-3.9v2h-6v-2h-3.9l2.6-8h0.4l0.9-1h-2l-3 9v5h16v-5z"></path></g>
<g id="vaadin:package"><path d="M8 0l-8 2v10l8 4 8-4v-10l-8-2zM8 1l2.1 0.5-5.9 1.9-2.3-0.8 6.1-1.6zM8 14.9l-7-3.5v-8.1l3 1v3.4l1 0.3v-3.3l3 1v9.2zM8.5 4.8l-2.7-0.9 6.2-1.9 2.4 0.6-5.9 2.2z"></path></g>
<g id="vaadin:padding-bottom"><path d="M16 16v-16h-16v16h16zM1 13h1v-1h-1v-11h14v12h-1v1h1v1h-1v-1h-1v1h-1v-1h-1v1h-1v-1h-1v1h-1v-1h-1v1h-1v-1h-1v1h-1v-1h-1v1h-1v-1h-1v-1z"></path><path d="M12 13h1v1h-1v-1z"></path><path d="M13 12h1v1h-1v-1z"></path><path d="M11 12h1v1h-1v-1z"></path><path d="M9 12h1v1h-1v-1z"></path><path d="M10 13h1v1h-1v-1z"></path><path d="M8 13h1v1h-1v-1z"></path><path d="M6 13h1v1h-1v-1z"></path><path d="M7 12h1v1h-1v-1z"></path><path d="M5 12h1v1h-1v-1z"></path><path d="M3 12h1v1h-1v-1z"></path><path d="M4 13h1v1h-1v-1z"></path><path d="M2 13h1v1h-1v-1z"></path></g>
<g id="vaadin:padding-left"><path d="M0 16h16v-16h-16v16zM3 1v1h1v-1h11v14h-12v-1h-1v1h-1v-1h1v-1h-1v-1h1v-1h-1v-1h1v-1h-1v-1h1v-1h-1v-1h1v-1h-1v-1h1v-1h-1v-1h1v-1h1z"></path><path d="M2 12h1v1h-1v-1z"></path><path d="M3 13h1v1h-1v-1z"></path><path d="M3 11h1v1h-1v-1z"></path><path d="M3 9h1v1h-1v-1z"></path><path d="M2 10h1v1h-1v-1z"></path><path d="M2 8h1v1h-1v-1z"></path><path d="M2 6h1v1h-1v-1z"></path><path d="M3 7h1v1h-1v-1z"></path><path d="M3 5h1v1h-1v-1z"></path><path d="M3 3h1v1h-1v-1z"></path><path d="M2 4h1v1h-1v-1z"></path><path d="M2 2h1v1h-1v-1z"></path></g>
<g id="vaadin:padding-right"><path d="M16 0h-16v16h16v-16zM13 15v-1h-1v1h-11v-14h12v1h1v-1h1v1h-1v1h1v1h-1v1h1v1h-1v1h1v1h-1v1h1v1h-1v1h1v1h-1v1h1v1h-1v1h-1z"></path><path d="M13 3h1v1h-1v-1z"></path><path d="M12 2h1v1h-1v-1z"></path><path d="M12 4h1v1h-1v-1z"></path><path d="M12 6h1v1h-1v-1z"></path><path d="M13 5h1v1h-1v-1z"></path><path d="M13 7h1v1h-1v-1z"></path><path d="M13 9h1v1h-1v-1z"></path><path d="M12 8h1v1h-1v-1z"></path><path d="M12 10h1v1h-1v-1z"></path><path d="M12 12h1v1h-1v-1z"></path><path d="M13 11h1v1h-1v-1z"></path><path d="M13 13h1v1h-1v-1z"></path></g>
<g id="vaadin:padding-top"><path d="M0 0v16h16v-16h-16zM15 3h-1v1h1v11h-14v-12h1v-1h-1v-1h1v1h1v-1h1v1h1v-1h1v1h1v-1h1v1h1v-1h1v1h1v-1h1v1h1v-1h1v1h1v1z"></path><path d="M3 2h1v1h-1v-1z"></path><path d="M2 3h1v1h-1v-1z"></path><path d="M4 3h1v1h-1v-1z"></path><path d="M6 3h1v1h-1v-1z"></path><path d="M5 2h1v1h-1v-1z"></path><path d="M7 2h1v1h-1v-1z"></path><path d="M9 2h1v1h-1v-1z"></path><path d="M8 3h1v1h-1v-1z"></path><path d="M10 3h1v1h-1v-1z"></path><path d="M12 3h1v1h-1v-1z"></path><path d="M11 2h1v1h-1v-1z"></path><path d="M13 2h1v1h-1v-1z"></path></g>
<g id="vaadin:padding"><path d="M0 0v16h16v-16h-16zM15 3h-1v1h1v1h-1v1h1v1h-1v1h1v1h-1v1h1v1h-1v1h1v1h-1v1h1v1h-1v-1h-1v1h-1v-1h-1v1h-1v-1h-1v1h-1v-1h-1v1h-1v-1h-1v1h-1v-1h-1v1h-1v-1h-1v-1h1v-1h-1v-1h1v-1h-1v-1h1v-1h-1v-1h1v-1h-1v-1h1v-1h-1v-1h1v-1h-1v-1h1v1h1v-1h1v1h1v-1h1v1h1v-1h1v1h1v-1h1v1h1v-1h1v1h1v-1h1v1h1v1z"></path><path d="M3 2h1v1h-1v-1z"></path><path d="M4 3h1v1h-1v-1z"></path><path d="M6 3h1v1h-1v-1z"></path><path d="M5 2h1v1h-1v-1z"></path><path d="M7 2h1v1h-1v-1z"></path><path d="M9 2h1v1h-1v-1z"></path><path d="M8 3h1v1h-1v-1z"></path><path d="M10 3h1v1h-1v-1z"></path><path d="M12 3h1v1h-1v-1z"></path><path d="M11 2h1v1h-1v-1z"></path><path d="M13 2h1v1h-1v-1z"></path><path d="M12 5h1v1h-1v-1z"></path><path d="M13 4h1v1h-1v-1z"></path><path d="M12 7h1v1h-1v-1z"></path><path d="M13 6h1v1h-1v-1z"></path><path d="M12 9h1v1h-1v-1z"></path><path d="M13 8h1v1h-1v-1z"></path><path d="M12 11h1v1h-1v-1z"></path><path d="M13 10h1v1h-1v-1z"></path><path d="M12 13h1v1h-1v-1z"></path><path d="M13 12h1v1h-1v-1z"></path><path d="M2 3h1v1h-1v-1z"></path><path d="M3 4h1v1h-1v-1z"></path><path d="M2 5h1v1h-1v-1z"></path><path d="M3 6h1v1h-1v-1z"></path><path d="M2 7h1v1h-1v-1z"></path><path d="M3 8h1v1h-1v-1z"></path><path d="M2 9h1v1h-1v-1z"></path><path d="M3 10h1v1h-1v-1z"></path><path d="M2 11h1v1h-1v-1z"></path><path d="M2 13h1v1h-1v-1z"></path><path d="M3 12h1v1h-1v-1z"></path><path d="M4 11h1v1h-1v-1z"></path><path d="M4 13h1v1h-1v-1z"></path><path d="M5 12h1v1h-1v-1z"></path><path d="M6 13h1v1h-1v-1z"></path><path d="M7 12h1v1h-1v-1z"></path><path d="M9 12h1v1h-1v-1z"></path><path d="M8 13h1v1h-1v-1z"></path><path d="M11 12h1v1h-1v-1z"></path><path d="M10 13h1v1h-1v-1z"></path></g>
<g id="vaadin:paint-roll"><path d="M16 6.9v-4.9h-2v-2h-13v1h-1v3h1v1h13v-2h1v3.1l-8 1v1.9h-1v0.9c0 0 0.5 0 0.5 0.9s-0.5 0.6-0.5 1.5v2.8c0 0 0 0.9 1.5 0.9s1.5-0.9 1.5-0.9v-2.8c0-0.9-0.5-0.7-0.5-1.5s0.5-0.9 0.5-0.9v-0.9h-1v-1.1l8-1z"></path></g>
<g id="vaadin:paintbrush"><path d="M5.6 11.6l-1.2-1.2c-0.8-0.2-2-0.1-2.7 1-0.8 1.1-0.3 2.8-1.7 4.6 0 0 3.5 0 4.8-1.3 1.2-1.2 1.2-2.2 1-3l-0.2-0.1z"></path><path d="M5.8 8.1c-0.2 0.3-0.5 0.7-0.7 1 0 0.2-0.1 0.3-0.2 0.4l1.5 1.5c0.1-0.1 0.3-0.2 0.4-0.3 0.3-0.2 0.7-0.4 1-0.7 0.4 0 0.6-0.2 0.8-0.4l-2.2-2.2c-0.2 0.2-0.4 0.4-0.6 0.7z"></path><path d="M15.8 0.2c-0.3-0.3-0.7-0.3-1-0.1 0 0-3 2.5-5.9 5.1-0.4 0.4-0.7 0.7-1.1 1-0.2 0.2-0.4 0.4-0.6 0.5l2.1 2.1c0.2-0.2 0.4-0.4 0.5-0.7 0.3-0.4 0.6-0.7 0.9-1.1 2.5-3 5.1-5.9 5.1-5.9 0.3-0.2 0.3-0.6 0-0.9z"></path></g>
<g id="vaadin:palette"><path d="M8.25 0c-6.38 0-9.11 7.38-8.010 9.92 0.82 1.89 2.62 0.080 3.34 1 1.88 2.46-2.11 3.81 0.090 4.68 2.59 1.060 12.33 0.4 12.33-8.53 0-2.69-1.34-7.070-7.75-7.070zM4.47 9c-0.815-0.017-1.47-0.682-1.47-1.5 0-0.828 0.672-1.5 1.5-1.5s1.5 0.671 1.5 1.5c0 0 0 0 0 0 0 0.828-0.672 1.5-1.5 1.5-0.011 0-0.021-0-0.032-0zM6 3.5c0-0.828 0.672-1.5 1.5-1.5s1.5 0.672 1.5 1.5-0.672 1.5-1.5 1.5c-0.011 0-0.021-0-0.032-0-0.814-0.017-1.468-0.682-1.468-1.5 0-0 0-0 0-0zM8.47 14c-0.815-0.017-1.47-0.682-1.47-1.5 0-0.828 0.672-1.5 1.5-1.5s1.5 0.671 1.5 1.5c0 0 0 0 0 0 0 0.828-0.672 1.5-1.5 1.5-0.011 0-0.021-0-0.032-0zM12.47 11c-0.815-0.017-1.47-0.682-1.47-1.5 0-0.828 0.672-1.5 1.5-1.5s1.5 0.671 1.5 1.5c0 0 0 0 0 0 0 0.828-0.672 1.5-1.5 1.5-0.011 0-0.021-0-0.032-0zM12.47 6c-0.815-0.017-1.47-0.682-1.47-1.5 0-0.828 0.672-1.5 1.5-1.5s1.5 0.671 1.5 1.5c0 0 0 0 0 0 0 0.828-0.672 1.5-1.5 1.5-0.011 0-0.021-0-0.032-0z"></path></g>
<g id="vaadin:panel"><path d="M0 0v16h16v-16h-16zM13 15h-12v-12h12v12zM15 15h-1v-1h1v1zM15 13h-1v-8h1v8zM15 4h-1v-1h1v1z"></path></g>
<g id="vaadin:paperclip"><path d="M2.7 15.3c-0.7 0-1.4-0.3-1.9-0.8-0.9-0.9-1.2-2.5 0-3.7l8.9-8.9c1.4-1.4 3.8-1.4 5.2 0s1.4 3.8 0 5.2l-7.4 7.4c-0.2 0.2-0.5 0.2-0.7 0s-0.2-0.5 0-0.7l7.4-7.4c1-1 1-2.7 0-3.7s-2.7-1-3.7 0l-8.9 8.9c-0.8 0.8-0.6 1.7 0 2.2 0.6 0.6 1.5 0.8 2.2 0l8.9-8.9c0.2-0.2 0.2-0.5 0-0.7s-0.5-0.2-0.7 0l-7.4 7.4c-0.2 0.2-0.5 0.2-0.7 0s-0.2-0.5 0-0.7l7.4-7.4c0.6-0.6 1.6-0.6 2.2 0s0.6 1.6 0 2.2l-8.9 8.9c-0.6 0.4-1.3 0.7-1.9 0.7z"></path></g>
<g id="vaadin:paperplane-o"><path d="M16 0l-16 8 4.7 1.6 0.3 5.4 2.5-2.8 2.5 3.8 6-16zM7.5 10.4l4.3-5.9-6.2 4.3-3-1 11.6-5.8-4.5 11.8-2.2-3.4z"></path></g>
<g id="vaadin:paperplane"><path d="M0 8l4.9 1.4h0.1v-0.1l7.1-5.3-1.1 1.2-6.2 6.6 0.2 3.2 2.9-3.2 2.1 4.2 6-16z"></path></g>
<g id="vaadin:paragraph"><path d="M5.5 0c-2.5 0-4.5 2-4.5 4.5s2 4.5 4.5 4.5h2.5v7h2v-14h1v14h2v-14h2v-2h-9.5z"></path></g>
<g id="vaadin:password"><path d="M16 5c0-0.6-0.4-1-1-1h-14c-0.6 0-1 0.4-1 1v6c0 0.6 0.4 1 1 1h14c0.6 0 1-0.4 1-1v-6zM15 11h-14v-6h14v6z"></path><path d="M6 8c0 0.552-0.448 1-1 1s-1-0.448-1-1c0-0.552 0.448-1 1-1s1 0.448 1 1z"></path><path d="M9 8c0 0.552-0.448 1-1 1s-1-0.448-1-1c0-0.552 0.448-1 1-1s1 0.448 1 1z"></path><path d="M12 8c0 0.552-0.448 1-1 1s-1-0.448-1-1c0-0.552 0.448-1 1-1s1 0.448 1 1z"></path></g>
<g id="vaadin:paste"><path d="M13 4h-3v-4h-10v14h6v2h10v-9l-3-3zM3 1h4v1h-4v-1zM15 15h-8v-10h5v3h3v7zM13 7v-2l2 2h-2z"></path></g>
<g id="vaadin:pause"><path d="M0 1h7v14h-7v-14z"></path><path d="M9 1h7v14h-7v-14z"></path></g>
<g id="vaadin:pencil"><path d="M1 11.9l-1 4.1 4.1-1 9.2-9.2-3.1-3.1-9.2 9.2zM1.5 15l-0.4-0.5 0.4-2 2 2-2 0.5zM10.9 4.4l-8.1 8-0.6-0.6 8.1-8 0.6 0.6z"></path><path d="M15.3 0.7c-1.1-1.1-2.6-0.5-2.6-0.5l-1.5 1.5 3.1 3.1 1.5-1.5c0-0.1 0.6-1.5-0.5-2.6zM13.4 1.6l-0.5-0.5c0.6-0.6 1.1-0.1 1.1-0.1l-0.6 0.6z"></path></g>
<g id="vaadin:phone-landline"><path d="M15.88 3.86l-0.61-1.31c-0.155-0.326-0.443-0.568-0.792-0.658-1.938-0.528-4.161-0.851-6.453-0.891-2.342 0.041-4.565 0.363-6.687 0.934-0.165 0.048-0.453 0.29-0.605 0.609l-0.613 1.317c-0.075 0.152-0.119 0.331-0.12 0.52v0.87c-0.001 0.012-0.001 0.026-0.001 0.041 0 0.392 0.318 0.71 0.71 0.71 0.011 0 0.022-0 0.033-0.001l2.518 0c0.412-0.010 0.742-0.346 0.742-0.76 0-0.018-0.001-0.035-0.002-0.053l0-0.838c-0-0.004-0-0.008-0-0.012 0-0.229 0.119-0.43 0.298-0.546 0.947-0.508 2.069-0.806 3.26-0.806 0.156 0 0.31 0.005 0.464 0.015 0.122-0.011 0.288-0.017 0.456-0.017 1.178 0 2.287 0.291 3.261 0.805 0.143 0.099 0.262 0.3 0.262 0.529 0 0.004-0 0.009-0 0.013l0 0.859c-0.001 0.015-0.002 0.033-0.002 0.050 0 0.413 0.33 0.75 0.741 0.76l2.521 0c0.009 0 0.020 0.001 0.031 0.001 0.392 0 0.71-0.318 0.71-0.71 0-0.014-0-0.029-0.001-0.043l0-0.868c-0.001-0.189-0.045-0.368-0.123-0.527z"></path><path d="M12 8.3c-0.624-0.797-1.001-1.815-1.001-2.92 0-0.028 0-0.056 0.001-0.084l-0-0.296h-1v1h-4v-1h-1v0.33c0 0.024 0.001 0.052 0.001 0.080 0 1.105-0.377 2.122-1.009 2.93l-2.992 3.66v3h14v-3zM8 13c-1.657 0-3-1.343-3-3s1.343-3 3-3c1.657 0 3 1.343 3 3s-1.343 3-3 3z"></path><path d="M10 10c0 1.105-0.895 2-2 2s-2-0.895-2-2c0-1.105 0.895-2 2-2s2 0.895 2 2z"></path></g>
<g id="vaadin:phone"><path d="M12.2 10c-1.1-0.1-1.7 1.4-2.5 1.8-1.3 0.7-3.7-1.8-3.7-1.8s-2.5-2.4-1.9-3.7c0.5-0.8 2-1.4 1.9-2.5-0.1-1-2.3-4.6-3.4-3.6-2.4 2.2-2.6 3.1-2.6 4.9-0.1 3.1 3.9 7 3.9 7 0.4 0.4 3.9 4 7 3.9 1.8 0 2.7-0.2 4.9-2.6 1-1.1-2.5-3.3-3.6-3.4z"></path></g>
<g id="vaadin:picture"><path d="M16 14h-16v-12h16v12zM1 13h14v-10h-14v10z"></path><path d="M2 10v2h12v-1c0 0 0.2-1.7-2-2-1.9-0.3-2.2 0.6-3.8 0.6-1.1 0-0.9-1.6-3.2-1.6-1.7 0-3 2-3 2z"></path><path d="M13 6c0 1.105-0.895 2-2 2s-2-0.895-2-2c0-1.105 0.895-2 2-2s2 0.895 2 2z"></path></g>
<g id="vaadin:pie-bar-chart"><path d="M5 11h3v5h-3v-5z"></path><path d="M1 14h3v2h-3v-2z"></path><path d="M13 12h3v4h-3v-4z"></path><path d="M9 9h3v7h-3v-7z"></path><path d="M5 0c-2.761 0-5 2.239-5 5s2.239 5 5 5c2.761 0 5-2.239 5-5s-2.239-5-5-5zM5 9c-2.209 0-4-1.791-4-4s1.791-4 4-4v4h4c0 2.209-1.791 4-4 4z"></path></g>
<g id="vaadin:pie-chart"><path d="M9 1c3.2 0.2 5.7 2.8 6 6h-6v-6zM8.5 0c-0.2 0-0.3 0-0.5 0v8h8c0-0.2 0-0.3 0-0.5 0-4.1-3.4-7.5-7.5-7.5v0z"></path><path d="M7 9v-8c-3.9 0.3-7 3.5-7 7.5 0 4.1 3.4 7.5 7.5 7.5 4 0 7.2-3.1 7.5-7h-8z"></path></g>
<g id="vaadin:piggy-bank-coin"><path d="M15.93 7.75c-0.061-0.2-0.165-0.371-0.3-0.51-0.105-0.113-0.241-0.197-0.394-0.238 0.074 0.117 0.141 0.252 0.191 0.396 0.056 0.147 0.092 0.304 0.103 0.467 0.008 0.067 0.012 0.138 0.012 0.21s-0.004 0.143-0.012 0.214c-0.035-0.115-0.083-0.208-0.142-0.292-0.123-0.166-0.288-0.299-0.48-0.383-0.119-0.053-0.248-0.082-0.384-0.082-0.346 0-0.648 0.186-0.811 0.464-0.050 0.082-0.090 0.171-0.12 0.266-1.182-1.968-3.309-3.271-5.741-3.271-0.124 0-0.247 0.003-0.369 0.010-0.763 0.001-1.517 0.11-2.231 0.313-0.062-0.434-0.632-1.314-3.252-1.314l0.8 2.51c-0.507 0.411-0.927 0.905-1.247 1.465l-1.553 0.025s-0.17 4 1 4h0.54c0.379 0.638 0.868 1.171 1.445 1.589l0.015 2.411h1.080c1.31 0 1.92 0 1.92-0.75v-0.39c0.451 0.088 0.97 0.139 1.5 0.139s1.049-0.051 1.551-0.147l-0.051 0.398c0 0.75 0.62 0.75 1.94 0.75h1.060v-2.39c0.932-0.651 1.613-1.605 1.903-2.717 0.057-0.027 0.114-0.024 0.172-0.024s0.115-0.003 0.172-0.010c0.251-0.046 0.48-0.144 0.679-0.283 0.266-0.188 0.474-0.454 0.591-0.765 0.028-0.093 0.049-0.191 0.063-0.292l0.001-0.010c0.221-0.262 0.372-0.59 0.419-0.951 0.012-0.084 0.019-0.171 0.019-0.259 0-0.197-0.032-0.386-0.091-0.563zM3.51 7.75c0.414 0 0.75 0.336 0.75 0.75s-0.336 0.75-0.75 0.75c-0.414 0-0.75-0.336-0.75-0.75s0.336-0.75 0.75-0.75zM5.88 7c-0.046 0.015-0.099 0.024-0.154 0.024-0.194 0-0.362-0.11-0.445-0.271-0.013-0.038-0.019-0.078-0.019-0.12 0-0.19 0.136-0.348 0.315-0.383 0.571-0.141 1.224-0.221 1.896-0.221 0.038 0 0.075 0 0.113 0.001 0.026-0 0.064-0.001 0.101-0.001 0.672 0 1.324 0.080 1.949 0.232 0.126 0.024 0.262 0.182 0.262 0.372 0 0.042-0.007 0.082-0.019 0.119-0.070 0.129-0.197 0.223-0.346 0.247l-0.153 0c-0.512-0.127-1.101-0.2-1.706-0.2-0.016 0-0.031 0-0.047 0-0.011-0-0.026-0-0.042-0-0.605 0-1.193 0.073-1.756 0.211zM14.58 9.93c-0.13 0.095-0.285 0.165-0.453 0.199l-0.127 0.001s0-0.13 0-0.13 0-0.21 0-0.31c0.165 0.125 0.374 0.2 0.6 0.2 0.007 0 0.014-0 0.021-0zM14.66 9.25c-0.018 0.003-0.040 0.004-0.061 0.004-0.176 0-0.327-0.103-0.398-0.252-0.044-0.084-0.069-0.18-0.069-0.283s0.025-0.199 0.070-0.283c0.059-0.082 0.157-0.138 0.269-0.138 0.059 0 0.113 0.015 0.161 0.042 0.181 0.070 0.308 0.244 0.308 0.448 0 0 0 0.001 0 0.001 0.009 0.062 0.014 0.133 0.014 0.205s-0.005 0.143-0.015 0.213c-0.066 0.012-0.144 0.024-0.224 0.024-0.019 0-0.039-0.001-0.058-0.002z"></path><path d="M8 3h-1v-0.17h0.25v-1.090h-0.25l0.55-0.55h0.2v1.64h0.25v0.17z"></path><path d="M7.5 0.75c0.828 0 1.5 0.672 1.5 1.5s-0.672 1.5-1.5 1.5c-0.828 0-1.5-0.672-1.5-1.5s0.672-1.5 1.5-1.5zM7.5 0c-1.243 0-2.25 1.007-2.25 2.25s1.007 2.25 2.25 2.25c1.243 0 2.25-1.007 2.25-2.25s-1.007-2.25-2.25-2.25v0z"></path></g>
<g id="vaadin:piggy-bank"><path d="M15.93 5.75c-0.061-0.2-0.165-0.371-0.3-0.51-0.105-0.113-0.241-0.197-0.394-0.238 0.074 0.117 0.141 0.252 0.191 0.396 0.056 0.147 0.092 0.304 0.103 0.467 0.008 0.067 0.012 0.138 0.012 0.21s-0.004 0.143-0.012 0.214c-0.035-0.115-0.083-0.208-0.142-0.292-0.123-0.166-0.288-0.299-0.48-0.383-0.119-0.053-0.248-0.082-0.384-0.082-0.346 0-0.648 0.186-0.811 0.464-0.050 0.082-0.090 0.171-0.12 0.266-1.182-1.968-3.309-3.271-5.741-3.271-0.124 0-0.247 0.003-0.369 0.010-0.763 0.001-1.517 0.11-2.231 0.313-0.062-0.434-0.632-1.314-3.252-1.314l0.8 2.51c-0.507 0.411-0.927 0.905-1.247 1.465l-1.553 0.025s-0.17 4 1 4h0.54c0.379 0.638 0.868 1.171 1.445 1.589l0.015 2.41h1.080c1.31 0 1.92 0 1.92-0.75v-0.39c0.451 0.088 0.97 0.139 1.5 0.139s1.049-0.051 1.551-0.147l-0.051 0.398c0 0.75 0.62 0.75 1.94 0.75h1.060v-2.39c0.932-0.651 1.613-1.605 1.903-2.717 0.057-0.027 0.114-0.024 0.172-0.024s0.115-0.003 0.172-0.010c0.251-0.046 0.48-0.144 0.679-0.283 0.266-0.188 0.474-0.454 0.591-0.765 0.028-0.093 0.049-0.191 0.063-0.292l0.001-0.010c0.221-0.262 0.372-0.59 0.419-0.951 0.012-0.084 0.019-0.171 0.019-0.259 0-0.197-0.032-0.386-0.091-0.563zM3.51 5.75c0.414 0 0.75 0.336 0.75 0.75s-0.336 0.75-0.75 0.75c-0.414 0-0.75-0.336-0.75-0.75s0.336-0.75 0.75-0.75zM5.88 5c-0.046 0.015-0.099 0.024-0.154 0.024-0.194 0-0.362-0.11-0.445-0.271-0.013-0.038-0.019-0.078-0.019-0.12 0-0.19 0.136-0.348 0.315-0.383 0.571-0.141 1.224-0.221 1.896-0.221 0.038 0 0.075 0 0.113 0.001 0.026-0 0.064-0.001 0.101-0.001 0.672 0 1.324 0.080 1.949 0.232 0.126 0.024 0.262 0.182 0.262 0.372 0 0.042-0.007 0.082-0.019 0.119-0.070 0.129-0.197 0.223-0.346 0.247l-0.153 0c-0.512-0.127-1.101-0.2-1.706-0.2-0.016 0-0.031 0-0.047 0-0.011-0-0.026-0-0.042-0-0.605 0-1.193 0.073-1.756 0.211zM14.58 7.93c-0.13 0.095-0.285 0.165-0.453 0.199l-0.127 0.011s0-0.14 0-0.14 0-0.21 0-0.31c0.165 0.125 0.374 0.2 0.6 0.2 0.007 0 0.014-0 0.021-0zM14.66 7.25c-0.018 0.003-0.040 0.004-0.061 0.004-0.176 0-0.327-0.103-0.398-0.252-0.044-0.084-0.069-0.18-0.069-0.283s0.025-0.199 0.070-0.283c0.059-0.082 0.157-0.138 0.269-0.138 0.059 0 0.113 0.015 0.161 0.042 0.181 0.070 0.308 0.244 0.308 0.448 0 0 0 0.001 0 0.001 0.009 0.062 0.014 0.133 0.014 0.205s-0.005 0.143-0.015 0.213c-0.066 0.012-0.144 0.024-0.224 0.024-0.019 0-0.039-0.001-0.058-0.002z"></path></g>
<g id="vaadin:pill"><path d="M14.8 1.4l-0.2-0.2c-0.7-0.8-1.8-1.2-2.8-1.2s-2.1 0.4-2.9 1.2l-7.7 7.7c-1.6 1.6-1.6 4.1 0 5.7l0.2 0.2c0.7 0.8 1.8 1.2 2.8 1.2s2.1-0.4 2.9-1.2l7.8-7.8c1.5-1.5 1.5-4.1-0.1-5.6zM14.1 6.4l-3.9 3.9-3.5-3.6-3.8 3.8c-1.1 1.1-1.1 2.5-1 3.5v0c-1.2-1.2-1.2-3.1 0-4.3l7.8-7.8c0.5-0.6 1.3-0.9 2.1-0.9s1.6 0.3 2.2 0.9l0.2 0.2c0.5 0.5 0.8 1.3 0.8 2.1s-0.3 1.6-0.9 2.2z"></path></g>
<g id="vaadin:pills"><path d="M3.5 8l6.3-6.3c0.4-0.4 1-0.7 1.7-0.7s1.3 0.3 1.8 0.7c1 1 1 2.6 0 3.5l-2.8 2.8h1.4l2-2c1.4-1.4 1.4-3.6 0-4.9-0.7-0.7-1.6-1-2.5-1s-1.7 0.2-2.4 0.9l-6.3 6.4c-0.3 0.2-0.5 0.5-0.7 0.9 0.5-0.2 1-0.3 1.5-0.3z"></path><path d="M7.3 5.6l-2.4 2.4h4.7z"></path><path d="M12.5 9h-9c-1.9 0-3.5 1.6-3.5 3.5s1.6 3.5 3.5 3.5h9c1.9 0 3.5-1.6 3.5-3.5s-1.6-3.5-3.5-3.5zM12.5 15h-4.5v-4h-4.5c-1.1 0-2 0.6-2.5 1.2 0.2-1.2 1.2-2.2 2.5-2.2h9c1.4 0 2.5 1.1 2.5 2.5s-1.1 2.5-2.5 2.5z"></path></g>
<g id="vaadin:pin-post"><path d="M15 4v-1h-6c0-1.69 1-2 1-2v-1h-5v1s1 0.31 1 2h-6v12h2v1h14v-12h-1zM14 14h-13v-10h4v1h2v2h1v-2h2v-1h4v10z"></path></g>
<g id="vaadin:pin"><path d="M11 6.5v-5.5h1v-1h-8v1h1v5.5c0 0-2 1.5-2 3.5 0 0.5 1.9 0.7 4 0.7v2.2c0 0.7 0.2 1.4 0.5 2.1l0.5 1 0.5-1c0.3-0.6 0.5-1.3 0.5-2.1v-2.2c2.1 0 4-0.3 4-0.7 0-2-2-3.5-2-3.5zM7 6.6c0 0-0.5 0.3-1.6 1.4-1 1-1.5 1.9-1.5 1.9s0.1-1 0.8-1.9c0.9-1.1 1.3-1.4 1.3-1.4v-5.6h1v5.6z"></path></g>
<g id="vaadin:play-circle-o"><path d="M8 1c3.9 0 7 3.1 7 7s-3.1 7-7 7-7-3.1-7-7 3.1-7 7-7zM8 0c-4.4 0-8 3.6-8 8s3.6 8 8 8 8-3.6 8-8-3.6-8-8-8v0z"></path><path d="M6 4v8l6-4z"></path></g>
<g id="vaadin:play-circle"><path d="M8 0c-4.4 0-8 3.6-8 8s3.6 8 8 8 8-3.6 8-8-3.6-8-8-8zM6 12v-8l6 4-6 4z"></path></g>
<g id="vaadin:play"><path d="M2 1v14l12-7z"></path></g>
<g id="vaadin:plug"><path d="M14.7 3.1c-0.4-0.4-1-0.4-1.4 0l-2.8 2.8-1.5-1.4 2.8-2.8c0.4-0.4 0.4-1 0-1.4s-1-0.4-1.4 0l-2.8 2.8-1.4-1.4-1.4 1.4 0.7 0.7-1.4 1.4c-1.4 1.4-1.5 3.5-0.5 5.1-1.7 1.5-2.6 3.8-2.6 5.7h2c0-1.3 0.4-3.2 2.1-4.4 1.5 0.8 3.4 0.5 4.6-0.7l1.4-1.4 0.7 0.7 1.4-1.4-1.4-1.4 2.8-2.8c0.5-0.5 0.5-1.1 0.1-1.5z"></path></g>
<g id="vaadin:plus-circle-o"><path d="M8 1c3.9 0 7 3.1 7 7s-3.1 7-7 7-7-3.1-7-7 3.1-7 7-7zM8 0c-4.4 0-8 3.6-8 8s3.6 8 8 8 8-3.6 8-8-3.6-8-8-8v0z"></path><path d="M13 7h-4v-4h-2v4h-4v2h4v4h2v-4h4z"></path></g>
<g id="vaadin:plus-circle"><path d="M8 0c-4.4 0-8 3.6-8 8s3.6 8 8 8 8-3.6 8-8-3.6-8-8-8zM13 9h-4v4h-2v-4h-4v-2h4v-4h2v4h4v2z"></path></g>
<g id="vaadin:plus-minus"><path d="M10 7h6v2h-6v-2z"></path><path d="M4 5h-2v2h-2v2h2v2h2v-2h2v-2h-2z"></path><path d="M6 2l3 12h1l-3-12z"></path></g>
<g id="vaadin:plus-square-o"><path d="M12 7h-3v-3h-2v3h-3v2h3v3h2v-3h3z"></path><path d="M15 1h-14v14h14v-14zM14 14h-12v-12h12v12z"></path></g>
<g id="vaadin:plus"><path d="M14 7h-5v-5h-2v5h-5v2h5v5h2v-5h5v-2z"></path></g>
<g id="vaadin:pointer"><path d="M12.6 5c-0.2 0-0.5 0-0.6 0 0-0.2-0.2-0.6-0.4-0.8s-0.6-0.4-1.1-0.4c-0.2 0-0.4 0-0.6 0.1-0.1-0.2-0.2-0.3-0.3-0.5-0.2-0.2-0.5-0.4-1.1-0.4-0.2 0-0.4 0-0.5 0.1v-1.7c0-0.6-0.4-1.4-1.4-1.4-0.4 0-0.8 0.2-1.1 0.4-0.5 0.6-0.5 1.4-0.5 1.4v4.3c-0.6 0.1-1.1 0.3-1.4 0.6-0.6 0.7-0.6 1.6-0.6 2.8 0 0.2 0 0.5 0 0.7 0 1.4 0.7 2.1 1.4 2.8l0.3 0.4c1.3 1.2 2.4 1.6 5.1 1.6 2.9 0 4.2-1.6 4.2-5.1v-2.5c0-0.7-0.2-2.1-1.4-2.4zM13 7.4v2.6c0 3.4-1.3 4.1-3.2 4.1-2.4 0-3.3-0.3-4.3-1.3-0.1-0.1-0.2-0.2-0.4-0.4-0.7-0.8-1.1-1.2-1.1-2.2 0-0.2 0-0.5 0-0.7 0-1 0-1.7 0.3-2.1 0.1-0.1 0.4-0.2 0.7-0.2v0.5l-0.3 1.5c0 0.1 0 0.1 0.1 0.2s0.2 0 0.2 0l1-1.2c0-0.1 0-0.2 0-0.2v-6.2c0-0.1 0-0.5 0.2-0.7 0.1 0 0.2-0.1 0.4-0.1 0.3 0 0.4 0.3 0.4 0.4v3.1c0 0 0 0 0 0v1.2c0 0.3 0.2 0.6 0.5 0.6s0.5-0.3 0.5-0.5v-1.3c0 0 0 0 0 0 0-0.1 0.1-0.5 0.5-0.5 0.3 0 0.5 0.1 0.5 0.4v1.3c0 0.3 0.2 0.6 0.5 0.6s0.5-0.3 0.5-0.5v-0.7c0-0.1 0.1-0.3 0.5-0.3 0.2 0 0.3 0.1 0.3 0.1 0.2 0.1 0.2 0.4 0.2 0.4v0.8c0 0.3 0.2 0.5 0.4 0.5 0.3 0 0.5-0.1 0.5-0.4 0-0.1 0.1-0.2 0.2-0.3 0 0 0.1 0 0.2 0 0.6 0.2 0.7 1.2 0.7 1.5 0-0.1 0-0.1 0 0z"></path></g>
<g id="vaadin:power-off"><path d="M10 2.3v3.3c1.2 0.7 2 2 2 3.4 0 2.2-1.8 4-4 4s-4-1.8-4-4c0-1.5 0.8-2.8 2-3.4v-3.3c-2.9 0.9-5 3.5-5 6.7 0 3.9 3.1 7 7 7s7-3.1 7-7c0-3.2-2.1-5.8-5-6.7z"></path><path d="M7 1h2v7h-2v-7z"></path></g>
<g id="vaadin:presentation"><path d="M16 1h-7v-1h-2v1h-7v11h5l-2 4h2.2l2-4h1.5l2 4h2.3l-2-4h5v-11zM15 11h-14v-9h14v9z"></path><path d="M6 4v5l4-2.5z"></path></g>
<g id="vaadin:print"><path d="M0 10v4h2v2h12v-2h2v-4h-16zM13 15h-10v-3h10v3z"></path><path d="M12 6v-4l-2.7-2h-5.3v6h-4v3h16v-3h-4zM9 1l1.3 1h-1.3v-1zM11 7h-6v-6h3v2h3v4zM15 8h-1v-1h1v1z"></path></g>
<g id="vaadin:progressbar"><path d="M0 5v6h16v-6h-16zM15 10h-14v-4h14v4z"></path><path d="M2 7h7v2h-7v-2z"></path></g>
<g id="vaadin:puzzle-piece"><path d="M14.9 0.9c-1.1-1-2.5-1.3-3.1-0.4-0.7 1.1 0.5 1.7-0.3 2.5-0.5 0.6-2-0.8-2-0.8l-0.8-0.8-1.4 1.4c-0.6 0.7-2.1 1.5-2.6 1.1-0.7-0.6 0.1-1.8-0.5-2.6-0.7-1-2.1-0.8-3 0.3-1 1.1-1.4 2.4-0.5 3 1.1 0.7 1.9-0.3 2.7 0.5 0.4 0.4-0.2 1.7-0.5 2.1l-2.3 2.3 6.5 6.5 1.7-1.7c0.7-0.7 1.5-2 1.1-2.4-0.6-0.7-1.7 0.1-2.5-0.4-1-0.7-0.8-2 0.3-3s2.5-1.3 3.1-0.4c0.7 1.1-0.4 1.8 0.4 2.6 0.4 0.4 1.6-0.2 2-0.6l2.1-2.1-1.1-1.1c-0.6-0.6-1.9-2-1.4-2.5 0.6-0.7 1.7 0.2 2.5-0.4 0.9-0.8 0.6-2.1-0.4-3.1z"></path></g>
<g id="vaadin:pyramid-chart"><path d="M10.29 5l-2.29-4-2.29 4h4.58z"></path><path d="M2.29 11l-2.29 4h16l-2.29-4h-11.42z"></path><path d="M13.14 10l-2.28-4h-5.72l-2.28 4h10.28z"></path></g>
<g id="vaadin:qrcode"><path d="M6 0h-6v6h6v-6zM5 5h-4v-4h4v4z"></path><path d="M2 2h2v2h-2v-2z"></path><path d="M0 16h6v-6h-6v6zM1 11h4v4h-4v-4z"></path><path d="M2 12h2v2h-2v-2z"></path><path d="M10 0v6h6v-6h-6zM15 5h-4v-4h4v4z"></path><path d="M12 2h2v2h-2v-2z"></path><path d="M2 7h-2v2h3v-1h-1z"></path><path d="M7 9h2v2h-2v-2z"></path><path d="M3 7h2v1h-2v-1z"></path><path d="M9 12h-2v1h1v1h1v-1z"></path><path d="M6 7v1h-1v1h2v-2z"></path><path d="M8 4h1v2h-1v-2z"></path><path d="M9 8v1h2v-2h-3v1z"></path><path d="M7 6h1v1h-1v-1z"></path><path d="M9 14h2v2h-2v-2z"></path><path d="M7 14h1v2h-1v-2z"></path><path d="M9 11h1v1h-1v-1z"></path><path d="M9 3v-2h-1v-1h-1v4h1v-1z"></path><path d="M12 14h1v2h-1v-2z"></path><path d="M12 12h2v1h-2v-1z"></path><path d="M11 13h1v1h-1v-1z"></path><path d="M10 12h1v1h-1v-1z"></path><path d="M14 10v1h1v1h1v-2h-1z"></path><path d="M15 13h-1v3h2v-2h-1z"></path><path d="M10 10v1h3v-2h-2v1z"></path><path d="M12 7v1h2v1h2v-2h-2z"></path></g>
<g id="vaadin:question-circle-o"><path d="M9 10h-2c0-2 1.2-2.6 2-3 0.3-0.1 0.5-0.2 0.7-0.4 0.1-0.1 0.3-0.3 0.1-0.7-0.2-0.5-0.8-1-1.7-1-1.4 0-1.6 1.2-1.7 1.5l-2-0.3c0.1-1.1 1-3.2 3.6-3.2 1.6 0 3 0.9 3.6 2.2 0.4 1.1 0.2 2.2-0.6 3-0.4 0.4-0.8 0.6-1.2 0.7-0.6 0.4-0.8 0.2-0.8 1.2z"></path><path d="M8 1c3.9 0 7 3.1 7 7s-3.1 7-7 7-7-3.1-7-7 3.1-7 7-7zM8 0c-4.4 0-8 3.6-8 8s3.6 8 8 8 8-3.6 8-8-3.6-8-8-8v0z"></path><path d="M6.9 11h2v2h-2v-2z"></path></g>
<g id="vaadin:question-circle"><path d="M8 0c-4.4 0-8 3.6-8 8s3.6 8 8 8 8-3.6 8-8-3.6-8-8-8zM8.9 13h-2v-2h2v2zM11 8.1c-0.4 0.4-0.8 0.6-1.2 0.7-0.6 0.4-0.8 0.2-0.8 1.2h-2c0-2 1.2-2.6 2-3 0.3-0.1 0.5-0.2 0.7-0.4 0.1-0.1 0.3-0.3 0.1-0.7-0.2-0.5-0.8-1-1.7-1-1.4 0-1.6 1.2-1.7 1.5l-2-0.3c0.1-1.1 1-3.2 3.6-3.2 1.6 0 3 0.9 3.6 2.2 0.4 1.1 0.2 2.2-0.6 3z"></path></g>
<g id="vaadin:question"><path d="M9 11h-3c0-3 1.6-4 2.7-4.6 0.4-0.2 0.7-0.4 0.9-0.6 0.5-0.5 0.3-1.2 0.2-1.4-0.3-0.7-1-1.4-2.3-1.4-2.1 0-2.5 1.9-2.5 2.3l-3-0.4c0.2-1.7 1.7-4.9 5.5-4.9 2.3 0 4.3 1.3 5.1 3.2 0.7 1.7 0.4 3.5-0.8 4.7-0.5 0.5-1.1 0.8-1.6 1.1-0.9 0.5-1.2 1-1.2 2z"></path><path d="M9.5 14c0 1.105-0.895 2-2 2s-2-0.895-2-2c0-1.105 0.895-2 2-2s2 0.895 2 2z"></path></g>
<g id="vaadin:quote-left"><path d="M7 7v7h-7v-7.1c0-4.8 4.5-5.4 4.5-5.4l0.6 1.4c0 0-2 0.3-2.4 1.9-0.4 1.2 0.4 2.2 0.4 2.2h3.9z"></path><path d="M16 7v7h-7v-7.1c0-4.8 4.5-5.4 4.5-5.4l0.6 1.4c0 0-2 0.3-2.4 1.9-0.4 1.2 0.4 2.2 0.4 2.2h3.9z"></path></g>
<g id="vaadin:quote-right"><path d="M9 9v-7h7v7.1c0 4.8-4.5 5.4-4.5 5.4l-0.6-1.4c0 0 2-0.3 2.4-1.9 0.4-1.2-0.4-2.2-0.4-2.2h-3.9z"></path><path d="M0 9v-7h7v7.1c0 4.8-4.5 5.4-4.5 5.4l-0.6-1.4c0 0 2-0.3 2.4-1.9 0.4-1.2-0.4-2.2-0.4-2.2h-3.9z"></path></g>
<g id="vaadin:random"><path d="M13 12h-2c-1 0-1.7-1.2-2.4-2.7-0.3 0.7-0.6 1.5-1 2.3 0.8 1.4 1.8 2.4 3.4 2.4h2v2l3-3-3-3v2z"></path><path d="M5.4 6.6c0.3-0.7 0.6-1.5 1-2.2-0.8-1.4-1.9-2.4-3.4-2.4h-3v2h3c1 0 1.7 1.2 2.4 2.6z"></path><path d="M16 3l-3-3v2h-2c-2.7 0-3.9 3-5 5.7-0.8 2.1-1.7 4.3-3 4.3h-3v2h3c2.6 0 3.8-2.8 4.9-5.6 0.9-2.2 1.8-4.4 3.1-4.4h2v2l3-3z"></path></g>
<g id="vaadin:raster-lower-left"><path d="M15 7h1v1h-1v-1z"></path><path d="M13 7h1v1h-1v-1z"></path><path d="M11 7h1v1h-1v-1z"></path><path d="M9 7h1v1h-1v-1z"></path><path d="M14 6h1v1h-1v-1z"></path><path d="M12 6h1v1h-1v-1z"></path><path d="M10 6h1v1h-1v-1z"></path><path d="M15 5h1v1h-1v-1z"></path><path d="M13 5h1v1h-1v-1z"></path><path d="M11 5h1v1h-1v-1z"></path><path d="M14 4h1v1h-1v-1z"></path><path d="M12 4h1v1h-1v-1z"></path><path d="M15 3h1v1h-1v-1z"></path><path d="M13 3h1v1h-1v-1z"></path><path d="M14 2h1v1h-1v-1z"></path><path d="M15 1h1v1h-1v-1z"></path><path d="M7 15h1v1h-1v-1z"></path><path d="M5 15h1v1h-1v-1z"></path><path d="M3 15h1v1h-1v-1z"></path><path d="M1 15h1v1h-1v-1z"></path><path d="M6 14h1v1h-1v-1z"></path><path d="M4 14h1v1h-1v-1z"></path><path d="M2 14h1v1h-1v-1z"></path><path d="M7 13h1v1h-1v-1z"></path><path d="M5 13h1v1h-1v-1z"></path><path d="M3 13h1v1h-1v-1z"></path><path d="M6 12h1v1h-1v-1z"></path><path d="M4 12h1v1h-1v-1z"></path><path d="M7 11h1v1h-1v-1z"></path><path d="M5 11h1v1h-1v-1z"></path><path d="M6 10h1v1h-1v-1z"></path><path d="M7 9h1v1h-1v-1z"></path><path d="M15 15h1v1h-1v-1z"></path><path d="M13 15h1v1h-1v-1z"></path><path d="M11 15h1v1h-1v-1z"></path><path d="M9 15h1v1h-1v-1z"></path><path d="M14 14h1v1h-1v-1z"></path><path d="M12 14h1v1h-1v-1z"></path><path d="M10 14h1v1h-1v-1z"></path><path d="M8 14h1v1h-1v-1z"></path><path d="M15 13h1v1h-1v-1z"></path><path d="M13 13h1v1h-1v-1z"></path><path d="M11 13h1v1h-1v-1z"></path><path d="M9 13h1v1h-1v-1z"></path><path d="M14 12h1v1h-1v-1z"></path><path d="M12 12h1v1h-1v-1z"></path><path d="M10 12h1v1h-1v-1z"></path><path d="M8 12h1v1h-1v-1z"></path><path d="M15 11h1v1h-1v-1z"></path><path d="M13 11h1v1h-1v-1z"></path><path d="M11 11h1v1h-1v-1z"></path><path d="M9 11h1v1h-1v-1z"></path><path d="M14 10h1v1h-1v-1z"></path><path d="M12 10h1v1h-1v-1z"></path><path d="M10 10h1v1h-1v-1z"></path><path d="M8 10h1v1h-1v-1z"></path><path d="M15 9h1v1h-1v-1z"></path><path d="M13 9h1v1h-1v-1z"></path><path d="M11 9h1v1h-1v-1z"></path><path d="M9 9h1v1h-1v-1z"></path><path d="M14 8h1v1h-1v-1z"></path><path d="M12 8h1v1h-1v-1z"></path><path d="M10 8h1v1h-1v-1z"></path><path d="M8 8h1v1h-1v-1z"></path></g>
<g id="vaadin:raster"><path d="M7 7h1v1h-1v-1z"></path><path d="M5 7h1v1h-1v-1z"></path><path d="M3 7h1v1h-1v-1z"></path><path d="M1 7h1v1h-1v-1z"></path><path d="M6 6h1v1h-1v-1z"></path><path d="M4 6h1v1h-1v-1z"></path><path d="M2 6h1v1h-1v-1z"></path><path d="M0 6h1v1h-1v-1z"></path><path d="M7 5h1v1h-1v-1z"></path><path d="M5 5h1v1h-1v-1z"></path><path d="M3 5h1v1h-1v-1z"></path><path d="M1 5h1v1h-1v-1z"></path><path d="M6 4h1v1h-1v-1z"></path><path d="M4 4h1v1h-1v-1z"></path><path d="M2 4h1v1h-1v-1z"></path><path d="M0 4h1v1h-1v-1z"></path><path d="M7 3h1v1h-1v-1z"></path><path d="M5 3h1v1h-1v-1z"></path><path d="M3 3h1v1h-1v-1z"></path><path d="M1 3h1v1h-1v-1z"></path><path d="M6 2h1v1h-1v-1z"></path><path d="M4 2h1v1h-1v-1z"></path><path d="M2 2h1v1h-1v-1z"></path><path d="M0 2h1v1h-1v-1z"></path><path d="M7 1h1v1h-1v-1z"></path><path d="M5 1h1v1h-1v-1z"></path><path d="M3 1h1v1h-1v-1z"></path><path d="M1 1h1v1h-1v-1z"></path><path d="M6 0h1v1h-1v-1z"></path><path d="M4 0h1v1h-1v-1z"></path><path d="M2 0h1v1h-1v-1z"></path><path d="M0 0h1v1h-1v-1z"></path><path d="M15 7h1v1h-1v-1z"></path><path d="M13 7h1v1h-1v-1z"></path><path d="M11 7h1v1h-1v-1z"></path><path d="M9 7h1v1h-1v-1z"></path><path d="M14 6h1v1h-1v-1z"></path><path d="M12 6h1v1h-1v-1z"></path><path d="M10 6h1v1h-1v-1z"></path><path d="M8 6h1v1h-1v-1z"></path><path d="M15 5h1v1h-1v-1z"></path><path d="M13 5h1v1h-1v-1z"></path><path d="M11 5h1v1h-1v-1z"></path><path d="M9 5h1v1h-1v-1z"></path><path d="M14 4h1v1h-1v-1z"></path><path d="M12 4h1v1h-1v-1z"></path><path d="M10 4h1v1h-1v-1z"></path><path d="M8 4h1v1h-1v-1z"></path><path d="M15 3h1v1h-1v-1z"></path><path d="M13 3h1v1h-1v-1z"></path><path d="M11 3h1v1h-1v-1z"></path><path d="M9 3h1v1h-1v-1z"></path><path d="M14 2h1v1h-1v-1z"></path><path d="M12 2h1v1h-1v-1z"></path><path d="M10 2h1v1h-1v-1z"></path><path d="M8 2h1v1h-1v-1z"></path><path d="M15 1h1v1h-1v-1z"></path><path d="M13 1h1v1h-1v-1z"></path><path d="M11 1h1v1h-1v-1z"></path><path d="M9 1h1v1h-1v-1z"></path><path d="M14 0h1v1h-1v-1z"></path><path d="M12 0h1v1h-1v-1z"></path><path d="M10 0h1v1h-1v-1z"></path><path d="M8 0h1v1h-1v-1z"></path><path d="M7 15h1v1h-1v-1z"></path><path d="M5 15h1v1h-1v-1z"></path><path d="M3 15h1v1h-1v-1z"></path><path d="M1 15h1v1h-1v-1z"></path><path d="M6 14h1v1h-1v-1z"></path><path d="M4 14h1v1h-1v-1z"></path><path d="M2 14h1v1h-1v-1z"></path><path d="M0 14h1v1h-1v-1z"></path><path d="M7 13h1v1h-1v-1z"></path><path d="M5 13h1v1h-1v-1z"></path><path d="M3 13h1v1h-1v-1z"></path><path d="M1 13h1v1h-1v-1z"></path><path d="M6 12h1v1h-1v-1z"></path><path d="M4 12h1v1h-1v-1z"></path><path d="M2 12h1v1h-1v-1z"></path><path d="M0 12h1v1h-1v-1z"></path><path d="M7 11h1v1h-1v-1z"></path><path d="M5 11h1v1h-1v-1z"></path><path d="M3 11h1v1h-1v-1z"></path><path d="M1 11h1v1h-1v-1z"></path><path d="M6 10h1v1h-1v-1z"></path><path d="M4 10h1v1h-1v-1z"></path><path d="M2 10h1v1h-1v-1z"></path><path d="M0 10h1v1h-1v-1z"></path><path d="M7 9h1v1h-1v-1z"></path><path d="M5 9h1v1h-1v-1z"></path><path d="M3 9h1v1h-1v-1z"></path><path d="M1 9h1v1h-1v-1z"></path><path d="M6 8h1v1h-1v-1z"></path><path d="M4 8h1v1h-1v-1z"></path><path d="M2 8h1v1h-1v-1z"></path><path d="M0 8h1v1h-1v-1z"></path><path d="M15 15h1v1h-1v-1z"></path><path d="M13 15h1v1h-1v-1z"></path><path d="M11 15h1v1h-1v-1z"></path><path d="M9 15h1v1h-1v-1z"></path><path d="M14 14h1v1h-1v-1z"></path><path d="M12 14h1v1h-1v-1z"></path><path d="M10 14h1v1h-1v-1z"></path><path d="M8 14h1v1h-1v-1z"></path><path d="M15 13h1v1h-1v-1z"></path><path d="M13 13h1v1h-1v-1z"></path><path d="M11 13h1v1h-1v-1z"></path><path d="M9 13h1v1h-1v-1z"></path><path d="M14 12h1v1h-1v-1z"></path><path d="M12 12h1v1h-1v-1z"></path><path d="M10 12h1v1h-1v-1z"></path><path d="M8 12h1v1h-1v-1z"></path><path d="M15 11h1v1h-1v-1z"></path><path d="M13 11h1v1h-1v-1z"></path><path d="M11 11h1v1h-1v-1z"></path><path d="M9 11h1v1h-1v-1z"></path><path d="M14 10h1v1h-1v-1z"></path><path d="M12 10h1v1h-1v-1z"></path><path d="M10 10h1v1h-1v-1z"></path><path d="M8 10h1v1h-1v-1z"></path><path d="M15 9h1v1h-1v-1z"></path><path d="M13 9h1v1h-1v-1z"></path><path d="M11 9h1v1h-1v-1z"></path><path d="M9 9h1v1h-1v-1z"></path><path d="M14 8h1v1h-1v-1z"></path><path d="M12 8h1v1h-1v-1z"></path><path d="M10 8h1v1h-1v-1z"></path><path d="M8 8h1v1h-1v-1z"></path></g>
<g id="vaadin:records"><path d="M4 9h4v2h-4v-2z"></path><path d="M16 2h-1v-2h-10v2h-2v1.25l-0.6 0.75h-1.4v1.75l-1 1.25v9h12l4-5v-9zM2 5h8v2h-8v-2zM11 15h-10v-7h10v7zM12 7h-1v-3h-7v-1h8v4zM14 4.5l-1 1.25v-3.75h-7v-1h8v3.5z"></path></g>
<g id="vaadin:recycle"><path d="M8 3.1l1.4 2.2-1.6 1.1 1.3 0.3 2.8 0.6 0.6-2.7 0.4-1.4-1.8 1.1-2-3.3h-2.2l-2.6 4.3 1.7 1z"></path><path d="M16 12l-2.7-4.3-1.7 1 2 3.3h-2.6v-2l-3 3 3 3v-2h3.7z"></path><path d="M2.4 12v0l1.4-2.3 1.7 1.1-0.9-4.2-2.8 0.7-1.3 0.3 1.6 1-2.1 3.4 1.3 2h5.7v-2z"></path></g>
<g id="vaadin:refresh"><path d="M2.6 5.6c0.9-2.1 3-3.6 5.4-3.6 3 0 5.4 2.2 5.9 5h2c-0.5-3.9-3.8-7-7.9-7-3 0-5.6 1.6-6.9 4.1l-1.1-1.1v4h4l-1.4-1.4z"></path><path d="M16 9h-4.1l1.5 1.4c-0.9 2.1-3 3.6-5.5 3.6-2.9 0-5.4-2.2-5.9-5h-2c0.5 3.9 3.9 7 7.9 7 3 0 5.6-1.7 7-4.1l1.1 1.1v-4z"></path></g>
<g id="vaadin:reply-all"><path d="M16 8c0-5-4.9-5-4.9-5h-2.1v-3l-6 6 6 6v-3h2.2c3.5 0 1.8 7 1.8 7s3-4.1 3-8z"></path><path d="M0 6l6 6v-1.5l-4.5-4.5 4.5-4.5v-1.5z"></path></g>
<g id="vaadin:reply"><path d="M16 8c0-5-4.9-5-4.9-5h-5.1v-3l-6 6 6 6v-3h5.2c3.5 0 1.8 7 1.8 7s3-4.1 3-8z"></path></g>
<g id="vaadin:resize-h"><path d="M0 7h16v2h-16v-2z"></path><path d="M7 6h2v-3h2l-3-3-3 3h2z"></path><path d="M9 10h-2v3h-2l3 3 3-3h-2z"></path></g>
<g id="vaadin:resize-v"><path d="M7 0h2v16h-2v-16z"></path><path d="M3 5l-3 3 3 3v-2h3v-2h-3z"></path><path d="M16 8l-3-3v2h-3v2h3v2z"></path></g>
<g id="vaadin:retweet"><path d="M2 1h12v5h2l-3 3-3-3h2v-3h-8v2h-2z"></path><path d="M14 14h-12v-5h-2l3-3 3 3h-2v3h8v-2h2z"></path></g>
<g id="vaadin:rhombus"><path d="M8 0l-8 8 8 8 8-8-8-8zM2 8l6-6 6 6-6 6-6-6z"></path></g>
<g id="vaadin:road-branch"><path d="M16 4h-16v3h3.2l3.8 3.6c1.6 1.5 3.6 2.4 5.8 2.4h3.2v-3h-3.2c-1.4 0-2.7-0.5-3.7-1.5l-1.6-1.5h8.5v-3z"></path></g>
<g id="vaadin:road-branches"><path d="M16 4v-3h-16v3h1.7l7.7 9.5c1.3 1.6 3.1 2.5 5 2.5h1.6v-3h-1.5c-1 0-1.9-0.5-2.7-1.4l-1.3-1.6h5.5v-3h-8l-2.4-3h10.4z"></path></g>
<g id="vaadin:road-split"><path d="M14 13v-1c0-0.2 0-4.1-2.8-5.4-2.2-1-2.2-3.5-2.2-3.6v-3h-2v3c0 0.1 0 2.6-2.2 3.6-2.8 1.3-2.8 5.2-2.8 5.4v1h-2l3 3 3-3h-2v-1c0 0 0-2.8 1.7-3.6 1.1-0.5 1.8-1.3 2.3-2 0.5 0.8 1.2 1.5 2.3 2 1.7 0.8 1.7 3.6 1.7 3.6v1h-2l3 3 3-3h-2z"></path></g>
<g id="vaadin:road"><path d="M9 11v4h7l-4-14h-3v3h-2v-3h-3l-4 14h7v-4h2zM7 6h2v3h-2v-3z"></path></g>
<g id="vaadin:rocket"><path d="M16 0c0 0-3.5-0.4-6.7 2.8-1.6 1.5-2.9 3.5-3.9 5.3l-2.5-0.6-1.6 1.6 2.8 1.4c-0.3 0.6-0.4 1-0.4 1l0.8 0.8c0 0 0.4-0.2 1-0.4l1.4 2.8 1.6-1.6-0.5-2.5c1.7-1 3.8-2.3 5.3-3.8 3.1-3.2 2.7-6.8 2.7-6.8zM12.8 4.8c-0.4 0.4-1.1 0.4-1.6 0-0.4-0.4-0.4-1.1 0-1.6 0.4-0.4 1.1-0.4 1.6 0 0.4 0.4 0.4 1.1 0 1.6z"></path><path d="M4 14.2c-0.8 0.8-2.6 0.4-2.6 0.4s-0.4-1.8 0.4-2.6c0.8-0.8 1.5-0.9 1.5-0.9s-1.3-0.3-2.1 0.6c-1.6 1.6-1 4.2-1 4.2s2.6 0.6 4.2-1c0.9-0.9 0.6-2.2 0.6-2.2s-0.2 0.7-1 1.5z"></path></g>
<g id="vaadin:rotate-left"><path d="M8 0c-3 0-5.6 1.6-6.9 4.1l-1.1-1.1v4h4l-1.5-1.5c1-2 3.1-3.5 5.5-3.5 3.3 0 6 2.7 6 6s-2.7 6-6 6c-1.8 0-3.4-0.8-4.5-2.1l-1.5 1.3c1.4 1.7 3.6 2.8 6 2.8 4.4 0 8-3.6 8-8s-3.6-8-8-8z"></path></g>
<g id="vaadin:rotate-right"><path d="M16 7v-4l-1.1 1.1c-1.3-2.5-3.9-4.1-6.9-4.1-4.4 0-8 3.6-8 8s3.6 8 8 8c2.4 0 4.6-1.1 6-2.8l-1.5-1.3c-1.1 1.3-2.7 2.1-4.5 2.1-3.3 0-6-2.7-6-6s2.7-6 6-6c2.4 0 4.5 1.5 5.5 3.5l-1.5 1.5h4z"></path></g>
<g id="vaadin:rss-square"><path d="M0 0v16h16v-16h-16zM3.6 14c-0.9 0-1.6-0.7-1.6-1.6s0.7-1.6 1.6-1.6 1.6 0.7 1.6 1.6-0.6 1.6-1.6 1.6zM7.6 14c0-3.1-2.5-5.6-5.6-5.6v-2.4c4.4 0 8 3.6 8 8h-2.4zM11.6 14c0-5.3-4.3-9.6-9.6-9.6v-2.4c6.6 0 12 5.4 12 12h-2.4z"></path></g>
<g id="vaadin:rss"><path d="M4.4 13.8c0 1.215-0.985 2.2-2.2 2.2s-2.2-0.985-2.2-2.2c0-1.215 0.985-2.2 2.2-2.2s2.2 0.985 2.2 2.2z"></path><path d="M10.6 16h-3.1c0-4.1-3.4-7.5-7.5-7.5v0-3.1c5.9 0 10.6 4.7 10.6 10.6z"></path><path d="M12.8 16c0-7.1-5.7-12.8-12.8-12.8v-3.2c8.8 0 16 7.2 16 16h-3.2z"></path></g>
<g id="vaadin:safe-lock"><path d="M8 0c-4.418 0-8 3.582-8 8s3.582 8 8 8c4.418 0 8-3.582 8-8s-3.582-8-8-8zM11.13 14.25l-0.37-0.9-0.92 0.38 0.37 0.9c-0.659 0.23-1.419 0.363-2.21 0.363s-1.551-0.133-2.259-0.378l0.419-0.885-0.92-0.38-0.37 0.9c-1.355-0.69-2.43-1.765-3.102-3.080l0.882-0.41-0.38-0.93-0.9 0.37c-0.23-0.659-0.363-1.419-0.363-2.21s0.133-1.551 0.378-2.259l0.885 0.419 0.38-0.92-0.9-0.37c0.691-1.351 1.766-2.423 3.080-3.092l0.41 0.882 0.92-0.38-0.37-0.9c0.659-0.23 1.419-0.363 2.21-0.363s1.551 0.133 2.259 0.378l-0.419 0.885 0.92 0.38 0.37-0.9c1.355 0.69 2.43 1.765 3.102 3.080l-0.882 0.41 0.38 0.92 0.9-0.37c0.23 0.659 0.363 1.419 0.363 2.21s-0.133 1.551-0.378 2.259l-0.885-0.419-0.38 0.92 0.9 0.37c-0.69 1.355-1.765 2.43-3.080 3.102z"></path><path d="M10.36 3.62l-1.16 2.79c-0.329-0.253-0.746-0.407-1.199-0.41h0.279l1.15-2.77c-0.426-0.14-0.917-0.223-1.427-0.23-0.023-0-0.047-0-0.071-0-2.795 0-5.060 2.265-5.060 5.060s2.265 5.060 5.060 5.060c2.795 0 5.060-2.265 5.060-5.060 0-1.904-1.052-3.563-2.606-4.426z"></path></g>
<g id="vaadin:safe"><path d="M1 0v16h3v-1h8v1h3v-16h-14zM14 10h-1v-5h1v5zM14 3h-1v-1h-10v11h10v-1h1v2h-12v-13h12v2zM8.5 7.5c0 1.1-0.9 2-2 2s-2-0.9-2-2 0.9-2 2-2 2 0.9 2 2z"></path><path d="M7.5 7.5c0 0.552-0.448 1-1 1s-1-0.448-1-1c0-0.552 0.448-1 1-1s1 0.448 1 1z"></path></g>
<g id="vaadin:scale-unbalance"><path d="M15.81 9l-2.47-4.93 0.83-0.15c0.239-0.044 0.418-0.251 0.418-0.5 0-0.281-0.227-0.508-0.508-0.508-0.032 0-0.063 0.003-0.093 0.009l-0.777 0.14c-0.993-0.755-2.25-1.21-3.613-1.21-0.21 0-0.418 0.011-0.623 0.032-0.036-0.5-0.457-0.882-0.967-0.882-0.003 0-0.005 0-0.008 0-0.552 0-1 0.448-1 1v0.2c-1.714 0.336-3.151 1.327-4.066 2.697l-0.754 0.153c-0.257 0.024-0.457 0.239-0.457 0.5 0 0.277 0.225 0.502 0.502 0.502 0.016 0 0.032-0.001 0.047-0.002l0.088 0 0.35-0.050-2.52 5h-0.19c0 1.1 1.34 2 3 2s3-0.9 3-2h-0.19l-2.56-5.12h0.1c0.172-0.031 0.311-0.144 0.379-0.297 0.021-0.093 0.701-1.583 3.271-2.363v10.78h-1v1h-2v1h8v-1h-2v-1h-1v-11.12c0.201-0.031 0.434-0.049 0.67-0.049 1.152 0 2.205 0.419 3.016 1.114l-0.006-0.005-2.49 5.060h-0.19c0 1.1 1.34 2 3 2s3-0.9 3-2h-0.19zM5 11h-4l2-3.94zM11 9l2-3.94 2 3.94h-4z"></path></g>
<g id="vaadin:scale"><path d="M15.81 10l-2.5-5h0.69c0.276 0 0.5-0.224 0.5-0.5s-0.224-0.5-0.5-0.5h-0.79c-1.056-1.145-2.541-1.881-4.198-1.95l-0.012-0.050c0-0.552-0.448-1-1-1s-1 0.448-1 1v0.050c-1.681 0.073-3.178 0.807-4.247 1.947l-0.753 0.003c-0.276 0-0.5 0.224-0.5 0.5s0.224 0.5 0.5 0.5h0.69l-2.5 5h-0.19c0 1.1 1.34 2 3 2s3-0.9 3-2h-0.19l-2.55-5.090c0.064-0.039 0.118-0.089 0.159-0.148 0.873-1.019 2.148-1.669 3.575-1.702l0.006 10.94h-1v1h-2v1h8v-1h-2v-1h-1v-10.94c1.418 0.030 2.679 0.682 3.524 1.693 0.053 0.084 0.117 0.145 0.193 0.186l-2.527 5.061h-0.19c0 1.1 1.34 2 3 2s3-0.9 3-2h-0.19zM5 10h-4l2-3.94zM11 10l2-3.94 2 3.94h-4z"></path></g>
<g id="vaadin:scatter-chart"><path d="M1 15v-15h-1v16h16v-1h-15z"></path><path d="M5 11c0 0.552-0.448 1-1 1s-1-0.448-1-1c0-0.552 0.448-1 1-1s1 0.448 1 1z"></path><path d="M8 6c0 0.552-0.448 1-1 1s-1-0.448-1-1c0-0.552 0.448-1 1-1s1 0.448 1 1z"></path><path d="M14 5c0 0.552-0.448 1-1 1s-1-0.448-1-1c0-0.552 0.448-1 1-1s1 0.448 1 1z"></path><path d="M11 10c0 0.552-0.448 1-1 1s-1-0.448-1-1c0-0.552 0.448-1 1-1s1 0.448 1 1z"></path></g>
<g id="vaadin:scissors"><path d="M16 3.1c0 0-2.1-1.1-3.5-1-0.3 0-0.5 0.1-0.7 0.2l-4.3 3.4-1.8-1.5c0.1-0.3 0.2-0.6 0.3-1 0.1-1.8-1.4-3.4-3.3-3.2-1.2 0.1-2.3 1-2.6 2.2-0.3 1.3 0.2 2.5 1.2 3.2l3.3 2.6-3.3 2.6c-1 0.7-1.5 1.9-1.2 3.2 0.3 1.2 1.4 2 2.6 2.2 1.9 0.2 3.4-1.4 3.2-3.2 0-0.3-0.1-0.7-0.3-1l1.8-1.5 4.3 3.4c0.2 0.1 0.4 0.2 0.7 0.2 1.4 0.1 3.5-1 3.5-1l-5.7-4.9 5.8-4.9zM2.8 4.6c-0.9-0.1-1.6-0.9-1.5-1.8s0.9-1.6 1.8-1.5c0.9 0.1 1.6 0.9 1.5 1.8 0 0.9-0.9 1.6-1.8 1.5zM3.1 14.7c-0.9 0.1-1.7-0.6-1.8-1.5s0.6-1.7 1.5-1.8c0.9-0.1 1.7 0.6 1.8 1.5s-0.6 1.7-1.5 1.8zM12.4 3.2c0 0 0.1 0 0.2 0 0.4 0 0.9 0.1 1.4 0.2l-6.8 5.7-0.9-1.1 6.1-4.8zM14 12.6c-0.5 0.2-1 0.3-1.4 0.2-0.1 0-0.2 0-0.2 0l-4-3.2 1-0.9 4.6 3.9z"></path></g>
<g id="vaadin:screwdriver"><path d="M8 10.8l0.9-0.8-0.9-0.9 5.7-5.7 1.2-0.4 1.1-2.2-0.7-0.7-2.3 1-0.5 1.2-5.6 5.7-0.9-0.9-0.8 0.9c0 0 0.8 0.6-0.1 1.5-0.5 0.5-1.3-0.1-2.8 1.4-0.5 0.5-2.1 2.1-2.1 2.1s-0.6 1 0.6 2.2 2.2 0.6 2.2 0.6 1.6-1.6 2.1-2.1c1.4-1.4 0.9-2.3 1.3-2.7 0.9-0.9 1.6-0.2 1.6-0.2zM4.9 10.4l0.7 0.7-3.8 3.8-0.7-0.7z"></path></g>
<g id="vaadin:search-minus"><path d="M15.7 14.3l-4.2-4.2c-0.2-0.2-0.5-0.3-0.8-0.3 0.8-1 1.3-2.4 1.3-3.8 0-3.3-2.7-6-6-6s-6 2.7-6 6 2.7 6 6 6c1.4 0 2.8-0.5 3.8-1.4 0 0.3 0 0.6 0.3 0.8l4.2 4.2c0.2 0.2 0.5 0.3 0.7 0.3s0.5-0.1 0.7-0.3c0.4-0.3 0.4-0.9 0-1.3zM6 10.5c-2.5 0-4.5-2-4.5-4.5s2-4.5 4.5-4.5 4.5 2 4.5 4.5-2 4.5-4.5 4.5z"></path><path d="M3 5h6v2h-6v-2z"></path></g>
<g id="vaadin:search-plus"><path d="M15.7 14.3l-4.2-4.2c-0.2-0.2-0.5-0.3-0.8-0.3 0.8-1 1.3-2.4 1.3-3.8 0-3.3-2.7-6-6-6s-6 2.7-6 6 2.7 6 6 6c1.4 0 2.8-0.5 3.8-1.4 0 0.3 0 0.6 0.3 0.8l4.2 4.2c0.2 0.2 0.5 0.3 0.7 0.3s0.5-0.1 0.7-0.3c0.4-0.3 0.4-0.9 0-1.3zM6 10.5c-2.5 0-4.5-2-4.5-4.5s2-4.5 4.5-4.5 4.5 2 4.5 4.5-2 4.5-4.5 4.5z"></path><path d="M7 3h-2v2h-2v2h2v2h2v-2h2v-2h-2z"></path></g>
<g id="vaadin:search"><path d="M15.7 14.3l-4.2-4.2c-0.2-0.2-0.5-0.3-0.8-0.3 0.8-1 1.3-2.4 1.3-3.8 0-3.3-2.7-6-6-6s-6 2.7-6 6 2.7 6 6 6c1.4 0 2.8-0.5 3.8-1.4 0 0.3 0 0.6 0.3 0.8l4.2 4.2c0.2 0.2 0.5 0.3 0.7 0.3s0.5-0.1 0.7-0.3c0.4-0.3 0.4-0.9 0-1.3zM6 10.5c-2.5 0-4.5-2-4.5-4.5s2-4.5 4.5-4.5 4.5 2 4.5 4.5-2 4.5-4.5 4.5z"></path></g>
<g id="vaadin:select"><path d="M15 4h-14c-0.6 0-1 0.4-1 1v6c0 0.6 0.4 1 1 1h14c0.6 0 1-0.4 1-1v-6c0-0.6-0.4-1-1-1zM12 9l-2-2h4l-2 2z"></path></g>
<g id="vaadin:server"><path d="M3 5v3h10v-3h-10zM7 7h-3v-1h3v1z"></path><path d="M3 4h10l-2-4h-6z"></path><path d="M3 12h10v-3h-10v3zM11 10h1v1h-1v-1zM9 10h1v1h-1v-1z"></path><path d="M3 16h10v-3h-10v3zM4 14h3v1h-3v-1z"></path></g>
<g id="vaadin:share-square"><path d="M11 3h-3.6c0 0-4.4-0.2-4.4 4.3 0 3.5 2 6.7 2 6.7s-0.4-7 2.3-7h3.7v3l5-5-5-5v3z"></path><path d="M14 9v6h-13v-13h9v-1h-10v15h15v-8z"></path></g>
<g id="vaadin:share"><path d="M10 3h-5.1c0 0-4.9 0-4.9 5 0 3.9 3 8 3 8s-1.7-7 1.8-7h5.2v3l6-6-6-6v3z"></path></g>
<g id="vaadin:shield"><path d="M1 0c0 0 0 3.2 0 7 0 5.6 7 9 7 9s7-3.4 7-9c0-3.8 0-7 0-7h-14zM14 7c0 4.2-4.6 7.1-6 7.9v-13.9h6v6z"></path></g>
<g id="vaadin:shift-arrow"><path d="M8 2l-7 7h4v5h6v-5h4zM10 8v5h-4v-5h-2.5l4.5-4.58 4.5 4.58h-2.5z"></path></g>
<g id="vaadin:shift"><path d="M0 2v12h16v-12h-16zM6 8v3h-2v-3h-2l3-3 3 3h-2z"></path></g>
<g id="vaadin:shop"><path d="M0 15h16v1h-16v-1z"></path><path d="M0 0v6c0.005 0.732 0.401 1.37 0.991 1.715l0.009 6.285h9v-5h3v5h2v-6.28c0.599-0.35 0.995-0.988 1-1.719v-6.001h-16zM4 2h2v4c0 0.552-0.448 1-1 1s-1-0.448-1-1v-4zM2 7c-0.552 0-1-0.448-1-1v-4h2v4c0 0.552-0.448 1-1 1zM8 12h-5v-3h5v3zM9 6c0 0.552-0.448 1-1 1s-1-0.448-1-1v-4h2v4zM12 6c0 0.552-0.448 1-1 1s-1-0.448-1-1v-4h2v4zM15 6c0 0.552-0.448 1-1 1s-1-0.448-1-1v-4h2v4z"></path></g>
<g id="vaadin:sign-in-alt"><path d="M0 0h2v16h-2v-16z"></path><path d="M3 10h8v3l5-5-5-5v3h-8z"></path></g>
<g id="vaadin:sign-in"><path d="M7 1v2l1 1v-2h7v12h-7v-2l-1 1v2h9v-14z"></path><path d="M10 8l-5-4v2h-5v4h5v2z"></path></g>
<g id="vaadin:sign-out-alt"><path d="M14 0h2v16h-2v-16z"></path><path d="M8 6h-8v4h8v3l5-5-5-5z"></path></g>
<g id="vaadin:sign-out"><path d="M9 4v-3h-9v14h9v-3h-1v2h-7v-12h7v2z"></path><path d="M16 8l-5-4v2h-5v4h5v2z"></path></g>
<g id="vaadin:signal"><path d="M6.9 13.2l1.1 1.1 1.1-1.1c-0.3-0.3-0.7-0.5-1.1-0.5s-0.9 0.2-1.1 0.5z"></path><path d="M8 4.6c2.7 0 5.1 1.1 6.9 2.8l1.1-1.1c-2-2-4.9-3.3-8-3.3s-6 1.3-8 3.3l1.1 1.1c1.8-1.7 4.2-2.8 6.9-2.8z"></path><path d="M2.3 8.6l1.1 1.1c1.2-1.1 2.8-1.8 4.6-1.8s3.4 0.7 4.6 1.9l1.1-1.1c-1.4-1.6-3.5-2.5-5.7-2.5s-4.3 0.9-5.7 2.4z"></path><path d="M4.6 10.9l1.1 1.1c0.6-0.6 1.4-0.9 2.3-0.9s1.7 0.4 2.3 0.9l1.1-1.1c-0.8-0.9-2.1-1.4-3.4-1.4s-2.6 0.5-3.4 1.4z"></path></g>
<g id="vaadin:sitemap"><path d="M14.5 12v-4.5h-6v-3.5h1.5v-4h-4v4h1.5v3.5h-6v4.5h-1.5v4h4v-4h-1.5v-3.5h5v3.5h-1.5v4h4v-4h-1.5v-3.5h5v3.5h-1.5v4h4v-4z"></path></g>
<g id="vaadin:slider"><path d="M16 6h-3.6c-0.7-1.2-2-2-3.4-2s-2.8 0.8-3.4 2h-5.6v4h5.6c0.7 1.2 2 2 3.4 2s2.8-0.8 3.4-2h3.6v-4zM1 9v-2h4.1c0 0.3-0.1 0.7-0.1 1s0.1 0.7 0.1 1h-4.1zM9 11c-1.7 0-3-1.3-3-3s1.3-3 3-3 3 1.3 3 3c0 1.7-1.3 3-3 3z"></path></g>
<g id="vaadin:sliders"><path d="M7 0h2v3h-2v-3z"></path><path d="M6 4v3h1v9h2v-9h1v-3z"></path><path d="M2 0h2v8h-2v-8z"></path><path d="M1 9v3h1v4h2v-4h1v-3z"></path><path d="M12 0h2v10h-2v-10z"></path><path d="M11 11v3h1v2h2v-2h1v-3z"></path></g>
<g id="vaadin:smiley-o"><path d="M8 1c3.9 0 7 3.1 7 7s-3.1 7-7 7-7-3.1-7-7 3.1-7 7-7zM8 0c-4.4 0-8 3.6-8 8s3.6 8 8 8 8-3.6 8-8-3.6-8-8-8v0z"></path><path d="M8 13.2c-2 0-3.8-1.2-4.6-3.1l0.9-0.4c0.6 1.5 2.1 2.4 3.7 2.4s3.1-1 3.7-2.4l0.9 0.4c-0.8 2-2.6 3.1-4.6 3.1z"></path><path d="M7 6c0 0.552-0.448 1-1 1s-1-0.448-1-1c0-0.552 0.448-1 1-1s1 0.448 1 1z"></path><path d="M11 6c0 0.552-0.448 1-1 1s-1-0.448-1-1c0-0.552 0.448-1 1-1s1 0.448 1 1z"></path></g>
<g id="vaadin:sort"><path d="M11 7h-6l3-4z"></path><path d="M5 9h6l-3 4z"></path></g>
<g id="vaadin:sound-disable"><path d="M4 5h-4v6h4l5 4v-14z"></path><path d="M15.9 5.6l-0.8-0.7-2.3 2.4-2.4-2.4-0.8 0.7 2.4 2.4-2.4 2.4 0.8 0.7 2.4-2.4 2.3 2.4 0.8-0.7-2.4-2.4z"></path></g>
<g id="vaadin:spark-line"><path d="M14 6c-1.105 0-2 0.895-2 2 0 0.060 0 0.11 0 0.16l-0.81 0.25-2.3-3.48-1.73 4.32-1.16-5.81-2.3 4.78-1.64-1.31-2.060 1.090v1.080l1.94-1 2.11 1.7 1.56-3.22 1.23 6.19 2.27-5.68 1.68 2.52 1.55-0.48c0.364 0.54 0.973 0.89 1.664 0.89 1.105 0 2-0.895 2-2s-0.895-2-2-2c-0.001 0-0.003 0-0.004 0zM14 9c-0.552 0-1-0.448-1-1s0.448-1 1-1c0.552 0 1 0.448 1 1s-0.448 1-1 1z"></path></g>
<g id="vaadin:specialist"><path d="M4.1 8c0.2 0.6 0.3 1.1 0.3 1.1 0.8 1.3 1.8 1.1 1.8 1.8 0 0.3-0.2 0.6-0.5 0.7l2.3 1.8 2.3-1.7c-0.3-0.2-0.5-0.4-0.5-0.7 0-0.8 1-0.5 1.8-1.8 0 0 0.2-0.4 0.3-1.1v0c0.3-1.1 0.6-3.1 0.5-4.1h-1.5c0-0.3 0.1-0.6 0.1-1h1.1c-0.3-1.4-1-2-2.2-2.3-0.5-0.4-1.2-0.7-1.9-0.7s-1.4 0.3-1.9 0.7c-1.2 0.3-1.8 0.9-2.2 2.3h1.1c0 0.4 0.1 0.7 0.2 1h-1.6c-0.1 1 0.2 3 0.5 4v0zM11.2 8.5c-0.1 0.1-0.2 0.2-0.3 0.3l-0.5 0.6c-0.4 0.5-0.8 0.8-1.4 0.9l-0.4 0.1c-0.4 0.1-0.9 0.1-1.4 0l-0.4-0.1c-0.6-0.2-1.1-0.5-1.5-1.1l-0.2-0.4c-0.1-0.1-0.2-0.2-0.3-0.3l-0.7-0.5 3.1-0.9c0.5-0.1 1-0.2 1.5 0l3.2 0.9-0.7 0.5zM6 3c0-1.1 0.9-2 2-2s2 0.9 2 2c0 1.1-0.9 2-2 2s-2-0.9-2-2z"></path><path d="M15.5 14.2c-1.3-2.4-2.6-2-3.9-2.2 0 0 0 0-0.1 0l-3.5 2.6-3.5-2.6c0 0 0 0-0.1 0-1.4 0.1-2.6-0.2-3.9 2.2-0.2 0.4-0.4 1.1-0.5 1.8h16c-0.1-0.7-0.3-1.4-0.5-1.8z"></path></g>
<g id="vaadin:spinner-arc"><path d="M15 8c0 3.9-3.1 7-7 7s-7-3-7-7h-1c0 4 3.6 8 8 8s8-3.6 8-8h-1z"></path></g>
<g id="vaadin:spinner-third"><path d="M12.9 3.1c1.3 1.2 2.1 3 2.1 4.9 0 3.9-3.1 7-7 7s-7-3.1-7-7c0-1.9 0.8-3.7 2.1-4.9l-0.8-0.8c-1.4 1.5-2.3 3.5-2.3 5.7 0 4.4 3.6 8 8 8s8-3.6 8-8c0-2.2-0.9-4.2-2.3-5.7l-0.8 0.8z"></path></g>
<g id="vaadin:spinner"><path d="M9.9 0.2l-0.2 1c3 0.8 5.3 3.5 5.3 6.8 0 3.9-3.1 7-7 7s-7-3.1-7-7c0-3.3 2.3-6 5.3-6.8l-0.2-1c-3.5 0.9-6.1 4.1-6.1 7.8 0 4.4 3.6 8 8 8s8-3.6 8-8c0-3.7-2.6-6.9-6.1-7.8z"></path></g>
<g id="vaadin:spline-area-chart"><path d="M1 15v-15h-1v16h16v-1h-15z"></path><path d="M10 7c-2 0-2.080-1-4-1-2.34 0-4 3-4 3v5h14v-12c-2 0-3.86 5-6 5z"></path></g>
<g id="vaadin:spline-chart"><path d="M1 15v-15h-1v16h16v-1h-15z"></path><path d="M12 5c-0.69 1-1.41 2-2 2-0.026 0.001-0.056 0.001-0.087 0.001-0.601 0-1.164-0.16-1.65-0.44-0.623-0.35-1.387-0.562-2.2-0.562-0.022 0-0.045 0-0.067 0-1.6 0.116-3.009 0.864-3.991 1.993l-0.006 2.347c0.77-1.12 2.32-2.84 4-2.84 0.014-0 0.031-0 0.048-0 0.579 0 1.121 0.156 1.587 0.428 0.643 0.358 1.429 0.573 2.264 0.573 0.035 0 0.071-0 0.106-0.001 1.395 0 2.335-1.32 3.245-2.6s1.75-2.4 2.75-2.4v-1.5c-1.81 0-3 1.61-4 3z"></path></g>
<g id="vaadin:split-h"><path d="M0 1v14h16v-14h-16zM1 4h6.5v10h-6.5v-10zM15 14h-6.5v-10h6.5v10zM15 3h-1v-1h1v1z"></path></g>
<g id="vaadin:split-v"><path d="M0 1v14h16v-14h-16zM14 2h1v1h-1v-1zM15 4v4.5h-14v-4.5h14zM1 14v-4.5h14v4.5h-14z"></path></g>
<g id="vaadin:split"><path d="M0 11h6v5h-6v-5z"></path><path d="M11 10v-2l-0.64 0.64c-0.851-0.81-1.38-1.952-1.38-3.217 0-0.149 0.007-0.296 0.022-0.441l1.999 0.018v-5h-6v5h2c0.013 0.127 0.020 0.274 0.020 0.423 0 1.265-0.529 2.407-1.378 3.216l-0.642-0.638v2h2l-0.65-0.65c1.028-0.991 1.667-2.38 1.667-3.919 0-0.152-0.006-0.302-0.018-0.45-0.010 0.149-0.016 0.299-0.016 0.45 0 1.539 0.639 2.928 1.665 3.917l-0.648 0.652h2z"></path><path d="M10 11h6v5h-6v-5z"></path></g>
<g id="vaadin:spoon"><path d="M10.5 4.8c0-1.8-0.9-4.8-3-4.8s-3 3-3 4.8c0 1.5 0.8 2.8 2.2 3.1-0.5 1.6-0.7 4.6-0.7 4.6v2c0 0.8 0.7 1.5 1.5 1.5s1.5-0.7 1.5-1.5v-2c0-0.6-0.2-3.2-0.7-4.6 1.4-0.3 2.2-1.6 2.2-3.1z"></path></g>
<g id="vaadin:square-shadow"><path d="M14 2v-2h-14v14h2v2h14v-14h-2zM13 13h-12v-12h12v12z"></path></g>
<g id="vaadin:star-half-left-o"><path d="M15.9 6.2l-5.5-0.8-2.4-5-2.4 5-5.5 0.8 3.9 3.8-0.9 5.4 4.9-2.5 4.9 2.6-0.9-5.5 3.9-3.8zM8 11.8v-9.1l1.8 3.6 4 0.6-2.9 2.8 0.7 4-3.6-1.9z"></path></g>
<g id="vaadin:star-half-left"><path d="M5.6 5.4l-5.5 0.8 3.9 3.8-0.9 5.5 4.9-2.6v-12.5z"></path></g>
<g id="vaadin:star-half-right-o"><path d="M15.9 6.2l-5.5-0.8-2.4-5-2.4 5-5.5 0.8 3.9 3.8-0.9 5.4 4.9-2.5 4.9 2.6-0.9-5.5 3.9-3.8zM4.4 13.7l0.7-4-2.9-2.8 4-0.6 1.8-3.6v9.1l-3.6 1.9z"></path></g>
<g id="vaadin:star-half-right"><path d="M10.5 5.4l5.5 0.8-4 3.8 0.9 5.5-4.9-2.6v-12.5z"></path></g>
<g id="vaadin:star-o"><path d="M15.9 6.2l-5.5-0.8-2.4-5-2.4 5-5.5 0.8 3.9 3.8-0.9 5.4 4.9-2.5 4.9 2.6-0.9-5.5 3.9-3.8zM8 11.8l-3.6 1.9 0.7-4-2.9-2.8 4-0.6 1.8-3.6 1.8 3.6 4 0.6-2.9 2.8 0.7 4-3.6-1.9z"></path></g>
<g id="vaadin:star"><path d="M12.9 15.4l-4.9-2.6-4.9 2.6 0.9-5.4-4-3.9 5.5-0.8 2.4-5 2.4 5 5.5 0.8-3.8 3.9 0.9 5.4z"></path></g>
<g id="vaadin:start-cog"><path d="M4 0v6h1.7l0.2 0.7 0.2 0.6c0 0 0.1 0 0.1 0l1.2-0.6 1.8 1.8-0.6 1.2c0 0 0 0.1 0 0.1l0.6 0.2 0.7 0.2v0.2l6.1-3.4-12-7z"></path><path d="M4.5 10.5c-0.2 0-0.4 0.1-0.5 0.2-0.3 0.2-0.5 0.5-0.5 0.8s0.2 0.7 0.5 0.8c0.1 0.1 0.3 0.2 0.5 0.2 0.6 0 1-0.4 1-1s-0.4-1-1-1z"></path><path d="M9 12v-1l-1.1-0.4c-0.1-0.3-0.2-0.6-0.4-0.9l0.5-1-0.7-0.7-1 0.5c-0.3-0.2-0.6-0.3-0.9-0.4l-0.4-1.1h-1l-0.4 1.1c-0.3 0.1-0.6 0.2-0.9 0.4l-1-0.5-0.7 0.7 0.5 1.1c-0.2 0.3-0.3 0.6-0.4 0.9l-1.1 0.3v1l1.1 0.4c0.1 0.3 0.2 0.6 0.4 0.9l-0.5 1 0.7 0.7 1.1-0.5c0.3 0.2 0.6 0.3 0.9 0.4l0.3 1.1h1l0.4-1.1c0.3-0.1 0.6-0.2 0.9-0.4l1 0.5 0.7-0.7-0.5-1.1c0.2-0.3 0.3-0.6 0.4-0.9l1.1-0.3zM4.5 13.5c-1.1 0-2-0.9-2-2s0.9-2 2-2 2 0.9 2 2c0 1.1-0.9 2-2 2z"></path></g>
<g id="vaadin:step-backward"><path d="M14 15v-14l-10 7z"></path><path d="M2 1h2v14h-2v-14z"></path></g>
<g id="vaadin:step-forward"><path d="M2 1v14l10-7z"></path><path d="M12 1h2v14h-2v-14z"></path></g>
<g id="vaadin:stethoscope"><path d="M5.7 15.2c0.3 0.3 1 0.8 1.8 0.8 2.7 0 3.3-2 3.4-3.6 0.2-2.3 0.8-2.2 1.1-2.2 0.7 0 0.9 0.4 0.9 1.1-0.6 0.4-1 1-1 1.7 0 1.1 0.9 2 2 2s2-0.9 2-2-0.9-2-2-2c-0.1 0-0.1 0-0.2 0-0.2-0.9-0.7-1.8-1.8-1.8-1.6 0-2 1.4-2.1 2.9-0.1 2.1-0.8 2.9-2.3 2.9-0.4 0-0.8-0.2-1-0.4-0.6-0.5-0.5-2.3-0.5-2.3 2 0 4-1.8 4.7-4.8l-0.2-0.1c0.3-1.2 0.5-2.6 0.5-3.6 0-1.1-0.3-1.9-1-2.5s-1.5-0.8-2.1-0.8c-0.2-0.3-0.5-0.5-0.9-0.5-0.5 0-1 0.4-1 1s0.4 1 1 1c0.4 0 0.7-0.2 0.8-0.5 0.5 0 1 0.2 1.5 0.6s0.7 0.9 0.7 1.7c0 0.9-0.2 2.2-0.5 3.5l-0.2-0.1c-0.3 1.1-1.3 3.6-3.3 3.6h-1c-2 0-3-2.5-3.3-3.6l-0.2 0.1c-0.3-1.3-0.5-2.6-0.5-3.5 0-0.8 0.2-1.3 0.7-1.7 0.4-0.4 1-0.5 1.5-0.6 0.1 0.3 0.4 0.5 0.8 0.5 0.6 0 1-0.4 1-1s-0.4-1-1-1c-0.4 0-0.7 0.2-0.9 0.5-0.6 0-1.4 0.2-2.1 0.8s-1 1.4-1 2.5c0 1 0.2 2.4 0.5 3.7l-0.2 0.1c0.7 2.9 2.7 4.7 4.7 4.7 0 0-0.1 2.2 0.7 2.9zM14 14c-0.6 0-1-0.4-1-1s0.4-1 1-1 1 0.4 1 1-0.5 1-1 1z"></path></g>
<g id="vaadin:stock"><path d="M12 6v-6h-8v6h-4v7h16v-7h-4zM7 12h-6v-5h2v1h2v-1h2v5zM5 6v-5h2v1h2v-1h2v5h-6zM15 12h-6v-5h2v1h2v-1h2v5z"></path><path d="M0 16h3v-1h10v1h3v-2h-16v2z"></path></g>
<g id="vaadin:stop-cog"><path d="M1 0v7.2l0.5-0.5 1.2 0.6c0 0 0.1 0 0.1 0l0.2-0.6 0.3-0.7h2.4l0.2 0.7 0.2 0.6c0 0 0.1 0 0.1 0l1.2-0.6 1.8 1.8-0.6 1.2c0 0 0 0.1 0 0.1l0.6 0.2 0.7 0.2v2.4l-0.7 0.2-0.6 0.2c0 0 0 0.1 0 0.1l0.6 1.2-0.4 0.7h7.2v-15h-15z"></path><path d="M5.5 11.5c0 0.552-0.448 1-1 1s-1-0.448-1-1c0-0.552 0.448-1 1-1s1 0.448 1 1z"></path><path d="M7.9 12.4l1.1-0.4v-1l-1.1-0.4c-0.1-0.3-0.2-0.6-0.4-0.9l0.5-1-0.7-0.7-1 0.5c-0.3-0.2-0.6-0.3-0.9-0.4l-0.4-1.1h-1l-0.4 1.1c-0.3 0.1-0.6 0.2-0.9 0.4l-1-0.5-0.7 0.7 0.5 1.1c-0.2 0.3-0.3 0.6-0.4 0.9l-1.1 0.3v1l1.1 0.4c0.1 0.3 0.2 0.6 0.4 0.9l-0.5 1 0.7 0.7 1.1-0.5c0.3 0.2 0.6 0.3 0.9 0.4l0.3 1.1h1l0.4-1.1c0.3-0.1 0.6-0.2 0.9-0.4l1 0.5 0.7-0.7-0.5-1.1c0.2-0.2 0.3-0.5 0.4-0.8zM4.5 13.5c-1.1 0-2-0.9-2-2s0.9-2 2-2 2 0.9 2 2c0 1.1-0.9 2-2 2z"></path></g>
<g id="vaadin:stop"><path d="M1 1h14v14h-14v-14z"></path></g>
<g id="vaadin:stopwatch"><path d="M8.5 8.14v-3.64h-1v3.64c-0.301 0.176-0.5 0.498-0.5 0.866 0 0.552 0.448 1 1 1s1-0.448 1-1c0-0.368-0.199-0.69-0.495-0.863z"></path><path d="M8 2c-3.866 0-7 3.134-7 7s3.134 7 7 7c3.866 0 7-3.134 7-7s-3.134-7-7-7zM8 14.5c-3.038 0-5.5-2.462-5.5-5.5s2.462-5.5 5.5-5.5c3.038 0 5.5 2.462 5.5 5.5-0.006 3.035-2.465 5.494-5.499 5.5z"></path><path d="M6 0h4v1.5h-4v-1.5z"></path><path d="M0.005 4.438l2.713-2.939 1.102 1.017-2.713 2.939-1.102-1.017z"></path><path d="M12.186 2.519l1.102-1.017 2.713 2.939-1.102 1.017-2.713-2.939z"></path></g>
<g id="vaadin:storage"><path d="M16 4l-8.060-4-7.94 4v1h1v11h2v-9h10v9h2v-11h1v-1zM4 6v-1h2v1h-2zM7 6v-1h2v1h-2zM10 6v-1h2v1h-2z"></path><path d="M6 9h-1v-1h-1v3h3v-3h-1v1z"></path><path d="M6 13h-1v-1h-1v3h3v-3h-1v1z"></path><path d="M10 13h-1v-1h-1v3h3v-3h-1v1z"></path></g>
<g id="vaadin:strikethrough"><path d="M10.5 7c-0.5-0.3-1-0.5-1.4-0.7-2-0.9-2.1-1.1-2-1.9s0.4-1 0.6-1.2c0.9-0.5 2.8-0.1 3.5 0.2l1.1-2.8c-0.4-0.2-3.7-1.4-6.1 0-0.8 0.5-1.9 1.5-2.1 3.4-0.2 1.3 0.1 2.3 0.7 3h-4.8v1h16v-1h-5.5z"></path><path d="M7.7 9c0 0 0.1 0 0.1 0.1 2 0.9 2.4 1.2 2.2 2.5-0.2 0.9-0.5 1.1-0.8 1.3-1.1 0.6-3.3 0-4.4-0.5l-1.2 2.6c0.3 0.1 2.3 1 4.5 1 0.9 0 1.8-0.2 2.6-0.6 0.9-0.5 2-1.4 2.4-3.4 0.2-1.3 0-2.3-0.4-3.1h-5z"></path></g>
<g id="vaadin:subscript"><path d="M16 15v1h-4v-1c0 0 3.3-1.6 2.6-3.2-0.5-1.1-2-0.2-2-0.2l-0.5-0.9c0 0 1.9-1.4 3.1-0.2 2.4 2.3-1.4 4.5-1.4 4.5h2.2z"></path><path d="M12 3h-3.4l-2.6 3-2.6-3h-3.4l4.3 5-4.3 5h3.4l2.6-3 2.6 3h3.4l-4.3-5z"></path></g>
<g id="vaadin:suitcase"><path d="M11 3v-2h-6v2h-5v12h16v-12h-5zM4 14h-1v-10h1v10zM10 3h-4v-1h4v1zM13 14h-1v-10h1v10z"></path></g>
<g id="vaadin:sun-down"><path d="M10 3h-1v-2h-2v2h-1l2 3 2-3z"></path><path d="M14 13l-1.58-1.18 0.78-1.82-2-0.23-0.2-1.97-1.82 0.78-1.18-1.58-1.18 1.58-1.82-0.78-0.23 2-1.97 0.2 0.78 1.82-1.58 1.18h-2v1h16v-1h-2zM4 13c0.075-2.178 1.822-3.925 3.993-4 2.185 0.075 3.932 1.821 4.007 3.993l-8 0.007z"></path></g>
<g id="vaadin:sun-o"><path d="M16 8l-2.2-1.6 1.1-2.4-2.7-0.2-0.2-2.7-2.4 1.1-1.6-2.2-1.6 2.2-2.4-1.1-0.2 2.7-2.7 0.2 1.1 2.4-2.2 1.6 2.2 1.6-1.1 2.4 2.7 0.2 0.2 2.7 2.4-1.1 1.6 2.2 1.6-2.2 2.4 1.1 0.2-2.7 2.7-0.2-1.1-2.4 2.2-1.6zM8 13c-2.8 0-5-2.2-5-5s2.2-5 5-5 5 2.2 5 5-2.2 5-5 5z"></path></g>
<g id="vaadin:sun-rise"><path d="M6 4h1v2h2v-2h1l-2-3-2 3z"></path><path d="M12.42 11.82l0.78-1.82-2-0.23-0.2-1.97-1.82 0.78-1.18-1.58-1.18 1.58-1.82-0.78-0.23 2-1.97 0.2 0.78 1.82-1.58 1.18h-2v1h16v-1h-2zM4 13c0.075-2.178 1.822-3.925 3.993-4 2.185 0.075 3.932 1.821 4.007 3.993l-8 0.007z"></path></g>
<g id="vaadin:superscript"><path d="M16 5v1h-4v-1c0 0 3.3-1.6 2.6-3.2-0.5-1.1-2-0.2-2-0.2l-0.5-0.9c0 0 1.9-1.4 3.1-0.2 2.4 2.3-1.4 4.5-1.4 4.5h2.2z"></path><path d="M12 3h-3.4l-2.6 3-2.6-3h-3.4l4.3 5-4.3 5h3.4l2.6-3 2.6 3h3.4l-4.3-5z"></path></g>
<g id="vaadin:sword"><path d="M15.8 0.5l-0.1-0.2-0.2-0.1c-0.1 0-2.5-0.8-4.2 0.9l-6.7 6.6c-0.9-0.6-1.7-1.2-1.8-1l-0.4 0.3c-0.2 0.2 0.9 1.7 1.8 2.7l-2.5 3.4c-0.3-0.3-0.8-0.3-1.1 0l-0.3 0.3c-0.3 0.3-0.3 0.8 0 1.1l1 1c0.3 0.3 0.8 0.3 1.1 0l0.3-0.3c0.3-0.3 0.3-0.8 0-1.1v0l3.5-2.5c1 0.9 2.5 2 2.7 1.8l0.4-0.4c0.1-0.1-0.4-1-1.1-1.8l6.7-6.7c1.7-1.5 0.9-3.9 0.9-4zM7.7 10.5l-0.8-0.8 6.2-6.9-6.9 6.2-0.7-0.7 6.5-6.5c1-1 2.3-0.8 2.9-0.7 0.1 0.6 0.3 1.9-0.7 2.8l-6.5 6.6z"></path></g>
<g id="vaadin:tab-a"><path d="M9 10h-9v-4h9v-2l5 4-5 4v-2z"></path><path d="M14 4h2v8h-2v-8z"></path></g>
<g id="vaadin:tab"><path d="M0 2v12h16v-12h-16zM13 11h-1v-3l-3 3v-2h-6v-2h6v-2l3 3v-3h1v6z"></path></g>
<g id="vaadin:table"><path d="M0 1v15h16v-15h-16zM5 15h-4v-2h4v2zM5 12h-4v-2h4v2zM5 9h-4v-2h4v2zM5 6h-4v-2h4v2zM10 15h-4v-2h4v2zM10 12h-4v-2h4v2zM10 9h-4v-2h4v2zM10 6h-4v-2h4v2zM15 15h-4v-2h4v2zM15 12h-4v-2h4v2zM15 9h-4v-2h4v2zM15 6h-4v-2h4v2z"></path></g>
<g id="vaadin:tablet"><path d="M0 2v12h16v-12h-16zM13 13h-11v-10h11v10zM15 9h-1v-2h1v2z"></path></g>
<g id="vaadin:tabs"><path d="M14 4v-2h-14v12h16v-10h-2zM10 3h3v1h-3v-1zM6 3h3v1h-3v-1zM15 13h-14v-10h4v2h10v8z"></path></g>
<g id="vaadin:tag"><path d="M8 1h-7v7l7 7 7-7zM3.75 5c-0.69 0-1.25-0.56-1.25-1.25s0.56-1.25 1.25-1.25c0.69 0 1.25 0.56 1.25 1.25s-0.56 1.25-1.25 1.25z"></path></g>
<g id="vaadin:tags"><path d="M9 2h-1.5l7 7-5.3 5.2 0.8 0.8 6-6z"></path><path d="M6 2h-6v6l7 7 6-6-7-7zM2.8 6c-0.7 0-1.3-0.6-1.3-1.2s0.6-1.2 1.2-1.2 1.3 0.5 1.3 1.2-0.6 1.2-1.2 1.2z"></path></g>
<g id="vaadin:tasks"><path d="M6 0h10v4h-10v-4z"></path><path d="M6 6h10v4h-10v-4z"></path><path d="M6 12h10v4h-10v-4z"></path><path d="M3 1v2h-2v-2h2zM4 0h-4v4h4v-4z"></path><path d="M3 13v2h-2v-2h2zM4 12h-4v4h4v-4z"></path><path d="M5.3 5.9l-0.6-0.8-0.9 0.9h-3.8v4h4v-2.8l1.3-1.3zM2.7 7l-0.7 0.7-0.8-0.7h1.5zM1 8.2l0.9 0.8h-0.9v-0.8zM3 9h-0.9l0.9-0.9v0.9z"></path></g>
<g id="vaadin:taxi"><path d="M15 6.1l-1.4-2.9c-0.4-0.7-1.1-1.2-2-1.2h-0.6v-1.3c0-0.4-0.3-0.7-0.7-0.7h-4.6c-0.4 0-0.7 0.3-0.7 0.7v1.3h-0.7c-0.8 0-1.6 0.5-1.9 1.2l-1.4 2.9c-0.6 0.1-1 0.6-1 1.1v3.5c0 0.6 0 1.1 1 1.2v2c0 0.6 0.4 1.1 1 1.1h0.9c0.6 0 1.1-0.5 1.1-1.1v-1.9h8v1.9c0 0.6 0.4 1.1 1 1.1h0.9c0.6 0 1.1-0.5 1.1-1.1v-2c1-0.1 1-0.6 1-1.2v-3.5c0-0.5-0.4-1-1-1.1zM4 8.4c0 0.3-0.3 0.6-0.6 0.6h-1.8c-0.3 0-0.6-0.3-0.6-0.6v-0.8c0-0.3 0.3-0.6 0.6-0.6h1.8c0.3 0 0.6 0.3 0.6 0.6v0.8zM10 11h-4v-1h4v1zM2.1 6l1.2-2.4c0.2-0.4 0.6-0.6 1-0.6h7.4c0.4 0 0.8 0.2 1 0.6l1.2 2.4h-11.8zM15 8.4c0 0.3-0.3 0.6-0.6 0.6h-1.8c-0.3 0-0.6-0.3-0.6-0.6v-0.8c0-0.3 0.3-0.6 0.6-0.6h1.8c0.3 0 0.6 0.3 0.6 0.6v0.8z"></path></g>
<g id="vaadin:teeth"><path d="M4.6 7.6c-0.1 0.1-0.5 0.4-1.6 0.4 1.1 0 1.5 0.3 1.6 0.4 0.2-0.2 0.6-0.4 1.5-0.4-0.9 0-1.3-0.2-1.5-0.4z"></path><path d="M8 0c-4.4 0-8 3.6-8 8s3.6 8 8 8c4.4 0 8-3.6 8-8s-3.6-8-8-8zM13.1 11.6c-1 0-1.4-0.8-1.6-1.6-0.2 0.9-0.6 2-1.8 2-1.1 0-1.5-1.1-1.7-2-0.2 1-0.6 2-1.7 2s-1.6-1.1-1.8-2c-0.2 0.8-0.6 1.6-1.6 1.6-2 0-1.9-3-1.9-3s0.2-0.6 1.7-0.6c-1.5 0-1.7-0.5-1.7-0.5s-0.1-3 1.9-3c1 0 1.4 0.8 1.6 1.6 0.2-0.9 0.6-2 1.8-2 1.1-0.1 1.5 1 1.7 1.9 0.2-1 0.6-2 1.7-2s1.6 1.1 1.8 2c0.2-0.8 0.6-1.6 1.6-1.6 2 0 1.9 3 1.9 3s-0.3 0.6-1.8 0.6c-1.2 0-1.6-0.3-1.8-0.4-0.2 0.2-0.7 0.4-1.6 0.4-1.2 0-1.6-0.2-1.8-0.4-0.1 0.1-0.6 0.4-1.6 0.4 1 0 1.4 0.3 1.6 0.4 0.2-0.2 0.6-0.4 1.8-0.4 1 0 1.4 0.2 1.7 0.4 0-0.1 0.5-0.4 1.7-0.4 1.5 0 1.8 0.6 1.8 0.6s0.1 3-1.9 3z"></path></g>
<g id="vaadin:terminal"><path d="M6 12h9v1h-9v-1z"></path><path d="M1.1 13h1.2l3.7-5-3.7-5h-1.3l3.8 5z"></path></g>
<g id="vaadin:text-height"><path d="M15 3h1l-1.5-3-1.5 3h1v10h-1l1.5 3 1.5-3h-1z"></path><path d="M1 0v3h4v13h3v-13h4v-3z"></path></g>
<g id="vaadin:text-input"><path d="M2 2h1v4h-1v-4z"></path><path d="M1 0c-0.6 0-1 0.4-1 1v14c0 0.6 0.4 1 1 1h15v-16h-15zM13 15h-12v-14h12v14zM15 15v0h-1v-1h1v1zM15 13h-1v-10h1v10zM15 2h-1v-1h1v1z"></path></g>
<g id="vaadin:text-label"><path d="M12.5 4.9c-1.4 0-2.5 0.8-2.6 0.9l1.2 1.6c0 0 0.7-0.5 1.4-0.5 1.4 0 1.5 1.2 1.5 1.6-0.4-0.1-1.1-0.3-2-0.1-1.4 0.3-2.8 2-2.1 3.9 0.7 1.8 3.1 2.1 4.1 0.6v1h2v-5.3c0-2.7-1.9-3.7-3.5-3.7zM11.5 11.4c-0.1-1.9 1.5-1.9 2.5-1.8v1c0 1.2-2.3 2.3-2.5 0.8z"></path><path d="M6.9 14h2.1l-3.2-12h-2.7l-3.1 12h2.1l1-4h2.7l1.1 4zM3.6 8l0.8-3.2 0.9 3.2h-1.7z"></path></g>
<g id="vaadin:text-width"><path d="M15 14.5l-3-1.5v1h-9v-1l-3 1.5 3 1.5v-1h9v1z"></path><path d="M0 0v3h6v9h3v-9h6v-3z"></path></g>
<g id="vaadin:thin-square"><path d="M15 1h-14v14h14v-14zM14 14h-12v-12h12v12z"></path></g>
<g id="vaadin:thumbs-down-o"><path d="M15.6 7.3c0.1-0.3 0.3-0.7 0.2-1.2 0-0.6-0.3-1.1-0.5-1.3 0.1-0.3 0.1-0.6 0-1.1s-0.4-0.8-0.6-1c0.1-0.3 0.1-0.8-0.3-1.4-0.4-1-1.2-1.3-3.6-1.3-1.7 0-3.3 0.8-4.6 1.5-0.4 0.2-1 0.5-1.2 0.5v0h-5v9h5v-0.9l2.7 2.7 1 2.8c0.2 0.2 0.4 0.4 0.8 0.4h0.1c0 0 0 0 0 0 0.5 0 2-0.1 2.4-1.9 0.2-0.9-0.1-2.2-0.5-3.1h2.3c0.7-0.1 2.1-0.6 2.2-2.1 0-0.7-0.2-1.3-0.4-1.6zM2.5 7.5c0.6 0 1 0.4 1 1s-0.4 1-1 1-1-0.4-1-1c0-0.6 0.4-1 1-1zM13.8 10h-2.5c-0.3 0-0.5 0.1-0.7 0.4-0.2 0.2-0.2 0.5-0.1 0.8 0.5 1.2 0.7 2.2 0.6 2.8-0.2 0.9-0.9 1.1-1.4 1.1l-1-2.7c0-0.1-0.1-0.2-0.2-0.3l-2.9-2.9c-0.1-0.1-0.3-0.2-0.5-0.2h-0.1v-6c0.4 0 0.8-0.2 1.7-0.6 1.1-0.6 2.7-1.4 4.1-1.4 2.5 0 2.7 0.4 2.9 0.7 0.3 0.5 0.1 0.9 0.1 0.9l-0.2 0.4 0.4 0.3c0 0 0.4 0.2 0.5 0.7 0.1 0.4 0 0.7 0 0.7l-0.3 0.3 0.3 0.3c0 0 0.4 0.3 0.4 0.9 0 0.5-0.2 0.7-0.2 0.7l-0.4 0.3 0.4 0.4c0 0 0.4 0.4 0.3 1.2 0 1.1-1.1 1.2-1.2 1.2z"></path></g>
<g id="vaadin:thumbs-down"><path d="M15.6 7.8c0 0 0.5 0.5 0.4 1.6 0 1.5-1.6 1.6-1.6 1.6h-2.4c-0.2 0-0.3 0.2-0.3 0.4 0.3 0.7 0.8 2.1 0.6 3.1-0.3 1.4-1.5 1.5-1.9 1.5-0.1 0-0.2-0.1-0.2-0.2l-1-2.8c0 0 0-0.1-0.1-0.1l-2.6-2.8c-0.1-0.1-0.2-0.1-0.3-0.1h-0.2v-7h0.2c0.7 0 3.2-2 5.4-2s2.7 0.3 3.1 1c0.4 0.7 0.1 1.3 0.1 1.3s0.5 0.3 0.6 1c0.1 0.7-0.1 1.1-0.1 1.1s0.5 0.4 0.5 1.2c0.1 0.9-0.2 1.2-0.2 1.2z"></path><path d="M0 11h5v-8h-5v8zM2.5 7.5c0.6 0 1 0.4 1 1s-0.4 1-1 1-1-0.4-1-1c0-0.6 0.4-1 1-1z"></path></g>
<g id="vaadin:thumbs-up-o"><path d="M16 7.1c0-1.5-1.4-2.1-2.2-2.1h-2.2c0.4-1 0.7-2.2 0.5-3.1-0.5-1.8-2-1.9-2.5-1.9h-0.1c-0.4 0-0.6 0.2-0.8 0.5l-1 2.8-2.7 2.7h-5v9h5v-1c0.2 0 0.7 0.3 1.2 0.6 1.2 0.6 2.9 1.5 4.5 1.5 2.4 0 3.2-0.3 3.8-1.3 0.3-0.6 0.3-1.1 0.3-1.4 0.2-0.2 0.5-0.5 0.6-1s0.1-0.8 0-1.1c0.2-0.3 0.4-0.7 0.5-1.3 0-0.5-0.1-0.9-0.2-1.2 0.1-0.4 0.3-0.9 0.3-1.7zM2.5 13.5c-0.6 0-1-0.4-1-1s0.4-1 1-1 1 0.4 1 1c0 0.6-0.4 1-1 1zM14.7 9.1c0 0 0.2 0.2 0.2 0.7 0 0.6-0.4 0.9-0.4 0.9l-0.3 0.3 0.2 0.3c0 0 0.2 0.3 0 0.7-0.1 0.4-0.5 0.7-0.5 0.7l-0.3 0.3 0.2 0.4c0 0 0.2 0.4-0.1 0.9-0.2 0.4-0.4 0.7-2.9 0.7-1.4 0-3-0.8-4.1-1.4-0.8-0.4-1.3-0.6-1.7-0.6v0-6h0.1c0.2 0 0.4-0.1 0.6-0.2l2.8-2.8c0.1-0.1 0.1-0.2 0.2-0.3l1-2.7c0.5 0 1.2 0.2 1.4 1.1 0.1 0.6-0.1 1.6-0.6 2.8-0.1 0.3-0.1 0.5 0.1 0.8 0.1 0.2 0.4 0.3 0.7 0.3h2.5c0.1 0 1.2 0.2 1.2 1.1 0 0.8-0.3 1.2-0.3 1.2l-0.3 0.4 0.3 0.4z"></path></g>
<g id="vaadin:thumbs-up"><path d="M15.6 8.2c0 0 0.5-0.5 0.4-1.6 0-1.5-1.6-1.6-1.6-1.6h-2.4c-0.2 0-0.3-0.2-0.3-0.4 0.3-0.7 0.8-2.1 0.6-3.1-0.3-1.4-1.5-1.5-1.9-1.5-0.1 0-0.2 0.1-0.2 0.2l-1 2.8c0 0 0 0.1-0.1 0.1l-2.6 2.8c-0.1 0.1-0.2 0.1-0.3 0.1h-0.2v7h0.2c0.7 0 3.2 2 5.4 2s2.7-0.3 3.1-1c0.4-0.7 0.1-1.3 0.1-1.3s0.5-0.3 0.6-1c0.1-0.7-0.1-1.1-0.1-1.1s0.5-0.4 0.5-1.2c0.1-0.9-0.2-1.2-0.2-1.2z"></path><path d="M0 14h5v-8h-5v8zM2.5 10.5c0.6 0 1 0.4 1 1s-0.4 1-1 1-1-0.4-1-1c0-0.6 0.4-1 1-1z"></path></g>
<g id="vaadin:ticket"><path d="M14 3h-12c0 1.1-0.9 2-2 2v6c1.1 0 2 0.9 2 2h12c0-1.1 0.9-2 2-2v0-6c-1.1 0-2-0.9-2-2zM13 12h-10v-8h10v8z"></path><path d="M4 5h8v6h-8v-6z"></path></g>
<g id="vaadin:time-backward"><path d="M8 4h-1v5h4v-1h-3z"></path><path d="M8 0c-3 0-5.6 1.6-6.9 4.1l-1.1-1.1v4h4l-1.5-1.5c1-2 3.1-3.5 5.5-3.5 3.3 0 6 2.7 6 6s-2.7 6-6 6c-1.8 0-3.4-0.8-4.5-2.1l-1.5 1.3c1.4 1.7 3.6 2.8 6 2.8 4.4 0 8-3.6 8-8s-3.6-8-8-8z"></path></g>
<g id="vaadin:time-forward"><path d="M8 4h-1v5h4v-1h-3z"></path><path d="M16 7v-4l-1.1 1.1c-1.3-2.5-3.9-4.1-6.9-4.1-4.4 0-8 3.6-8 8s3.6 8 8 8c2.4 0 4.6-1.1 6-2.8l-1.5-1.3c-1.1 1.3-2.7 2.1-4.5 2.1-3.3 0-6-2.7-6-6s2.7-6 6-6c2.4 0 4.5 1.5 5.5 3.5l-1.5 1.5h4z"></path></g>
<g id="vaadin:timer"><path d="M9.060 9.060c0.271-0.271 0.439-0.646 0.439-1.060s-0.168-0.789-0.439-1.060c-0.59-0.59-6.72-4.6-6.72-4.6s4 6.13 4.59 6.72c0.272 0.274 0.649 0.444 1.065 0.444s0.793-0.17 1.065-0.444z"></path><path d="M8 0v3h1v-1.41c3.153 0.495 5.536 3.192 5.536 6.445 0 3.601-2.919 6.52-6.52 6.52s-6.52-2.919-6.52-6.52c0-1.256 0.355-2.428 0.97-3.423l-0.916-1.322c-0.958 1.303-1.533 2.939-1.533 4.71 0 4.418 3.582 8 8 8s8-3.582 8-8c0-4.418-3.582-8-8-8-0.006 0-0.012 0-0.017 0z"></path></g>
<g id="vaadin:toolbox"><path d="M0 8h6v2h4v-2h6v6h-16z"></path><path d="M7 7h2v2h-2v-2z"></path><path d="M11 4v-2h-6v2h-5v3h6v-1h4v1h6v-3h-5zM6 4v-1h4v1h-4z"></path></g>
<g id="vaadin:tools"><path d="M10.3 8.2l-0.9 0.9 0.9 0.9-1.2 1.2 4.3 4.3c0.6 0.6 1.5 0.6 2.1 0s0.6-1.5 0-2.1l-5.2-5.2zM14.2 15c-0.4 0-0.8-0.3-0.8-0.8 0-0.4 0.3-0.8 0.8-0.8s0.8 0.3 0.8 0.8c0 0.5-0.3 0.8-0.8 0.8z"></path><path d="M3.6 8l0.9-0.6 1.5-1.7 0.9 0.9 0.9-0.9-0.1-0.1c0.2-0.5 0.3-1 0.3-1.6 0-2.2-1.8-4-4-4-0.6 0-1.1 0.1-1.6 0.3l2.9 2.9-2.1 2.1-2.9-2.9c-0.2 0.5-0.3 1-0.3 1.6 0 2.1 1.6 3.7 3.6 4z"></path><path d="M8 10.8l0.9-0.8-0.9-0.9 5.7-5.7 1.2-0.4 1.1-2.2-0.7-0.7-2.3 1-0.5 1.2-5.6 5.7-0.9-0.9-0.8 0.9c0 0 0.8 0.6-0.1 1.5-0.5 0.5-1.3-0.1-2.8 1.4-0.5 0.5-2.1 2.1-2.1 2.1s-0.6 1 0.6 2.2 2.2 0.6 2.2 0.6 1.6-1.6 2.1-2.1c1.4-1.4 0.9-2.3 1.3-2.7 0.9-0.9 1.6-0.2 1.6-0.2zM4.9 10.4l0.7 0.7-3.8 3.8-0.7-0.7z"></path></g>
<g id="vaadin:tooth"><path d="M11.3 16c-1.2 0-1.7-3.9-1.7-4.1-0.1-1.3-1-2.1-1.6-2.2-0.6 0-1.4 0.9-1.6 2.2 0 0.2-0.5 4.1-1.7 4.1s-1.8-4.4-1.9-4.4c-0.2-1.4 0.1-3.4 0.2-4-0.4-1.2-1.8-5.6-0.5-7 0.5-0.4 1.1-0.6 1.9-0.6 0.6 0 1.3 0.1 2 0.3 0.6 0.1 1.1 0.2 1.6 0.2s1-0.1 1.6-0.2c0.7-0.2 1.4-0.3 2-0.3 0.8 0 1.4 0.2 1.8 0.7 1.3 1.4-0.1 5.8-0.5 7 0.1 0.5 0.4 2.5 0.2 3.9 0.1 0-0.5 4.4-1.8 4.4zM8 8.7c1.3 0.1 2.4 1.4 2.6 3.1 0.1 1.2 0.5 2.4 0.7 2.9 0.3-0.6 0.7-2.1 0.9-3.3 0.2-1.4-0.2-3.7-0.2-3.7v-0.2c0.7-2.1 1.4-5.3 0.8-6.1-0.3-0.3-0.7-0.4-1.2-0.4s-1.2 0.1-1.8 0.3c-0.6 0.1-1.2 0.2-1.8 0.2s-1.2-0.1-1.8-0.2c-0.6-0.2-1.3-0.3-1.8-0.3s-0.9 0.1-1.1 0.4c-0.7 0.7 0 4 0.8 6.1v0.2c0 0-0.4 2.3-0.2 3.7 0.2 1.2 0.6 2.7 0.9 3.3 0.2-0.6 0.6-1.7 0.7-2.9 0.1-1.6 1.2-3 2.5-3.1z"></path></g>
<g id="vaadin:touch"><path d="M12.62 6c-0.093-0.023-0.2-0.036-0.31-0.036s-0.217 0.013-0.319 0.038c-0.045-0.33-0.192-0.616-0.402-0.843-0.257-0.259-0.614-0.42-1.008-0.42-0.018 0-0.036 0-0.053 0.001-0-0-0.004-0-0.007-0-0.22 0-0.43 0.044-0.621 0.124-0.062-0.183-0.163-0.336-0.29-0.464-0.261-0.25-0.617-0.403-1.008-0.403-0.036 0-0.072 0.001-0.107 0.004l0.005-0c0.315-0.414 0.505-0.938 0.505-1.506 0-1.381-1.119-2.5-2.5-2.5s-2.5 1.119-2.5 2.5c0 0.813 0.388 1.535 0.989 1.992l0.006 2.664c-0.554 0.015-1.054 0.233-1.432 0.581-0.568 0.619-0.568 1.579-0.568 2.779 0 0.23 0 0.47 0 0.72 0.032 1.127 0.573 2.121 1.402 2.764l0.358 0.356c1.24 1.27 2.38 1.65 5.020 1.65 2.88 0 4.22-1.61 4.22-5.060v-2.51c0-0.77-0.22-2.12-1.38-2.43zM13 8.35v2.59c0 3.37-1.29 4.060-3.22 4.060-2.6 0-3.4-0.39-4.3-1.33l-0.36-0.37c-0.657-0.468-1.088-1.215-1.12-2.065-0-0.265-0-0.505-0-0.735-0.033-0.178-0.053-0.383-0.053-0.592 0-0.538 0.126-1.047 0.351-1.498 0.186-0.132 0.431-0.228 0.698-0.24l0.003 0.7v-0.22l-0.34 1.5c-0.010 0.022-0.016 0.048-0.016 0.075 0 0.103 0.083 0.186 0.186 0.186 0.075 0 0.14-0.045 0.17-0.11l1-1.211c0.003-0.014 0.005-0.029 0.005-0.045s-0.002-0.031-0.005-0.046l0-5.609c-0-0.012-0.001-0.026-0.001-0.039 0-0.256 0.083-0.492 0.223-0.684 0.091-0.096 0.223-0.158 0.369-0.158 0.010 0 0.020 0 0.030 0.001-0.001-0-0.001-0-0.001-0 0.21 0 0.38 0.17 0.38 0.38 0 0.004-0 0.007-0 0.011l0 3.869c0 0.276 0.224 0.5 0.5 0.5s0.5-0.224 0.5-0.5v-1.32c0.010-0.251 0.217-0.451 0.47-0.451 0.011 0 0.021 0 0.032 0.001 0.023-0.005 0.051-0.008 0.079-0.008 0.232 0 0.42 0.188 0.42 0.42 0 0.010-0 0.020-0.001 0.029l0 1.329c0 0.276 0.224 0.5 0.5 0.5s0.5-0.224 0.5-0.5v-0.64c0.034-0.218 0.22-0.383 0.445-0.383 0.019 0 0.038 0.001 0.057 0.004 0.013-0.002 0.030-0.003 0.047-0.003 0.112 0 0.214 0.043 0.291 0.113 0.1 0.129 0.16 0.294 0.16 0.473 0 0.006-0 0.012-0 0.017l0 0.819c0.003 0.252 0.193 0.459 0.438 0.49 0.021 0.003 0.043 0.004 0.066 0.004 0.241 0 0.442-0.166 0.496-0.39 0.026-0.112 0.082-0.204 0.16-0.273 0.033-0.015 0.071-0.024 0.111-0.024s0.078 0.009 0.112 0.024c0.38 0.249 0.628 0.674 0.628 1.157 0 0.057-0.003 0.113-0.010 0.169l0.001-0.007z"></path></g>
<g id="vaadin:train"><path d="M13 11.2v-7.4c0-1-0.8-1.8-1.8-1.8h-2.2v-1h2v-1h-6v1h2v1h-2.2c-1 0-1.8 0.8-1.8 1.8v7.4c0 1 0.8 1.8 1.8 1.8h0.2l-0.7 1h-1.3v1h0.7l-0.7 1h2l0.6-1h4.9l0.6 1h2l-0.7-1h0.6v-1h-1.3l-0.7-1h0.2c1 0 1.8-0.8 1.8-1.8zM4 3.9c0-0.5 0.4-0.9 0.9-0.9h6.1c0.6 0 1 0.4 1 0.9v2.1c0 0.6-0.4 1-0.9 1h-6.2c-0.5 0-0.9-0.4-0.9-0.9v-2.2zM4 11c0-0.6 0.4-1 1-1s1 0.4 1 1c0 0.6-0.4 1-1 1s-1-0.4-1-1zM9.9 14h-3.8l0.6-1h2.6l0.6 1zM10 11c0-0.6 0.4-1 1-1s1 0.4 1 1c0 0.6-0.4 1-1 1s-1-0.4-1-1z"></path></g>
<g id="vaadin:trash"><path d="M13 3s0-0.51-2-0.8v-0.7c-0.017-0.832-0.695-1.5-1.53-1.5-0 0-0 0-0 0h-3c-0.815 0.017-1.47 0.682-1.47 1.5 0 0 0 0 0 0v0.7c-0.765 0.068-1.452 0.359-2.007 0.806l-0.993-0.006v1h12v-1h-1zM6 1.5c0.005-0.274 0.226-0.495 0.499-0.5l3.001-0c0 0 0.001 0 0.001 0 0.282 0 0.513 0.22 0.529 0.499l0 0.561c-0.353-0.042-0.763-0.065-1.178-0.065-0.117 0-0.233 0.002-0.349 0.006-0.553-0-2.063-0-2.503 0.070v-0.57z"></path><path d="M2 5v1h1v9c1.234 0.631 2.692 1 4.236 1 0.002 0 0.003 0 0.005 0h1.52c0.001 0 0.003 0 0.004 0 1.544 0 3.002-0.369 4.289-1.025l-0.054-8.975h1v-1h-12zM6 13.92q-0.51-0.060-1-0.17v-6.75h1v6.92zM9 14h-2v-7h2v7zM11 13.72c-0.267 0.070-0.606 0.136-0.95 0.184l-0.050-6.904h1v6.72z"></path></g>
<g id="vaadin:tree-table"><path d="M6 10v-2h-2v-1h1v-2h-3v2h1v6h3v-2h-2v-1z"></path><path d="M0 0v16h16v-16h-16zM7 15h-6v-12h6v12zM11 15h-3v-12h3v12zM15 15h-3v-12h3v12z"></path></g>
<g id="vaadin:trending-down"><path d="M16 14h-4l1.29-1.29-4.29-4.3-3 3-6-6v-2.82l6 6 3-3 5.71 5.7 1.28-1.29 0.010 4z"></path></g>
<g id="vaadin:trending-up"><path d="M16 2h-4l1.29 1.29-4.29 4.3-3-3-6 6v2.82l6-6 3 3 5.71-5.7 1.28 1.29 0.010-4z"></path></g>
<g id="vaadin:trophy"><path d="M11.7 8c4.2-0.3 4.3-2.7 4.3-5h-3v-3h-10v3h-3c0 2.3 0.1 4.7 4.3 5 0.9 1.4 2.1 2 2.7 2v4c-3 0-3 2-3 2h8c0 0 0-2-3-2v-4c0.6 0 1.8-0.6 2.7-2zM13 4h2c-0.1 1.6-0.4 2.7-2.7 2.9 0.3-0.8 0.6-1.7 0.7-2.9zM1 4h2c0.1 1.2 0.4 2.1 0.7 2.9-2.2-0.2-2.6-1.3-2.7-2.9zM4.5 6.1c-0.5-1.7-0.5-3.1-0.5-3.1v-2h1v2c0 0 0 1.7 0.4 3.1 0.5 1.7 1.6 2.9 1.6 2.9s-1.8-0.2-2.5-2.9z"></path></g>
<g id="vaadin:truck"><path d="M6 3h10v7h-10v-7z"></path><path d="M15 14c0 1.105-0.895 2-2 2s-2-0.895-2-2c0-1.105 0.895-2 2-2s2 0.895 2 2z"></path><path d="M13 11c1.3 0 2.4 0.8 2.8 2h0.2v-2h-3z"></path><path d="M5 5h-4l-1 4v4h1.2c0.4-1.2 1.5-2 2.8-2s2.4 0.8 2.8 2h3.4c0.4-1.2 1.5-2 2.8-2h-8v-6zM4 9h-3l0.8-3h2.2v3z"></path><path d="M6 14c0 1.105-0.895 2-2 2s-2-0.895-2-2c0-1.105 0.895-2 2-2s2 0.895 2 2z"></path></g>
<g id="vaadin:twin-col-select"><path d="M0 2v12h16v-12h-16zM7 13h-6v-10h6v10zM15 13h-6v-10h6v10z"></path><path d="M10 4h4v1h-4v-1z"></path><path d="M2 4h4v1h-4v-1z"></path><path d="M2 6h4v1h-4v-1z"></path><path d="M2 8h4v1h-4v-1z"></path></g>
<g id="vaadin:twitter-square"><path d="M0 0v16h16v-16h-16zM12.8 5.6c0 0.1 0 0.2 0 0.3 0 3.3-2.5 7-7 7-1.4 0-2.7-0.4-3.8-1.1 0.2 0 0.4 0 0.6 0 1.2 0 2.2-0.4 3.1-1.1-1.1 0-2-0.7-2.3-1.7 0.2 0 0.3 0 0.5 0s0.4 0 0.6-0.1c-1.1-0.2-2-1.2-2-2.4 0 0 0 0 0 0 0.3 0.2 0.7 0.3 1.1 0.3-0.7-0.4-1.1-1.2-1.1-2 0-0.5 0.1-0.9 0.3-1.2 1.2 1.5 3.1 2.4 5.1 2.5 0-0.2-0.1-0.4-0.1-0.6 0-1.4 1.1-2.5 2.5-2.5 0.7 0 1.3 0.3 1.8 0.8 0.6-0.1 1.1-0.3 1.6-0.6-0.2 0.6-0.6 1.1-1.1 1.4 0.5-0.1 1-0.2 1.4-0.4-0.3 0.6-0.7 1-1.2 1.4z"></path></g>
<g id="vaadin:twitter"><path d="M16 3c-0.6 0.3-1.2 0.4-1.9 0.5 0.7-0.4 1.2-1 1.4-1.8-0.6 0.4-1.3 0.6-2.1 0.8-0.6-0.6-1.5-1-2.4-1-1.7 0-3.2 1.5-3.2 3.3 0 0.3 0 0.5 0.1 0.7-2.7-0.1-5.2-1.4-6.8-3.4-0.3 0.5-0.4 1-0.4 1.7 0 1.1 0.6 2.1 1.5 2.7-0.5 0-1-0.2-1.5-0.4 0 0 0 0 0 0 0 1.6 1.1 2.9 2.6 3.2-0.3 0.1-0.6 0.1-0.9 0.1-0.2 0-0.4 0-0.6-0.1 0.4 1.3 1.6 2.3 3.1 2.3-1.1 0.9-2.5 1.4-4.1 1.4-0.3 0-0.5 0-0.8 0 1.5 0.9 3.2 1.5 5 1.5 6 0 9.3-5 9.3-9.3 0-0.1 0-0.3 0-0.4 0.7-0.5 1.3-1.1 1.7-1.8z"></path></g>
<g id="vaadin:umbrella"><path d="M5.36 0.9l-0.27-0.57c-0.083-0.197-0.275-0.333-0.499-0.333-0.1 0-0.193 0.027-0.274 0.074-0.217 0.074-0.372 0.279-0.372 0.52 0 0.087 0.020 0.169 0.056 0.242l0.319 0.577c-6.2 3.49-3.9 10.59-3.9 10.59h0.060c0.25-0.12 0.8-1.64 2.050-2.25s2.78-0.090 3-0.21l0.12-0.060c0.477-0.742 0.998-1.387 1.58-1.97l3.37 7.070c0.246 0.619 0.729 1.098 1.334 1.335 0.168 0.053 0.343 0.080 0.524 0.080 0.254 0 0.495-0.053 0.713-0.149l0.359-0.176c0.263-0.145 0.462-0.38 0.558-0.662 0.117-0.276 0.183-0.586 0.183-0.913 0-0.401-0.1-0.778-0.277-1.108-0.102-0.189-0.311-0.324-0.551-0.324-0.076 0-0.149 0.014-0.217 0.038-0.182 0.089-0.308 0.277-0.308 0.495 0 0.093 0.023 0.18 0.064 0.257s0.529 1.067-0.101 1.337-1.19-0.73-1.19-0.73l-3.42-7.060c0.372-0.043 0.803-0.067 1.24-0.067s0.868 0.024 1.292 0.072l0.068-0.065c0.25-0.12 0.8-1.64 2.050-2.25s2.78-0.090 3-0.21h0.060s-3.98-6.41-10.62-3.58zM7.36 6.36c-1.034 0.399-1.834 1.209-2.211 2.224-0.55-1.082-0.909-2.375-1.007-3.74-0.142-2.244 0.608-2.924 0.608-2.924l0.77-0.32c1.084 0.101 2.052 0.534 2.816 1.195 0.976 0.895 1.747 2.009 2.233 3.265-0.339-0.021-0.752-0.067-1.175-0.067-0.724 0-1.417 0.134-2.054 0.379z"></path></g>
<g id="vaadin:underline"><path d="M2 15h12v1h-12v-1z"></path><path d="M11 0v8.4c0 1.5-1.1 2.6-2.6 2.6h-0.8c-1.5 0-2.6-1.1-2.6-2.6v-8.4h-3v8.4c0 3.1 2.5 5.6 5.6 5.6h0.9c3.1 0 5.6-2.5 5.6-5.6v-8.4h-3.1z"></path></g>
<g id="vaadin:unlink"><path d="M8 0h1v4h-1v-4z"></path><path d="M8 12h1v4h-1v-4z"></path><path d="M7 9h-4c-0.552 0-1-0.448-1-1s0.448-1 1-1h4v-2h-4c-1.657 0-3 1.343-3 3s1.343 3 3 3h4v-2z"></path><path d="M13 5h-4v2h4c0.552 0 1 0.448 1 1s-0.448 1-1 1h-4v2h4c1.657 0 3-1.343 3-3s-1.343-3-3-3z"></path><path d="M4.51 15.44l2.49-3.44h-1.23l-2.080 2.88 0.82 0.56z"></path><path d="M12.49 15.44l-2.49-3.44h1.23l2.080 2.88-0.82 0.56z"></path><path d="M12.49 0.99l-2.49 3.010h1.23l2.080-2.66-0.82-0.35z"></path><path d="M4.51 0.99l2.49 3.010h-1.23l-2.080-2.66 0.82-0.35z"></path></g>
<g id="vaadin:unlock"><path d="M8 8v-3.1c0-2.2-1.8-3.9-3.9-3.9h-0.3c-2.2 0-3.8 1.7-3.8 3.9v2.1h2v-2.1c0-1.1 0.7-1.9 1.8-1.9h0.3c1 0 1.9 0.8 1.9 1.9v3.1h-1l0.1 5c0 0-0.1 3 4.9 3s5-3 5-3v-5h-7zM11 14h-1v-1.8c-0.6 0-1-0.6-1-1.1 0-0.6 0.4-1.1 1-1.1s1 0.4 1 0.9v3.1z"></path></g>
<g id="vaadin:upload-alt"><path d="M0 14h16v2h-16v-2z"></path><path d="M8 0l-5 5h3v8h4v-8h3z"></path></g>
<g id="vaadin:upload"><path d="M11 10v2h-6v-2h-5v6h16v-6h-5zM4 14h-2v-2h2v2z"></path><path d="M13 5l-5-5-5 5h3v6h4v-6z"></path></g>
<g id="vaadin:user-card"><path d="M15 3v10h-14v-10h14zM16 2h-16v12h16v-12z"></path><path d="M8 5h6v1h-6v-1z"></path><path d="M8 7h6v1h-6v-1z"></path><path d="M8 9h3v1h-3v-1z"></path><path d="M5.4 7h-0.4v-0.1c0.6-0.2 1-0.8 1-1.4 0-0.8-0.7-1.5-1.5-1.5s-1.5 0.7-1.5 1.5c0 0.7 0.4 1.2 1 1.4v0.1h-0.4c-0.9 0-1.6 0.7-1.6 1.6v2.4h5v-2.4c0-0.9-0.7-1.6-1.6-1.6z"></path></g>
<g id="vaadin:user-check"><path d="M7.5 14.4c-0.8-0.8-0.8-2 0-2.8s2-0.8 2.8 0l0.6 0.6 1.9-2.1c-0.7-0.4-1.3-0.4-2-0.4-0.7-0.1-1.4-0.3-1.4-0.9s0.8-0.4 1.4-1.5c0 0 2.7-7.3-2.9-7.3-5.5 0-2.8 7.3-2.8 7.3 0.6 1 1.4 0.8 1.4 1.5s-0.7 0.7-1.4 0.8c-1.1 0.1-2.1-0.1-3.1 1.7-0.6 1.1-0.9 4.7-0.9 4.7h8l-1.6-1.6z"></path><path d="M12.8 16h2.1c0 0-0.1-0.9-0.2-2l-1.9 2z"></path><path d="M11 16c-0.3 0-0.5-0.1-0.7-0.3l-2-2c-0.4-0.4-0.4-1 0-1.4s1-0.4 1.4 0l1.3 1.3 3.3-3.6c0.4-0.4 1-0.4 1.4-0.1 0.4 0.4 0.4 1 0.1 1.4l-4 4.3c-0.3 0.3-0.5 0.4-0.8 0.4 0 0 0 0 0 0z"></path></g>
<g id="vaadin:user-clock"><path d="M14 13h-3v-3h1v2h2z"></path><path d="M16 12.5c0-2.5-2-4.5-4.5-4.5-0.7 0-1.4 0.2-2 0.5 0.2-0.3 0.8-0.3 1.4-1.2 0 0 2.7-7.3-2.9-7.3s-2.9 7.3-2.9 7.3c0.6 1 1.4 0.8 1.4 1.5s-0.7 0.7-1.4 0.8c-1.1 0.1-2.1-0.1-3.1 1.7-0.6 1.1-0.9 4.7-0.9 4.7h10.4c-1.9 0-3.5-1.6-3.5-3.5s1.6-3.5 3.5-3.5 3.5 1.6 3.5 3.5c0 1.9-1.6 3.5-3.5 3.5h3.4c0 0 0-0.2 0-0.5 0.6-0.8 1.1-1.8 1.1-3z"></path></g>
<g id="vaadin:user-heart"><path d="M14.2 16h0.6c0 0 0-0.2 0-0.6l-0.6 0.6z"></path><path d="M8.6 13.9c-0.7-0.7-1-1.8-0.8-2.8s0.8-1.8 1.7-2.1c0-0.1-0.1-0.2-0.1-0.2 0-0.6 0.8-0.4 1.4-1.5 0 0 2.7-7.3-2.9-7.3-5.5 0-2.8 7.3-2.8 7.3 0.6 1 1.4 0.8 1.4 1.5s-0.7 0.7-1.4 0.8c-1.1 0.1-2.1-0.1-3.1 1.7-0.6 1.1-0.9 4.7-0.9 4.7h9.6l-2.1-2.1z"></path><path d="M14.9 10.1c-0.2-0.1-0.5-0.1-0.7-0.1-0.7 0-1.3 0.6-1.7 1.1-0.4-0.5-1-1.1-1.7-1.1-0.3 0-0.5 0-0.7 0.1-1.2 0.4-1.4 2-0.5 2.9l3 2.9 3-2.9c0.8-0.9 0.5-2.5-0.7-2.9z"></path></g>
<g id="vaadin:user-star"><path d="M8.92 13.67l-1.61-1.53-1.5-1.42 2-0.29 2.25-0.32 0.29-0.57c-0.006 0-0.013 0-0.020 0-0.482 0-0.884-0.34-0.979-0.794-0.001-0.617 0.799-0.417 1.429-1.457 0.080-0.020 2.82-7.29-2.78-7.29s-2.86 7.27-2.86 7.27c0.63 1 1.44 0.85 1.43 1.45s-0.74 0.8-1.43 0.87c-1.14 0.13-2.14-0.13-3.14 1.76-0.6 1.090-0.85 4.65-0.85 4.65h7.36v-0.17z"></path><path d="M11.72 16h0.56l-0.28-0.14-0.28 0.14z"></path><path d="M12 14.73l2.47 1.27-0.47-2.69 2-1.9-2.76-0.39-1.24-2.45-1.24 2.45-2.76 0.39 2 1.9-0.47 2.69 2.47-1.27z"></path></g>
<g id="vaadin:user"><path d="M8 0c-5.6 0-2.9 7.3-2.9 7.3 0.6 1 1.4 0.8 1.4 1.5 0 0.6-0.7 0.8-1.4 0.9-1.1 0-2.1-0.2-3.1 1.6-0.6 1.1-0.9 4.7-0.9 4.7h13.7c0 0-0.3-3.6-0.8-4.7-1-1.9-2-1.6-3.1-1.7-0.7-0.1-1.4-0.3-1.4-0.9s0.8-0.4 1.4-1.5c0 0.1 2.7-7.2-2.9-7.2z"></path></g>
<g id="vaadin:users"><path d="M5.3 9.7c-0.4 0-0.9-0.2-0.9-0.6s0.5-0.3 0.9-1c0 0 1.8-4.9-1.8-4.9s-1.8 4.9-1.8 4.9c0.4 0.7 0.9 0.6 0.9 1s-0.5 0.6-0.9 0.6c-0.6 0.1-1.1 0-1.7 0.6v5.7h5c0.2-1.7 0.7-5.2 1.1-6.1 0 0 0.1-0.1 0.1-0.1-0.2-0.1-0.5-0.1-0.9-0.1z"></path><path d="M16 9.5c-0.7-0.8-1.3-0.7-2-0.8-0.5-0.1-1.1-0.2-1.1-0.7s0.6-0.3 1.1-1.2c0 0 2.1-5.9-2.2-5.9-4.4 0.1-2.3 6-2.3 6 0.5 0.8 1.1 0.7 1.1 1.1 0 0.5-0.6 0.6-1.1 0.7-0.9 0.1-1.7 0-2.5 1.5-0.4 0.9-1 5.8-1 5.8h10v-6.5z"></path></g>
<g id="vaadin:vaadin-h"><path d="M15.21 0.35c-0.436 0-0.79 0.354-0.79 0.79v0 0.46c0 0.5-0.32 0.85-1.070 0.85h-3.55c-1.61 0-1.73 1.19-1.8 1.83v0c-0.060-0.64-0.18-1.83-1.79-1.83h-3.57c-0.75 0-1.090-0.37-1.090-0.86v-0.45c0-0.006 0-0.013 0-0.020 0-0.425-0.345-0.77-0.77-0.77-0 0-0 0-0 0h0c-0 0-0 0-0 0-0.431 0-0.78 0.349-0.78 0.78 0 0.004 0 0.007 0 0.011v-0.001 1.32c0 1.54 0.7 2.31 2.34 2.31h3.66c1.090 0 1.19 0.46 1.19 0.9 0 0 0 0.090 0 0.13 0.048 0.428 0.408 0.758 0.845 0.758s0.797-0.33 0.845-0.754l0-0.004s0-0.080 0-0.13c0-0.44 0.1-0.9 1.19-0.9h3.61c1.61 0 2.32-0.77 2.32-2.31v-1.32c0-0.436-0.354-0.79-0.79-0.79v0z"></path><path d="M11.21 7.38c-0.012-0-0.026-0.001-0.040-0.001-0.453 0-0.835 0.301-0.958 0.714l-0.002 0.007-2.21 4.21-2.3-4.2c-0.122-0.425-0.507-0.731-0.963-0.731-0.013 0-0.026 0-0.039 0.001l0.002-0c-0.012-0-0.025-0.001-0.039-0.001-0.58 0-1.050 0.47-1.050 1.050 0 0.212 0.063 0.41 0.171 0.575l-0.002-0.004 3.29 6.1c0.15 0.333 0.478 0.561 0.86 0.561s0.71-0.228 0.858-0.555l0.002-0.006 3.34-6.1c0.090-0.152 0.144-0.335 0.144-0.53 0-0.58-0.47-1.050-1.050-1.050-0.005 0-0.010 0-0.014 0h0.001z"></path></g>
<g id="vaadin:vaadin-v"><path d="M5.8 7.16h-0.13c-0.44 0-0.9-0.1-0.9-1.19v-3.62c0-1.64-0.77-2.35-2.31-2.35h-1.32c-0.436 0-0.79 0.354-0.79 0.79v0c0 0.436 0.354 0.79 0.79 0.79v0h0.46c0.5 0 0.85 0.32 0.85 1.070v3.55c0 1.61 1.19 1.73 1.83 1.8v0c-0.64 0.060-1.83 0.18-1.83 1.79v3.55c0 0.75-0.37 1.090-0.86 1.090h-0.45c-0.006-0-0.013-0-0.020-0-0.425 0-0.77 0.345-0.77 0.77 0 0 0 0 0 0v-0c0 0 0 0 0 0 0 0.431 0.349 0.78 0.78 0.78 0.004 0 0.007-0 0.011-0h1.319c1.54 0 2.31-0.7 2.31-2.34v-3.59c0-1.090 0.46-1.19 0.9-1.19h0.13c0.428-0.048 0.758-0.408 0.758-0.845s-0.33-0.797-0.754-0.845l-0.004-0z"></path><path d="M15.1 7.19v0l-6.1-3.32c-0.152-0.090-0.335-0.144-0.53-0.144-0.58 0-1.050 0.47-1.050 1.050 0 0.005 0 0.010 0 0.014v-0.001c-0 0.012-0.001 0.026-0.001 0.040 0 0.453 0.301 0.835 0.714 0.958l0.007 0.002 4.21 2.26-4.24 2.25c-0.425 0.122-0.731 0.507-0.731 0.963 0 0.013 0 0.026 0.001 0.039l-0-0.002c-0 0.012-0.001 0.025-0.001 0.039 0 0.58 0.47 1.050 1.050 1.050 0.212 0 0.41-0.063 0.575-0.171l-0.004 0.002 6.1-3.29c0.333-0.15 0.561-0.478 0.561-0.86s-0.228-0.71-0.555-0.858l-0.006-0.002z"></path></g>
<g id="vaadin:viewport"><path d="M1 4h-1v-4h4v1h-3z"></path><path d="M12 1v-1h4v4h-1v-3z"></path><path d="M15 12h1v4h-4v-1h3z"></path><path d="M4 15v1h-4v-4h1v3z"></path><path d="M13 3v10h-10v-10h10zM14 2h-12v12h12v-12z"></path></g>
<g id="vaadin:vimeo-square"><path d="M0 0v16h16v-16h-16zM13.9 5.3c-0.7 3.8-4.4 7-5.5 7.7s-2.2-0.3-2.5-1.1c-0.4-0.9-1.7-5.7-2-6.1-0.4-0.3-1.4 0.5-1.4 0.5l-0.5-0.7c0 0 2-2.4 3.6-2.7s1.6 2.5 2 4.1c0.4 1.5 0.6 2.4 1 2.4 0.3 0 1-0.9 1.7-2.2s0-2.5-1.4-1.6c0.5-3.3 5.7-4.1 5-0.3z"></path></g>
<g id="vaadin:vimeo"><path d="M15.9 4.4c-0.9 5-5.9 9.3-7.4 10.3s-2.9-0.4-3.4-1.4c-0.5-1.3-2.2-7.6-2.7-8.2-0.4-0.5-1.8 0.6-1.8 0.6l-0.6-0.9c0 0 2.7-3.3 4.8-3.7 2.2-0.4 2.2 3.4 2.7 5.5 0.5 2 0.9 3.2 1.3 3.2s1.3-1.1 2.2-2.9c0.9-1.7 0-3.3-1.9-2.2 0.8-4.3 7.7-5.4 6.8-0.3z"></path></g>
<g id="vaadin:volume-down"><path d="M10.8 4.4l-0.5 1.1c0.5 0.9 0.8 1.9 0.8 3 0 1-0.3 2-0.7 2.9l0.7 0.9c0.6-1.1 1-2.4 1-3.7-0.1-1.6-0.5-3-1.3-4.2z"></path><path d="M4 5h-4v6h4l5 4v-14z"></path></g>
<g id="vaadin:volume-off"><path d="M4 5h-4v6h4l5 4v-14z"></path></g>
<g id="vaadin:volume-up"><path d="M15 8.5c0 2.3-0.8 4.5-2 6.2l0.7 0.8c1.5-1.9 2.4-4.4 2.4-7 0-3.1-1.2-5.9-3.2-8l-0.5 1c1.6 1.8 2.6 4.3 2.6 7z"></path><path d="M11.8 2.4l-0.5 1c1.1 1.4 1.7 3.2 1.7 5.1 0 1.7-0.5 3.2-1.3 4.6l0.7 0.8c1.1-1.5 1.7-3.4 1.7-5.4-0.1-2.3-0.9-4.4-2.3-6.1z"></path><path d="M10.8 4.4l-0.5 1.1c0.5 0.9 0.8 1.9 0.8 3 0 1-0.3 2-0.7 2.9l0.7 0.9c0.6-1.1 1-2.4 1-3.7-0.1-1.6-0.5-3-1.3-4.2z"></path><path d="M4 5h-4v6h4l5 4v-14z"></path></g>
<g id="vaadin:volume"><path d="M11.8 2.4l-0.5 1c1.1 1.4 1.7 3.2 1.7 5.1 0 1.7-0.5 3.2-1.3 4.6l0.7 0.8c1.1-1.5 1.7-3.4 1.7-5.4-0.1-2.3-0.9-4.4-2.3-6.1z"></path><path d="M10.8 4.4l-0.5 1.1c0.5 0.9 0.8 1.9 0.8 3 0 1-0.3 2-0.7 2.9l0.7 0.9c0.6-1.1 1-2.4 1-3.7-0.1-1.6-0.5-3-1.3-4.2z"></path><path d="M4 5h-4v6h4l5 4v-14z"></path></g>
<g id="vaadin:wallet"><path d="M14.5 4h-12.12c-0.057 0.012-0.123 0.018-0.19 0.018-0.552 0-1-0.448-1-1 0-0.006 0-0.013 0-0.019l12.81-0.499v-1.19c0.005-0.041 0.008-0.089 0.008-0.138 0-0.652-0.528-1.18-1.18-1.18-0.049 0-0.097 0.003-0.144 0.009l-11.374 1.849c-0.771 0.289-1.31 1.020-1.31 1.877 0 0.011 0 0.023 0 0.034l-0 10.728c-0 0.003-0 0.006-0 0.010 0 0.828 0.672 1.5 1.5 1.5 0 0 0 0 0 0h13c0 0 0 0 0 0 0.828 0 1.5-0.672 1.5-1.5 0-0.004-0-0.007-0-0.011v-8.999c0-0.012 0.001-0.027 0.001-0.041 0-0.801-0.649-1.45-1.45-1.45-0.018 0-0.036 0-0.053 0.001zM13 11c-0.828 0-1.5-0.672-1.5-1.5s0.672-1.5 1.5-1.5c0.828 0 1.5 0.672 1.5 1.5s-0.672 1.5-1.5 1.5z"></path></g>
<g id="vaadin:warning"><path d="M8 1l-8 14h16l-8-14zM8 13c-0.6 0-1-0.4-1-1s0.4-1 1-1 1 0.4 1 1c0 0.6-0.4 1-1 1zM7 10v-4h2v4h-2z"></path></g>
<g id="vaadin:workplace"><path d="M11,3 L11,0 L2,0 L2,14 L0,14 L0,15 L7,15 L7,10 L9,10 L9,8 L14,8 L14,3 L11,3 Z M6,10 L4,10 L4,8 L6,8 L6,10 Z M6,7 L4,7 L4,5 L6,5 L6,7 Z M6,4 L4,4 L4,2 L6,2 L6,4 Z M9,7 L7,7 L7,5 L9,5 L9,7 Z M9,4 L7,4 L7,2 L9,2 L9,4 Z M13,7 L11,7 L11,5 L13,5 L13,7 Z M14,11 L16,11 L16,16 L8,16 L8,11 L10,11 L10,9 L14,9 L14,11 Z" fill-rule="nonzero"></path></g>
<g id="vaadin:wrench"><path d="M15.5 13.4l-7.8-7.8c0.2-0.5 0.3-1 0.3-1.6 0-2.2-1.8-4-4-4-0.6 0-1.1 0.1-1.6 0.3l2.9 2.9-2.1 2.1-2.9-2.9c-0.2 0.5-0.3 1-0.3 1.6 0 2.2 1.8 4 4 4 0.6 0 1.1-0.1 1.6-0.3l7.8 7.8c0.6 0.6 1.5 0.6 2.1 0s0.6-1.5 0-2.1zM6.8 7.6l-1.4-1.4 0.9-0.9 1.4 1.4-0.9 0.9zM14.2 15c-0.4 0-0.8-0.3-0.8-0.8 0-0.4 0.3-0.8 0.8-0.8s0.8 0.3 0.8 0.8c0 0.5-0.3 0.8-0.8 0.8z"></path></g>
<g id="vaadin:youtube-square"><path d="M7.9 6c0.2 0 0.3-0.2 0.3-0.5v-1.4c0-0.3-0.1-0.5-0.3-0.5s-0.3 0.2-0.3 0.5v1.4c0 0.3 0.1 0.5 0.3 0.5z"></path><path d="M7.1 11.9c-0.1 0.2-0.3 0.3-0.4 0.3s-0.1 0-0.1-0.1c0 0 0-0.1 0-0.2v-2.5h-0.6v2.6c0 0.2 0 0.4 0.1 0.5 0.1 0.2 0.2 0.2 0.4 0.2s0.4-0.1 0.7-0.4v0.4h0.6v-3.3h-0.7v2.5z"></path><path d="M3.8 8.9h0.7v3.8h0.7v-3.8h0.7v-0.7h-2.1z"></path><path d="M9.4 9.3c-0.2 0-0.4 0.2-0.6 0.4v-1.5h-0.6v4.4h0.6v-0.3c0.2 0.2 0.4 0.4 0.6 0.4s0.4-0.1 0.5-0.4c0-0.1 0.1-0.4 0.1-0.7v-1.3c0-0.3 0-0.5-0.1-0.7-0.1-0.1-0.2-0.3-0.5-0.3zM9.4 11.7c0 0.3-0.1 0.4-0.3 0.4-0.1 0-0.2 0-0.3-0.1v-2c0.1-0.1 0.2-0.1 0.3-0.1 0.2 0 0.3 0.2 0.3 0.5v1.3z"></path><path d="M11.3 9.3c-0.3 0-0.5 0.1-0.7 0.3-0.1 0.2-0.2 0.4-0.2 0.8v1.2c0 0.4 0.1 0.6 0.2 0.8 0.2 0.2 0.4 0.3 0.7 0.3s0.6-0.1 0.7-0.4c0.1-0.1 0.1-0.2 0.1-0.4 0-0.1 0-0.2 0-0.4v-0.1h-0.6c0 0.2 0 0.4 0 0.4 0 0.2-0.1 0.2-0.3 0.2s-0.3-0.2-0.3-0.5v-0.6h1.2v-0.7c0-0.4-0.1-0.6-0.2-0.8 0 0.1-0.3-0.1-0.6-0.1zM11.6 10.6h-0.6v-0.3c0-0.3 0.1-0.5 0.3-0.5s0.3 0.2 0.3 0.5v0.3z"></path><path d="M0 0v16h16v-16h-16zM9.3 3.1h0.6v2.5c0 0.1 0 0.2 0 0.2 0 0.1 0 0.2 0.1 0.2s0.2-0.1 0.4-0.3v-2.6h0.6v3.3h-0.6v-0.3c-0.2 0.3-0.5 0.4-0.7 0.4s-0.3-0.1-0.4-0.2c0-0.1-0.1-0.3-0.1-0.5v-2.7zM7 4.2c0-0.3 0-0.6 0.2-0.8s0.4-0.3 0.7-0.3c0.3 0 0.5 0.1 0.7 0.3 0.1 0.2 0.2 0.4 0.2 0.8v1.2c0 0.4-0.1 0.6-0.2 0.8-0.2 0.2-0.4 0.3-0.7 0.3s-0.5-0.1-0.7-0.3c-0.2-0.2-0.2-0.4-0.2-0.8v-1.2zM5.3 2l0.5 1.8 0.5-1.8h0.7l-0.8 2.7v1.8h-0.7v-1.8c-0.1-0.4-0.2-0.8-0.4-1.5-0.2-0.4-0.3-0.8-0.5-1.2h0.7zM12.8 12.9c-0.1 0.5-0.6 0.9-1.1 1-1.2 0.1-2.5 0.1-3.7 0.1s-2.5 0-3.7-0.1c-0.5-0.1-1-0.4-1.1-1-0.2-0.8-0.2-1.6-0.2-2.4 0-0.7 0-1.5 0.2-2.3 0.1-0.5 0.6-0.9 1.1-1 1.2-0.1 2.5-0.1 3.7-0.1s2.5 0 3.7 0.1c0.5 0.1 1 0.4 1.1 1 0.2 0.8 0.2 1.6 0.2 2.3 0 0.8 0 1.6-0.2 2.4z"></path></g>
<g id="vaadin:youtube"><path d="M6.6 0h-0.9l-0.6 2.3-0.6-2.3h-1c0.2 0.6 0.4 1.1 0.6 1.7 0.3 0.8 0.5 1.5 0.5 1.9v2.4h0.9v-2.4l1.1-3.6zM9 4.5v-1.5c0-0.5-0.1-0.8-0.3-1.1s-0.5-0.4-0.9-0.4c-0.4 0-0.7 0.2-0.9 0.5-0.2 0.2-0.3 0.5-0.3 1v1.6c0 0.5 0.1 0.8 0.3 1 0.2 0.3 0.5 0.4 0.9 0.4s0.7-0.2 0.9-0.5c0.2-0.1 0.3-0.5 0.3-1zM8.2 4.7c0 0.4-0.1 0.6-0.4 0.6s-0.4-0.2-0.4-0.6v-1.9c0-0.4 0.1-0.6 0.4-0.6s0.4 0.2 0.4 0.6v1.9zM12 6v-4.5h-0.8v3.4c-0.2 0.3-0.3 0.4-0.5 0.4-0.1 0-0.2-0.1-0.2-0.2 0 0 0-0.1 0-0.3v-3.3h-0.8v3.5c0 0.3 0 0.5 0.1 0.7 0 0.2 0.2 0.3 0.5 0.3s0.6-0.2 0.9-0.5v0.5h0.8z"></path><path d="M12.4 10.5c-0.3 0-0.4 0.2-0.4 0.6v0.4h0.8v-0.4c0-0.4-0.1-0.6-0.4-0.6z"></path><path d="M9.5 10.5c-0.1 0-0.3 0.1-0.4 0.2v2.7c0.1 0.1 0.3 0.2 0.4 0.2 0.2 0 0.3-0.2 0.3-0.6v-1.9c0-0.4-0.1-0.6-0.3-0.6z"></path><path d="M14.4 8.3c-0.2-0.7-0.8-1.3-1.4-1.3-1.6-0.2-3.3-0.2-5-0.2s-3.3 0-5 0.2c-0.6 0-1.2 0.6-1.4 1.3-0.2 1-0.2 2.1-0.2 3.1s0 2.1 0.2 3.1c0.2 0.7 0.7 1.2 1.4 1.3 1.7 0.2 3.3 0.2 5 0.2s3.3 0 5-0.2c0.7-0.1 1.3-0.6 1.4-1.3 0.2-1 0.2-2.1 0.2-3.1s0-2.1-0.2-3.1zM5.2 9.2h-1v5.1h-0.9v-5.1h-0.9v-0.9h2.8v0.9zM7.6 14.3h-0.8v-0.5c-0.3 0.4-0.6 0.5-0.9 0.5s-0.4-0.1-0.5-0.3c0-0.1-0.1-0.3-0.1-0.7v-3.5h0.8v3.2c0 0.2 0 0.3 0 0.3 0 0.1 0.1 0.2 0.2 0.2 0.2 0 0.3-0.1 0.5-0.4v-3.3h0.8v4.5zM10.6 12.9c0 0.4 0 0.7-0.1 0.9-0.1 0.3-0.3 0.5-0.6 0.5s-0.6-0.2-0.8-0.5v0.4h-0.8v-5.9h0.8v1.9c0.3-0.3 0.5-0.5 0.8-0.5s0.5 0.2 0.6 0.5c0.1 0.2 0.1 0.5 0.1 0.9v1.8zM13.6 12.2h-1.6v0.8c0 0.4 0.1 0.6 0.4 0.6 0.2 0 0.3-0.1 0.4-0.3 0 0 0-0.2 0-0.5h0.8v0.1c0 0.3 0 0.4 0 0.5 0 0.2-0.1 0.3-0.2 0.5-0.2 0.3-0.5 0.5-1 0.5-0.4 0-0.7-0.2-1-0.5-0.2-0.2-0.3-0.6-0.3-1v-1.5c0-0.5 0.1-0.8 0.2-1 0.2-0.3 0.5-0.5 1-0.5 0.4 0 0.7 0.2 0.9 0.5 0.2 0.2 0.2 0.6 0.2 1v0.8z"></path></g>
</defs></svg>`;
Iconset$1.register("vaadin", 16, template$3);
/**
 * @license
 * Copyright (c) 2017 - 2025 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const MultiSelectListMixin = (superClass) => class VaadinMultiSelectListMixin extends ListMixin(superClass) {
  static get properties() {
    return {
      /**
       * Specifies that multiple options can be selected at once.
       */
      multiple: {
        type: Boolean,
        value: false,
        reflectToAttribute: true,
        observer: "_multipleChanged"
      },
      /**
       * Array of indexes of the items selected in the items array
       * Note: Not updated when used in single selection mode.
       * @type {number[] | null | undefined}
       */
      selectedValues: {
        type: Array,
        notify: true,
        value: () => []
      }
    };
  }
  static get observers() {
    return ["_enhanceMultipleItems(items, multiple, selected, disabled, selectedValues)"];
  }
  /** @protected */
  ready() {
    this.addEventListener("click", (e2) => this._onMultipleClick(e2));
    super.ready();
  }
  /** @private */
  _enhanceMultipleItems(items, multiple, _selected, _disabled, selectedValues) {
    if (!items || !multiple) {
      return;
    }
    if (selectedValues) {
      const selectedItems = selectedValues.map((selectedId) => items[selectedId]);
      items.forEach((item2) => {
        item2.selected = selectedItems.includes(item2);
      });
    }
    this._scrollToLastSelectedItem();
  }
  /** @private */
  _scrollToLastSelectedItem() {
    const lastSelectedItem = this.selectedValues.slice(-1)[0];
    if (lastSelectedItem && !lastSelectedItem.disabled) {
      this._scrollToItem(lastSelectedItem);
    }
  }
  /**
   * @param {!MouseEvent} event
   * @protected
   */
  _onMultipleClick(event) {
    const item2 = this._filterItems(event.composedPath())[0];
    const idx = item2 && !item2.disabled ? this.items.indexOf(item2) : -1;
    if (idx < 0 || !this.multiple) {
      return;
    }
    event.preventDefault();
    if (this.selectedValues.includes(idx)) {
      this.selectedValues = this.selectedValues.filter((v) => v !== idx);
    } else {
      this.selectedValues = this.selectedValues.concat(idx);
    }
  }
  /** @private */
  _multipleChanged(value, oldValue) {
    if (!value && oldValue) {
      this.selectedValues = [];
      this.items.forEach((item2) => {
        item2.selected = false;
      });
      this.removeAttribute("aria-multiselectable");
    }
    if (value && !oldValue) {
      this.setAttribute("aria-multiselectable", "true");
      if (this.selected !== void 0) {
        this.selectedValues = [...this.selectedValues, this.selected];
        this.selected = void 0;
      }
    }
  }
  /**
   * Fired when the selection is changed.
   * Not fired in single selection mode.
   *
   * @event selected-values-changed
   * @param {Object} detail
   * @param {Object} detail.value the array of indexes of the items selected in the items array.
   */
};
/**
 * @license
 * Copyright (c) 2017 - 2025 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
class ListBox extends ElementMixin(MultiSelectListMixin(ThemableMixin(ControllerMixin(PolymerElement)))) {
  static get template() {
    return html`
      <style>
        :host {
          display: flex;
        }

        :host([hidden]) {
          display: none !important;
        }

        [part='items'] {
          height: 100%;
          width: 100%;
          overflow-y: auto;
          -webkit-overflow-scrolling: touch;
        }
      </style>
      <div part="items">
        <slot></slot>
      </div>

      <slot name="tooltip"></slot>
    `;
  }
  static get is() {
    return "vaadin-list-box";
  }
  static get properties() {
    return {
      // We don't need to define this property since super default is vertical,
      // but we don't want it to be modified, or be shown in the API docs.
      /** @private */
      orientation: {
        readOnly: true
      }
    };
  }
  constructor() {
    super();
    this.focused;
  }
  /**
   * @return {!HTMLElement}
   * @protected
   * @override
   */
  get _scrollerElement() {
    return this.shadowRoot.querySelector('[part="items"]');
  }
  /** @protected */
  ready() {
    super.ready();
    this.setAttribute("role", "listbox");
    setTimeout(this._checkImport.bind(this), 2e3);
    this._tooltipController = new TooltipController(this);
    this.addController(this._tooltipController);
  }
  /** @private */
  _checkImport() {
    const item2 = this.querySelector("vaadin-item");
    if (item2 && !(item2 instanceof PolymerElement)) {
      console.warn(`Make sure you have imported the vaadin-item element.`);
    }
  }
}
defineCustomElement(ListBox);
/**
 * @license
 * Copyright (c) 2017 - 2025 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
class Item extends ItemMixin(ThemableMixin(DirMixin(PolymerElement))) {
  static get template() {
    return html`
      <style>
        :host {
          display: inline-block;
        }

        :host([hidden]) {
          display: none !important;
        }
      </style>
      <span part="checkmark" aria-hidden="true"></span>
      <div part="content">
        <slot></slot>
      </div>
    `;
  }
  static get is() {
    return "vaadin-item";
  }
  constructor() {
    super();
    this.value;
    this.label;
  }
  /** @protected */
  ready() {
    super.ready();
    this.setAttribute("role", "option");
  }
}
defineCustomElement(Item);
/**
 * @license
 * Copyright (c) 2017 - 2025 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
registerStyles$1("vaadin-text-field", inputFieldShared$1, {
  moduleId: "lumo-text-field-styles"
});
/**
 * @license
 * Copyright (c) 2021 - 2025 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const InputFieldMixin = (superclass) => class InputFieldMixinClass extends InputControlMixin(superclass) {
  static get properties() {
    return {
      /**
       * Whether the value of the control can be automatically completed by the browser.
       * List of available options at:
       * https://developer.mozilla.org/en/docs/Web/HTML/Element/input#attr-autocomplete
       */
      autocomplete: {
        type: String
      },
      /**
       * This is a property supported by Safari that is used to control whether
       * autocorrection should be enabled when the user is entering/editing the text.
       * Possible values are:
       * on: Enable autocorrection.
       * off: Disable autocorrection.
       */
      autocorrect: {
        type: String,
        reflectToAttribute: true
      },
      /**
       * This is a property supported by Safari and Chrome that is used to control whether
       * autocapitalization should be enabled when the user is entering/editing the text.
       * Possible values are:
       * characters: Characters capitalization.
       * words: Words capitalization.
       * sentences: Sentences capitalization.
       * none: No capitalization.
       */
      autocapitalize: {
        type: String,
        reflectToAttribute: true
      }
    };
  }
  static get delegateAttrs() {
    return [...super.delegateAttrs, "autocapitalize", "autocomplete", "autocorrect"];
  }
  // Workaround for https://github.com/Polymer/polymer/issues/5259
  get __data() {
    return this.__dataValue || {};
  }
  set __data(value) {
    this.__dataValue = value;
  }
  /**
   * @param {HTMLElement} input
   * @protected
   * @override
   */
  _inputElementChanged(input) {
    super._inputElementChanged(input);
    if (input) {
      if (input.value && input.value !== this.value) {
        console.warn(`Please define value on the <${this.localName}> component!`);
        input.value = "";
      }
      if (this.value) {
        input.value = this.value;
      }
    }
  }
  /**
   * Override an event listener from `FocusMixin`.
   * @param {boolean} focused
   * @protected
   * @override
   */
  _setFocused(focused) {
    super._setFocused(focused);
    if (!focused && document.hasFocus()) {
      this._requestValidation();
    }
  }
  /**
   * Override an event listener from `InputMixin`
   * to mark as valid after user started typing.
   * @param {Event} event
   * @protected
   * @override
   */
  _onInput(event) {
    super._onInput(event);
    if (this.invalid) {
      this._requestValidation();
    }
  }
  /**
   * Override an observer from `InputMixin` to validate the field
   * when a new value is set programmatically.
   *
   * @param {string | undefined} newValue
   * @param {string | undefined} oldValue
   * @protected
   * @override
   */
  _valueChanged(newValue, oldValue) {
    super._valueChanged(newValue, oldValue);
    if (oldValue === void 0) {
      return;
    }
    if (this.invalid) {
      this._requestValidation();
    }
  }
};
/**
 * @license
 * Copyright (c) 2021 - 2025 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const TextFieldMixin = (superClass) => class TextFieldMixinClass extends InputFieldMixin(superClass) {
  static get properties() {
    return {
      /**
       * Maximum number of characters (in Unicode code points) that the user can enter.
       */
      maxlength: {
        type: Number
      },
      /**
       * Minimum number of characters (in Unicode code points) that the user can enter.
       */
      minlength: {
        type: Number
      },
      /**
       * A regular expression that the value is checked against.
       * The pattern must match the entire value, not just some subset.
       */
      pattern: {
        type: String
      }
    };
  }
  static get delegateAttrs() {
    return [...super.delegateAttrs, "maxlength", "minlength", "pattern"];
  }
  static get constraints() {
    return [...super.constraints, "maxlength", "minlength", "pattern"];
  }
  constructor() {
    super();
    this._setType("text");
  }
  /** @protected */
  get clearElement() {
    return this.$.clearButton;
  }
  /** @protected */
  ready() {
    super.ready();
    this.addController(
      new InputController(this, (input) => {
        this._setInputElement(input);
        this._setFocusElement(input);
        this.stateTarget = input;
        this.ariaTarget = input;
      })
    );
    this.addController(new LabelledInputController(this.inputElement, this._labelController));
  }
};
/**
 * @license
 * Copyright (c) 2017 - 2025 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
registerStyles$1("vaadin-text-field", inputFieldShared, { moduleId: "vaadin-text-field-styles" });
class TextField extends TextFieldMixin(ThemableMixin(ElementMixin(PolymerElement))) {
  static get is() {
    return "vaadin-text-field";
  }
  static get template() {
    return html`
      <div class="vaadin-field-container">
        <div part="label">
          <slot name="label"></slot>
          <span part="required-indicator" aria-hidden="true" on-click="focus"></span>
        </div>

        <vaadin-input-container
          part="input-field"
          readonly="[[readonly]]"
          disabled="[[disabled]]"
          invalid="[[invalid]]"
          theme$="[[_theme]]"
        >
          <slot name="prefix" slot="prefix"></slot>
          <slot name="input"></slot>
          <slot name="suffix" slot="suffix"></slot>
          <div id="clearButton" part="clear-button" slot="suffix" aria-hidden="true"></div>
        </vaadin-input-container>

        <div part="helper-text">
          <slot name="helper"></slot>
        </div>

        <div part="error-message">
          <slot name="error-message"></slot>
        </div>
      </div>
      <slot name="tooltip"></slot>
    `;
  }
  /** @protected */
  ready() {
    super.ready();
    this._tooltipController = new TooltipController(this);
    this._tooltipController.setPosition("top");
    this._tooltipController.setAriaTarget(this.inputElement);
    this.addController(this._tooltipController);
  }
}
defineCustomElement(TextField);
/**
 * @license
 * Copyright (c) 2021 - 2025 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const passwordFieldButton = css`
  :host {
    position: absolute;
    right: 0;
    top: 0;
    margin: 0;
    padding: 0;
    width: 100%;
    height: 100%;
    min-width: auto;
    background: transparent;
    outline: none;
  }
`;
registerStyles$1("vaadin-password-field-button", [button, passwordFieldButton], {
  moduleId: "lumo-password-field-button"
});
/**
 * @license
 * Copyright (c) 2021 - 2025 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const passwordField = css`
  [part='reveal-button']::before {
    content: var(--lumo-icons-eye);
  }

  :host([password-visible]) [part='reveal-button']::before {
    content: var(--lumo-icons-eye-disabled);
  }

  /* Make it easy to hide the button across the whole app */
  [part='reveal-button'] {
    position: relative;
    display: var(--lumo-password-field-reveal-button-display, block);
  }

  [part='reveal-button'][hidden] {
    display: none !important;
  }
`;
registerStyles$1("vaadin-password-field", [inputFieldShared$1, passwordField], { moduleId: "lumo-password-field" });
/**
 * @license
 * Copyright (c) 2021 - 2025 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
registerStyles$1("vaadin-password-field-button", buttonStyles, { moduleId: "vaadin-password-field-button-styles" });
class PasswordFieldButton extends ButtonMixin(DirMixin(ThemableMixin(PolymerElement))) {
  static get is() {
    return "vaadin-password-field-button";
  }
  static get template() {
    return html``;
  }
}
defineCustomElement(PasswordFieldButton);
/**
 * @license
 * Copyright (c) 2021 - 2025 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const PasswordFieldMixin = (superClass) => class PasswordFieldMixinClass extends SlotStylesMixin(DisabledMixin(FocusMixin(InputMixin(superClass)))) {
  static get properties() {
    return {
      /**
       * Set to true to hide the eye icon which toggles the password visibility.
       * @attr {boolean} reveal-button-hidden
       */
      revealButtonHidden: {
        type: Boolean,
        observer: "_revealButtonHiddenChanged",
        value: false
      },
      /**
       * True if the password is visible ([type=text]).
       * @attr {boolean} password-visible
       */
      passwordVisible: {
        type: Boolean,
        value: false,
        reflectToAttribute: true,
        observer: "_passwordVisibleChanged",
        readOnly: true
      },
      /**
       * An object with translated strings used for localization.
       * It has the following structure and default values:
       *
       * ```
       * {
       *   // Translation of the reveal icon button accessible label
       *   reveal: 'Show password'
       * }
       * ```
       */
      i18n: {
        type: Object,
        value: () => {
          return {
            reveal: "Show password"
          };
        }
      }
    };
  }
  static get observers() {
    return ["__i18nChanged(i18n)"];
  }
  constructor() {
    super();
    this._setType("password");
    this.__boundRevealButtonClick = this._onRevealButtonClick.bind(this);
    this.__boundRevealButtonMouseDown = this._onRevealButtonMouseDown.bind(this);
    this.__lastChange = "";
  }
  /** @protected */
  get slotStyles() {
    const tag = this.localName;
    return [
      ...super.slotStyles,
      `
          ${tag} [slot="input"]::-ms-reveal {
            display: none;
          }
        `
    ];
  }
  /** @protected */
  get _revealNode() {
    return this._revealButtonController && this._revealButtonController.node;
  }
  /** @protected */
  ready() {
    super.ready();
    this._revealPart = this.shadowRoot.querySelector('[part="reveal-button"]');
    this._revealButtonController = new SlotController(this, "reveal", "vaadin-password-field-button", {
      initializer: (btn) => {
        btn.disabled = this.disabled;
        btn.addEventListener("click", this.__boundRevealButtonClick);
        btn.addEventListener("mousedown", this.__boundRevealButtonMouseDown);
      }
    });
    this.addController(this._revealButtonController);
    this.__updateAriaLabel(this.i18n);
    this._updateToggleState(false);
    this._toggleRevealHidden(this.revealButtonHidden);
    if (this.inputElement) {
      this.inputElement.autocapitalize = "off";
    }
  }
  /**
   * Override an event listener inherited from `InputControlMixin`
   * to store the value at the moment of the native `change` event.
   * @param {Event} event
   * @protected
   * @override
   */
  _onChange(event) {
    super._onChange(event);
    this.__lastChange = this.inputElement.value;
  }
  /**
   * Override method inherited from `FocusMixin` to mark field as focused
   * when focus moves to the reveal button using Shift Tab.
   * @param {Event} event
   * @return {boolean}
   * @protected
   */
  _shouldSetFocus(event) {
    return event.target === this.inputElement || event.target === this._revealNode;
  }
  /**
   * Override method inherited from `FocusMixin` to not hide password
   * when focus moves to the reveal button or back to the input.
   * @param {Event} event
   * @return {boolean}
   * @protected
   */
  _shouldRemoveFocus(event) {
    return !(event.relatedTarget === this._revealNode || event.relatedTarget === this.inputElement && event.target === this._revealNode);
  }
  /**
   * Override method inherited from `FocusMixin` to toggle password visibility.
   * @param {boolean} focused
   * @protected
   * @override
   */
  _setFocused(focused) {
    super._setFocused(focused);
    if (!focused) {
      this._setPasswordVisible(false);
      if (this.__lastChange !== this.inputElement.value) {
        this.__lastChange = this.inputElement.value;
        this.dispatchEvent(new CustomEvent("change", { bubbles: true }));
      }
    } else {
      const isButtonFocused = this.getRootNode().activeElement === this._revealNode;
      this.toggleAttribute("focus-ring", this._keyboardActive && !isButtonFocused);
    }
  }
  /** @private */
  __updateAriaLabel(i18n) {
    if (i18n && i18n.reveal && this._revealNode) {
      this._revealNode.setAttribute("aria-label", i18n.reveal);
    }
  }
  /** @private */
  __i18nChanged(i18n) {
    this.__updateAriaLabel(i18n);
  }
  /** @private */
  _revealButtonHiddenChanged(hidden) {
    this._toggleRevealHidden(hidden);
  }
  /** @private */
  _togglePasswordVisibility() {
    this._setPasswordVisible(!this.passwordVisible);
  }
  /** @private */
  _onRevealButtonClick() {
    this._togglePasswordVisibility();
  }
  /** @private */
  _onRevealButtonMouseDown(e2) {
    e2.preventDefault();
    this.inputElement.focus();
  }
  /** @private */
  _toggleRevealHidden(hidden) {
    if (this._revealNode) {
      if (hidden) {
        this._revealPart.setAttribute("hidden", "");
        this._revealNode.setAttribute("tabindex", "-1");
        this._revealNode.setAttribute("aria-hidden", "true");
      } else {
        this._revealPart.removeAttribute("hidden");
        this._revealNode.setAttribute("tabindex", "0");
        this._revealNode.removeAttribute("aria-hidden");
      }
    }
  }
  /** @private */
  _updateToggleState(passwordVisible) {
    if (this._revealNode) {
      this._revealNode.setAttribute("aria-pressed", passwordVisible ? "true" : "false");
    }
  }
  /** @private */
  _passwordVisibleChanged(passwordVisible) {
    this._setType(passwordVisible ? "text" : "password");
    this._updateToggleState(passwordVisible);
  }
  /**
   * Override method inherited from `DisabledMixin` to synchronize the reveal button
   * disabled state with the password field disabled state.
   * @param {boolean} disabled
   * @param {boolean} oldDisabled
   * @protected
   */
  _disabledChanged(disabled, oldDisabled) {
    super._disabledChanged(disabled, oldDisabled);
    if (this._revealNode) {
      this._revealNode.disabled = disabled;
    }
  }
};
/**
 * @license
 * Copyright (c) 2021 - 2025 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const ownTemplate = html`
  <div part="reveal-button" slot="suffix">
    <slot name="reveal"></slot>
  </div>
`;
let memoizedTemplate$1;
class PasswordField extends PasswordFieldMixin(TextField) {
  static get is() {
    return "vaadin-password-field";
  }
  static get template() {
    if (!memoizedTemplate$1) {
      memoizedTemplate$1 = super.template.cloneNode(true);
      const revealButton = ownTemplate.content.querySelector('[part="reveal-button"]');
      const inputField2 = memoizedTemplate$1.content.querySelector('[part="input-field"]');
      inputField2.appendChild(revealButton);
    }
    return memoizedTemplate$1;
  }
}
defineCustomElement(PasswordField);
const loginFormWrapper$1 = css`
  :host {
    max-width: calc(var(--lumo-size-m) * 10);
    background: var(--lumo-base-color) linear-gradient(var(--lumo-tint-5pct), var(--lumo-tint-5pct));
  }

  [part='form'] {
    padding: var(--lumo-space-l);
  }

  [part='form-title'] {
    margin-top: calc(var(--lumo-font-size-xxxl) - var(--lumo-font-size-xxl));
    color: var(--lumo-header-text-color);
    font-size: var(--lumo-font-size-xxl);
    font-weight: 600;
    line-height: var(--lumo-line-height-xs);
  }

  ::slotted([slot='submit']) {
    margin-top: var(--lumo-space-l);
    margin-bottom: var(--lumo-space-s);
  }

  ::slotted([slot='forgot-password']) {
    margin: var(--lumo-space-s) auto;
  }

  [part='error-message'] {
    background-color: var(--lumo-error-color-10pct);
    padding: var(--lumo-space-m);
    border-radius: var(--lumo-border-radius-m);
    margin-top: var(--lumo-space-m);
    margin-bottom: var(--lumo-space-s);
    color: var(--lumo-error-text-color);
  }

  :host(:not([dir='rtl'])) [part='error-message'] {
    padding-left: var(--lumo-size-m);
  }

  :host([dir='rtl']) [part='error-message'] {
    padding-right: var(--lumo-size-m);
  }

  [part='error-message']::before {
    content: var(--lumo-icons-error);
    font-family: lumo-icons;
    font-size: var(--lumo-icon-size-m);
    position: absolute;
    width: var(--lumo-size-m);
    height: 1em;
    line-height: 1;
    text-align: center;
  }

  :host(:not([dir='rtl'])) [part='error-message']::before {
    /* Visual centering */
    margin-left: calc(var(--lumo-size-m) * -0.95);
  }

  :host([dir='rtl']) [part='error-message']::before {
    /* Visual centering */
    margin-right: calc(var(--lumo-size-m) * -0.95);
  }

  [part='error-message-title'] {
    display: block;
    margin: 0 0 0.25em;
    color: inherit;
    line-height: var(--lumo-line-height-xs);
  }

  [part='error-message-description'] {
    font-size: var(--lumo-font-size-s);
    line-height: var(--lumo-line-height-s);
    margin: 0;
    opacity: 0.9;
  }

  [part='footer'] {
    font-size: var(--lumo-font-size-xs);
    line-height: var(--lumo-line-height-s);
    color: var(--lumo-secondary-text-color);
  }
`;
registerStyles$1("vaadin-login-form-wrapper", [color, typography, loginFormWrapper$1], {
  moduleId: "lumo-login-form-wrapper"
});
/**
 * @license
 * Copyright (c) 2018 - 2025 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const loginFormWrapperStyles = css`
  :host {
    overflow: hidden;
    display: inline-block;
  }

  :host([hidden]) {
    display: none !important;
  }

  [part='form'] {
    flex: 1;
    display: flex;
    flex-direction: column;
    box-sizing: border-box;
  }

  [part='form-title'] {
    margin: 0;
  }

  [part='error-message'] {
    position: relative;
  }
`;
/**
 * @license
 * Copyright (c) 2018 - 2025 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
registerStyles$1("vaadin-login-form-wrapper", loginFormWrapperStyles, {
  moduleId: "vaadin-login-form-wrapper-styles"
});
class LoginFormWrapper extends ThemableMixin(PolymerElement) {
  static get template() {
    return html`
      <section part="form">
        <div part="form-title" part="form-title" role="heading" aria-level$="[[headingLevel]]">[[i18n.form.title]]</div>
        <div part="error-message" hidden$="[[!error]]">
          <strong part="error-message-title">[[i18n.errorMessage.title]]</strong>
          <p part="error-message-description">[[i18n.errorMessage.message]]</p>
        </div>

        <slot name="form"></slot>

        <slot name="custom-form-area"></slot>

        <slot name="submit"></slot>

        <slot name="forgot-password"></slot>

        <div part="footer">
          <slot name="footer"></slot>
          <p>[[i18n.additionalInformation]]</p>
        </div>
      </section>
    `;
  }
  static get is() {
    return "vaadin-login-form-wrapper";
  }
  static get properties() {
    return {
      /**
       * If set, the error message is shown. The message is hidden by default.
       * When set, it changes the disabled state of the submit button.
       * @type {boolean}
       */
      error: {
        type: Boolean,
        value: false,
        reflectToAttribute: true
      },
      /**
       * The object used to localize this component.
       */
      i18n: {
        type: Object
      },
      /**
       * Used to customize the `aria-level` attribute on the heading element.
       */
      headingLevel: {
        type: Number
      }
    };
  }
}
defineCustomElement(LoginFormWrapper);
/**
 * @license
 * Copyright (c) 2018 - 2025 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const LoginMixin = (superClass) => class LoginMixin extends superClass {
  /**
   * Fired when user clicks on the "Forgot password" button.
   *
   * @event forgot-password
   */
  /**
   * Fired when an user submits the login.
   * The event contains `username` and `password` values in the `detail` property.
   *
   * @event login
   */
  static get properties() {
    return {
      /**
       * If set, a synchronous POST call will be fired to the path defined.
       * The `login` event is also dispatched, so `event.preventDefault()` can be called to prevent the POST call.
       * @type {string | null}
       */
      action: {
        type: String,
        value: null
      },
      /**
       * If set, disable the "Log in" button and prevent user from submitting login form.
       * It is re-enabled automatically, when error is set to true, allowing form resubmission
       * after user makes changes.
       * @type {boolean}
       */
      disabled: {
        type: Boolean,
        value: false,
        notify: true
      },
      /**
       * If set, the error message is shown. The message is hidden by default.
       * When set, it changes the disabled state of the submit button.
       * @type {boolean}
       */
      error: {
        type: Boolean,
        value: false,
        reflectToAttribute: true,
        notify: true
      },
      /**
       * Whether to hide the forgot password button. The button is visible by default.
       * @type {boolean}
       * @attr {boolean} no-forgot-password
       */
      noForgotPassword: {
        type: Boolean,
        value: false
      },
      /**
       * If set, the user name field automatically receives focus when the component is attached to the document.
       * @type {boolean}
       * @attr {boolean} no-autofocus
       */
      noAutofocus: {
        type: Boolean,
        value: false
      },
      /**
       * The object used to localize this component.
       * For changing the default localization, change the entire
       * _i18n_ object or just the property you want to modify.
       *
       * The object has the following JSON structure (by default it doesn't include `additionalInformation`
       * and `header` sections, `header` can be added to override `title` and `description` properties
       * in `vaadin-login-overlay`):
       *
       * ```
       * {
       *   header: {
       *     title: 'App name',
       *     description: 'Inspiring application description'
       *   },
       *   form: {
       *     title: 'Log in',
       *     username: 'Username',
       *     password: 'Password',
       *     submit: 'Log in',
       *     forgotPassword: 'Forgot password'
       *   },
       *   errorMessage: {
       *     title: 'Incorrect username or password',
       *     message: 'Check that you have entered the correct username and password and try again.',
       *     username: 'Username is required',
       *     password: 'Password is required'
       *   },
       *   additionalInformation: 'In case you need to provide some additional info for the user.'
       * }
       * ```
       *
       * @type {!LoginI18n}
       * @default {English/US}
       */
      i18n: {
        type: Object,
        value() {
          return {
            form: {
              title: "Log in",
              username: "Username",
              password: "Password",
              submit: "Log in",
              forgotPassword: "Forgot password"
            },
            errorMessage: {
              title: "Incorrect username or password",
              message: "Check that you have entered the correct username and password and try again.",
              username: "Username is required",
              password: "Password is required"
            }
          };
        }
      },
      /**
       * Sets the root heading level (`aria-level`) for the heading hierarchy. Default value: 1.
       * Child headings automatically increment from this base level i.e. standalone login form
       * renders its title as `<h1>`, whereas the form in the overlay uses `<h2>`, as the `<h1>`
       * element is used by the overlay's own title.
       *
       * @attr {number} heading-level
       */
      headingLevel: {
        type: Number,
        value: 1
      },
      /**
       * If set, prevents auto enabling the component when error property is set to true.
       * @private
       */
      _preventAutoEnable: {
        type: Boolean,
        value: false
      }
    };
  }
};
/**
 * @license
 * Copyright (c) 2018 - 2025 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
function isCheckbox(field) {
  return (field.inputElement || field).type === "checkbox";
}
const LoginFormMixin = (superClass) => class LoginFormMixin extends LoginMixin(superClass) {
  static get observers() {
    return ["_errorChanged(error)"];
  }
  get _customFields() {
    return [...this.$.vaadinLoginFormWrapper.children].filter((node) => {
      return node.getAttribute("slot") === "custom-form-area" && node.hasAttribute("name");
    });
  }
  /** @protected */
  async connectedCallback() {
    super.connectedCallback();
    if (!this.noAutofocus) {
      await new Promise(requestAnimationFrame);
      this.$.vaadinLoginUsername.focus();
    }
  }
  /** @private */
  _errorChanged() {
    if (this.error && !this._preventAutoEnable) {
      this.disabled = false;
    }
  }
  /**
   * Submits the form.
   */
  submit() {
    const userName = this.$.vaadinLoginUsername;
    const password = this.$.vaadinLoginPassword;
    userName.validate();
    password.validate();
    if (this.disabled || userName.invalid || password.invalid) {
      return;
    }
    this.error = false;
    this.disabled = true;
    const detail = {
      username: userName.value,
      password: password.value
    };
    const fields2 = this._customFields;
    if (fields2.length) {
      detail.custom = {};
      fields2.forEach((field) => {
        if (isCheckbox(field) && !field.checked) {
          return;
        }
        detail.custom[field.name] = field.value;
      });
    }
    const loginEventDetails = {
      bubbles: true,
      cancelable: true,
      detail
    };
    const firedEvent = this.dispatchEvent(new CustomEvent("login", loginEventDetails));
    if (this.action && firedEvent) {
      const csrfMetaName = document.querySelector("meta[name=_csrf_parameter]");
      const csrfMetaValue = document.querySelector("meta[name=_csrf]");
      if (csrfMetaName && csrfMetaValue) {
        this.$.csrf.name = csrfMetaName.content;
        this.$.csrf.value = csrfMetaValue.content;
      }
      this.querySelector("form").submit();
    }
  }
  /** @protected */
  _onFormData(event) {
    const { formData } = event;
    if (this._customFields.length) {
      this._customFields.forEach((field) => {
        if (isCheckbox(field) && !field.checked) {
          return;
        }
        formData.append(field.name, field.value);
      });
    }
  }
  /** @protected */
  _handleInputKeydown(e2) {
    if (e2.key === "Enter") {
      const { currentTarget: inputActive } = e2;
      const nextInput = inputActive.id === "vaadinLoginUsername" ? this.$.vaadinLoginPassword : this.$.vaadinLoginUsername;
      if (inputActive.validate()) {
        if (nextInput.checkValidity()) {
          this.submit();
        } else {
          nextInput.focus();
        }
      }
    }
  }
  /** @protected */
  _handleInputKeyup(e2) {
    const input = e2.currentTarget;
    if (e2.key === "Tab" && input instanceof HTMLInputElement) {
      input.select();
    }
  }
  /** @protected */
  _onForgotPasswordClick() {
    this.dispatchEvent(new CustomEvent("forgot-password"));
  }
};
/**
 * @license
 * Copyright (c) 2018 - 2025 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
class LoginForm extends LoginFormMixin(ElementMixin(ThemableMixin(PolymerElement))) {
  static get template() {
    return html`
      <style>
        vaadin-login-form-wrapper > form > * {
          width: 100%;
        }
      </style>
      <vaadin-login-form-wrapper
        id="vaadinLoginFormWrapper"
        theme$="[[_theme]]"
        error="[[error]]"
        i18n="[[i18n]]"
        heading-level="[[headingLevel]]"
      >
        <form method="POST" action$="[[action]]" on-formdata="_onFormData" slot="form">
          <input id="csrf" type="hidden" />
          <vaadin-text-field
            name="username"
            label="[[i18n.form.username]]"
            error-message="[[i18n.errorMessage.username]]"
            id="vaadinLoginUsername"
            required
            on-keydown="_handleInputKeydown"
            autocapitalize="none"
            autocorrect="off"
            spellcheck="false"
            autocomplete="username"
            manual-validation
          >
            <input type="text" slot="input" on-keyup="_handleInputKeyup" />
          </vaadin-text-field>

          <vaadin-password-field
            name="password"
            label="[[i18n.form.password]]"
            error-message="[[i18n.errorMessage.password]]"
            id="vaadinLoginPassword"
            required
            on-keydown="_handleInputKeydown"
            spellcheck="false"
            autocomplete="current-password"
            manual-validation
          >
            <input type="password" slot="input" on-keyup="_handleInputKeyup" />
          </vaadin-password-field>
        </form>

        <vaadin-button slot="submit" theme="primary contained submit" on-click="submit" disabled$="[[disabled]]">
          [[i18n.form.submit]]
        </vaadin-button>

        <vaadin-button
          slot="forgot-password"
          theme="tertiary small"
          on-click="_onForgotPasswordClick"
          hidden$="[[noForgotPassword]]"
        >
          [[i18n.form.forgotPassword]]
        </vaadin-button>
      </vaadin-login-form-wrapper>
    `;
  }
  static get is() {
    return "vaadin-login-form";
  }
  /**
   * @param {StampedTemplate} dom
   * @return {null}
   * @protected
   */
  _attachDom(dom) {
    this.appendChild(dom);
  }
}
defineCustomElement(LoginForm);
const loginOverlayWrapper = css`
  :host {
    inset: 0;
  }

  [part='backdrop'] {
    background: var(--lumo-base-color) linear-gradient(var(--lumo-shade-5pct), var(--lumo-shade-5pct));
  }

  [part='overlay'] {
    background: none;
    border-radius: 0;
    box-shadow: none;
    width: 100%;
    height: 100%;
  }

  [part='brand'] {
    padding: var(--lumo-space-l) var(--lumo-space-xl) var(--lumo-space-l) var(--lumo-space-l);
    background-color: var(--lumo-primary-color);
    color: var(--lumo-primary-contrast-color);
    min-height: calc(var(--lumo-size-m) * 5);
  }

  [part='title'] {
    font-size: var(--lumo-font-size-xxxl);
    font-weight: 600;
    line-height: var(--lumo-line-height-xs);
  }

  [part='description'] {
    line-height: var(--lumo-line-height-s);
    color: var(--lumo-tint-70pct);
    margin-bottom: 0;
  }

  [part='content'] {
    height: 100%;
    display: flex;
    align-items: center;
    justify-content: center;
    padding: 0;
  }

  [part='card'] {
    width: calc(var(--lumo-size-m) * 10);
    background: var(--lumo-base-color) linear-gradient(var(--lumo-tint-5pct), var(--lumo-tint-5pct));
    border-radius: var(--lumo-border-radius-l);
    box-shadow: var(--lumo-box-shadow-s);
    margin: var(--lumo-space-s);
    height: auto;
  }

  /* Small screen */
  @media only screen and (max-width: 500px) {
    [part='overlay'],
    [part='content'] {
      height: 100%;
    }

    [part='content'] {
      min-height: 100%;
      background: var(--lumo-base-color);
      align-items: flex-start;
    }

    [part='card'],
    [part='overlay'] {
      width: 100%;
      border-radius: 0;
      box-shadow: none;
      margin: 0;
    }

    /* RTL styles */
    :host([dir='rtl']) [part='brand'] {
      padding: var(--lumo-space-l) var(--lumo-space-l) var(--lumo-space-l) var(--lumo-space-xl);
    }
  }

  /* Landscape small screen */
  @media only screen and (max-height: 600px) and (min-width: 600px) and (orientation: landscape) {
    [part='card'] {
      flex-direction: row;
      align-items: stretch;
      max-width: calc(var(--lumo-size-m) * 16);
      width: 100%;
    }

    [part='brand'],
    [part='form'] {
      flex: auto;
      flex-basis: 0;
      box-sizing: border-box;
    }

    [part='brand'] {
      justify-content: flex-start;
    }

    [part='form'] {
      padding: var(--lumo-space-l);
      overflow: auto;
    }
  }

  /* Landscape really small screen */
  @media only screen and (max-height: 500px) and (min-width: 600px) and (orientation: landscape),
    only screen and (max-width: 600px) and (min-width: 600px) and (orientation: landscape) {
    [part='content'] {
      height: 100vh;
    }

    [part='card'] {
      margin: 0;
      width: 100%;
      max-width: none;
      height: 100%;
      flex: auto;
      border-radius: 0;
      box-shadow: none;
    }

    [part='form'] {
      height: 100%;
      overflow: auto;
      -webkit-overflow-scrolling: touch;
    }
  }

  /* Handle iPhone X notch */
  @media only screen and (device-width: 375px) and (device-height: 812px) and (-webkit-device-pixel-ratio: 3) {
    [part='card'] {
      padding-right: env(safe-area-inset-right);
      padding-left: env(safe-area-inset-left);
    }

    [part='brand'] {
      margin-left: calc(env(safe-area-inset-left) * -1);
      padding-left: calc(var(--lumo-space-l) + env(safe-area-inset-left));
    }

    /* RTL styles */
    :host([dir='rtl']) [part='card'] {
      padding-left: env(safe-area-inset-right);
      padding-right: env(safe-area-inset-left);
    }

    :host([dir='rtl']) [part='brand'] {
      margin-right: calc(env(safe-area-inset-left) * -1);
      padding-right: calc(var(--lumo-space-l) + env(safe-area-inset-left));
    }
  }
`;
registerStyles$1("vaadin-login-overlay-wrapper", [color, typography, overlay, loginOverlayWrapper], {
  moduleId: "lumo-login-overlay-wrapper"
});
const loginFormWrapper = css`
  :host([theme~='with-overlay']) {
    min-height: 100%;
    display: flex;
    justify-content: center;
    max-width: 100%;
  }

  /* Landscape small screen */
  @media only screen and (max-height: 600px) and (min-width: 600px) and (orientation: landscape) {
    :host([theme~='with-overlay']) [part='form'] {
      height: 100%;
      -webkit-overflow-scrolling: touch;
      flex: 1;
      padding: 2px;
    }
  }
`;
registerStyles$1("vaadin-login-form-wrapper", [loginFormWrapper], {
  moduleId: "lumo-login-overlay"
});
/**
 * @license
 * Copyright (c) 2018 - 2025 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const LoginOverlayWrapperMixin = (superClass) => class LoginOverlayWrapperMixin extends OverlayMixin(DirMixin(superClass)) {
  static get properties() {
    return {
      /**
       * Title of the application.
       */
      title: {
        type: String,
        observer: "_titleChanged"
      },
      /**
       * Application description. Displayed under the title.
       */
      description: {
        type: String
      },
      /**
       * Used to customize the `aria-level` attribute on the heading element.
       */
      headingLevel: {
        type: Number
      }
    };
  }
  /** @protected */
  ready() {
    super.ready();
    const slot = this.shadowRoot.querySelector('slot[name="title"]');
    this._titleSlotObserver = new SlotObserver(slot, () => {
      const title = slot.assignedElements({ flatten: true })[0];
      if (!title) {
        return;
      }
      if (title.getAttribute("part") === "title") {
        this.setAttribute("aria-label", this.title);
        this.removeAttribute("aria-labelledby");
      } else {
        if (!title.id) {
          title.id = `login-overlay-title-${generateUniqueId()}`;
        }
        this.removeAttribute("aria-label");
        this.setAttribute("aria-labelledby", title.id);
      }
    });
  }
  /** @private */
  _titleChanged(title) {
    if (title && this.hasAttribute("aria-label")) {
      this.setAttribute("aria-label", title);
    }
  }
};
/**
 * @license
 * Copyright (c) 2018 - 2025 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const loginOverlayWrapperStyles = css`
  [part='overlay'] {
    outline: none;
  }

  [part='card'] {
    max-width: 100%;
    box-sizing: border-box;
    overflow: hidden;
    display: flex;
    flex-direction: column;
  }

  [part='brand'] {
    box-sizing: border-box;
    overflow: hidden;
    flex-grow: 1;
    flex-shrink: 0;
    display: flex;
    flex-direction: column;
    justify-content: flex-end;
  }

  [part='title'] {
    color: inherit;
    margin: 0;
  }
`;
/**
 * @license
 * Copyright (c) 2018 - 2025 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
registerStyles$1("vaadin-login-overlay-wrapper", [overlayStyles, loginOverlayWrapperStyles], {
  moduleId: "vaadin-login-overlay-wrapper-styles"
});
class LoginOverlayWrapper extends LoginOverlayWrapperMixin(ThemableMixin(PolymerElement)) {
  static get is() {
    return "vaadin-login-overlay-wrapper";
  }
  static get template() {
    return html`
      <div id="backdrop" part="backdrop" hidden$="[[!withBackdrop]]"></div>
      <div part="overlay" id="overlay" tabindex="0">
        <div part="content" id="content">
          <section part="card">
            <div part="brand">
              <slot name="title">
                <div part="title" role="heading" aria-level$="[[headingLevel]]">[[title]]</div>
              </slot>
              <p part="description">[[description]]</p>
            </div>
            <div part="form">
              <slot></slot>
            </div>
          </section>
        </div>
      </div>
    `;
  }
}
defineCustomElement(LoginOverlayWrapper);
/**
 * @license
 * Copyright (c) 2018 - 2025 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const LoginOverlayMixin = (superClass) => class LoginOverlayMixin extends OverlayClassMixin(LoginMixin(superClass)) {
  static get properties() {
    return {
      /**
       * Defines the application description
       * @type {string}
       */
      description: {
        type: String,
        value: "Application description",
        notify: true
      },
      /**
       * True if the overlay is currently displayed.
       * @type {boolean}
       */
      opened: {
        type: Boolean,
        value: false,
        observer: "_onOpenedChange"
      },
      /**
       * Defines the application title
       * @type {string}
       */
      title: {
        type: String,
        value: "App name"
      }
    };
  }
  static get observers() {
    return ["__i18nChanged(i18n)"];
  }
  /** @protected */
  ready() {
    super.ready();
    this._overlayElement = this.$.vaadinLoginOverlayWrapper;
  }
  /** @protected */
  connectedCallback() {
    super.connectedCallback();
    if (this.__restoreOpened) {
      this.opened = true;
    }
  }
  /** @protected */
  disconnectedCallback() {
    super.disconnectedCallback();
    this.__restoreOpened = this.opened;
    this.opened = false;
  }
  /** @private */
  __i18nChanged(i18n) {
    const header = i18n && i18n.header;
    if (!header) {
      return;
    }
    this.title = header.title;
    this.description = header.description;
  }
  /** @protected */
  _preventClosingLogin(e2) {
    e2.preventDefault();
  }
  /**
   * @param {!Event} e
   * @protected
   */
  _retargetEvent(e2) {
    e2.stopPropagation();
    const { detail, composed, cancelable, bubbles } = e2;
    const firedEvent = this.dispatchEvent(new CustomEvent(e2.type, { bubbles, cancelable, composed, detail }));
    if (!firedEvent) {
      e2.preventDefault();
    }
  }
  /** @private */
  _onOpenedChange() {
    const form = this.$.vaadinLoginForm;
    if (!this.opened) {
      form.$.vaadinLoginUsername.value = "";
      form.$.vaadinLoginPassword.value = "";
      this.disabled = false;
      if (this._undoTitleTeleport) {
        this._undoTitleTeleport();
      }
      if (this._undoFieldsTeleport) {
        this._undoFieldsTeleport();
      }
      if (this._undoFooterTeleport) {
        this._undoFooterTeleport();
      }
    } else {
      this._undoTitleTeleport = this._teleport("title", this.$.vaadinLoginOverlayWrapper);
      this._undoFieldsTeleport = this._teleport(
        "custom-form-area",
        form.$.vaadinLoginFormWrapper,
        form.querySelector("vaadin-button")
      );
      this._undoFooterTeleport = this._teleport("footer", form.$.vaadinLoginFormWrapper);
      document.body.style.pointerEvents = this.$.vaadinLoginOverlayWrapper._previousDocumentPointerEvents;
    }
  }
  /** @private */
  _teleport(slot, target, refNode) {
    const teleported = [...this.querySelectorAll(`[slot="${slot}"]`)].map((el) => {
      if (refNode) {
        target.insertBefore(el, refNode);
      } else {
        target.appendChild(el);
      }
      return el;
    });
    return () => {
      this.append(...teleported);
    };
  }
  /** @private */
  __computeHeadingLevel(headingLevel) {
    return headingLevel + 1;
  }
};
/**
 * @license
 * Copyright (c) 2018 - 2025 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
class LoginOverlay extends LoginOverlayMixin(ElementMixin(ThemableMixin(PolymerElement))) {
  static get template() {
    return html`
      <vaadin-login-overlay-wrapper
        id="vaadinLoginOverlayWrapper"
        opened="{{opened}}"
        role="dialog"
        focus-trap
        with-backdrop
        title="[[title]]"
        description="[[description]]"
        heading-level="[[headingLevel]]"
        theme$="[[_theme]]"
        on-vaadin-overlay-escape-press="_preventClosingLogin"
        on-vaadin-overlay-outside-click="_preventClosingLogin"
      >
        <vaadin-login-form
          theme="with-overlay"
          id="vaadinLoginForm"
          action="[[action]]"
          disabled="{{disabled}}"
          error="{{error}}"
          heading-level="[[__computeHeadingLevel(headingLevel)]]"
          no-autofocus="[[noAutofocus]]"
          no-forgot-password="[[noForgotPassword]]"
          i18n="{{i18n}}"
          on-login="_retargetEvent"
          on-forgot-password="_retargetEvent"
        ></vaadin-login-form>
      </vaadin-login-overlay-wrapper>

      <div hidden>
        <slot name="custom-form-area"></slot>
        <slot name="footer"></slot>
      </div>
    `;
  }
  static get is() {
    return "vaadin-login-overlay";
  }
}
defineCustomElement(LoginOverlay);
function initLazy(menubar, appId) {
  if (menubar.$connector) {
    return;
  }
  const observer2 = new MutationObserver((records) => {
    const hasChangedAttributes = records.some((entry) => {
      const oldValue = entry.oldValue;
      const newValue = entry.target.getAttribute(entry.attributeName);
      return oldValue !== newValue;
    });
    if (hasChangedAttributes) {
      menubar.$connector.generateItems();
    }
  });
  menubar.$connector = {
    /**
     * Generates and assigns the items to the menu bar.
     *
     * When the method is called without providing a node id,
     * the previously generated items tree will be used.
     * That can be useful if you only want to sync the disabled and hidden properties of root items.
     *
     * @param {number | undefined} nodeId
     */
    generateItems(nodeId) {
      if (!menubar.shadowRoot) {
        setTimeout(() => menubar.$connector.generateItems(nodeId));
        return;
      }
      if (!menubar._container) {
        queueMicrotask(() => menubar.$connector.generateItems(nodeId));
        return;
      }
      if (nodeId) {
        menubar.__generatedItems = window.Vaadin.Flow.contextMenuConnector.generateItemsTree(appId, nodeId);
      }
      let items = menubar.__generatedItems || [];
      items.forEach((item2) => {
        item2.disabled = item2.component.disabled;
        item2.component._rootItem = item2;
      });
      items.forEach((item2) => {
        observer2.observe(item2.component, {
          attributeFilter: ["hidden", "disabled"],
          attributeOldValue: true
        });
      });
      items = items.filter((item2) => !item2.component.hidden);
      menubar.items = items;
      menubar._buttons.forEach((button2) => {
        if (button2.item && button2.item.component) {
          button2.addEventListener("click", (e2) => {
            if (e2.composedPath().indexOf(button2.item.component) === -1) {
              button2.item.component.click();
              e2.stopPropagation();
            }
          });
        }
      });
    }
  };
}
function setClassName(component) {
  const item2 = component._rootItem || component._item;
  if (item2) {
    item2.className = component.className;
  }
}
window.Vaadin.Flow.menubarConnector = { initLazy, setClassName };
const menuBarButton = css`
  :host {
    margin: calc(var(--lumo-space-xs) / 2);
    margin-left: 0;
    border-radius: 0;
  }

  [part='label'] {
    width: 100%;
  }

  /* NOTE(web-padawan): avoid using shorthand padding property for IE11 */
  [part='label'] ::slotted(vaadin-menu-bar-item) {
    justify-content: center;
    background-color: transparent;
    height: var(--lumo-button-size);
    margin: 0 calc((var(--lumo-size-m) / 3 + var(--lumo-border-radius-m) / 2) * -1);
    padding-left: calc(var(--lumo-size-m) / 3 + var(--lumo-border-radius-m) / 2);
    padding-right: calc(var(--lumo-size-m) / 3 + var(--lumo-border-radius-m) / 2);
  }

  :host([theme~='small']) [part='label'] ::slotted(vaadin-menu-bar-item) {
    min-height: var(--lumo-size-s);
    margin: 0 calc((var(--lumo-size-s) / 3 + var(--lumo-border-radius-m) / 2) * -1);
    padding-left: calc(var(--lumo-size-s) / 3 + var(--lumo-border-radius-m) / 2);
    padding-right: calc(var(--lumo-size-s) / 3 + var(--lumo-border-radius-m) / 2);
  }

  :host([theme~='tertiary']) [part='label'] ::slotted(vaadin-menu-bar-item) {
    margin: 0 calc((var(--lumo-button-size) / 6) * -1);
    padding-left: calc(var(--lumo-button-size) / 6);
    padding-right: calc(var(--lumo-button-size) / 6);
  }

  :host([theme~='tertiary-inline']) {
    margin-top: calc(var(--lumo-space-xs) / 2);
    margin-bottom: calc(var(--lumo-space-xs) / 2);
    margin-right: calc(var(--lumo-space-xs) / 2);
  }

  :host([theme~='tertiary-inline']) [part='label'] ::slotted(vaadin-menu-bar-item) {
    margin: 0;
    padding: 0;
  }

  :host([first-visible]) {
    border-radius: var(--lumo-border-radius-m) 0 0 var(--lumo-border-radius-m);

    /* Needed to retain the focus-ring with border-radius */
    margin-left: calc(var(--lumo-space-xs) / 2);
  }

  :host([last-visible]),
  :host([slot='overflow']) {
    border-radius: 0 var(--lumo-border-radius-m) var(--lumo-border-radius-m) 0;
  }

  :host([theme~='tertiary']),
  :host([theme~='tertiary-inline']) {
    border-radius: var(--lumo-border-radius-m);
  }

  :host([slot='overflow']) {
    min-width: var(--lumo-button-size);
    padding-left: calc(var(--lumo-button-size) / 4);
    padding-right: calc(var(--lumo-button-size) / 4);
  }

  :host([slot='overflow']) ::slotted(*) {
    font-size: var(--lumo-font-size-xl);
  }

  :host([slot='overflow']) [part='prefix'],
  :host([slot='overflow']) [part='suffix'] {
    margin-left: 0;
    margin-right: 0;
  }

  :host([theme~='dropdown-indicators']:not([slot='overflow']):not([theme~='icon'])[aria-haspopup]) [part='suffix'] {
    margin-inline-start: 0;
    width: 1em;
    height: 1em;
    line-height: 1;
    font-size: var(--lumo-icon-size-s);
    position: relative;
    inset-inline-start: 0.15em;
  }

  /* prettier-ignore */
  :host([theme~='dropdown-indicators']:not([slot='overflow']):not([theme~='icon'])[aria-haspopup]) [part='suffix']::after {
    font-family: lumo-icons;
    content: var(--lumo-icons-dropdown);
  }

  /* prettier-ignore */
  :host([theme~='dropdown-indicators']:not([slot='overflow']):not([theme~='icon'])[theme~='tertiary'][aria-haspopup]) [part='suffix'] {
    inset-inline-start: 0.05em;
  }

  /* prettier-ignore */
  :host([theme~='dropdown-indicators']:not([slot='overflow']):not([theme~='icon'])[theme~='tertiary-inline'][aria-haspopup]) [part='suffix'] {
    inset-inline-start: 0;
  }

  /* RTL styles */
  :host([dir='rtl']) {
    margin-left: calc(var(--lumo-space-xs) / 2);
    margin-right: 0;
    border-radius: 0;
  }

  :host([dir='rtl'][first-visible]) {
    border-radius: 0 var(--lumo-border-radius-m) var(--lumo-border-radius-m) 0;
    margin-right: calc(var(--lumo-space-xs) / 2);
  }

  :host([dir='rtl'][last-visible]),
  :host([dir='rtl'][slot='overflow']) {
    border-radius: var(--lumo-border-radius-m) 0 0 var(--lumo-border-radius-m);
  }
`;
registerStyles$1("vaadin-menu-bar-button", [button, menuBarButton], {
  moduleId: "lumo-menu-bar-button"
});
/**
 * @license
 * Copyright (c) 2019 - 2025 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
registerStyles$1(
  "vaadin-menu-bar-button",
  css`
    :host {
      flex-shrink: 0;
    }

    :host([slot='overflow']) {
      margin-inline-end: 0;
    }
  `,
  { moduleId: "vaadin-menu-bar-button-styles" }
);
class MenuBarButton extends Button {
  static get is() {
    return "vaadin-menu-bar-button";
  }
  /**
   * Override method inherited from `ButtonMixin`. Sets a flag based on whether the key is an active key. Unlike a mouse click, Enter and Space should also focus the first item. This flag is used in menu bar to identify the action that triggered the click.
   *
   * @param {KeyboardEvent} event
   * @protected
   * @override
   */
  _onKeyDown(event) {
    this.__triggeredWithActiveKeys = this._activeKeys.includes(event.key);
    super._onKeyDown(event);
    this.__triggeredWithActiveKeys = null;
  }
  /**
   * Override method inherited from `ButtonMixin` to allow keyboard navigation with
   * arrow keys in the menu bar when the button is focusable in the disabled state.
   *
   * @override
   */
  __shouldSuppressInteractionEvent(event) {
    if (event.type === "keydown" && ["ArrowLeft", "ArrowRight"].includes(event.key)) {
      return false;
    }
    return super.__shouldSuppressInteractionEvent(event);
  }
}
defineCustomElement(MenuBarButton);
const menuBarItem = css`
  [part='content'] {
    display: flex;
    /* tweak to inherit centering from menu bar button */
    align-items: inherit;
    justify-content: inherit;
  }

  [part='content'] ::slotted(vaadin-icon) {
    display: inline-block;
    width: var(--lumo-icon-size-m);
    height: var(--lumo-icon-size-m);
  }

  [part='content'] ::slotted(vaadin-icon[icon^='vaadin:']) {
    padding: var(--lumo-space-xs);
    box-sizing: border-box !important;
  }
`;
registerStyles$1("vaadin-menu-bar-item", [item, contextMenuItem, menuBarItem], { moduleId: "lumo-menu-bar-item" });
registerStyles$1("vaadin-menu-bar-list-box", [listBox, contextMenuListBox], { moduleId: "lumo-menu-bar-list-box" });
const menuBarOverlay = css`
  :host(:first-of-type) {
    padding-top: var(--lumo-space-xs);
  }
`;
registerStyles$1("vaadin-menu-bar-overlay", [menuOverlay, contextMenuOverlay, menuBarOverlay], {
  moduleId: "lumo-menu-bar-overlay"
});
registerStyles$1(
  "vaadin-menu-bar",
  css`
    :host([has-single-button]) ::slotted(vaadin-menu-bar-button) {
      border-radius: var(--lumo-border-radius-m);
    }

    :host([theme~='end-aligned']) ::slotted(vaadin-menu-bar-button[first-visible]),
    :host([theme~='end-aligned'][has-single-button]) ::slotted(vaadin-menu-bar-button) {
      margin-inline-start: auto;
    }
  `,
  { moduleId: "lumo-menu-bar" }
);
/**
 * @license
 * Copyright (c) 2019 - 2025 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
class MenuBarItem extends ItemMixin(ThemableMixin(DirMixin(PolymerElement))) {
  static get is() {
    return "vaadin-menu-bar-item";
  }
  static get template() {
    return html`
      <style>
        :host {
          display: inline-block;
        }

        :host([hidden]) {
          display: none !important;
        }
      </style>
      <span part="checkmark" aria-hidden="true"></span>
      <div part="content">
        <slot></slot>
      </div>
    `;
  }
  /** @protected */
  connectedCallback() {
    super.connectedCallback();
    this.setAttribute("role", "menuitem");
  }
}
defineCustomElement(MenuBarItem);
/**
 * @license
 * Copyright (c) 2019 - 2025 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
class MenuBarListBox extends ListMixin(ThemableMixin(DirMixin(ControllerMixin(PolymerElement)))) {
  static get is() {
    return "vaadin-menu-bar-list-box";
  }
  static get template() {
    return html`
      <style>
        :host {
          display: flex;
        }

        :host([hidden]) {
          display: none !important;
        }

        [part='items'] {
          height: 100%;
          width: 100%;
          overflow-y: auto;
          -webkit-overflow-scrolling: touch;
        }
      </style>
      <div part="items">
        <slot></slot>
      </div>
    `;
  }
  static get properties() {
    return {
      // We don't need to define this property since super default is vertical,
      // but we don't want it to be modified, or be shown in the API docs.
      /** @private */
      orientation: {
        readOnly: true
      }
    };
  }
  /**
   * @return {!HTMLElement}
   * @protected
   * @override
   */
  get _scrollerElement() {
    return this.shadowRoot.querySelector('[part="items"]');
  }
  /** @protected */
  ready() {
    super.ready();
    this.setAttribute("role", "menu");
  }
}
defineCustomElement(MenuBarListBox);
/**
 * @license
 * Copyright (c) 2019 - 2025 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
registerStyles$1("vaadin-menu-bar-overlay", [overlayStyles, styles], {
  moduleId: "vaadin-menu-bar-overlay-styles"
});
class MenuBarOverlay extends MenuOverlayMixin(OverlayMixin(DirMixin(ThemableMixin(PolymerElement)))) {
  static get is() {
    return "vaadin-menu-bar-overlay";
  }
  static get template() {
    return html`
      <div id="backdrop" part="backdrop" hidden$="[[!withBackdrop]]"></div>
      <div part="overlay" id="overlay" tabindex="0">
        <div part="content" id="content">
          <slot></slot>
        </div>
      </div>
    `;
  }
}
defineCustomElement(MenuBarOverlay);
/**
 * @license
 * Copyright (c) 2019 - 2025 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const SubMenuMixin = (superClass) => class SubMenuMixinClass extends ContextMenuMixin(OverlayClassMixin(superClass)) {
  constructor() {
    super();
    this.openOn = "opensubmenu";
  }
  /**
   * Tag name prefix used by overlay, list-box and items.
   * @protected
   * @return {string}
   */
  get _tagNamePrefix() {
    return "vaadin-menu-bar";
  }
  /**
   * Overriding the observer to not add global "contextmenu" listener.
   */
  _openedChanged(opened) {
    this._overlayElement.opened = opened;
  }
  /**
   * Overriding the public method to reset expanded button state.
   */
  close() {
    super.close();
    if (this.hasAttribute("is-root")) {
      this.getRootNode().host._close();
    }
  }
  /**
   * Override method from `ContextMenuMixin` to prevent closing
   * sub-menu on the same click event that was used to open it.
   *
   * @param {Event} event
   * @return {boolean}
   * @protected
   * @override
   */
  _shouldCloseOnOutsideClick(event) {
    if (this.hasAttribute("is-root") && event.composedPath().includes(this.listenOn)) {
      return false;
    }
    return super._shouldCloseOnOutsideClick(event);
  }
};
/**
 * @license
 * Copyright (c) 2019 - 2025 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
class MenuBarSubmenu extends SubMenuMixin(ControllerMixin(ThemePropertyMixin(PolymerElement))) {
  static get is() {
    return "vaadin-menu-bar-submenu";
  }
  static get template() {
    return html`
      <style>
        :host {
          display: block;
        }

        :host([hidden]) {
          display: none !important;
        }
      </style>

      <slot id="slot"></slot>
    `;
  }
  /**
   * @param {DocumentFragment} dom
   * @return {ShadowRoot}
   * @protected
   * @override
   */
  _attachDom(dom) {
    const root2 = this.attachShadow({ mode: "open" });
    root2.appendChild(dom);
    root2.appendChild(this._overlayElement);
    return root2;
  }
}
defineCustomElement(MenuBarSubmenu);
/**
 * @license
 * Copyright (c) 2019 - 2025 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const MenuBarMixin = (superClass) => class MenuBarMixinClass extends KeyboardDirectionMixin(
  ResizeMixin(FocusMixin(DisabledMixin(ControllerMixin(superClass))))
) {
  static get properties() {
    return {
      /**
       * @typedef MenuBarItem
       * @type {object}
       * @property {string} text - Text to be set as the menu button component's textContent.
       * @property {string} tooltip - Text to be set as the menu button's tooltip.
       * Requires a `<vaadin-tooltip slot="tooltip">` element to be added inside the `<vaadin-menu-bar>`.
       * @property {union: string | object} component - The component to represent the button content.
       * Either a tagName or an element instance. Defaults to "vaadin-menu-bar-item".
       * @property {boolean} disabled - If true, the button is disabled and cannot be activated.
       * @property {union: string | string[]} theme - Theme(s) to be set as the theme attribute of the button, overriding any theme set on the menu bar.
       * @property {SubMenuItem[]} children - Array of submenu items.
       */
      /**
       * @typedef SubMenuItem
       * @type {object}
       * @property {string} text - Text to be set as the menu item component's textContent.
       * @property {union: string | object} component - The component to represent the item.
       * Either a tagName or an element instance. Defaults to "vaadin-menu-bar-item".
       * @property {boolean} disabled - If true, the item is disabled and cannot be selected.
       * @property {boolean} checked - If true, the item shows a checkmark next to it.
       * @property {SubMenuItem[]} children - Array of child submenu items.
       */
      /**
       * Defines a hierarchical structure, where root level items represent menu bar buttons,
       * and `children` property configures a submenu with items to be opened below
       * the button on click, Enter, Space, Up and Down arrow keys.
       *
       * #### Example
       *
       * ```js
       * menubar.items = [
       *   {
       *     text: 'File',
       *     className: 'file',
       *     children: [
       *       {text: 'Open', className: 'file open'}
       *       {text: 'Auto Save', checked: true},
       *     ]
       *   },
       *   {component: 'hr'},
       *   {
       *     text: 'Edit',
       *     children: [
       *       {text: 'Undo', disabled: true},
       *       {text: 'Redo'}
       *     ]
       *   },
       *   {text: 'Help'}
       * ];
       * ```
       *
       * #### Disabled buttons
       *
       * When disabled, menu bar buttons (root-level items) are rendered
       * as "dimmed" and prevent all user interactions (mouse and keyboard).
       *
       * Since disabled buttons are not focusable and cannot react to hover
       * events by default, it can cause accessibility issues by making them
       * entirely invisible to assistive technologies, and prevents the use
       * of Tooltips to explain why the action is not available. This can be
       * addressed by enabling the feature flag `accessibleDisabledButtons`,
       * which makes disabled buttons focusable and hoverable, while still
       * preventing them from being triggered:
       *
       * ```
       * // Set before any menu bar is attached to the DOM.
       * window.Vaadin.featureFlags.accessibleDisabledButtons = true;
       * ```
       *
       * ```
       * // Set before any menu bar is attached to the DOM.
       * window.Vaadin.featureFlags.accessibleDisabledButtons = true;
       * ```
       *
       * @type {!Array<!MenuBarItem>}
       */
      items: {
        type: Array,
        value: () => []
      },
      /**
       * The object used to localize this component.
       * To change the default localization, replace the entire
       * `i18n` object with a custom one.
       *
       * To update individual properties, extend the existing i18n object like so:
       * ```
       * menuBar.i18n = {
       *   ...menuBar.i18n,
       *   moreOptions: 'More options'
       * }
       * ```
       *
       * The object has the following JSON structure and default values:
       * ```
       * {
       *   moreOptions: 'More options'
       * }
       * ```
       *
       * @type {!MenuBarI18n}
       * @default {English/US}
       */
      i18n: {
        type: Object,
        value: () => {
          return {
            moreOptions: "More options"
          };
        }
      },
      /**
       * A space-delimited list of CSS class names
       * to set on each sub-menu overlay element.
       *
       * @attr {string} overlay-class
       */
      overlayClass: {
        type: String
      },
      /**
       * If true, the submenu will open on hover (mouseover) instead of click.
       * @attr {boolean} open-on-hover
       */
      openOnHover: {
        type: Boolean
      },
      /**
       * If true, the buttons will be collapsed into the overflow menu
       * starting from the "start" end of the bar instead of the "end".
       * @attr {boolean} reverse-collapse
       */
      reverseCollapse: {
        type: Boolean
      },
      /**
       * If true, the top-level menu items is traversable by tab
       * instead of arrow keys (i.e. disabling roving tabindex)
       * @attr {boolean} tab-navigation
       */
      tabNavigation: {
        type: Boolean
      },
      /**
       * @type {boolean}
       * @protected
       */
      _hasOverflow: {
        type: Boolean,
        value: false,
        sync: true
      },
      /** @protected */
      _overflow: {
        type: Object
      },
      /** @protected */
      _container: {
        type: Object
      }
    };
  }
  static get observers() {
    return [
      "_themeChanged(_theme, _overflow, _container)",
      "__hasOverflowChanged(_hasOverflow, _overflow)",
      "__i18nChanged(i18n, _overflow)",
      "_menuItemsChanged(items, _overflow, _container)",
      "_reverseCollapseChanged(reverseCollapse, _overflow, _container)",
      "_tabNavigationChanged(tabNavigation, _overflow, _container)"
    ];
  }
  constructor() {
    super();
    this.__boundOnContextMenuKeydown = this.__onContextMenuKeydown.bind(this);
    this.__boundOnTooltipMouseLeave = this.__onTooltipOverlayMouseLeave.bind(this);
  }
  /**
   * Override getter from `KeyboardDirectionMixin`
   * to use expanded button for arrow navigation
   * when the sub-menu is opened and has focus.
   *
   * @return {Element | null}
   * @protected
   * @override
   */
  get focused() {
    return (this._getItems() || []).find(isElementFocused) || this._expandedButton;
  }
  /**
   * Override getter from `KeyboardDirectionMixin`.
   *
   * @return {boolean}
   * @protected
   * @override
   */
  get _vertical() {
    return false;
  }
  /**
   * Override getter from `ResizeMixin` to observe parent.
   *
   * @protected
   * @override
   */
  get _observeParent() {
    return true;
  }
  /**
   * @return {!Array<!HTMLElement>}
   * @protected
   */
  get _buttons() {
    return Array.from(this.querySelectorAll("vaadin-menu-bar-button"));
  }
  /** @private */
  get _subMenu() {
    return this.shadowRoot.querySelector("vaadin-menu-bar-submenu");
  }
  /** @protected */
  ready() {
    super.ready();
    this.setAttribute("role", "menubar");
    this._overflowController = new SlotController(this, "overflow", "vaadin-menu-bar-button", {
      initializer: (btn) => {
        btn.setAttribute("hidden", "");
        const dots = document.createElement("div");
        dots.setAttribute("aria-hidden", "true");
        dots.innerHTML = "&centerdot;".repeat(3);
        btn.appendChild(dots);
        this._overflow = btn;
        this._initButtonAttrs(btn);
      }
    });
    this.addController(this._overflowController);
    this.addEventListener("mousedown", () => this._hideTooltip(true));
    this.addEventListener("mouseleave", () => this._hideTooltip());
    this._subMenu.addEventListener("item-selected", this.__onItemSelected.bind(this));
    this._subMenu.addEventListener("close-all-menus", this.__onEscapeClose.bind(this));
    const overlay2 = this._subMenu._overlayElement;
    overlay2.addEventListener("keydown", this.__boundOnContextMenuKeydown);
    const container = this.shadowRoot.querySelector('[part="container"]');
    container.addEventListener("click", this.__onButtonClick.bind(this));
    container.addEventListener("mouseover", (e2) => this._onMouseOver(e2));
    this._container = container;
  }
  /**
   * Override method inherited from `KeyboardDirectionMixin`
   * to use the list of menu-bar buttons as items.
   *
   * @return {Element[]}
   * @protected
   * @override
   */
  _getItems() {
    return this._buttons;
  }
  /** @protected */
  disconnectedCallback() {
    super.disconnectedCallback();
    this._hideTooltip(true);
  }
  /**
   * Implement callback from `ResizeMixin` to update buttons
   * and detect whether to show or hide the overflow button.
   *
   * @protected
   * @override
   */
  _onResize() {
    this.__scheduleOverflow();
  }
  /**
   * Override method inherited from `DisabledMixin`
   * to update the `disabled` property for the buttons
   * whenever the property changes on the menu bar.
   *
   * @param {boolean} newValue the new disabled value
   * @param {boolean} oldValue the previous disabled value
   * @override
   * @protected
   */
  _disabledChanged(newValue, oldValue) {
    super._disabledChanged(newValue, oldValue);
    if (oldValue !== newValue) {
      this.__updateButtonsDisabled(newValue);
    }
  }
  /**
   * A callback for the `_theme` property observer.
   * It propagates the host theme to the buttons and the sub menu.
   *
   * @param {string | null} theme
   * @private
   */
  _themeChanged(theme, overflow, container) {
    if (overflow && container) {
      this._buttons.forEach((btn) => this._setButtonTheme(btn, theme));
      this.__scheduleOverflow();
    }
    if (theme) {
      this._subMenu.setAttribute("theme", theme);
    } else {
      this._subMenu.removeAttribute("theme");
    }
  }
  /**
   * A callback for the 'reverseCollapse' property observer.
   *
   * @param {boolean | null} _reverseCollapse
   * @private
   */
  _reverseCollapseChanged(_reverseCollapse, overflow, container) {
    if (overflow && container) {
      this.__scheduleOverflow();
    }
  }
  /** @private */
  _tabNavigationChanged(tabNavigation, overflow, container) {
    if (overflow && container) {
      const target = this.querySelector('[tabindex="0"]');
      this._buttons.forEach((btn) => {
        if (target) {
          this._setTabindex(btn, btn === target);
        } else {
          this._setTabindex(btn, false);
        }
        btn.setAttribute("role", tabNavigation ? "button" : "menuitem");
      });
    }
    this.setAttribute("role", tabNavigation ? "group" : "menubar");
  }
  /** @private */
  __hasOverflowChanged(hasOverflow, overflow) {
    if (overflow) {
      overflow.toggleAttribute("hidden", !hasOverflow);
    }
  }
  /** @private */
  _menuItemsChanged(items, overflow, container) {
    if (!overflow || !container) {
      return;
    }
    if (items !== this._oldItems) {
      this._oldItems = items;
      this.__renderButtons(items);
    }
    const subMenu = this._subMenu;
    if (subMenu && subMenu.opened) {
      subMenu.close();
    }
  }
  /** @private */
  __i18nChanged(i18n, overflow) {
    if (overflow && i18n && i18n.moreOptions !== void 0) {
      if (i18n.moreOptions) {
        overflow.setAttribute("aria-label", i18n.moreOptions);
      } else {
        overflow.removeAttribute("aria-label");
      }
    }
  }
  /** @private */
  __getOverflowCount(overflow) {
    return overflow.item && overflow.item.children && overflow.item.children.length || 0;
  }
  /** @private */
  __restoreButtons(buttons) {
    buttons.forEach((button2) => {
      button2.disabled = button2.item && button2.item.disabled || this.disabled;
      button2.style.visibility = "";
      button2.style.position = "";
      button2.style.width = "";
      const item2 = button2.item && button2.item.component;
      if (item2 instanceof HTMLElement && item2.getAttribute("role") === "menuitem") {
        this.__restoreItem(button2, item2);
      }
    });
    this.__updateOverflow([]);
  }
  /** @private */
  __restoreItem(button2, item2) {
    button2.appendChild(item2);
    item2.removeAttribute("role");
    item2.removeAttribute("aria-expanded");
    item2.removeAttribute("aria-haspopup");
    item2.removeAttribute("tabindex");
  }
  /** @private */
  __updateButtonsDisabled(disabled) {
    this._buttons.forEach((btn) => {
      btn.disabled = disabled || btn.item && btn.item.disabled;
    });
  }
  /** @private */
  __updateOverflow(items) {
    this._overflow.item = { children: items };
    this._hasOverflow = items.length > 0;
  }
  /** @private */
  __setOverflowItems(buttons, overflow) {
    const container = this._container;
    if (container.offsetWidth < container.scrollWidth) {
      this._hasOverflow = true;
      const isRTL = this.__isRTL;
      const containerLeft = container.offsetLeft;
      const remaining = [...buttons];
      while (remaining.length) {
        const lastButton = remaining[remaining.length - 1];
        const btnLeft = lastButton.offsetLeft - containerLeft;
        if (!isRTL && btnLeft + lastButton.offsetWidth < container.offsetWidth - overflow.offsetWidth || isRTL && btnLeft >= overflow.offsetWidth) {
          break;
        }
        const btn = this.reverseCollapse ? remaining.shift() : remaining.pop();
        btn.style.width = getComputedStyle(btn).width;
        btn.disabled = true;
        btn.style.visibility = "hidden";
        btn.style.position = "absolute";
      }
      const items = buttons.filter((b2) => !remaining.includes(b2)).map((b2) => b2.item);
      this.__updateOverflow(items);
      if (remaining.length && !remaining.some((btn) => btn.getAttribute("tabindex") === "0")) {
        this._setTabindex(remaining[remaining.length - 1], true);
      }
    }
  }
  /** @private */
  __scheduleOverflow() {
    this._overflowDebouncer = Debouncer$1.debounce(this._overflowDebouncer, microTask$1, () => {
      this.__detectOverflow();
    });
  }
  /** @private */
  __detectOverflow() {
    const overflow = this._overflow;
    const buttons = this._buttons.filter((btn) => btn !== overflow);
    const oldOverflowCount = this.__getOverflowCount(overflow);
    this.__restoreButtons(buttons);
    this.__setOverflowItems(buttons, overflow);
    const newOverflowCount = this.__getOverflowCount(overflow);
    if (oldOverflowCount !== newOverflowCount && this._subMenu.opened) {
      this._subMenu.close();
    }
    const isSingleButton = newOverflowCount === buttons.length || newOverflowCount === 0 && buttons.length === 1;
    this.toggleAttribute("has-single-button", isSingleButton);
    buttons.filter((btn) => btn.style.visibility !== "hidden").forEach((btn, index, visibleButtons) => {
      btn.toggleAttribute("first-visible", index === 0);
      btn.toggleAttribute("last-visible", !this._hasOverflow && index === visibleButtons.length - 1);
    });
  }
  /** @protected */
  _removeButtons() {
    this._buttons.forEach((button2) => {
      if (button2 !== this._overflow) {
        this.removeChild(button2);
      }
    });
  }
  /** @protected */
  _initButton(item2) {
    const button2 = document.createElement("vaadin-menu-bar-button");
    const itemCopy = { ...item2 };
    button2.item = itemCopy;
    if (item2.component) {
      const component = this.__getComponent(itemCopy);
      itemCopy.component = component;
      component.item = itemCopy;
      button2.appendChild(component);
    } else if (item2.text) {
      button2.textContent = item2.text;
    }
    if (item2.className) {
      button2.className = item2.className;
    }
    button2.disabled = item2.disabled;
    return button2;
  }
  /** @protected */
  _initButtonAttrs(button2) {
    button2.setAttribute("role", this.tabNavigation ? "button" : "menuitem");
    if (button2 === this._overflow || button2.item && button2.item.children) {
      button2.setAttribute("aria-haspopup", "true");
      button2.setAttribute("aria-expanded", "false");
    }
  }
  /** @protected */
  _setButtonTheme(btn, hostTheme) {
    let theme = hostTheme;
    const itemTheme = btn.item && btn.item.theme;
    if (itemTheme != null) {
      theme = Array.isArray(itemTheme) ? itemTheme.join(" ") : itemTheme;
    }
    if (theme) {
      btn.setAttribute("theme", theme);
    } else {
      btn.removeAttribute("theme");
    }
  }
  /** @private */
  __getComponent(item2) {
    const itemComponent = item2.component;
    let component;
    const isElement2 = itemComponent instanceof HTMLElement;
    if (isElement2 && itemComponent.localName === "vaadin-menu-bar-item") {
      component = itemComponent;
    } else {
      component = document.createElement("vaadin-menu-bar-item");
      component.appendChild(isElement2 ? itemComponent : document.createElement(itemComponent));
    }
    if (item2.text) {
      const node = component.firstChild || component;
      node.textContent = item2.text;
    }
    return component;
  }
  /** @private */
  __renderButtons(items = []) {
    this._removeButtons();
    if (items.length === 0) {
      return;
    }
    items.forEach((item2) => {
      const button2 = this._initButton(item2);
      this.insertBefore(button2, this._overflow);
      this._initButtonAttrs(button2);
      this._setButtonTheme(button2, this._theme);
    });
    this.__scheduleOverflow();
  }
  /**
   * @param {HTMLElement} button
   * @protected
   */
  _showTooltip(button2, isHover) {
    const tooltip = this._tooltipController.node;
    if (tooltip && tooltip.isConnected) {
      if (tooltip.generator === void 0) {
        tooltip.generator = ({ item: item2 }) => item2 && item2.tooltip;
      }
      if (!tooltip._mouseLeaveListenerAdded) {
        tooltip._overlayElement.addEventListener("mouseleave", this.__boundOnTooltipMouseLeave);
        tooltip._mouseLeaveListenerAdded = true;
      }
      if (!this._subMenu.opened) {
        this._tooltipController.setTarget(button2);
        this._tooltipController.setContext({ item: button2.item });
        tooltip._stateController.open({
          hover: isHover,
          focus: !isHover
        });
      }
    }
  }
  /** @protected */
  _hideTooltip(immediate) {
    const tooltip = this._tooltipController && this._tooltipController.node;
    if (tooltip) {
      tooltip._stateController.close(immediate);
    }
  }
  /** @private */
  __onTooltipOverlayMouseLeave(event) {
    if (event.relatedTarget !== this._tooltipController.target) {
      this._hideTooltip();
    }
  }
  /** @protected */
  _setExpanded(button2, expanded) {
    button2.toggleAttribute("expanded", expanded);
    button2.toggleAttribute("active", expanded);
    button2.setAttribute("aria-expanded", expanded ? "true" : "false");
  }
  /** @protected */
  _setTabindex(button2, focused) {
    if (this.tabNavigation && this._isItemFocusable(button2)) {
      button2.setAttribute("tabindex", "0");
    } else {
      button2.setAttribute("tabindex", focused ? "0" : "-1");
    }
  }
  /**
   * Override method inherited from `KeyboardDirectionMixin`
   * to close the submenu for the previously focused button
   * and open another one for the newly focused button.
   *
   * @param {Element} item
   * @param {boolean} navigating
   * @protected
   * @override
   */
  _focusItem(item2, navigating) {
    const wasExpanded = navigating && this.focused === this._expandedButton;
    if (wasExpanded) {
      this._close();
    }
    super._focusItem(item2, navigating);
    this._buttons.forEach((btn) => {
      this._setTabindex(btn, btn === item2);
    });
    if (wasExpanded && item2.item && item2.item.children) {
      this.__openSubMenu(item2, true, { keepFocus: true });
    } else if (item2 === this._overflow) {
      this._hideTooltip();
    } else {
      this._showTooltip(item2);
    }
  }
  /** @private */
  _getButtonFromEvent(e2) {
    return Array.from(e2.composedPath()).find((el) => el.localName === "vaadin-menu-bar-button");
  }
  /**
   * Override method inherited from `FocusMixin`
   *
   * @param {boolean} focused
   * @override
   * @protected
   */
  _setFocused(focused) {
    if (focused) {
      let target = this.querySelector('[tabindex="0"]');
      if (this.tabNavigation) {
        target = this.querySelector("[focused]");
        this.__switchSubMenu(target);
      }
      if (target) {
        this._buttons.forEach((btn) => {
          this._setTabindex(btn, btn === target);
          if (btn === target && btn !== this._overflow && isKeyboardActive()) {
            this._showTooltip(btn);
          }
        });
      }
    } else {
      this._hideTooltip();
    }
  }
  /**
   * @param {!KeyboardEvent} event
   * @private
   */
  _onArrowDown(event) {
    event.preventDefault();
    const button2 = this._getButtonFromEvent(event);
    if (button2 === this._expandedButton) {
      this._focusFirstItem();
    } else {
      this.__openSubMenu(button2, true);
    }
  }
  /**
   * @param {!KeyboardEvent} event
   * @private
   */
  _onArrowUp(event) {
    event.preventDefault();
    const button2 = this._getButtonFromEvent(event);
    if (button2 === this._expandedButton) {
      this._focusLastItem();
    } else {
      this.__openSubMenu(button2, true, { focusLast: true });
    }
  }
  /**
   * Override an event listener from `KeyboardMixin`:
   * - to close the sub-menu for expanded button,
   * - to close a tooltip for collapsed button.
   *
   * @param {!KeyboardEvent} event
   * @protected
   * @override
   */
  _onEscape(event) {
    if (event.composedPath().includes(this._expandedButton)) {
      this._close(true);
    }
    this._hideTooltip(true);
  }
  /**
   * Override an event listener from `KeyboardMixin`.
   *
   * @param {!KeyboardEvent} event
   * @protected
   * @override
   */
  _onKeyDown(event) {
    switch (event.key) {
      case "ArrowDown":
        this._onArrowDown(event);
        break;
      case "ArrowUp":
        this._onArrowUp(event);
        break;
      default:
        super._onKeyDown(event);
        break;
    }
  }
  /**
   * @param {!MouseEvent} e
   * @protected
   */
  _onMouseOver(e2) {
    const button2 = this._getButtonFromEvent(e2);
    if (!button2) {
      this._hideTooltip();
    } else if (button2 !== this._expandedButton) {
      const isOpened = this._subMenu.opened;
      if (button2.item.children && (this.openOnHover || isOpened)) {
        this.__openSubMenu(button2, false);
      } else if (isOpened) {
        this._close();
      }
      if (button2 === this._overflow || this.openOnHover && button2.item.children) {
        this._hideTooltip();
      } else {
        this._showTooltip(button2, true);
      }
    }
  }
  /** @private */
  __onContextMenuKeydown(e2) {
    const item2 = Array.from(e2.composedPath()).find((el) => el._item);
    if (item2) {
      const list = item2.parentNode;
      if (e2.keyCode === 38 && item2 === list.items[0]) {
        this._close(true);
      }
      if (e2.keyCode === 37 || e2.keyCode === 39 && !item2._item.children) {
        e2.stopImmediatePropagation();
        this._onKeyDown(e2);
      } else if (e2.keyCode === 9 && this.tabNavigation) {
        const items = this._getItems() || [];
        const currentIdx = items.indexOf(this.focused);
        const increment = e2.shiftKey ? -1 : 1;
        let idx = currentIdx + increment;
        idx = this._getAvailableIndex(items, idx, increment, (item3) => !isElementHidden(item3));
        if (idx > currentIdx && e2.shiftKey || idx < currentIdx && !e2.shiftKey) {
          return;
        }
        this.__switchSubMenu(items[idx]);
      }
    }
  }
  /** @private */
  __switchSubMenu(target) {
    const wasExpanded = this._expandedButton != null && this._expandedButton !== target;
    if (wasExpanded) {
      this._close();
      if (target.item && target.item.children) {
        this.__openSubMenu(target, true, { keepFocus: true });
      }
    }
  }
  /** @private */
  __fireItemSelected(value) {
    this.dispatchEvent(new CustomEvent("item-selected", { detail: { value } }));
  }
  /** @private */
  __onButtonClick(e2) {
    const button2 = this._getButtonFromEvent(e2);
    if (button2) {
      this.__openSubMenu(button2, button2.__triggeredWithActiveKeys);
    }
  }
  /** @private */
  __openSubMenu(button2, keydown, options = {}) {
    if (button2.disabled) {
      return;
    }
    const subMenu = this._subMenu;
    const item2 = button2.item;
    if (subMenu.opened) {
      this._close();
      if (subMenu.listenOn === button2) {
        return;
      }
    }
    const items = item2 && item2.children;
    if (!items || items.length === 0) {
      this.__fireItemSelected(item2);
      return;
    }
    subMenu.items = items;
    subMenu.listenOn = button2;
    const overlay2 = subMenu._overlayElement;
    overlay2.noVerticalOverlap = true;
    this._expandedButton = button2;
    requestAnimationFrame(() => {
      if (overlay2.positionTarget && !overlay2.positionTarget.isConnected) {
        overlay2.positionTarget = null;
      }
      button2.dispatchEvent(
        new CustomEvent("opensubmenu", {
          detail: {
            children: items
          }
        })
      );
      this._hideTooltip(true);
      this._setExpanded(button2, true);
      overlay2.positionTarget = button2;
    });
    this.style.pointerEvents = "auto";
    overlay2.addEventListener(
      "vaadin-overlay-open",
      () => {
        if (options.focusLast) {
          this._focusLastItem();
        }
        if (options.keepFocus) {
          this._focusItem(this._expandedButton, false);
        }
        if (!keydown) {
          overlay2.$.overlay.focus();
        }
      },
      { once: true }
    );
  }
  /** @private */
  _focusFirstItem() {
    const list = this._subMenu._overlayElement.firstElementChild;
    list.focus();
  }
  /** @private */
  _focusLastItem() {
    const list = this._subMenu._overlayElement.firstElementChild;
    const item2 = list.items[list.items.length - 1];
    if (item2) {
      item2.focus();
    }
  }
  /** @private */
  __onItemSelected(e2) {
    e2.stopPropagation();
    this.__fireItemSelected(e2.detail.value);
  }
  /** @private */
  __onEscapeClose() {
    this.__deactivateButton(true);
  }
  /** @private */
  __deactivateButton(restoreFocus) {
    const button2 = this._expandedButton;
    if (button2 && button2.hasAttribute("expanded")) {
      this._setExpanded(button2, false);
      if (restoreFocus) {
        this._focusItem(button2, false);
      }
      this._expandedButton = null;
    }
  }
  /**
   * @param {boolean} restoreFocus
   * @protected
   */
  _close(restoreFocus = false) {
    this.style.pointerEvents = "";
    this.__deactivateButton(restoreFocus);
    if (this._subMenu.opened) {
      this._subMenu.close();
    }
  }
  /**
   * Closes the current submenu.
   */
  close() {
    this._close();
  }
  /**
   * Override method inherited from `KeyboardDirectionMixin` to allow
   * focusing disabled buttons that are configured so.
   *
   * @param {Element} button
   * @protected
   * @override
   */
  _isItemFocusable(button2) {
    if (button2.disabled && button2.__shouldAllowFocusWhenDisabled) {
      return button2.__shouldAllowFocusWhenDisabled();
    }
    return super._isItemFocusable(button2);
  }
};
/**
 * @license
 * Copyright (c) 2019 - 2025 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
class MenuBar extends MenuBarMixin(ElementMixin(ThemableMixin(PolymerElement))) {
  static get template() {
    return html`
      <style>
        :host {
          display: block;
        }

        :host([hidden]) {
          display: none !important;
        }

        [part='container'] {
          position: relative;
          display: flex;
          width: 100%;
          flex-wrap: nowrap;
          overflow: hidden;
        }
      </style>

      <div part="container">
        <slot></slot>
        <slot name="overflow"></slot>
      </div>
      <vaadin-menu-bar-submenu is-root overlay-class="[[overlayClass]]"></vaadin-menu-bar-submenu>

      <slot name="tooltip"></slot>
    `;
  }
  static get is() {
    return "vaadin-menu-bar";
  }
  /** @protected */
  ready() {
    super.ready();
    this._tooltipController = new TooltipController(this);
    this._tooltipController.setManual(true);
    this.addController(this._tooltipController);
  }
  /**
   * Fired when either a submenu item or menu bar button without nested children is clicked.
   *
   * @event item-selected
   * @param {Object} detail
   * @param {Object} detail.value the selected menu bar item
   */
}
defineCustomElement(MenuBar);
/**
 * @license
 * Copyright (c) 2017 - 2025 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const textArea = css`
  [part='input-field'],
  [part='input-field'] ::slotted(textarea) {
    height: auto;
    box-sizing: border-box;
    min-height: 0;
  }

  [part='input-field'] {
    /* Equal to the implicit padding in vaadin-text-field */
    padding-top: calc((var(--lumo-text-field-size) - 1em * var(--lumo-line-height-s)) / 2);
    padding-bottom: calc((var(--lumo-text-field-size) - 1em * var(--lumo-line-height-s)) / 2);
    transition: background-color 0.1s;
    line-height: var(--lumo-line-height-s);
  }

  :host(:not([readonly])) [part='input-field']::after {
    display: none;
  }

  :host([readonly]) [part='input-field'] {
    border: var(--vaadin-input-field-readonly-border, 1px dashed var(--lumo-contrast-30pct));
  }

  :host([readonly]) [part='input-field']::after {
    border: none;
  }

  :host(:hover:not([readonly]):not([focused]):not([invalid])) [part='input-field'] {
    background-color: var(--lumo-contrast-20pct);
  }

  @media (pointer: coarse) {
    :host(:hover:not([readonly]):not([focused]):not([invalid])) [part='input-field'] {
      background-color: var(--lumo-contrast-10pct);
    }

    :host(:active:not([readonly]):not([focused])) [part='input-field'] {
      background-color: var(--lumo-contrast-20pct);
    }
  }

  [part='input-field'] ::slotted(textarea) {
    line-height: inherit;
    --_lumo-text-field-overflow-mask-image: none;
  }

  /* Use sticky positioning to keep prefix/suffix/clear button visible when scrolling textarea container */
  [part='input-field'] ::slotted([slot$='fix']),
  [part='clear-button'] {
    position: sticky;
    top: 0;
    align-self: flex-start;
  }

  [part='input-field'] ::slotted(vaadin-icon[slot$='fix']),
  [part='clear-button'] {
    /* Vertically align icon prefix/suffix/clear button with the first line of text */
    top: calc((var(--lumo-icon-size-m) - 1em * var(--lumo-line-height-s)) / -2);
    margin-top: calc((var(--lumo-icon-size-m) - 1em * var(--lumo-line-height-s)) / -2);
    /* Reduce effective height to match line height of native textarea, so icons don't increase component size when using single row */
    margin-bottom: calc((var(--lumo-icon-size-m) - 1em * var(--lumo-line-height-s)) / -2);
  }
`;
registerStyles$1("vaadin-text-area", [inputFieldShared$1, textArea], {
  moduleId: "lumo-text-area"
});
/**
 * @license
 * Copyright (c) 2021 - 2025 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
class TextAreaController extends SlotController {
  constructor(host, callback) {
    super(host, "textarea", "textarea", {
      initializer: (node, host2) => {
        const value = host2.getAttribute("value");
        if (value) {
          node.value = value;
        }
        const name = host2.getAttribute("name");
        if (name) {
          node.setAttribute("name", name);
        }
        node.id = this.defaultId;
        if (typeof callback === "function") {
          callback(node);
        }
      },
      useUniqueId: true
    });
  }
}
/**
 * @license
 * Copyright (c) 2021 - 2025 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const TextAreaMixin = (superClass) => class TextAreaMixinClass extends ResizeMixin(InputFieldMixin(superClass)) {
  static get properties() {
    return {
      /**
       * Maximum number of characters (in Unicode code points) that the user can enter.
       */
      maxlength: {
        type: Number
      },
      /**
       * Minimum number of characters (in Unicode code points) that the user can enter.
       */
      minlength: {
        type: Number
      },
      /**
       * A regular expression that the value is checked against.
       * The pattern must match the entire value, not just some subset.
       */
      pattern: {
        type: String
      },
      /**
       * Minimum number of rows to show. Default is two rows.
       *
       * When using a custom slotted textarea, the minimum number of rows are not applied for backwards compatibility.
       *
       * @attr {number} min-rows
       */
      minRows: {
        type: Number,
        value: 2,
        observer: "__minRowsChanged"
      },
      /**
       * Maximum number of rows to expand to before the text area starts scrolling. This effectively sets a max-height
       * on the `input-field` part. By default, it is not set, and the text area grows with the content without
       * constraints.
       * @attr {number} max-rows
       */
      maxRows: {
        type: Number
      }
    };
  }
  static get delegateAttrs() {
    return [...super.delegateAttrs, "maxlength", "minlength", "pattern"];
  }
  static get constraints() {
    return [...super.constraints, "maxlength", "minlength", "pattern"];
  }
  static get observers() {
    return ["__updateMinHeight(minRows, inputElement)", "__updateMaxHeight(maxRows, inputElement, _inputField)"];
  }
  /**
   * Used by `InputControlMixin` as a reference to the clear button element.
   * @protected
   */
  get clearElement() {
    return this.$.clearButton;
  }
  /**
   * @protected
   * @override
   */
  _onResize() {
    this._updateHeight();
    this.__scrollPositionUpdated();
  }
  /** @protected */
  _onScroll() {
    this.__scrollPositionUpdated();
  }
  /** @protected */
  ready() {
    super.ready();
    this.__textAreaController = new TextAreaController(this, (input) => {
      this._setInputElement(input);
      this._setFocusElement(input);
      this.stateTarget = input;
      this.ariaTarget = input;
    });
    this.addController(this.__textAreaController);
    this.addController(new LabelledInputController(this.inputElement, this._labelController));
    this._inputField = this.shadowRoot.querySelector("[part=input-field]");
    this._inputField.addEventListener("wheel", (e2) => {
      const scrollTopBefore = this._inputField.scrollTop;
      this._inputField.scrollTop += e2.deltaY;
      if (scrollTopBefore !== this._inputField.scrollTop) {
        e2.preventDefault();
        this.__scrollPositionUpdated();
      }
    });
    this._updateHeight();
    this.__scrollPositionUpdated();
  }
  /** @private */
  __scrollPositionUpdated() {
    this._inputField.style.setProperty("--_text-area-vertical-scroll-position", "0px");
    this._inputField.style.setProperty("--_text-area-vertical-scroll-position", `${this._inputField.scrollTop}px`);
  }
  /**
   * @param {unknown} newVal
   * @param {unknown} oldVal
   * @protected
   * @override
   */
  _valueChanged(newVal, oldVal) {
    super._valueChanged(newVal, oldVal);
    this._updateHeight();
  }
  /** @private */
  _updateHeight() {
    const input = this.inputElement;
    const inputField2 = this._inputField;
    if (!input || !inputField2) {
      return;
    }
    const scrollTop = inputField2.scrollTop;
    const valueLength = this.value ? this.value.length : 0;
    if (this._oldValueLength >= valueLength) {
      const inputFieldHeight = getComputedStyle(inputField2).height;
      const inputWidth = getComputedStyle(input).width;
      inputField2.style.height = inputFieldHeight;
      input.style.maxWidth = inputWidth;
      input.style.alignSelf = "flex-start";
      input.style.height = "auto";
    }
    this._oldValueLength = valueLength;
    const inputHeight = input.scrollHeight;
    if (inputHeight > input.clientHeight) {
      input.style.height = `${inputHeight}px`;
    }
    input.style.removeProperty("max-width");
    input.style.removeProperty("align-self");
    inputField2.style.removeProperty("height");
    inputField2.scrollTop = scrollTop;
    this.__updateMaxHeight(this.maxRows);
  }
  /** @private */
  __updateMinHeight(minRows) {
    if (!this.inputElement) {
      return;
    }
    if (this.inputElement === this.__textAreaController.defaultNode) {
      this.inputElement.rows = Math.max(minRows, 1);
    }
  }
  /** @private */
  __updateMaxHeight(maxRows) {
    if (!this._inputField || !this.inputElement) {
      return;
    }
    if (maxRows) {
      const inputStyle = getComputedStyle(this.inputElement);
      const inputFieldStyle = getComputedStyle(this._inputField);
      const lineHeight = parseFloat(inputStyle.lineHeight);
      const contentHeight = lineHeight * maxRows;
      const marginsAndPaddings = parseFloat(inputStyle.paddingTop) + parseFloat(inputStyle.paddingBottom) + parseFloat(inputStyle.marginTop) + parseFloat(inputStyle.marginBottom) + parseFloat(inputFieldStyle.borderTopWidth) + parseFloat(inputFieldStyle.borderBottomWidth) + parseFloat(inputFieldStyle.paddingTop) + parseFloat(inputFieldStyle.paddingBottom);
      const maxHeight = Math.ceil(contentHeight + marginsAndPaddings);
      this._inputField.style.setProperty("max-height", `${maxHeight}px`);
    } else {
      this._inputField.style.removeProperty("max-height");
    }
  }
  /**
   * @private
   */
  __minRowsChanged(minRows) {
    if (minRows < 1) {
      console.warn("<vaadin-text-area> minRows must be at least 1.");
    }
  }
  /**
   * Scrolls the textarea to the start if it has a vertical scrollbar.
   */
  scrollToStart() {
    this._inputField.scrollTop = 0;
  }
  /**
   * Scrolls the textarea to the end if it has a vertical scrollbar.
   */
  scrollToEnd() {
    this._inputField.scrollTop = this._inputField.scrollHeight;
  }
  /**
   * Returns true if the current textarea value satisfies all constraints (if any).
   * @return {boolean}
   * @override
   */
  checkValidity() {
    if (!super.checkValidity()) {
      return false;
    }
    if (!this.pattern || !this.inputElement.value) {
      return true;
    }
    try {
      const match2 = this.inputElement.value.match(this.pattern);
      return match2 ? match2[0] === match2.input : false;
    } catch (_) {
      return true;
    }
  }
};
/**
 * @license
 * Copyright (c) 2021 - 2025 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const textAreaStyles = css`
  .vaadin-text-area-container {
    flex: auto;
  }

  /* The label, helper text and the error message should neither grow nor shrink. */
  [part='label'],
  [part='helper-text'],
  [part='error-message'] {
    flex: none;
  }

  [part='input-field'] {
    flex: auto;
    overflow: auto;
    -webkit-overflow-scrolling: touch;
  }

  ::slotted(textarea) {
    -webkit-appearance: none;
    -moz-appearance: none;
    flex: auto;
    overflow: hidden;
    width: 100%;
    height: 100%;
    outline: none;
    resize: none;
    margin: 0;
    padding: 0 0.25em;
    border: 0;
    border-radius: 0;
    min-width: 0;
    font: inherit;
    font-size: 1em;
    line-height: normal;
    color: inherit;
    background-color: transparent;
    /* Disable default invalid style in Firefox */
    box-shadow: none;
  }

  /* Override styles from <vaadin-input-container> */
  [part='input-field'] ::slotted(textarea) {
    align-self: stretch;
    white-space: pre-wrap;
    box-sizing: border-box;
  }

  [part='input-field'] ::slotted(:not(textarea)) {
    align-self: flex-start;
  }

  /* Workaround https://bugzilla.mozilla.org/show_bug.cgi?id=1739079 */
  :host([disabled]) ::slotted(textarea) {
    user-select: none;
  }
`;
/**
 * @license
 * Copyright (c) 2021 - 2025 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
registerStyles$1("vaadin-text-area", [inputFieldShared, textAreaStyles], { moduleId: "vaadin-text-area-styles" });
class TextArea extends TextAreaMixin(ThemableMixin(ElementMixin(PolymerElement))) {
  static get is() {
    return "vaadin-text-area";
  }
  static get template() {
    return html`
      <div class="vaadin-text-area-container">
        <div part="label">
          <slot name="label"></slot>
          <span part="required-indicator" aria-hidden="true" on-click="focus"></span>
        </div>

        <vaadin-input-container
          part="input-field"
          readonly="[[readonly]]"
          disabled="[[disabled]]"
          invalid="[[invalid]]"
          theme$="[[_theme]]"
          on-scroll="_onScroll"
        >
          <slot name="prefix" slot="prefix"></slot>
          <slot name="textarea"></slot>
          <slot name="suffix" slot="suffix"></slot>
          <div id="clearButton" part="clear-button" slot="suffix" aria-hidden="true"></div>
        </vaadin-input-container>

        <div part="helper-text">
          <slot name="helper"></slot>
        </div>

        <div part="error-message">
          <slot name="error-message"></slot>
        </div>
      </div>

      <slot name="tooltip"></slot>
    `;
  }
  /** @protected */
  ready() {
    super.ready();
    this._tooltipController = new TooltipController(this);
    this._tooltipController.setPosition("top");
    this._tooltipController.setAriaTarget(this.inputElement);
    this.addController(this._tooltipController);
  }
}
defineCustomElement(TextArea);
registerStyles$1(
  "vaadin-message-input",
  css`
    :host {
      padding: var(--lumo-space-s) var(--lumo-space-m);
    }

    ::slotted([slot='textarea']) {
      margin-inline-end: var(--lumo-space-s);
    }
  `,
  { moduleId: "lumo-message-input" }
);
/**
 * @license
 * Copyright (c) 2021 - 2025 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const MessageInputMixin = (superClass) => class MessageInputMixinClass extends ControllerMixin(superClass) {
  static get properties() {
    return {
      /**
       * Current content of the text input field
       */
      value: {
        type: String,
        value: "",
        sync: true
      },
      /**
       * The object used to localize this component.
       * For changing the default localization, change the entire
       * `i18n` object.
       *
       * The object has the following JSON structure and default values:
       *
       * ```
       * {
       *   // Used as the button label
       *   send: 'Send',
       *
       *   // Used as the input field's placeholder and aria-label
       *   message: 'Message'
       * }
       * ```
       *
       * @type {!MessageInputI18n}
       * @default {English}
       */
      i18n: {
        type: Object,
        sync: true,
        value: () => ({
          send: "Send",
          message: "Message"
        })
      },
      /**
       * Set to true to disable this element.
       * @type {boolean}
       */
      disabled: {
        type: Boolean,
        value: false,
        reflectToAttribute: true,
        sync: true
      },
      /** @private */
      _button: {
        type: Object,
        sync: true
      },
      /** @private */
      _textArea: {
        type: Object,
        sync: true
      }
    };
  }
  static get observers() {
    return [
      "__buttonPropsChanged(_button, disabled, i18n)",
      "__textAreaPropsChanged(_textArea, disabled, i18n, value)"
    ];
  }
  /** @protected */
  ready() {
    super.ready();
    this._buttonController = new SlotController(this, "button", "vaadin-button", {
      initializer: (btn) => {
        btn.setAttribute("theme", "primary contained");
        btn.addEventListener("click", () => {
          this.__submit();
        });
        this._button = btn;
      }
    });
    this.addController(this._buttonController);
    this._textAreaController = new SlotController(this, "textarea", "vaadin-text-area", {
      initializer: (textarea) => {
        textarea.addEventListener("value-changed", (event) => {
          this.value = event.detail.value;
        });
        textarea.addEventListener("keydown", (event) => {
          if (event.key === "Enter" && !event.shiftKey) {
            event.preventDefault();
            event.stopImmediatePropagation();
            this.__submit();
          }
        });
        textarea.minRows = 1;
        this._textArea = textarea;
      }
    });
    this.addController(this._textAreaController);
    this._tooltipController = new TooltipController(this);
    this.addController(this._tooltipController);
  }
  focus() {
    if (this._textArea) {
      this._textArea.focus();
    }
  }
  /** @private */
  __buttonPropsChanged(button2, disabled, i18n) {
    if (button2) {
      button2.disabled = disabled;
      button2.textContent = i18n.send;
    }
  }
  /** @private */
  __textAreaPropsChanged(textArea2, disabled, i18n, value) {
    if (textArea2) {
      textArea2.disabled = disabled;
      textArea2.value = value;
      const message = i18n.message;
      textArea2.placeholder = message;
      textArea2.accessibleName = message;
    }
  }
  /**
   * Submits the current value as an custom event named 'submit'.
   * It also clears the text input and refocuses it for sending another message.
   * In UI, can be triggered by pressing the submit button or pressing enter key when field is focused.
   * It does not submit anything if text is empty.
   */
  __submit() {
    if (this.value !== "") {
      this.dispatchEvent(new CustomEvent("submit", { detail: { value: this.value } }));
      this.value = "";
    }
    this._textArea.focus();
  }
  /**
   * Fired when a new message is submitted with `<vaadin-message-input>`, either
   * by clicking the "send" button, or pressing the Enter key.
   * @event submit
   */
};
/**
 * @license
 * Copyright (c) 2021 - 2025 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
class MessageInput extends MessageInputMixin(ElementMixin(ThemableMixin(PolymerElement))) {
  static get template() {
    return html`
      <style>
        :host {
          align-items: flex-start;
          box-sizing: border-box;
          display: flex;
          max-height: 50vh;
          overflow: hidden;
          flex-shrink: 0;
        }

        :host([hidden]) {
          display: none !important;
        }

        ::slotted([slot='button']) {
          flex-shrink: 0;
        }

        ::slotted([slot='textarea']) {
          align-self: stretch;
          flex-grow: 1;
        }
      </style>
      <slot name="textarea"></slot>

      <slot name="button"></slot>

      <slot name="tooltip"></slot>
    `;
  }
  static get is() {
    return "vaadin-message-input";
  }
}
defineCustomElement(MessageInput);
window.Vaadin.Flow.messageListConnector = {
  setItems(list, items, locale2) {
    const formatter = new Intl.DateTimeFormat(locale2, {
      year: "numeric",
      month: "short",
      day: "numeric",
      hour: "numeric",
      minute: "numeric"
    });
    list.items = items.map(
      (item2) => item2.time ? Object.assign(item2, {
        time: formatter.format(new Date(item2.time))
      }) : item2
    );
  }
};
registerStyles$1(
  "vaadin-message",
  css`
    :host {
      color: var(--lumo-body-text-color);
      font-family: var(--lumo-font-family);
      font-size: var(--lumo-font-size-m);
      line-height: var(--lumo-line-height-m);
      padding: var(--lumo-space-s) var(--lumo-space-m);
      -moz-osx-font-smoothing: grayscale;
      -webkit-font-smoothing: antialiased;
      -webkit-text-size-adjust: 100%;
      --_focus-ring-color: var(--vaadin-focus-ring-color, var(--lumo-primary-color-50pct));
      --_focus-ring-width: var(--vaadin-focus-ring-width, 2px);
    }

    :host([focus-ring]) {
      box-shadow: inset 0 0 0 var(--_focus-ring-width) var(--_focus-ring-color);
    }

    [part='header'] {
      min-height: calc(var(--lumo-font-size-m) * var(--lumo-line-height-m));
    }

    [part='name'] {
      margin-right: var(--lumo-space-s);
    }

    [part='name']:empty {
      margin-right: 0;
    }

    :host([dir='rtl']) [part='name'] {
      margin-left: var(--lumo-space-s);
      margin-right: 0;
    }

    :host([dir='rtl']) [part='name']:empty {
      margin-left: 0;
    }

    [part='time'] {
      color: var(--lumo-secondary-text-color);
      font-size: var(--lumo-font-size-s);
    }

    ::slotted([slot='avatar']) {
      --vaadin-avatar-size: var(--lumo-size-m);
      margin-top: calc(var(--lumo-space-s));
      margin-inline-end: calc(var(--lumo-space-m));
    }
  `,
  { moduleId: "lumo-message" }
);
registerStyles$1("vaadin-message-list", css``, { moduleId: "lumo-message-list" });
/**
 * @license
 * Copyright (c) 2021 - 2025 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const MessageMixin = (superClass) => class MessageMixinClass extends FocusMixin(ControllerMixin(superClass)) {
  static get properties() {
    return {
      /**
       * Time of sending the message. It is rendered as-is to the part='time' slot,
       * so the formatting is up to you.
       */
      time: {
        type: String
      },
      /**
       * The name of the user posting the message.
       * It will be placed in the name part to indicate who has sent the message.
       * It is also used as a tooltip for the avatar.
       * Example: `message.userName = "Jessica Jacobs";`
       * @attr {string} user-name
       */
      userName: {
        type: String
      },
      /**
       * The abbreviation of the user.
       * The abbreviation will be passed on to avatar of the message.
       * If the user does not have an avatar picture set with `userImg`, `userAbbr` will be shown in the avatar.
       * Example: `message.userAbbr = "JJ";`
       * @attr {string} user-abbr
       */
      userAbbr: {
        type: String
      },
      /**
       * An URL for a user image.
       * The image will be used in the avatar component to show who has sent the message.
       * Example: `message.userImg = "/static/img/avatar.jpg";`
       * @attr {string} user-img
       */
      userImg: {
        type: String
      },
      /**
       * A color index to be used to render the color of the avatar.
       * With no `userColorIndex` set, the basic avatar color will be used.
       * By setting a userColorIndex, the component will check if there exists a CSS variable defining the color, and uses it if there is one.
       * If now CSS variable is found for the color index, the property for the color will not be set.
       *
       * Example:
       * CSS:
       * ```css
       * html {
       *   --vaadin-user-color-1: red;
       * }
       * ```
       *
       * JavaScript:
       * ```js
       * message.userColorIndex = 1;
       * ```
       * @attr {number} user-color-index
       */
      userColorIndex: {
        type: Number
      },
      /** @private */
      _avatar: {
        type: Object
      }
    };
  }
  static get observers() {
    return ["__avatarChanged(_avatar, userName, userAbbr, userImg, userColorIndex)"];
  }
  /** @protected */
  ready() {
    super.ready();
    this._avatarController = new SlotController(this, "avatar", "vaadin-avatar", {
      initializer: (avatar) => {
        avatar.setAttribute("tabindex", "-1");
        avatar.setAttribute("aria-hidden", "true");
        this._avatar = avatar;
      }
    });
    this.addController(this._avatarController);
  }
  /** @private */
  __avatarChanged(avatar, userName, userAbbr, userImg, userColorIndex) {
    if (avatar) {
      avatar.setProperties({
        name: userName,
        abbr: userAbbr,
        img: userImg,
        colorIndex: userColorIndex
      });
    }
  }
};
/**
 * @license
 * Copyright (c) 2021 - 2025 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const messageStyles = css`
  :host {
    display: flex;
    flex-direction: row;
    outline: none;
  }

  :host([hidden]) {
    display: none !important;
  }

  [part='content'] {
    display: flex;
    flex-direction: column;
    flex-grow: 1;
  }

  [part='header'] {
    align-items: baseline;
    display: flex;
    flex-flow: row wrap;
  }

  [part='name'] {
    font-weight: 500;
  }

  [part='message'] {
    white-space: pre-wrap;
  }

  ::slotted([slot='avatar']) {
    --vaadin-avatar-outline-width: 0;
    flex-shrink: 0;
  }
`;
/**
 * @license
 * Copyright (c) 2021 - 2025 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
registerStyles$1("vaadin-message", messageStyles, { moduleId: "vaadin-message-styles" });
class Message extends MessageMixin(ElementMixin(ThemableMixin(PolymerElement))) {
  static get template() {
    return html`
      <slot name="avatar"></slot>
      <div part="content">
        <div part="header">
          <span part="name">[[userName]]</span>
          <span part="time">[[time]]</span>
        </div>
        <div part="message"><slot></slot></div>
      </div>
    `;
  }
  static get is() {
    return "vaadin-message";
  }
}
defineCustomElement(Message);
/**
 * @license
 * Copyright (c) 2021 - 2025 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const MessageListMixin = (superClass) => class MessageListMixinClass extends KeyboardDirectionMixin(superClass) {
  static get properties() {
    return {
      /**
       * An array of objects which will be rendered as messages.
       * The message objects can have the following properties:
       * ```js
       * Array<{
       *   text: string,
       *   time: string,
       *   userName: string,
       *   userAbbr: string,
       *   userImg: string,
       *   userColorIndex: number,
       *   className: string,
       *   theme: string
       * }>
       * ```
       */
      items: {
        type: Array,
        value: () => [],
        observer: "_itemsChanged",
        sync: true
      }
    };
  }
  /** @protected */
  get _messages() {
    return [...this.querySelectorAll("vaadin-message")];
  }
  /** @protected */
  ready() {
    super.ready();
    this.setAttribute("aria-relevant", "additions");
    this.setAttribute("role", "log");
  }
  /**
   * Override method inherited from `KeyboardDirectionMixin`
   * to use the list of message elements as items.
   *
   * @return {Element[]}
   * @protected
   * @override
   */
  _getItems() {
    return this._messages;
  }
  /** @private */
  _itemsChanged(newVal, oldVal) {
    const items = newVal || [];
    const oldItems = oldVal || [];
    if (items.length || oldItems.length) {
      const focusedIndex = this._getIndexOfFocusableElement();
      const closeToBottom = this.scrollHeight < this.clientHeight + this.scrollTop + 50;
      this._renderMessages(items);
      this._setTabIndexesByIndex(focusedIndex);
      requestAnimationFrame(() => {
        if (items.length > oldItems.length && closeToBottom) {
          this._scrollToLastMessage();
        }
      });
    }
  }
  /** @private */
  _renderMessages(items) {
    render(
      html$1`
          ${items.map(
        (item2) => html$1`
              <vaadin-message
                role="listitem"
                .time="${item2.time}"
                .userAbbr="${item2.userAbbr}"
                .userName="${item2.userName}"
                .userImg="${item2.userImg}"
                .userColorIndex="${item2.userColorIndex}"
                theme="${ifDefined(item2.theme)}"
                class="${ifDefined(item2.className)}"
                @focusin="${this._onMessageFocusIn}"
                >${item2.text}<vaadin-avatar slot="avatar"></vaadin-avatar
              ></vaadin-message>
            `
      )}
        `,
      this,
      { host: this }
    );
  }
  /** @private */
  _scrollToLastMessage() {
    if (this.items.length > 0) {
      this.scrollTop = this.scrollHeight - this.clientHeight;
    }
  }
  /** @private */
  _onMessageFocusIn(e2) {
    const target = e2.composedPath().find((node) => node instanceof customElements.get("vaadin-message"));
    this._setTabIndexesByMessage(target);
  }
  /**
   * @param {number} idx
   * @protected
   */
  _setTabIndexesByIndex(index) {
    const message = this._messages[index] || this._messages[0];
    this._setTabIndexesByMessage(message);
  }
  /** @private */
  _setTabIndexesByMessage(message) {
    this._messages.forEach((e2) => {
      e2.tabIndex = e2 === message ? 0 : -1;
    });
  }
  /** @private */
  _getIndexOfFocusableElement() {
    const index = this._messages.findIndex((e2) => e2.tabIndex === 0);
    return index !== -1 ? index : 0;
  }
};
/**
 * @license
 * Copyright (c) 2021 - 2025 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
class MessageList extends MessageListMixin(ElementMixin(ThemableMixin(PolymerElement))) {
  static get is() {
    return "vaadin-message-list";
  }
  static get template() {
    return html`
      <style>
        :host {
          display: block;
          overflow: auto;
        }

        :host([hidden]) {
          display: none !important;
        }
      </style>
      <div part="list" role="list">
        <slot></slot>
      </div>
    `;
  }
}
defineCustomElement(MessageList);
registerStyles$1(
  "vaadin-notification-card",
  css`
    :host {
      position: relative;
      margin: var(--lumo-space-s);
    }

    [part='overlay'] {
      background: var(--lumo-base-color) linear-gradient(var(--lumo-contrast-5pct), var(--lumo-contrast-5pct));
      border-radius: var(--lumo-border-radius-l);
      box-shadow:
        0 0 0 1px var(--lumo-contrast-10pct),
        var(--lumo-box-shadow-l);
      font-family: var(--lumo-font-family);
      font-size: var(--lumo-font-size-m);
      font-weight: 400;
      line-height: var(--lumo-line-height-s);
      letter-spacing: 0;
      text-transform: none;
      -webkit-text-size-adjust: 100%;
      -webkit-font-smoothing: antialiased;
      -moz-osx-font-smoothing: grayscale;
    }

    [part='content'] {
      padding: var(--lumo-space-wide-l);
      display: flex;
      align-items: center;
      justify-content: space-between;
    }

    [part='content'] ::slotted(vaadin-button) {
      flex: none;
      margin: 0 calc(var(--lumo-space-s) * -1) 0 var(--lumo-space-m);
    }

    :host([slot^='middle']) {
      max-width: 80vw;
      margin: var(--lumo-space-s) auto;
    }

    :host([slot$='stretch']) {
      margin: 0;
    }

    :host([slot$='stretch']) [part='overlay'] {
      border-radius: 0;
    }

    @media (min-width: 421px) {
      :host(:not([slot$='stretch'])) {
        display: flex;
      }

      :host([slot$='end']) {
        justify-content: flex-end;
      }

      :host([slot^='middle']),
      :host([slot$='center']) {
        display: flex;
        justify-content: center;
      }
    }

    @keyframes lumo-notification-exit-fade-out {
      100% {
        opacity: 0;
      }
    }

    @keyframes lumo-notification-enter-fade-in {
      0% {
        opacity: 0;
      }
    }

    @keyframes lumo-notification-enter-slide-down {
      0% {
        transform: translateY(-200%);
        opacity: 0;
      }
    }

    @keyframes lumo-notification-exit-slide-up {
      100% {
        transform: translateY(-200%);
        opacity: 0;
      }
    }

    @keyframes lumo-notification-enter-slide-up {
      0% {
        transform: translateY(200%);
        opacity: 0;
      }
    }

    @keyframes lumo-notification-exit-slide-down {
      100% {
        transform: translateY(200%);
        opacity: 0;
      }
    }

    :host([slot='middle'][opening]) {
      animation: lumo-notification-enter-fade-in 300ms;
    }

    :host([slot='middle'][closing]) {
      animation: lumo-notification-exit-fade-out 300ms;
    }

    :host([slot^='top'][opening]) {
      animation: lumo-notification-enter-slide-down 300ms;
    }

    :host([slot^='top'][closing]) {
      animation: lumo-notification-exit-slide-up 300ms;
    }

    :host([slot^='bottom'][opening]) {
      animation: lumo-notification-enter-slide-up 300ms;
    }

    :host([slot^='bottom'][closing]) {
      animation: lumo-notification-exit-slide-down 300ms;
    }

    :host([theme='success']) {
      --_focus-ring-gap-color: var(--lumo-success-color);
      --vaadin-focus-ring-color: var(--lumo-success-contrast-color);
    }

    :host([theme='warning']) {
      --_focus-ring-gap-color: var(--lumo-warning-color);
      --vaadin-focus-ring-color: var(--lumo-warning-contrast-color);
    }

    :host([theme='error']) {
      --_focus-ring-gap-color: var(--lumo-error-color);
      --vaadin-focus-ring-color: var(--lumo-error-contrast-color);
    }

    :host([theme='primary']) {
      --_focus-ring-gap-color: var(--lumo-primary-color);
      --vaadin-focus-ring-color: var(--lumo-primary-contrast-color);
    }

    :host([theme~='primary']) [part='overlay'] {
      background: var(--lumo-primary-color);
      color: var(--lumo-primary-contrast-color);
      box-shadow: var(--lumo-box-shadow-l);
    }

    :host([theme~='primary']) {
      --vaadin-button-background: var(--lumo-shade-20pct);
      --vaadin-button-text-color: var(--lumo-primary-contrast-color);
      --vaadin-button-primary-background: var(--lumo-primary-contrast-color);
      --vaadin-button-primary-text-color: var(--lumo-primary-text-color);
    }

    :host([theme~='contrast']) [part='overlay'] {
      background: var(--lumo-contrast);
      color: var(--lumo-base-color);
      box-shadow: var(--lumo-box-shadow-l);
    }

    :host([theme~='contrast']) {
      --vaadin-button-background: var(--lumo-contrast-20pct);
      --vaadin-button-text-color: var(--lumo-base-color);
      --vaadin-button-primary-background: var(--lumo-base-color);
      --vaadin-button-primary-text-color: var(--lumo-contrast);
    }

    :host([theme~='success']) [part='overlay'] {
      background: var(--lumo-success-color);
      color: var(--lumo-success-contrast-color);
      box-shadow: var(--lumo-box-shadow-l);
    }

    :host([theme~='success']) {
      --vaadin-button-background: var(--lumo-shade-20pct);
      --vaadin-button-text-color: var(--lumo-success-contrast-color);
      --vaadin-button-primary-background: var(--lumo-success-contrast-color);
      --vaadin-button-primary-text-color: var(--lumo-success-text-color);
    }

    :host([theme~='error']) [part='overlay'] {
      background: var(--lumo-error-color);
      color: var(--lumo-error-contrast-color);
      box-shadow: var(--lumo-box-shadow-l);
    }

    :host([theme~='error']) {
      --vaadin-button-background: var(--lumo-shade-20pct);
      --vaadin-button-text-color: var(--lumo-error-contrast-color);
      --vaadin-button-primary-background: var(--lumo-error-contrast-color);
      --vaadin-button-primary-text-color: var(--lumo-error-text-color);
    }

    :host([theme~='warning']) [part='overlay'] {
      background: var(--lumo-warning-color);
      color: var(--lumo-warning-contrast-color);
      box-shadow:
        inset 0 0 0 1px var(--lumo-contrast-20pct),
        var(--lumo-box-shadow-l);
    }

    :host([theme~='warning']) {
      --vaadin-button-background: var(--lumo-shade-20pct);
      --vaadin-button-text-color: var(--lumo-warning-contrast-color);
      --vaadin-button-primary-background: var(--lumo-shade-50pct);
      --vaadin-button-primary-text-color: var(--lumo-primary-contrast-color);
    }
  `,
  { moduleId: "lumo-notification-card" }
);
/**
 * @license
 * Copyright (c) 2017 - 2025 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const NotificationContainerMixin = (superClass) => class extends OverlayStackMixin(superClass) {
  static get properties() {
    return {
      /**
       * True when the container is opened
       * @type {boolean}
       */
      opened: {
        type: Boolean,
        value: false,
        sync: true,
        observer: "_openedChanged"
      }
    };
  }
  constructor() {
    super();
    this._boundVaadinOverlayClose = this._onVaadinOverlayClose.bind(this);
    if (isIOS) {
      this._boundIosResizeListener = () => this._detectIosNavbar();
    }
  }
  /** @private */
  _openedChanged(opened) {
    if (opened) {
      document.body.appendChild(this);
      document.addEventListener("vaadin-overlay-close", this._boundVaadinOverlayClose);
      if (this._boundIosResizeListener) {
        this._detectIosNavbar();
        window.addEventListener("resize", this._boundIosResizeListener);
      }
    } else {
      document.body.removeChild(this);
      document.removeEventListener("vaadin-overlay-close", this._boundVaadinOverlayClose);
      if (this._boundIosResizeListener) {
        window.removeEventListener("resize", this._boundIosResizeListener);
      }
    }
  }
  /** @private */
  _detectIosNavbar() {
    const innerHeight = window.innerHeight;
    const innerWidth = window.innerWidth;
    const landscape = innerWidth > innerHeight;
    const clientHeight = document.documentElement.clientHeight;
    if (landscape && clientHeight > innerHeight) {
      this.style.bottom = `${clientHeight - innerHeight}px`;
    } else {
      this.style.bottom = "0";
    }
  }
  /** @private */
  _onVaadinOverlayClose(event) {
    const sourceEvent = event.detail.sourceEvent;
    const isFromNotification = sourceEvent && sourceEvent.composedPath().indexOf(this) >= 0;
    if (isFromNotification) {
      event.preventDefault();
    }
  }
};
const NotificationMixin = (superClass) => class extends ThemePropertyMixin(OverlayClassMixin(superClass)) {
  static get properties() {
    return {
      /**
       * When true, the notification card has `aria-live` attribute set to
       * `assertive` instead of `polite`. This makes screen readers announce
       * the notification content immediately when it appears.
       */
      assertive: {
        type: Boolean,
        value: false,
        sync: true
      },
      /**
       * The duration in milliseconds to show the notification.
       * Set to `0` or a negative number to disable the notification auto-closing.
       * @type {number}
       */
      duration: {
        type: Number,
        value: 5e3,
        sync: true
      },
      /**
       * True if the notification is currently displayed.
       * @type {boolean}
       */
      opened: {
        type: Boolean,
        value: false,
        notify: true,
        sync: true,
        observer: "_openedChanged"
      },
      /**
       * Alignment of the notification in the viewport
       * Valid values are `top-stretch|top-start|top-center|top-end|middle|bottom-start|bottom-center|bottom-end|bottom-stretch`
       * @type {!NotificationPosition}
       */
      position: {
        type: String,
        value: "bottom-start",
        observer: "_positionChanged",
        sync: true
      },
      /**
       * Custom function for rendering the content of the notification.
       * Receives two arguments:
       *
       * - `root` The `<vaadin-notification-card>` DOM element. Append
       *   your content to it.
       * - `notification` The reference to the `<vaadin-notification>` element.
       * @type {!NotificationRenderer | undefined}
       */
      renderer: {
        type: Function,
        sync: true
      }
    };
  }
  static get observers() {
    return ["_durationChanged(duration, opened)", "_rendererChanged(renderer, opened, _overlayElement)"];
  }
  /**
   * Shows a notification with the given content.
   * By default, positions the notification at `bottom-start` and uses a 5 second duration.
   * An options object can be passed to configure the notification.
   * The options object has the following structure:
   *
   * ```
   * {
   *   assertive?: boolean
   *   position?: string
   *   duration?: number
   *   theme?: string
   * }
   * ```
   *
   * See the individual documentation for:
   * - [`assertive`](#/elements/vaadin-notification#property-assertive)
   * - [`position`](#/elements/vaadin-notification#property-position)
   * - [`duration`](#/elements/vaadin-notification#property-duration)
   *
   * @param contents the contents to show, either as a string or a Lit template.
   * @param options optional options for customizing the notification.
   */
  static show(contents, options) {
    const Notification2 = customElements.get("vaadin-notification");
    if (isTemplateResult(contents)) {
      return Notification2._createAndShowNotification((root2) => {
        render(contents, root2);
      }, options);
    }
    return Notification2._createAndShowNotification((root2) => {
      root2.innerText = contents;
    }, options);
  }
  /** @private */
  static _createAndShowNotification(renderer, options) {
    const notification = document.createElement("vaadin-notification");
    if (options && Number.isFinite(options.duration)) {
      notification.duration = options.duration;
    }
    if (options && options.position) {
      notification.position = options.position;
    }
    if (options && options.assertive) {
      notification.assertive = options.assertive;
    }
    if (options && options.theme) {
      notification.setAttribute("theme", options.theme);
    }
    notification.renderer = renderer;
    document.body.appendChild(notification);
    notification.opened = true;
    notification.addEventListener("opened-changed", (e2) => {
      if (!e2.detail.value) {
        notification.remove();
      }
    });
    return notification;
  }
  /** @private */
  get _container() {
    const Notification2 = customElements.get("vaadin-notification");
    if (!Notification2._container) {
      Notification2._container = document.createElement("vaadin-notification-container");
      document.body.appendChild(Notification2._container);
    }
    return Notification2._container;
  }
  /** @protected */
  get _card() {
    return this._overlayElement;
  }
  /** @protected */
  ready() {
    super.ready();
    this._overlayElement = this.shadowRoot.querySelector("vaadin-notification-card");
    processTemplates(this);
  }
  /** @protected */
  disconnectedCallback() {
    super.disconnectedCallback();
    queueMicrotask(() => {
      if (!this.isConnected) {
        this.opened = false;
      }
    });
  }
  /**
   * Requests an update for the content of the notification.
   * While performing the update, it invokes the renderer passed in the `renderer` property.
   *
   * It is not guaranteed that the update happens immediately (synchronously) after it is requested.
   */
  requestContentUpdate() {
    if (!this.renderer || !this._card) {
      return;
    }
    this.renderer(this._card, this);
  }
  /** @private */
  __computeAriaLive(assertive) {
    return assertive ? "assertive" : "polite";
  }
  /** @private */
  _rendererChanged(renderer, opened, card) {
    if (!card) {
      return;
    }
    const rendererChanged = this._oldRenderer !== renderer;
    this._oldRenderer = renderer;
    if (rendererChanged) {
      card.innerHTML = "";
      delete card._$litPart$;
    }
    if (opened) {
      if (!this._didAnimateNotificationAppend) {
        this._animatedAppendNotificationCard();
      }
      this.requestContentUpdate();
    }
  }
  /**
   * Opens the notification.
   */
  open() {
    this.opened = true;
  }
  /**
   * Closes the notification.
   */
  close() {
    this.opened = false;
  }
  /** @private */
  _openedChanged(opened) {
    if (opened) {
      this._container.opened = true;
      this._animatedAppendNotificationCard();
    } else if (this._card) {
      this._closeNotificationCard();
    }
  }
  /** @private */
  __cleanUpOpeningClosingState() {
    this._card.removeAttribute("opening");
    this._card.removeAttribute("closing");
    this._card.removeEventListener("animationend", this.__animationEndListener);
  }
  /** @private */
  _animatedAppendNotificationCard() {
    if (this._card) {
      this.__cleanUpOpeningClosingState();
      this._card.setAttribute("opening", "");
      this._appendNotificationCard();
      this.__animationEndListener = () => this.__cleanUpOpeningClosingState();
      this._card.addEventListener("animationend", this.__animationEndListener);
      this._didAnimateNotificationAppend = true;
    } else {
      this._didAnimateNotificationAppend = false;
    }
  }
  /** @private */
  _appendNotificationCard() {
    if (!this._card) {
      return;
    }
    if (!this._container.shadowRoot.querySelector(`slot[name="${this.position}"]`)) {
      console.warn(`Invalid alignment parameter provided: position=${this.position}`);
      return;
    }
    this._container.bringToFront();
    this._card.slot = this.position;
    if (this._container.firstElementChild && /top/u.test(this.position)) {
      this._container.insertBefore(this._card, this._container.firstElementChild);
    } else {
      this._container.appendChild(this._card);
    }
  }
  /** @private */
  _removeNotificationCard() {
    if (!this._card) {
      return;
    }
    if (this._card.parentNode) {
      this._card.parentNode.removeChild(this._card);
    }
    this._card.removeAttribute("closing");
    this._container.opened = Boolean(this._container.firstElementChild);
    this.dispatchEvent(new CustomEvent("closed"));
  }
  /** @private */
  _closeNotificationCard() {
    if (this._durationTimeoutId) {
      clearTimeout(this._durationTimeoutId);
    }
    this._animatedRemoveNotificationCard();
  }
  /** @private */
  _animatedRemoveNotificationCard() {
    this.__cleanUpOpeningClosingState();
    this._card.setAttribute("closing", "");
    const name = getComputedStyle(this._card).getPropertyValue("animation-name");
    if (name && name !== "none") {
      this.__animationEndListener = () => {
        this._removeNotificationCard();
        this.__cleanUpOpeningClosingState();
      };
      this._card.addEventListener("animationend", this.__animationEndListener);
    } else {
      this._removeNotificationCard();
    }
  }
  /** @private */
  _positionChanged() {
    if (this.opened) {
      this._animatedAppendNotificationCard();
    }
  }
  /** @private */
  _durationChanged(duration, opened) {
    if (opened) {
      clearTimeout(this._durationTimeoutId);
      if (duration > 0) {
        this._durationTimeoutId = setTimeout(() => this.close(), duration);
      }
    }
  }
  /**
   * Fired when the notification is closed.
   *
   * @event closed
   */
};
/**
 * @license
 * Copyright (c) 2016 - 2025 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const notificationContainerStyles = css`
  :host {
    position: fixed;
    z-index: 1000;
    inset: 0;
    box-sizing: border-box;
    display: flex;
    flex-direction: column;
    align-items: stretch;
    pointer-events: none;
  }

  [region-group] {
    flex: 1 1 0%;
    display: flex;
  }

  [region-group='top'] {
    align-items: flex-start;
  }

  [region-group='bottom'] {
    align-items: flex-end;
  }

  [region-group] > [region] {
    flex: 1 1 0%;
  }

  @media (max-width: 420px) {
    [region-group] {
      flex-direction: column;
      align-items: stretch;
    }

    [region-group='top'] {
      justify-content: flex-start;
    }

    [region-group='bottom'] {
      justify-content: flex-end;
    }

    [region-group] > [region] {
      flex: initial;
    }
  }
`;
const notificationCardStyles = css`
  :host {
    display: block;
  }

  [part='overlay'] {
    pointer-events: auto;
  }

  @media (forced-colors: active) {
    [part='overlay'] {
      outline: 3px solid;
    }
  }
`;
/**
 * @license
 * Copyright (c) 2017 - 2025 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
registerStyles$1("vaadin-notification-container", notificationContainerStyles, {
  moduleId: "vaadin-notification-container-styles"
});
registerStyles$1("vaadin-notification-card", notificationCardStyles, {
  moduleId: "vaadin-notification-card-styles"
});
class NotificationContainer extends NotificationContainerMixin(ThemableMixin(ElementMixin(PolymerElement))) {
  static get template() {
    return html`
      <div region="top-stretch"><slot name="top-stretch"></slot></div>
      <div region-group="top">
        <div region="top-start"><slot name="top-start"></slot></div>
        <div region="top-center"><slot name="top-center"></slot></div>
        <div region="top-end"><slot name="top-end"></slot></div>
      </div>
      <div region="middle"><slot name="middle"></slot></div>
      <div region-group="bottom">
        <div region="bottom-start"><slot name="bottom-start"></slot></div>
        <div region="bottom-center"><slot name="bottom-center"></slot></div>
        <div region="bottom-end"><slot name="bottom-end"></slot></div>
      </div>
      <div region="bottom-stretch"><slot name="bottom-stretch"></slot></div>
    `;
  }
  static get is() {
    return "vaadin-notification-container";
  }
}
class NotificationCard extends ThemableMixin(PolymerElement) {
  static get template() {
    return html`
      <div part="overlay">
        <div part="content">
          <slot></slot>
        </div>
      </div>
    `;
  }
  static get is() {
    return "vaadin-notification-card";
  }
  /** @protected */
  ready() {
    super.ready();
    this.setAttribute("role", "alert");
  }
}
class Notification extends NotificationMixin(ElementMixin(PolymerElement)) {
  static get template() {
    return html`
      <style>
        :host {
          display: none !important;
        }
      </style>
      <vaadin-notification-card
        theme$="[[_theme]]"
        aria-live$="[[__computeAriaLive(assertive)]]"
      ></vaadin-notification-card>
    `;
  }
  static get is() {
    return "vaadin-notification";
  }
}
defineCustomElement(NotificationContainer);
defineCustomElement(NotificationCard);
defineCustomElement(Notification);
const horizontalLayout = css`
  :host([theme~='margin']) {
    margin: var(--lumo-space-m);
  }

  :host([theme~='padding']) {
    padding: var(--lumo-space-m);
  }

  :host([theme~='spacing-xs']) {
    gap: var(--lumo-space-xs);
  }

  :host([theme~='spacing-s']) {
    gap: var(--lumo-space-s);
  }

  :host([theme~='spacing']) {
    gap: var(--lumo-space-m);
  }

  :host([theme~='spacing-l']) {
    gap: var(--lumo-space-l);
  }

  :host([theme~='spacing-xl']) {
    gap: var(--lumo-space-xl);
  }

  :host([theme~='wrap']) {
    flex-wrap: wrap;
  }
`;
registerStyles$1("vaadin-horizontal-layout", horizontalLayout, { moduleId: "lumo-horizontal-layout" });
/**
 * @license
 * Copyright (c) 2017 - 2025 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const HorizontalLayoutMixin = (superClass) => class extends superClass {
  /** @protected */
  ready() {
    super.ready();
    const startSlot = this.shadowRoot.querySelector("slot:not([name])");
    this.__startSlotObserver = new SlotObserver(startSlot, ({ currentNodes, removedNodes }) => {
      if (removedNodes.length) {
        this.__clearAttribute(removedNodes, "last-start-child");
      }
      const children = currentNodes.filter((node) => node.nodeType === Node.ELEMENT_NODE);
      this.__updateAttributes(children, "start", false, true);
      const nodes = currentNodes.filter((node) => !isEmptyTextNode(node));
      this.toggleAttribute("has-start", nodes.length > 0);
    });
    const endSlot = this.shadowRoot.querySelector('[name="end"]');
    this.__endSlotObserver = new SlotObserver(endSlot, ({ currentNodes, removedNodes }) => {
      if (removedNodes.length) {
        this.__clearAttribute(removedNodes, "first-end-child");
      }
      this.__updateAttributes(currentNodes, "end", true, false);
      this.toggleAttribute("has-end", currentNodes.length > 0);
    });
    const middleSlot = this.shadowRoot.querySelector('[name="middle"]');
    this.__middleSlotObserver = new SlotObserver(middleSlot, ({ currentNodes, removedNodes }) => {
      if (removedNodes.length) {
        this.__clearAttribute(removedNodes, "first-middle-child");
        this.__clearAttribute(removedNodes, "last-middle-child");
      }
      this.__updateAttributes(currentNodes, "middle", true, true);
      this.toggleAttribute("has-middle", currentNodes.length > 0);
    });
  }
  /** @private */
  __clearAttribute(nodes, attr) {
    const el = nodes.find((node) => node.nodeType === Node.ELEMENT_NODE && node.hasAttribute(attr));
    if (el) {
      el.removeAttribute(attr);
    }
  }
  /** @private */
  __updateAttributes(nodes, slot, setFirst, setLast) {
    nodes.forEach((child, idx) => {
      if (setFirst) {
        const attr = `first-${slot}-child`;
        if (idx === 0) {
          child.setAttribute(attr, "");
        } else if (child.hasAttribute(attr)) {
          child.removeAttribute(attr);
        }
      }
      if (setLast) {
        const attr = `last-${slot}-child`;
        if (idx === nodes.length - 1) {
          child.setAttribute(attr, "");
        } else if (child.hasAttribute(attr)) {
          child.removeAttribute(attr);
        }
      }
    });
  }
};
/**
 * @license
 * Copyright (c) 2017 - 2025 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const baseStyles$1 = css`
  :host {
    display: flex;
    box-sizing: border-box;
  }

  :host([hidden]) {
    display: none !important;
  }

  /* Theme variations */
  :host([theme~='margin']) {
    margin: 1em;
  }

  :host([theme~='padding']) {
    padding: 1em;
  }

  :host([theme~='spacing']) {
    gap: 1em;
  }

  :host([has-end]:not([has-middle])) ::slotted([last-start-child]) {
    margin-inline-end: auto;
  }

  ::slotted([first-middle-child]) {
    margin-inline-start: auto;
  }

  ::slotted([last-middle-child]) {
    margin-inline-end: auto;
  }

  :host(:not([has-middle])) ::slotted([first-end-child]) {
    margin-inline-start: auto;
  }
`;
const enableLayoutImprovements$1 = window.Vaadin.featureFlags.layoutComponentImprovements;
const layoutImprovementStyles$1 = css`
  ::slotted([data-width-full]) {
    flex: 1;
  }

  ::slotted(vaadin-horizontal-layout[data-width-full]),
  ::slotted(vaadin-vertical-layout[data-width-full]) {
    min-width: 0;
  }
`;
const horizontalLayoutStyles = enableLayoutImprovements$1 ? [baseStyles$1, layoutImprovementStyles$1] : [baseStyles$1];
/**
 * @license
 * Copyright (c) 2017 - 2025 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
registerStyles$1("vaadin-horizontal-layout", horizontalLayoutStyles, { moduleId: "vaadin-horizontal-layout-styles" });
class HorizontalLayout extends HorizontalLayoutMixin(ElementMixin(ThemableMixin(PolymerElement))) {
  static get template() {
    return html`
      <slot></slot>
      <slot name="middle"></slot>
      <slot name="end"></slot>
    `;
  }
  static get is() {
    return "vaadin-horizontal-layout";
  }
}
defineCustomElement(HorizontalLayout);
const scroller = css`
  :host {
    outline: none;
    --_focus-ring-color: var(--vaadin-focus-ring-color, var(--lumo-primary-color-50pct));
    --_focus-ring-width: var(--vaadin-focus-ring-width, 2px);
  }

  :host([focus-ring]) {
    box-shadow: 0 0 0 var(--_focus-ring-width) var(--_focus-ring-color);
  }

  /* Show dividers when content overflows */

  :host([theme~='overflow-indicators'])::before,
  :host([theme~='overflow-indicators'])::after {
    content: '';
    display: none;
    position: sticky;
    inset: 0;
    z-index: 9999;
    height: 1px;
    margin-bottom: -1px;
    background: var(--lumo-contrast-10pct);
  }

  :host([theme~='overflow-indicators'])::after {
    margin-bottom: 0;
    margin-top: -1px;
  }

  :host([theme~='overflow-indicators'][overflow~='top'])::before,
  :host([theme~='overflow-indicators'][overflow~='bottom'])::after {
    display: block;
  }
`;
registerStyles$1("vaadin-scroller", scroller, { moduleId: "lumo-scroller" });
/**
 * @license
 * Copyright (c) 2021 - 2025 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
class OverflowController {
  constructor(host, scrollTarget) {
    this.host = host;
    this.scrollTarget = scrollTarget || host;
    this.__boundOnScroll = this.__onScroll.bind(this);
  }
  hostConnected() {
    if (!this.initialized) {
      this.initialized = true;
      this.observe();
    }
  }
  /**
   * Setup scroll listener and observers to update overflow.
   * Also performs one-time update synchronously when called.
   * @protected
   */
  observe() {
    const { host } = this;
    this.__resizeObserver = new ResizeObserver(() => {
      this.__debounceOverflow = Debouncer$1.debounce(this.__debounceOverflow, animationFrame$1, () => {
        this.__updateOverflow();
      });
    });
    this.__resizeObserver.observe(host);
    [...host.children].forEach((child) => {
      this.__resizeObserver.observe(child);
    });
    this.__childObserver = new MutationObserver((mutations) => {
      mutations.forEach(({ addedNodes, removedNodes }) => {
        addedNodes.forEach((node) => {
          if (node.nodeType === Node.ELEMENT_NODE) {
            this.__resizeObserver.observe(node);
          }
        });
        removedNodes.forEach((node) => {
          if (node.nodeType === Node.ELEMENT_NODE) {
            this.__resizeObserver.unobserve(node);
          }
        });
      });
      this.__updateOverflow();
    });
    this.__childObserver.observe(host, { childList: true });
    this.scrollTarget.addEventListener("scroll", this.__boundOnScroll);
    this.__updateOverflow();
  }
  /** @private */
  __onScroll() {
    this.__updateOverflow();
  }
  /** @private */
  __updateOverflow() {
    const target = this.scrollTarget;
    let overflow = "";
    if (target.scrollTop > 0) {
      overflow += " top";
    }
    if (Math.ceil(target.scrollTop) < Math.ceil(target.scrollHeight - target.clientHeight)) {
      overflow += " bottom";
    }
    const scrollLeft = Math.abs(target.scrollLeft);
    if (scrollLeft > 0) {
      overflow += " start";
    }
    if (Math.ceil(scrollLeft) < Math.ceil(target.scrollWidth - target.clientWidth)) {
      overflow += " end";
    }
    overflow = overflow.trim();
    if (overflow.length > 0 && this.host.getAttribute("overflow") !== overflow) {
      this.host.setAttribute("overflow", overflow);
    } else if (overflow.length === 0 && this.host.hasAttribute("overflow")) {
      this.host.removeAttribute("overflow");
    }
  }
}
/**
 * @license
 * Copyright (c) 2020 - 2025 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const ScrollerMixin = (superClass) => class ScrollerMixinClass extends FocusMixin(superClass) {
  static get properties() {
    return {
      /**
       * This property indicates the scroll direction. Supported values are `vertical`, `horizontal`, `none`.
       * When `scrollDirection` is undefined scrollbars will be shown in both directions.
       * @attr {string} scroll-direction
       */
      scrollDirection: {
        type: String,
        reflectToAttribute: true
      },
      /**
       * Indicates whether the element can be focused and where it participates in sequential keyboard navigation.
       * @protected
       */
      tabindex: {
        type: Number,
        value: 0,
        reflectToAttribute: true
      }
    };
  }
  /**
   * Override method inherited from `FocusMixin` to mark the scroller as focused
   * only when the host is focused.
   * @param {Event} event
   * @return {boolean}
   * @protected
   */
  _shouldSetFocus(event) {
    return event.target === this;
  }
};
/**
 * @license
 * Copyright (c) 2020 - 2025 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
class Scroller extends ScrollerMixin(ElementMixin(ControllerMixin(ThemableMixin(PolymerElement)))) {
  static get template() {
    return html`
      <style>
        :host([hidden]) {
          display: none !important;
        }

        :host {
          display: block;
          overflow: auto;
        }

        :host([scroll-direction='vertical']) {
          overflow-x: hidden;
        }

        :host([scroll-direction='horizontal']) {
          overflow-y: hidden;
        }

        :host([scroll-direction='none']) {
          overflow: hidden;
        }
      </style>

      <slot></slot>
    `;
  }
  static get is() {
    return "vaadin-scroller";
  }
  /** @protected */
  ready() {
    super.ready();
    this.__overflowController = new OverflowController(this);
    this.addController(this.__overflowController);
  }
}
defineCustomElement(Scroller);
const verticalLayout = css`
  :host([theme~='margin']) {
    margin: var(--lumo-space-m);
  }

  :host([theme~='padding']) {
    padding: var(--lumo-space-m);
  }

  :host([theme~='spacing-xs']) {
    gap: var(--lumo-space-xs);
  }

  :host([theme~='spacing-s']) {
    gap: var(--lumo-space-s);
  }

  :host([theme~='spacing']) {
    gap: var(--lumo-space-m);
  }

  :host([theme~='spacing-l']) {
    gap: var(--lumo-space-l);
  }

  :host([theme~='spacing-xl']) {
    gap: var(--lumo-space-xl);
  }

  :host([theme~='wrap']) {
    flex-wrap: wrap;
  }
`;
registerStyles$1("vaadin-vertical-layout", verticalLayout, { moduleId: "lumo-vertical-layout" });
/**
 * @license
 * Copyright (c) 2017 - 2025 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const baseStyles = css`
  :host {
    display: flex;
    flex-direction: column;
    align-items: flex-start;
    box-sizing: border-box;
  }

  :host([hidden]) {
    display: none !important;
  }

  /* Theme variations */
  :host([theme~='margin']) {
    margin: 1em;
  }

  :host([theme~='padding']) {
    padding: 1em;
  }

  :host([theme~='spacing']) {
    gap: 1em;
  }
`;
const enableLayoutImprovements = window.Vaadin.featureFlags.layoutComponentImprovements;
const layoutImprovementStyles = css`
  ::slotted([data-height-full]) {
    flex: 1;
  }

  ::slotted(vaadin-horizontal-layout[data-height-full]),
  ::slotted(vaadin-vertical-layout[data-height-full]) {
    min-height: 0;
  }
`;
const verticalLayoutStyles = enableLayoutImprovements ? [baseStyles, layoutImprovementStyles] : [baseStyles];
/**
 * @license
 * Copyright (c) 2017 - 2025 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
registerStyles$1("vaadin-vertical-layout", verticalLayoutStyles, { moduleId: "vaadin-vertical-layout-styles" });
class VerticalLayout extends ElementMixin(ThemableMixin(PolymerElement)) {
  static get template() {
    return html`<slot></slot>`;
  }
  static get is() {
    return "vaadin-vertical-layout";
  }
}
defineCustomElement(VerticalLayout);
const popoverOverlay = css`
  :host {
    --vaadin-popover-offset-top: var(--_vaadin-popover-default-offset);
    --vaadin-popover-offset-bottom: var(--_vaadin-popover-default-offset);
    --vaadin-popover-offset-start: var(--_vaadin-popover-default-offset);
    --vaadin-popover-offset-end: var(--_vaadin-popover-default-offset);
    --vaadin-popover-arrow-size: 0.5rem;
    --_vaadin-popover-default-offset: var(--lumo-space-xs);
  }

  [part='overlay'] {
    outline: none;
  }

  [part='content'] {
    padding: var(--lumo-space-xs) var(--lumo-space-s);
  }

  :host([theme~='no-padding']) [part='content'] {
    padding: 0;
  }

  :host([theme~='arrow']) {
    --_vaadin-popover-default-offset: calc(var(--lumo-space-s) + var(--vaadin-popover-arrow-size) / 2);
  }

  /* top / bottom position */
  :host([theme~='arrow'][position^='top']) [part='arrow'],
  :host([theme~='arrow'][position^='bottom']) [part='arrow'] {
    border-left: var(--vaadin-popover-arrow-size) solid transparent;
    border-right: var(--vaadin-popover-arrow-size) solid transparent;
  }

  :host([theme~='arrow'][position^='bottom'][bottom-aligned]) [part='arrow'],
  :host([theme~='arrow'][position^='top'][bottom-aligned]) [part='arrow'] {
    bottom: calc(var(--vaadin-popover-arrow-size) * -1);
    border-top: var(--vaadin-popover-arrow-size) solid var(--lumo-base-color);
    filter: drop-shadow(0 2px 1px var(--lumo-shade-10pct));
  }

  :host([theme~='arrow'][position^='bottom'][top-aligned]) [part='arrow'],
  :host([theme~='arrow'][position^='top'][top-aligned]) [part='arrow'] {
    top: calc(var(--vaadin-popover-arrow-size) * -1);
    border-bottom: var(--vaadin-popover-arrow-size) solid var(--lumo-base-color);
    filter: drop-shadow(0 -2px 1px var(--lumo-shade-10pct));
  }

  :host([theme~='arrow'][position^='bottom'][start-aligned]) [part='arrow'],
  :host([theme~='arrow'][position^='top'][start-aligned]) [part='arrow'] {
    transform: translateX(-50%);
    inset-inline-start: 1.5rem;
  }

  :host([theme~='arrow'][position^='bottom'][end-aligned]) [part='arrow'],
  :host([theme~='arrow'][position^='top'][end-aligned]) [part='arrow'] {
    transform: translateX(50%);
    inset-inline-end: 1.5rem;
  }

  :host([theme~='arrow'][position^='bottom'][arrow-centered]) [part='arrow'],
  :host([theme~='arrow'][position^='top'][arrow-centered]) [part='arrow'] {
    transform: translateX(-50%);
    inset-inline-start: 50%;
  }

  /* start / end position */
  :host([theme~='arrow'][position^='start']) [part='arrow'],
  :host([theme~='arrow'][position^='end']) [part='arrow'] {
    border-top: var(--vaadin-popover-arrow-size) solid transparent;
    border-bottom: var(--vaadin-popover-arrow-size) solid transparent;
  }

  :host([theme~='arrow'][position^='start'][start-aligned]) [part='arrow'],
  :host([theme~='arrow'][position^='end'][start-aligned]) [part='arrow'] {
    inset-inline-start: calc(var(--vaadin-popover-arrow-size) * -1);
    border-right: var(--vaadin-popover-arrow-size) solid var(--lumo-base-color);
    filter: drop-shadow(-2px 0 1px var(--lumo-shade-10pct));
  }

  :host([theme~='arrow'][position^='start'][end-aligned]) [part='arrow'],
  :host([theme~='arrow'][position^='end'][end-aligned]) [part='arrow'] {
    inset-inline-end: calc(var(--vaadin-popover-arrow-size) * -1);
    border-left: var(--vaadin-popover-arrow-size) solid var(--lumo-base-color);
    filter: drop-shadow(2px 0 1px var(--lumo-shade-10pct));
  }

  :host([theme~='arrow'][position^='start'][top-aligned]) [part='arrow'],
  :host([theme~='arrow'][position^='end'][top-aligned]) [part='arrow'] {
    top: 0.5rem;
  }

  :host([theme~='arrow'][position='start'][top-aligned]) [part='arrow'],
  :host([theme~='arrow'][position='end'][top-aligned]) [part='arrow'] {
    top: 50%;
    transform: translateY(-50%);
  }

  :host([theme~='arrow'][position^='start'][bottom-aligned]) [part='arrow'],
  :host([theme~='arrow'][position^='end'][bottom-aligned]) [part='arrow'] {
    bottom: 0.5rem;
  }
`;
registerStyles$1("vaadin-popover-overlay", [overlay, popoverOverlay], { moduleId: "lumo-popover-overlay" });
/**
 * @license
 * Copyright (c) 2024 - 2025 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
class PopoverOverlay extends PopoverOverlayMixin(DirMixin(ThemableMixin(PolylitMixin(LitElement)))) {
  static get is() {
    return "vaadin-popover-overlay";
  }
  static get styles() {
    return [
      overlayStyles,
      css`
        :host {
          --_vaadin-popover-content-width: auto;
          --_vaadin-popover-content-height: auto;
        }

        :host([modeless][with-backdrop]) [part='backdrop'] {
          pointer-events: none;
        }

        :host([position^='top'][top-aligned]) [part='overlay'],
        :host([position^='bottom'][top-aligned]) [part='overlay'] {
          margin-top: var(--vaadin-popover-offset-top, 0);
        }

        [part='overlay'] {
          position: relative;
          overflow: visible;
          max-height: 100%;
        }

        [part='content'] {
          overflow: auto;
          box-sizing: border-box;
          max-height: 100%;
          width: var(--_vaadin-popover-content-width);
          height: var(--_vaadin-popover-content-height);
        }

        /* Increase the area of the popover so the pointer can go from the target directly to it. */
        [part='overlay']::before {
          position: absolute;
          content: '';
          inset-block: calc(var(--vaadin-popover-offset-top, 0) * -1) calc(var(--vaadin-popover-offset-bottom, 0) * -1);
          inset-inline: calc(var(--vaadin-popover-offset-start, 0) * -1) calc(var(--vaadin-popover-offset-end, 0) * -1);
          z-index: -1;
          pointer-events: auto;
        }

        :host([position^='top'][bottom-aligned]) [part='overlay'],
        :host([position^='bottom'][bottom-aligned]) [part='overlay'] {
          margin-bottom: var(--vaadin-popover-offset-bottom, 0);
        }

        :host([position^='start'][start-aligned]) [part='overlay'],
        :host([position^='end'][start-aligned]) [part='overlay'] {
          margin-inline-start: var(--vaadin-popover-offset-start, 0);
        }

        :host([position^='start'][end-aligned]) [part='overlay'],
        :host([position^='end'][end-aligned]) [part='overlay'] {
          margin-inline-end: var(--vaadin-popover-offset-end, 0);
        }

        [part='arrow'] {
          display: none;
          position: absolute;
          height: 0;
          width: 0;
        }

        :host([theme~='arrow']) [part='arrow'] {
          display: block;
        }
      `
    ];
  }
  /** @protected */
  render() {
    return html$1`
      <div id="backdrop" part="backdrop" hidden ?hidden="${!this.withBackdrop}"></div>
      <div part="overlay" id="overlay" tabindex="0">
        <div part="arrow"></div>
        <div part="content" id="content"><slot></slot></div>
      </div>
    `;
  }
  /** @protected */
  updated(props) {
    super.updated(props);
    if (props.has("restoreFocusNode") && this.opened) {
      if (this.restoreFocusNode && isElementFocused(this.restoreFocusNode.focusElement || this.restoreFocusNode)) {
        this.__focusRestorationController.saveFocus();
      } else if (!this.restoreFocusNode) {
        this.__focusRestorationController.focusNode = null;
      }
    }
  }
}
defineCustomElement(PopoverOverlay);
/**
 * @license
 * Copyright (c) 2024 - 2025 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const DEFAULT_DELAY = 500;
let defaultFocusDelay$2 = DEFAULT_DELAY;
let defaultHoverDelay$2 = DEFAULT_DELAY;
let defaultHideDelay$2 = DEFAULT_DELAY;
class PopoverOpenedStateController {
  constructor(host) {
    this.host = host;
  }
  /**
   * Whether closing is currently in progress.
   * @return {boolean}
   */
  get isClosing() {
    return this.__closeTimeout != null;
  }
  /** @private */
  get __focusDelay() {
    const popover = this.host;
    return popover.focusDelay != null && popover.focusDelay >= 0 ? popover.focusDelay : defaultFocusDelay$2;
  }
  /** @private */
  get __hoverDelay() {
    const popover = this.host;
    return popover.hoverDelay != null && popover.hoverDelay >= 0 ? popover.hoverDelay : defaultHoverDelay$2;
  }
  /** @private */
  get __hideDelay() {
    const popover = this.host;
    return popover.hideDelay != null && popover.hideDelay >= 0 ? popover.hideDelay : defaultHideDelay$2;
  }
  /**
   * Schedule opening the popover.
   * @param {Object} options
   */
  open(options = { immediate: false }) {
    if (this.isClosing) {
      this.__abortClose();
      return;
    }
    const { immediate, trigger } = options;
    const shouldDelayHover = trigger === "hover" && this.__hoverDelay > 0;
    const shouldDelayFocus = trigger === "focus" && this.__focusDelay > 0;
    if (!immediate && (shouldDelayHover || shouldDelayFocus)) {
      this.__scheduleOpen(trigger);
    } else {
      this.__showPopover();
    }
  }
  /**
   * Schedule closing the popover.
   * @param {boolean} immediate
   */
  close(immediate) {
    if (this.__openTimeout != null) {
      this.__abortOpen();
    } else if (immediate || this.__hideDelay === 0) {
      this.__abortClose();
      this.__setOpened(false);
    } else {
      this.__scheduleClose();
    }
  }
  /** @private */
  __setOpened(opened) {
    this.host.opened = opened;
  }
  /** @private */
  __showPopover() {
    this.__abortClose();
    this.__setOpened(true);
  }
  /** @private */
  __abortClose() {
    if (this.__closeTimeout) {
      clearTimeout(this.__closeTimeout);
      this.__closeTimeout = null;
    }
  }
  /** @private */
  __abortOpen() {
    if (this.__openTimeout) {
      clearTimeout(this.__openTimeout);
      this.__openTimeout = null;
    }
  }
  /** @private */
  __scheduleClose() {
    this.__closeTimeout = setTimeout(() => {
      this.__closeTimeout = null;
      this.__setOpened(false);
    }, this.__hideDelay);
  }
  /** @private */
  __scheduleOpen(trigger) {
    this.__abortOpen();
    const delay = trigger === "focus" ? this.__focusDelay : this.__hoverDelay;
    this.__openTimeout = setTimeout(() => {
      this.__openTimeout = null;
      this.__showPopover();
    }, delay);
  }
}
const isLastOverlay = (overlay2) => {
  const filter2 = (o) => o.localName !== "vaadin-tooltip-overlay";
  return isLastOverlay$1(overlay2, filter2);
};
class Popover extends PopoverPositionMixin(
  PopoverTargetMixin(OverlayClassMixin(ThemePropertyMixin(ElementMixin(PolylitMixin(LitElement)))))
) {
  static get is() {
    return "vaadin-popover";
  }
  static get styles() {
    return css`
      :host {
        display: none !important;
      }
    `;
  }
  static get properties() {
    return {
      /**
       * String used to label the overlay to screen reader users.
       *
       * @attr {string} accessible-name
       */
      accessibleName: {
        type: String
      },
      /**
       * Id of the element used as label of the overlay to screen reader users.
       *
       * @attr {string} accessible-name-ref
       */
      accessibleNameRef: {
        type: String
      },
      /**
       * When true, the popover content automatically receives focus after
       * it is opened. Modal popovers use this behavior by default.
       */
      autofocus: {
        type: Boolean
      },
      /**
       * Height to be set on the overlay content.
       *
       * @attr {string} content-height
       */
      contentHeight: {
        type: String
      },
      /**
       * Width to be set on the overlay content.
       *
       * @attr {string} content-width
       */
      contentWidth: {
        type: String
      },
      /**
       * The delay in milliseconds before the popover is opened
       * on focus when the corresponding trigger is used.
       *
       * When not specified, the global default (500ms) is used.
       *
       * @attr {number} focus-delay
       */
      focusDelay: {
        type: Number
      },
      /**
       * The delay in milliseconds before the popover is closed
       * on losing hover, when the corresponding trigger is used.
       * On blur, the popover is closed immediately.
       *
       * When not specified, the global default (500ms) is used.
       *
       * @attr {number} hide-delay
       */
      hideDelay: {
        type: Number
      },
      /**
       * The delay in milliseconds before the popover is opened
       * on hover when the corresponding trigger is used.
       *
       * When not specified, the global default (500ms) is used.
       *
       * @attr {number} hover-delay
       */
      hoverDelay: {
        type: Number
      },
      /**
       * True if the popover overlay is opened, false otherwise.
       */
      opened: {
        type: Boolean,
        value: false,
        notify: true,
        observer: "__openedChanged"
      },
      /**
       * The `role` attribute value to be set on the overlay.
       *
       * @attr {string} overlay-role
       */
      overlayRole: {
        type: String,
        value: "dialog"
      },
      /**
       * Custom function for rendering the content of the overlay.
       * Receives two arguments:
       *
       * - `root` The root container DOM element. Append your content to it.
       * - `popover` The reference to the `vaadin-popover` element (overlay host).
       */
      renderer: {
        type: Object
      },
      /**
       * When true, the popover prevents interacting with background elements
       * by setting `pointer-events` style on the document body to `none`.
       * This also enables trapping focus inside the overlay.
       */
      modal: {
        type: Boolean,
        value: false
      },
      /**
       * Set to true to disable closing popover overlay on outside click.
       *
       * @attr {boolean} no-close-on-outside-click
       */
      noCloseOnOutsideClick: {
        type: Boolean,
        value: false
      },
      /**
       * Set to true to disable closing popover overlay on Escape press.
       * When the popover is modal, pressing Escape anywhere in the
       * document closes the overlay. Otherwise, only Escape press
       * from the popover itself or its target closes the overlay.
       *
       * @attr {boolean} no-close-on-esc
       */
      noCloseOnEsc: {
        type: Boolean,
        value: false
      },
      /**
       * Popover trigger mode, used to configure how the overlay is opened or closed.
       * Could be set to multiple by providing an array, e.g. `trigger = ['hover', 'focus']`.
       *
       * Supported values:
       * - `click` (default) - opens and closes on target click.
       * - `hover` - opens on target mouseenter, closes on target mouseleave. Moving mouse
       * to the popover overlay content keeps the overlay opened.
       * - `focus` - opens on target focus, closes on target blur. Moving focus to the
       * popover overlay content keeps the overlay opened.
       *
       * In addition to the behavior specified by `trigger`, the popover can be closed by:
       * - pressing Escape key (unless `noCloseOnEsc` property is true)
       * - outside click (unless `noCloseOnOutsideClick` property is true)
       *
       * When setting `trigger` property to `null`, `undefined` or empty array, the popover
       * can be only opened programmatically by changing `opened` property. Note, closing
       * on Escape press or outside click is still allowed unless explicitly disabled.
       */
      trigger: {
        type: Array,
        value: () => ["click"]
      },
      /**
       * When true, the overlay has a backdrop (modality curtain) on top of the
       * underlying page content, covering the whole viewport.
       *
       * @attr {boolean} with-backdrop
       */
      withBackdrop: {
        type: Boolean,
        value: false
      },
      /** @private */
      __shouldRestoreFocus: {
        type: Boolean,
        value: false,
        sync: true
      },
      /** @private */
      __overlayId: {
        type: String
      }
    };
  }
  static get observers() {
    return [
      "__updateContentHeight(contentHeight, _overlayElement)",
      "__updateContentWidth(contentWidth, _overlayElement)",
      "__updateAriaAttributes(opened, overlayRole, target)"
    ];
  }
  /**
   * Sets the default focus delay to be used by all popover instances,
   * except for those that have focus delay configured using property.
   *
   * @param {number} focusDelay
   */
  static setDefaultFocusDelay(focusDelay) {
    defaultFocusDelay$2 = focusDelay != null && focusDelay >= 0 ? focusDelay : DEFAULT_DELAY;
  }
  /**
   * Sets the default hide delay to be used by all popover instances,
   * except for those that have hide delay configured using property.
   *
   * @param {number} hideDelay
   */
  static setDefaultHideDelay(hideDelay) {
    defaultHideDelay$2 = hideDelay != null && hideDelay >= 0 ? hideDelay : DEFAULT_DELAY;
  }
  /**
   * Sets the default hover delay to be used by all popover instances,
   * except for those that have hover delay configured using property.
   *
   * @param {number} hoverDelay
   */
  static setDefaultHoverDelay(hoverDelay) {
    defaultHoverDelay$2 = hoverDelay != null && hoverDelay >= 0 ? hoverDelay : DEFAULT_DELAY;
  }
  constructor() {
    super();
    this.__overlayId = `vaadin-popover-${generateUniqueId()}`;
    this.__onGlobalClick = this.__onGlobalClick.bind(this);
    this.__onGlobalKeyDown = this.__onGlobalKeyDown.bind(this);
    this.__onTargetClick = this.__onTargetClick.bind(this);
    this.__onTargetFocusIn = this.__onTargetFocusIn.bind(this);
    this.__onTargetFocusOut = this.__onTargetFocusOut.bind(this);
    this.__onTargetMouseEnter = this.__onTargetMouseEnter.bind(this);
    this.__onTargetMouseLeave = this.__onTargetMouseLeave.bind(this);
    this._openedStateController = new PopoverOpenedStateController(this);
  }
  /** @protected */
  render() {
    const effectivePosition = this.__effectivePosition;
    return html$1`
      <vaadin-popover-overlay
        id="${this.__overlayId}"
        role="${this.overlayRole}"
        aria-label="${ifDefined(this.accessibleName)}"
        aria-labelledby="${ifDefined(this.accessibleNameRef)}"
        .renderer="${this.renderer}"
        .owner="${this}"
        theme="${ifDefined(this._theme)}"
        .positionTarget="${this.target}"
        .position="${effectivePosition}"
        .opened="${this.opened}"
        .modeless="${!this.modal}"
        .focusTrap="${this.modal}"
        .withBackdrop="${this.withBackdrop}"
        ?no-horizontal-overlap="${this.__computeNoHorizontalOverlap(effectivePosition)}"
        ?no-vertical-overlap="${this.__computeNoVerticalOverlap(effectivePosition)}"
        .horizontalAlign="${this.__computeHorizontalAlign(effectivePosition)}"
        .verticalAlign="${this.__computeVerticalAlign(effectivePosition)}"
        @mousedown="${this.__onOverlayMouseDown}"
        @mouseenter="${this.__onOverlayMouseEnter}"
        @mouseleave="${this.__onOverlayMouseLeave}"
        @focusin="${this.__onOverlayFocusIn}"
        @focusout="${this.__onOverlayFocusOut}"
        @opened-changed="${this.__onOpenedChanged}"
        .restoreFocusOnClose="${this.__shouldRestoreFocus}"
        .restoreFocusNode="${this.target}"
        @vaadin-overlay-escape-press="${this.__onEscapePress}"
        @vaadin-overlay-outside-click="${this.__onOutsideClick}"
        @vaadin-overlay-open="${this.__onOverlayOpened}"
        @vaadin-overlay-closed="${this.__onOverlayClosed}"
      ></vaadin-popover-overlay>
    `;
  }
  /**
   * Requests an update for the content of the popover.
   * While performing the update, it invokes the renderer passed in the `renderer` property.
   *
   * It is not guaranteed that the update happens immediately (synchronously) after it is requested.
   */
  requestContentUpdate() {
    if (!this.renderer || !this._overlayElement) {
      return;
    }
    this._overlayElement.requestContentUpdate();
  }
  /** @protected */
  ready() {
    super.ready();
    this._overlayElement = this.$[this.__overlayId];
  }
  /** @protected */
  connectedCallback() {
    super.connectedCallback();
    document.documentElement.addEventListener("click", this.__onGlobalClick, true);
  }
  /** @protected */
  disconnectedCallback() {
    super.disconnectedCallback();
    document.documentElement.removeEventListener("click", this.__onGlobalClick, true);
    queueMicrotask(() => {
      if (!this.isConnected) {
        this._openedStateController.close(true);
      }
    });
  }
  /**
   * @param {HTMLElement} target
   * @protected
   * @override
   */
  _addTargetListeners(target) {
    target.addEventListener("click", this.__onTargetClick);
    target.addEventListener("mouseenter", this.__onTargetMouseEnter);
    target.addEventListener("mouseleave", this.__onTargetMouseLeave);
    target.addEventListener("focusin", this.__onTargetFocusIn);
    target.addEventListener("focusout", this.__onTargetFocusOut);
  }
  /**
   * @param {HTMLElement} target
   * @protected
   * @override
   */
  _removeTargetListeners(target) {
    target.removeEventListener("click", this.__onTargetClick);
    target.removeEventListener("mouseenter", this.__onTargetMouseEnter);
    target.removeEventListener("mouseleave", this.__onTargetMouseLeave);
    target.removeEventListener("focusin", this.__onTargetFocusIn);
    target.removeEventListener("focusout", this.__onTargetFocusOut);
  }
  /** @private */
  __openedChanged(opened, oldOpened) {
    if (opened) {
      document.addEventListener("keydown", this.__onGlobalKeyDown, true);
    } else if (oldOpened) {
      document.removeEventListener("keydown", this.__onGlobalKeyDown, true);
    }
  }
  /** @private */
  __updateAriaAttributes(opened, overlayRole, target) {
    if (this.__oldTarget) {
      const oldEffectiveTarget = this.__oldTarget.ariaTarget || this.__oldTarget;
      oldEffectiveTarget.removeAttribute("aria-haspopup");
      oldEffectiveTarget.removeAttribute("aria-expanded");
      oldEffectiveTarget.removeAttribute("aria-controls");
    }
    if (target) {
      const effectiveTarget = target.ariaTarget || target;
      const isDialog = overlayRole === "dialog" || overlayRole === "alertdialog";
      effectiveTarget.setAttribute("aria-haspopup", isDialog ? "dialog" : "true");
      effectiveTarget.setAttribute("aria-expanded", opened ? "true" : "false");
      if (opened) {
        effectiveTarget.setAttribute("aria-controls", this.__overlayId);
      } else {
        effectiveTarget.removeAttribute("aria-controls");
      }
      this.__oldTarget = target;
    }
  }
  /**
   * Overlay's global outside click listener doesn't work when
   * the overlay is modeless, so we use a separate listener.
   * @private
   */
  __onGlobalClick(event) {
    if (this.opened && !this.modal && !event.composedPath().some((el) => el === this._overlayElement || el === this.target) && !this.noCloseOnOutsideClick && isLastOverlay(this._overlayElement)) {
      this._openedStateController.close(true);
    }
  }
  /** @private */
  __onTargetClick() {
    if (this.__hasTrigger("click")) {
      if (!this.opened) {
        this.__shouldRestoreFocus = true;
      }
      if (this.opened) {
        this._openedStateController.close(true);
      } else {
        this._openedStateController.open({ immediate: true });
      }
    }
  }
  /**
   * Overlay's global Escape press listener doesn't work when
   * the overlay is modeless, so we use a separate listener.
   * @private
   */
  __onGlobalKeyDown(event) {
    if (this.modal) {
      return;
    }
    if (event.key === "Escape" && !this.noCloseOnEsc && this.opened && isLastOverlay(this._overlayElement)) {
      event.stopPropagation();
      this._openedStateController.close(true);
    }
    if (event.key === "Tab") {
      if (event.shiftKey) {
        this.__onGlobalShiftTab(event);
      } else {
        this.__onGlobalTab(event);
      }
    }
  }
  /** @private */
  __onGlobalTab(event) {
    const overlayPart = this._overlayElement.$.overlay;
    if (this.target && isElementFocused(this.__getTargetFocusable())) {
      event.preventDefault();
      overlayPart.focus();
      return;
    }
    const lastFocusable = this.__getLastFocusable(overlayPart);
    if (lastFocusable && isElementFocused(lastFocusable)) {
      const focusable = this.__getNextBodyFocusable(this.__getTargetFocusable());
      if (focusable && focusable !== overlayPart) {
        event.preventDefault();
        focusable.focus();
        return;
      }
    }
    const activeElement = getDeepActiveElement();
    const nextFocusable = this.__getNextBodyFocusable(activeElement);
    if (nextFocusable === overlayPart && lastFocusable) {
      lastFocusable.focus();
    }
  }
  /** @private */
  __onGlobalShiftTab(event) {
    const overlayPart = this._overlayElement.$.overlay;
    if (this.target && isElementFocused(this.__getTargetFocusable()) && this.__shouldRestoreFocus) {
      this.__shouldRestoreFocus = false;
      return;
    }
    if (this.target && isElementFocused(overlayPart)) {
      event.preventDefault();
      this.__getTargetFocusable().focus();
      return;
    }
    const nextFocusable = this.__getNextBodyFocusable(this.__getTargetFocusable());
    if (nextFocusable && isElementFocused(nextFocusable)) {
      const lastFocusable = this.__getLastFocusable(overlayPart);
      if (lastFocusable) {
        event.preventDefault();
        lastFocusable.focus();
      }
    }
  }
  /** @private */
  __getNextBodyFocusable(target) {
    const focusables = getFocusableElements(document.body);
    const idx = focusables.findIndex((el) => el === target);
    return focusables[idx + 1];
  }
  /** @private */
  __getLastFocusable(container) {
    const focusables = getFocusableElements(container);
    return focusables.pop();
  }
  /** @private */
  __getTargetFocusable() {
    if (!this.target) {
      return null;
    }
    return this.target.focusElement || this.target;
  }
  /** @private */
  __onTargetFocusIn() {
    this.__focusInside = true;
    if (this.__hasTrigger("focus")) {
      if (this.__hasTrigger("click") && !isKeyboardActive()) {
        return;
      }
      if (!this.__shouldRestoreFocus) {
        this.__shouldRestoreFocus = true;
        this._openedStateController.open({ trigger: "focus" });
      }
    }
  }
  /** @private */
  __onTargetFocusOut(event) {
    if (this._overlayElement.opened && !isLastOverlay(this._overlayElement)) {
      return;
    }
    if (this.__hasTrigger("focus") && this.__mouseDownInside || this._overlayElement.contains(event.relatedTarget)) {
      return;
    }
    this.__handleFocusout();
  }
  /** @private */
  __onTargetMouseEnter() {
    this.__hoverInside = true;
    if (this.__hasTrigger("hover") && !this.opened) {
      if (this.modal) {
        this.target.style.pointerEvents = "auto";
      }
      this._openedStateController.open({ trigger: "hover" });
    }
  }
  /** @private */
  __onTargetMouseLeave(event) {
    if (this._overlayElement.opened && !isLastOverlay(this._overlayElement)) {
      return;
    }
    if (this._overlayElement.contains(event.relatedTarget)) {
      return;
    }
    this.__handleMouseLeave();
  }
  /** @private */
  __onOverlayFocusIn() {
    this.__focusInside = true;
    if (this.__hasTrigger("focus") || this.__hasTrigger("click")) {
      this.__shouldRestoreFocus = true;
    }
  }
  /** @private */
  __onOverlayFocusOut(event) {
    if (!isLastOverlay(this._overlayElement)) {
      return;
    }
    if (this.__hasTrigger("focus") && this.__mouseDownInside || event.relatedTarget === this.target || this._overlayElement.contains(event.relatedTarget)) {
      return;
    }
    this.__handleFocusout();
  }
  /** @private */
  __onOverlayMouseDown() {
    if (this.__hasTrigger("focus")) {
      this.__mouseDownInside = true;
      document.addEventListener(
        "mouseup",
        () => {
          this.__mouseDownInside = false;
        },
        { once: true }
      );
    }
  }
  /** @private */
  __onOverlayMouseEnter() {
    this.__hoverInside = true;
    if (this.__hasTrigger("hover") && this._openedStateController.isClosing) {
      this._openedStateController.open({ immediate: true });
    }
  }
  /** @private */
  __onOverlayMouseLeave(event) {
    if (!isLastOverlay(this._overlayElement)) {
      return;
    }
    if (event.relatedTarget === this.target) {
      return;
    }
    this.__handleMouseLeave();
  }
  /** @private */
  __handleFocusout() {
    this.__focusInside = false;
    if (this.__hasTrigger("hover") && this.__hoverInside) {
      return;
    }
    if (this.__hasTrigger("focus")) {
      this._openedStateController.close(true);
    }
  }
  /** @private */
  __handleMouseLeave() {
    this.__hoverInside = false;
    if (this.__hasTrigger("focus") && this.__focusInside) {
      return;
    }
    if (this.__hasTrigger("hover")) {
      this._openedStateController.close();
    }
  }
  /** @private */
  __onOpenedChanged(event) {
    this.opened = event.detail.value;
  }
  /** @private */
  __onOverlayOpened() {
    if (this.autofocus && !this.modal) {
      this._overlayElement.$.overlay.focus();
    }
  }
  /** @private */
  __onOverlayClosed() {
    if (this.__shouldRestoreFocus) {
      setTimeout(() => {
        this.__shouldRestoreFocus = false;
      });
    }
    if (this.modal && this.target && this.target.style.pointerEvents) {
      this.target.style.pointerEvents = "";
    }
    this.dispatchEvent(new CustomEvent("closed"));
  }
  /**
   * Close the popover if `noCloseOnEsc` isn't set to true.
   * @private
   */
  __onEscapePress(e2) {
    if (this.noCloseOnEsc) {
      e2.preventDefault();
    }
  }
  /**
   * Close the popover if `noCloseOnOutsideClick` isn't set to true.
   * @private
   */
  __onOutsideClick(e2) {
    if (this.noCloseOnOutsideClick) {
      e2.preventDefault();
    }
  }
  /** @private */
  __hasTrigger(trigger) {
    return Array.isArray(this.trigger) && this.trigger.includes(trigger);
  }
  /** @private */
  __updateDimension(overlay2, dimension, value) {
    const prop = `--_vaadin-popover-content-${dimension}`;
    if (value) {
      overlay2.style.setProperty(prop, value);
    } else {
      overlay2.style.removeProperty(prop);
    }
  }
  /** @private */
  __updateContentHeight(height, overlay2) {
    if (overlay2) {
      this.__updateDimension(overlay2, "height", height);
    }
  }
  /** @private */
  __updateContentWidth(width, overlay2) {
    if (overlay2) {
      this.__updateDimension(overlay2, "width", width);
    }
  }
  /**
   * Fired when the popover is closed.
   *
   * @event closed
   */
}
defineCustomElement(Popover);
const _window$2 = window;
_window$2.Vaadin ||= {};
_window$2.Vaadin.Flow ||= {};
_window$2.Vaadin.Flow.popover ||= {};
Object.assign(_window$2.Vaadin.Flow.popover, {
  setDefaultHideDelay: (hideDelay) => Popover.setDefaultHideDelay(hideDelay),
  setDefaultFocusDelay: (focusDelay) => Popover.setDefaultFocusDelay(focusDelay),
  setDefaultHoverDelay: (hoverDelay) => Popover.setDefaultHoverDelay(hoverDelay)
});
const { defaultHideDelay: defaultHideDelay$1, defaultFocusDelay: defaultFocusDelay$1, defaultHoverDelay: defaultHoverDelay$1 } = _window$2.Vaadin.Flow.popover;
if (defaultHideDelay$1) {
  Popover.setDefaultHideDelay(defaultHideDelay$1);
}
if (defaultFocusDelay$1) {
  Popover.setDefaultFocusDelay(defaultFocusDelay$1);
}
if (defaultHoverDelay$1) {
  Popover.setDefaultHoverDelay(defaultHoverDelay$1);
}
registerStyles$1(
  "vaadin-progress-bar",
  css`
    :host {
      height: calc(var(--lumo-size-l) / 10);
      margin: var(--lumo-space-s) 0;
    }

    [part='bar'] {
      border-radius: var(--lumo-border-radius-m);
      background-color: var(--lumo-contrast-10pct);
    }

    [part='value'] {
      border-radius: var(--lumo-border-radius-m);
      background-color: var(--lumo-primary-color);
      /* Use width instead of transform to preserve border radius */
      transform: none;
      width: calc(var(--vaadin-progress-value) * 100%);
      will-change: width;
      transition: 0.1s width linear;
    }

    /* Indeterminate mode */
    :host([indeterminate]) [part='value'] {
      --lumo-progress-indeterminate-progress-bar-background: linear-gradient(
        to right,
        var(--lumo-primary-color-10pct) 10%,
        var(--lumo-primary-color)
      );
      --lumo-progress-indeterminate-progress-bar-background-reverse: linear-gradient(
        to left,
        var(--lumo-primary-color-10pct) 10%,
        var(--lumo-primary-color)
      );
      width: 100%;
      background-color: transparent !important;
      background-image: var(--lumo-progress-indeterminate-progress-bar-background);
      opacity: 0.75;
      will-change: transform;
      animation: vaadin-progress-indeterminate 1.6s infinite cubic-bezier(0.645, 0.045, 0.355, 1);
    }

    @keyframes vaadin-progress-indeterminate {
      0% {
        transform: scaleX(0.015);
        transform-origin: 0% 0%;
      }

      25% {
        transform: scaleX(0.4);
      }

      50% {
        transform: scaleX(0.015);
        transform-origin: 100% 0%;
        background-image: var(--lumo-progress-indeterminate-progress-bar-background);
      }

      50.1% {
        transform: scaleX(0.015);
        transform-origin: 100% 0%;
        background-image: var(--lumo-progress-indeterminate-progress-bar-background-reverse);
      }

      75% {
        transform: scaleX(0.4);
      }

      100% {
        transform: scaleX(0.015);
        transform-origin: 0% 0%;
        background-image: var(--lumo-progress-indeterminate-progress-bar-background-reverse);
      }
    }

    :host(:not([aria-valuenow])) [part='value']::before,
    :host([indeterminate]) [part='value']::before {
      content: '';
      display: block;
      width: 100%;
      height: 100%;
      border-radius: inherit;
      background-color: var(--lumo-primary-color);
      will-change: opacity;
      animation: vaadin-progress-pulse3 1.6s infinite cubic-bezier(0.645, 0.045, 0.355, 1);
    }

    @keyframes vaadin-progress-pulse3 {
      0% {
        opacity: 1;
      }

      10% {
        opacity: 0;
      }

      40% {
        opacity: 0;
      }

      50% {
        opacity: 1;
      }

      50.1% {
        opacity: 1;
      }

      60% {
        opacity: 0;
      }

      90% {
        opacity: 0;
      }

      100% {
        opacity: 1;
      }
    }

    /* Contrast color */
    :host([theme~='contrast']) [part='value'],
    :host([theme~='contrast']) [part='value']::before {
      background-color: var(--lumo-contrast-80pct);
      --lumo-progress-indeterminate-progress-bar-background: linear-gradient(
        to right,
        var(--lumo-contrast-5pct) 10%,
        var(--lumo-contrast-80pct)
      );
      --lumo-progress-indeterminate-progress-bar-background-reverse: linear-gradient(
        to left,
        var(--lumo-contrast-5pct) 10%,
        var(--lumo-contrast-60pct)
      );
    }

    /* Error color */
    :host([theme~='error']) [part='value'],
    :host([theme~='error']) [part='value']::before {
      background-color: var(--lumo-error-color);
      --lumo-progress-indeterminate-progress-bar-background: linear-gradient(
        to right,
        var(--lumo-error-color-10pct) 10%,
        var(--lumo-error-color)
      );
      --lumo-progress-indeterminate-progress-bar-background-reverse: linear-gradient(
        to left,
        var(--lumo-error-color-10pct) 10%,
        var(--lumo-error-color)
      );
    }

    /* Primary color */
    :host([theme~='success']) [part='value'],
    :host([theme~='success']) [part='value']::before {
      background-color: var(--lumo-success-color);
      --lumo-progress-indeterminate-progress-bar-background: linear-gradient(
        to right,
        var(--lumo-success-color-10pct) 10%,
        var(--lumo-success-color)
      );
      --lumo-progress-indeterminate-progress-bar-background-reverse: linear-gradient(
        to left,
        var(--lumo-success-color-10pct) 10%,
        var(--lumo-success-color)
      );
    }

    /* RTL specific styles */
    :host([indeterminate][dir='rtl']) [part='value'] {
      --lumo-progress-indeterminate-progress-bar-background: linear-gradient(
        to left,
        var(--lumo-primary-color-10pct) 10%,
        var(--lumo-primary-color)
      );
      --lumo-progress-indeterminate-progress-bar-background-reverse: linear-gradient(
        to right,
        var(--lumo-primary-color-10pct) 10%,
        var(--lumo-primary-color)
      );
      animation: vaadin-progress-indeterminate-rtl 1.6s infinite cubic-bezier(0.355, 0.045, 0.645, 1);
    }

    :host(:not([aria-valuenow])[dir='rtl']) [part='value']::before,
    :host([indeterminate][dir='rtl']) [part='value']::before {
      animation: vaadin-progress-pulse3 1.6s infinite cubic-bezier(0.355, 0.045, 0.645, 1);
    }

    @keyframes vaadin-progress-indeterminate-rtl {
      0% {
        transform: scaleX(0.015);
        transform-origin: 100% 0%;
      }

      25% {
        transform: scaleX(0.4);
      }

      50% {
        transform: scaleX(0.015);
        transform-origin: 0% 0%;
        background-image: var(--lumo-progress-indeterminate-progress-bar-background);
      }

      50.1% {
        transform: scaleX(0.015);
        transform-origin: 0% 0%;
        background-image: var(--lumo-progress-indeterminate-progress-bar-background-reverse);
      }

      75% {
        transform: scaleX(0.4);
      }

      100% {
        transform: scaleX(0.015);
        transform-origin: 100% 0%;
        background-image: var(--lumo-progress-indeterminate-progress-bar-background-reverse);
      }
    }

    /* Contrast color */
    :host([theme~='contrast'][dir='rtl']) [part='value'],
    :host([theme~='contrast'][dir='rtl']) [part='value']::before {
      --lumo-progress-indeterminate-progress-bar-background: linear-gradient(
        to left,
        var(--lumo-contrast-5pct) 10%,
        var(--lumo-contrast-80pct)
      );
      --lumo-progress-indeterminate-progress-bar-background-reverse: linear-gradient(
        to right,
        var(--lumo-contrast-5pct) 10%,
        var(--lumo-contrast-60pct)
      );
    }

    /* Error color */
    :host([theme~='error'][dir='rtl']) [part='value'],
    :host([theme~='error'][dir='rtl']) [part='value']::before {
      --lumo-progress-indeterminate-progress-bar-background: linear-gradient(
        to left,
        var(--lumo-error-color-10pct) 10%,
        var(--lumo-error-color)
      );
      --lumo-progress-indeterminate-progress-bar-background-reverse: linear-gradient(
        to right,
        var(--lumo-error-color-10pct) 10%,
        var(--lumo-error-color)
      );
    }

    /* Primary color */
    :host([theme~='success'][dir='rtl']) [part='value'],
    :host([theme~='success'][dir='rtl']) [part='value']::before {
      --lumo-progress-indeterminate-progress-bar-background: linear-gradient(
        to left,
        var(--lumo-success-color-10pct) 10%,
        var(--lumo-success-color)
      );
      --lumo-progress-indeterminate-progress-bar-background-reverse: linear-gradient(
        to right,
        var(--lumo-success-color-10pct) 10%,
        var(--lumo-success-color)
      );
    }
  `,
  { moduleId: "lumo-progress-bar" }
);
/**
 * @license
 * Copyright (c) 2017 - 2025 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const progressBarStyles = css`
  :host {
    display: block;
    width: 100%; /* prevent collapsing inside non-stretching column flex */
    height: 8px;
  }

  :host([hidden]) {
    display: none !important;
  }

  [part='bar'] {
    height: 100%;
  }

  [part='value'] {
    height: 100%;
    transform-origin: 0 50%;
    transform: scaleX(var(--vaadin-progress-value));
  }

  :host([dir='rtl']) [part='value'] {
    transform-origin: 100% 50%;
  }

  @media (forced-colors: active) {
    [part='bar'] {
      outline: 1px solid;
    }

    [part='value'] {
      background-color: AccentColor !important;
      forced-color-adjust: none;
    }
  }
`;
/**
 * @license
 * Copyright (c) 2017 - 2025 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const ProgressMixin = (superClass) => class VaadinProgressMixin extends superClass {
  static get properties() {
    return {
      /**
       * Current progress value.
       */
      value: {
        type: Number,
        observer: "_valueChanged"
      },
      /**
       * Minimum bound of the progress bar.
       * @type {number}
       */
      min: {
        type: Number,
        value: 0,
        observer: "_minChanged"
      },
      /**
       * Maximum bound of the progress bar.
       * @type {number}
       */
      max: {
        type: Number,
        value: 1,
        observer: "_maxChanged"
      },
      /**
       * Indeterminate state of the progress bar.
       * This property takes precedence over other state properties (min, max, value).
       * @type {boolean}
       */
      indeterminate: {
        type: Boolean,
        value: false,
        reflectToAttribute: true
      }
    };
  }
  static get observers() {
    return ["_normalizedValueChanged(value, min, max)"];
  }
  /** @protected */
  ready() {
    super.ready();
    this.setAttribute("role", "progressbar");
  }
  /** @private */
  _normalizedValueChanged(value, min, max) {
    const newNormalizedValue = this._normalizeValue(value, min, max);
    this.style.setProperty("--vaadin-progress-value", newNormalizedValue);
  }
  /** @private */
  _valueChanged(newV) {
    this.setAttribute("aria-valuenow", newV);
  }
  /** @private */
  _minChanged(newV) {
    this.setAttribute("aria-valuemin", newV);
  }
  /** @private */
  _maxChanged(newV) {
    this.setAttribute("aria-valuemax", newV);
  }
  /**
   * Percent of current progress relative to whole progress bar (max - min)
   * @private
   */
  _normalizeValue(value, min, max) {
    let nV;
    if (!value && value !== 0) {
      nV = 0;
    } else if (min >= max) {
      nV = 1;
    } else {
      nV = (value - min) / (max - min);
      nV = Math.min(Math.max(nV, 0), 1);
    }
    return nV;
  }
};
/**
 * @license
 * Copyright (c) 2017 - 2025 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
registerStyles$1("vaadin-progress-bar", progressBarStyles, { moduleId: "vaadin-progress-bar-styles" });
class ProgressBar extends ElementMixin(ThemableMixin(ProgressMixin(PolymerElement))) {
  static get is() {
    return "vaadin-progress-bar";
  }
  static get template() {
    return html`
      <div part="bar">
        <div part="value"></div>
      </div>
    `;
  }
}
defineCustomElement(ProgressBar);
registerStyles$1(
  "vaadin-radio-button",
  css`
    :host {
      color: var(--vaadin-radio-button-label-color, var(--lumo-body-text-color));
      font-size: var(--vaadin-radio-button-label-font-size, var(--lumo-font-size-m));
      font-family: var(--lumo-font-family);
      line-height: var(--lumo-line-height-s);
      -webkit-font-smoothing: antialiased;
      -moz-osx-font-smoothing: grayscale;
      -webkit-tap-highlight-color: transparent;
      -webkit-user-select: none;
      user-select: none;
      cursor: default;
      outline: none;
      --_radio-button-size: var(--vaadin-radio-button-size, calc(var(--lumo-size-m) / 2));
      --_focus-ring-color: var(--vaadin-focus-ring-color, var(--lumo-primary-color-50pct));
      --_focus-ring-width: var(--vaadin-focus-ring-width, 2px);
      --_selection-color: var(--vaadin-selection-color, var(--lumo-primary-color));
    }

    :host([has-label]) ::slotted(label) {
      padding: var(
        --vaadin-radio-button-label-padding,
        var(--lumo-space-xs) var(--lumo-space-s) var(--lumo-space-xs) var(--lumo-space-xs)
      );
    }

    [part='radio'] {
      width: var(--_radio-button-size);
      height: var(--_radio-button-size);
      margin: var(--lumo-space-xs);
      position: relative;
      border-radius: 50%;
      background: var(--vaadin-radio-button-background, var(--lumo-contrast-20pct));
      transition:
        transform 0.2s cubic-bezier(0.12, 0.32, 0.54, 2),
        background-color 0.15s;
      will-change: transform;
      cursor: var(--lumo-clickable-cursor);
      /* Default field border color */
      --_input-border-color: var(--vaadin-input-field-border-color, var(--lumo-contrast-50pct));
    }

    /* Used for activation "halo" */
    [part='radio']::before {
      pointer-events: none;
      color: transparent;
      width: 100%;
      height: 100%;
      line-height: var(--_radio-button-size);
      border-radius: inherit;
      background-color: inherit;
      transform: scale(1.4);
      opacity: 0;
      transition:
        transform 0.1s,
        opacity 0.8s;
      will-change: transform, opacity;
    }

    /* Used for the dot */
    [part='radio']::after {
      content: '';
      pointer-events: none;
      width: 0;
      height: 0;
      border: var(--vaadin-radio-button-dot-size, 3px) solid
        var(--vaadin-radio-button-dot-color, var(--lumo-primary-contrast-color));
      border-radius: 50%;
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%) scale(0);
      transition: 0.25s transform;
      will-change: transform;
      background-clip: content-box;
    }

    :host([checked]) {
      --vaadin-input-field-border-color: transparent;
    }

    :host([checked]) [part='radio'] {
      background-color: var(--_selection-color);
    }

    :host([checked]) [part='radio']::after {
      transform: translate(-50%, -50%) scale(1);
    }

    :host(:not([checked]):not([disabled]):hover) [part='radio'] {
      background: var(--vaadin-radio-button-background-hover, var(--lumo-contrast-30pct));
    }

    :host([active]) [part='radio'] {
      transform: scale(0.9);
      transition-duration: 0.05s;
    }

    :host([active][checked]) [part='radio'] {
      transform: scale(1.1);
    }

    :host([active]:not([checked])) [part='radio']::before {
      transition-duration: 0.01s, 0.01s;
      transform: scale(0);
      opacity: 0.4;
    }

    :host([focus-ring]) [part='radio'] {
      box-shadow:
        0 0 0 1px var(--lumo-base-color),
        0 0 0 calc(var(--_focus-ring-width) + 1px) var(--_focus-ring-color),
        inset 0 0 0 var(--_input-border-width, 0) var(--_input-border-color);
    }

    :host([disabled]) {
      pointer-events: none;
      color: var(--lumo-disabled-text-color);
      --vaadin-input-field-border-color: var(--lumo-contrast-20pct);
    }

    :host([disabled]) ::slotted(label) {
      color: inherit;
    }

    :host([disabled]) [part='radio'] {
      background-color: var(--vaadin-radio-button-disabled-background, var(--lumo-contrast-10pct));
    }

    :host([disabled]) [part='radio']::after {
      border-color: var(--vaadin-radio-button-disabled-dot-color, var(--lumo-contrast-30pct));
    }

    /* RTL specific styles */
    :host([dir='rtl'][has-label]) ::slotted(label) {
      padding: var(--lumo-space-xs) var(--lumo-space-xs) var(--lumo-space-xs) var(--lumo-space-s);
    }
  `,
  { moduleId: "lumo-radio-button" }
);
/**
 * @license
 * Copyright (c) 2017 - 2025 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const RadioButtonMixin = (superclass) => class RadioButtonMixinClass extends SlotStylesMixin(
  LabelMixin(CheckedMixin(DelegateFocusMixin(ActiveMixin(superclass))))
) {
  static get properties() {
    return {
      /**
       * The name of the radio button.
       *
       * @type {string}
       */
      name: {
        type: String,
        value: ""
      }
    };
  }
  /** @override */
  static get delegateAttrs() {
    return [...super.delegateAttrs, "name"];
  }
  constructor() {
    super();
    this._setType("radio");
    this.value = "on";
    this.tabindex = 0;
  }
  /** @protected */
  get slotStyles() {
    const tag = this.localName;
    return [
      `
          ${tag} > input[slot='input'] {
            opacity: 0;
          }
        `
    ];
  }
  /** @protected */
  ready() {
    super.ready();
    this.addController(
      new InputController(this, (input) => {
        this._setInputElement(input);
        this._setFocusElement(input);
        this.stateTarget = input;
        this.ariaTarget = input;
      })
    );
    this.addController(new LabelledInputController(this.inputElement, this._labelController));
  }
};
/**
 * @license
 * Copyright (c) 2017 - 2025 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const radioButtonStyles = css`
  :host {
    display: inline-block;
  }

  :host([hidden]) {
    display: none !important;
  }

  :host([disabled]) {
    -webkit-tap-highlight-color: transparent;
  }

  .vaadin-radio-button-container {
    display: grid;
    grid-template-columns: auto 1fr;
    align-items: baseline;
  }

  [part='radio'],
  ::slotted(input),
  ::slotted(label) {
    grid-row: 1;
  }

  [part='radio'],
  ::slotted(input) {
    grid-column: 1;
  }

  [part='radio'] {
    width: var(--vaadin-radio-button-size, 1em);
    height: var(--vaadin-radio-button-size, 1em);
    --_input-border-width: var(--vaadin-input-field-border-width, 0);
    --_input-border-color: var(--vaadin-input-field-border-color, transparent);
    box-shadow: inset 0 0 0 var(--_input-border-width, 0) var(--_input-border-color);
  }

  [part='radio']::before {
    display: block;
    content: '\\202F';
    line-height: var(--vaadin-radio-button-size, 1em);
    contain: paint;
  }

  /* visually hidden */
  ::slotted(input) {
    cursor: inherit;
    margin: 0;
    align-self: stretch;
    -webkit-appearance: none;
    width: initial;
    height: initial;
  }

  @media (forced-colors: active) {
    [part='radio'] {
      outline: 1px solid;
      outline-offset: -1px;
    }

    :host([focused]) [part='radio'] {
      outline-width: 2px;
    }

    :host([disabled]) [part='radio'] {
      outline-color: GrayText;
    }
  }
`;
/**
 * @license
 * Copyright (c) 2017 - 2025 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
registerStyles$1("vaadin-radio-button", radioButtonStyles, { moduleId: "vaadin-radio-button-styles" });
class RadioButton extends RadioButtonMixin(ElementMixin(ThemableMixin(ControllerMixin(PolymerElement)))) {
  static get is() {
    return "vaadin-radio-button";
  }
  static get template() {
    return html`
      <div class="vaadin-radio-button-container">
        <div part="radio" aria-hidden="true"></div>
        <slot name="input"></slot>
        <slot name="label"></slot>
      </div>
    `;
  }
}
defineCustomElement(RadioButton);
const radioGroup = css`
  :host {
    color: var(--lumo-body-text-color);
    font-size: var(--lumo-font-size-m);
    font-family: var(--lumo-font-family);
    -webkit-font-smoothing: antialiased;
    -moz-osx-font-smoothing: grayscale;
    -webkit-tap-highlight-color: transparent;
    padding: var(--lumo-space-xs) 0;
  }

  :host::before {
    /* Effective height of vaadin-radio-button */
    height: var(--lumo-size-s);
    box-sizing: border-box;
    display: inline-flex;
    align-items: center;
  }

  :host([theme~='vertical']) [part='group-field'] {
    flex-direction: column;
  }

  :host([disabled]) [part='label'] {
    color: var(--lumo-disabled-text-color);
    -webkit-text-fill-color: var(--lumo-disabled-text-color);
  }

  :host([focused]:not([readonly])) [part='label'] {
    color: var(--lumo-primary-text-color);
  }

  :host(:hover:not([readonly]):not([focused])) [part='label'],
  :host(:hover:not([readonly])) [part='helper-text'] {
    color: var(--lumo-body-text-color);
  }

  /* Touch device adjustment */
  @media (pointer: coarse) {
    :host(:hover:not([readonly]):not([focused])) [part='label'] {
      color: var(--lumo-secondary-text-color);
    }
  }
`;
registerStyles$1("vaadin-radio-group", [requiredField, helper, radioGroup], { moduleId: "lumo-radio-group" });
/**
 * @license
 * Copyright (c) 2017 - 2025 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const RadioGroupMixin = (superclass) => class RadioGroupMixinClass extends FieldMixin(FocusMixin(DisabledMixin(KeyboardMixin(superclass)))) {
  static get properties() {
    return {
      /**
       * The name of the control, which is submitted with the form data.
       */
      name: {
        type: String,
        observer: "__nameChanged",
        sync: true
      },
      /**
       * The value of the radio group.
       *
       * @type {string}
       */
      value: {
        type: String,
        notify: true,
        value: "",
        sync: true,
        observer: "__valueChanged"
      },
      /**
       * When present, the user cannot modify the value of the radio group.
       * The property works similarly to the `disabled` property.
       * While the `disabled` property disables all radio buttons inside the group,
       * the `readonly` property disables only unchecked ones.
       *
       * @type {boolean}
       */
      readonly: {
        type: Boolean,
        value: false,
        reflectToAttribute: true,
        sync: true,
        observer: "__readonlyChanged"
      },
      /**
       * @type {string}
       * @private
       */
      _fieldName: {
        type: String
      }
    };
  }
  constructor() {
    super();
    this.__registerRadioButton = this.__registerRadioButton.bind(this);
    this.__unregisterRadioButton = this.__unregisterRadioButton.bind(this);
    this.__onRadioButtonCheckedChange = this.__onRadioButtonCheckedChange.bind(this);
    this._tooltipController = new TooltipController(this);
    this._tooltipController.addEventListener("tooltip-changed", (event) => {
      const tooltip = event.detail.node;
      if (tooltip && tooltip.isConnected) {
        const inputs = this.__radioButtons.map((radio) => radio.inputElement);
        this._tooltipController.setAriaTarget(inputs);
      } else {
        this._tooltipController.setAriaTarget([]);
      }
    });
  }
  /**
   * A collection of the group's radio buttons.
   *
   * @return {!Array<!RadioButton>}
   * @private
   */
  get __radioButtons() {
    return this.__filterRadioButtons([...this.children]);
  }
  /**
   * A currently selected radio button.
   *
   * @return {!RadioButton | undefined}
   * @private
   */
  get __selectedRadioButton() {
    return this.__radioButtons.find((radioButton) => radioButton.checked);
  }
  /**
   * @return {boolean}
   * @private
   */
  get isHorizontalRTL() {
    return this.__isRTL && this._theme !== "vertical";
  }
  /** @protected */
  ready() {
    super.ready();
    this.ariaTarget = this;
    this.setAttribute("role", "radiogroup");
    this._fieldName = `${this.localName}-${generateUniqueId()}`;
    const slot = this.shadowRoot.querySelector("slot:not([name])");
    this._observer = new SlotObserver(slot, ({ addedNodes, removedNodes }) => {
      this.__filterRadioButtons(addedNodes).reverse().forEach(this.__registerRadioButton);
      this.__filterRadioButtons(removedNodes).forEach(this.__unregisterRadioButton);
      const inputs = this.__radioButtons.map((radio) => radio.inputElement);
      this._tooltipController.setAriaTarget(inputs);
    });
    this.addController(this._tooltipController);
  }
  /**
   * @param {!Array<!Node>} nodes
   * @return {!Array<!RadioButton>}
   * @private
   */
  __filterRadioButtons(nodes) {
    return nodes.filter((node) => node.nodeType === Node.ELEMENT_NODE && node.localName === "vaadin-radio-button");
  }
  /**
   * Override method inherited from `KeyboardMixin`
   * to implement the custom keyboard navigation as a replacement for the native one
   * in order for the navigation to work the same way across different browsers.
   *
   * @param {!KeyboardEvent} event
   * @override
   * @protected
   */
  _onKeyDown(event) {
    super._onKeyDown(event);
    const radioButton = event.composedPath().find((node) => node.nodeType === Node.ELEMENT_NODE && node.localName === "vaadin-radio-button");
    if (["ArrowLeft", "ArrowUp"].includes(event.key)) {
      event.preventDefault();
      this.__selectNextRadioButton(radioButton);
    }
    if (["ArrowRight", "ArrowDown"].includes(event.key)) {
      event.preventDefault();
      this.__selectPrevRadioButton(radioButton);
    }
  }
  /**
   * Override an observer from `FieldMixin`.
   *
   * @param {boolean} invalid
   * @protected
   * @override
   */
  _invalidChanged(invalid) {
    super._invalidChanged(invalid);
    if (invalid) {
      this.setAttribute("aria-invalid", "true");
    } else {
      this.removeAttribute("aria-invalid");
    }
  }
  /** @private */
  __nameChanged(name) {
    this.__radioButtons.forEach((radioButton) => {
      radioButton.name = name || this._fieldName;
    });
  }
  /**
   * @param {number} index
   * @private
   */
  __selectNextRadioButton(radioButton) {
    const index = this.__radioButtons.indexOf(radioButton);
    this.__selectIncRadioButton(index, this.isHorizontalRTL ? 1 : -1);
  }
  /**
   * @param {number} index
   * @private
   */
  __selectPrevRadioButton(radioButton) {
    const index = this.__radioButtons.indexOf(radioButton);
    this.__selectIncRadioButton(index, this.isHorizontalRTL ? -1 : 1);
  }
  /**
   * @param {number} index
   * @param {number} step
   * @private
   */
  __selectIncRadioButton(index, step) {
    const newIndex = (this.__radioButtons.length + index + step) % this.__radioButtons.length;
    const newRadioButton = this.__radioButtons[newIndex];
    if (newRadioButton.disabled) {
      this.__selectIncRadioButton(newIndex, step);
    } else {
      newRadioButton.focusElement.focus();
      newRadioButton.focusElement.click();
    }
  }
  /**
   * Registers the radio button after adding it to the group.
   *
   * @param {!RadioButton} radioButton
   * @private
   */
  __registerRadioButton(radioButton) {
    radioButton.name = this.name || this._fieldName;
    radioButton.addEventListener("checked-changed", this.__onRadioButtonCheckedChange);
    if (this.disabled || this.readonly) {
      radioButton.disabled = true;
    }
    if (radioButton.checked) {
      this.__selectRadioButton(radioButton);
    }
  }
  /**
   * Unregisters the radio button before removing it from the group.
   *
   * @param {!RadioButton} radioButton
   * @private
   */
  __unregisterRadioButton(radioButton) {
    radioButton.removeEventListener("checked-changed", this.__onRadioButtonCheckedChange);
    if (radioButton.value === this.value) {
      this.__selectRadioButton(null);
    }
  }
  /**
   * @param {!CustomEvent} event
   * @private
   */
  __onRadioButtonCheckedChange(event) {
    if (event.target.checked) {
      this.__selectRadioButton(event.target);
    }
  }
  /**
   * Whenever the user sets a non-empty value,
   * the method tries to select the radio button with that value
   * showing a warning if no radio button was found with the given value.
   * If the new value is empty, the method deselects the currently selected radio button.
   * At last, the method toggles the `has-value` attribute considering the new value.
   *
   * @param {string | null | undefined} newValue
   * @param {string | null | undefined} oldValue
   * @private
   */
  __valueChanged(newValue, oldValue) {
    if (oldValue === void 0 && newValue === "") {
      return;
    }
    if (newValue) {
      const newSelectedRadioButton = this.__radioButtons.find((radioButton) => {
        return radioButton.value === newValue;
      });
      if (newSelectedRadioButton) {
        this.__selectRadioButton(newSelectedRadioButton);
        this.toggleAttribute("has-value", true);
      } else {
        console.warn(`The radio button with the value "${newValue}" was not found.`);
      }
    } else {
      this.__selectRadioButton(null);
      this.removeAttribute("has-value");
    }
    if (oldValue !== void 0) {
      this._requestValidation();
    }
  }
  /**
   * Whenever `readonly` property changes on the group element,
   * the method updates the `disabled` property for the radio buttons.
   *
   * @param {boolean} newValue
   * @param {boolean} oldValue
   * @private
   */
  __readonlyChanged(newValue, oldValue) {
    if (!newValue && oldValue === void 0) {
      return;
    }
    if (oldValue !== newValue) {
      this.__updateRadioButtonsDisabledProperty();
    }
  }
  /**
   * Override method inherited from `DisabledMixin`
   * to update the `disabled` property for the radio buttons
   * whenever the property changes on the group element.
   *
   * @param {boolean} newValue
   * @param {boolean} oldValue
   * @override
   * @protected
   */
  _disabledChanged(newValue, oldValue) {
    super._disabledChanged(newValue, oldValue);
    if (!newValue && oldValue === void 0) {
      return;
    }
    if (oldValue !== newValue) {
      this.__updateRadioButtonsDisabledProperty();
    }
  }
  /**
   * Override method inherited from `FocusMixin`
   * to prevent removing the `focused` attribute
   * when focus moves between radio buttons inside the group.
   *
   * @param {!FocusEvent} event
   * @return {boolean}
   * @protected
   */
  _shouldRemoveFocus(event) {
    return !this.contains(event.relatedTarget);
  }
  /**
   * Override method inherited from `FocusMixin`
   * to run validation when the group loses focus.
   *
   * @param {boolean} focused
   * @override
   * @protected
   */
  _setFocused(focused) {
    super._setFocused(focused);
    if (!focused && document.hasFocus()) {
      this._requestValidation();
    }
  }
  /**
   * @param {RadioButton} radioButton
   * @private
   */
  __selectRadioButton(radioButton) {
    if (radioButton) {
      this.value = radioButton.value;
    } else {
      this.value = "";
    }
    this.__radioButtons.forEach((button2) => {
      button2.checked = button2 === radioButton;
    });
    if (this.readonly) {
      this.__updateRadioButtonsDisabledProperty();
    }
  }
  /**
   * If the group is read-only, the method disables the unchecked radio buttons.
   * Otherwise, the method propagates the group's `disabled` property to the radio buttons.
   *
   * @private
   */
  __updateRadioButtonsDisabledProperty() {
    this.__radioButtons.forEach((button2) => {
      if (this.readonly) {
        button2.disabled = button2 !== this.__selectedRadioButton;
      } else {
        button2.disabled = this.disabled;
      }
    });
  }
};
/**
 * @license
 * Copyright (c) 2017 - 2025 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const radioGroupStyles = css`
  :host {
    display: inline-flex;
  }

  :host::before {
    content: '\\2003';
    width: 0;
    display: inline-block;
  }

  :host([hidden]) {
    display: none !important;
  }

  .vaadin-group-field-container {
    display: flex;
    flex-direction: column;
    width: 100%;
  }

  [part='group-field'] {
    display: flex;
    flex-wrap: wrap;
  }

  :host(:not([has-label])) [part='label'] {
    display: none;
  }
`;
/**
 * @license
 * Copyright (c) 2017 - 2025 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
registerStyles$1("vaadin-radio-group", radioGroupStyles, { moduleId: "vaadin-radio-group-styles" });
class RadioGroup extends RadioGroupMixin(ElementMixin(ThemableMixin(PolymerElement))) {
  static get is() {
    return "vaadin-radio-group";
  }
  static get template() {
    return html`
      <div class="vaadin-group-field-container">
        <div part="label">
          <slot name="label"></slot>
          <span part="required-indicator" aria-hidden="true"></span>
        </div>

        <div part="group-field">
          <slot></slot>
        </div>

        <div part="helper-text">
          <slot name="helper"></slot>
        </div>

        <div part="error-message">
          <slot name="error-message"></slot>
        </div>
      </div>

      <slot name="tooltip"></slot>
    `;
  }
}
defineCustomElement(RadioGroup);
function stateReducer(state, action) {
  switch (action.type) {
    case "stateKeyChanged":
      const { value } = action;
      return {
        ...state,
        key: value
      };
    default:
      return state;
  }
}
const emptyAction = () => {
};
class ReactAdapterElement extends HTMLElement {
  #root = void 0;
  #rootRendered = false;
  #rendering = void 0;
  #state = /* @__PURE__ */ Object.create(null);
  #stateSetters = /* @__PURE__ */ new Map();
  #customEvents = /* @__PURE__ */ new Map();
  #dispatchFlowState = emptyAction;
  #readyCallback = /* @__PURE__ */ new Map();
  #renderHooks;
  #Wrapper;
  #unmounting;
  constructor() {
    super();
    this.#renderHooks = {
      useState: this.useState.bind(this),
      useCustomEvent: this.useCustomEvent.bind(this),
      useContent: this.useContent.bind(this)
    };
    this.#Wrapper = this.#renderWrapper.bind(this);
    this.#markAsUsed();
  }
  async connectedCallback() {
    this.#rendering = /* @__PURE__ */ reactExports.createElement(this.#Wrapper);
    const createNewRoot = this.dispatchEvent(
      new CustomEvent("flow-portal-add", {
        bubbles: true,
        cancelable: true,
        composed: true,
        detail: {
          children: this.#rendering,
          domNode: this
        }
      })
    );
    if (!createNewRoot || this.#root) {
      return;
    }
    await this.#unmounting;
    this.#root = clientExports.createRoot(this);
    this.#maybeRenderRoot();
    this.#root.render(this.#rendering);
  }
  /**
   * Add a callback for specified element identifier to be called when
   * react element is ready.
   * <p>
   * For internal use only. May be renamed or removed in a future release.
   *
   * @param id element identifier that callback is for
   * @param readyCallback callback method to be informed on element ready state
   * @internal
   */
  addReadyCallback(id, readyCallback) {
    this.#readyCallback.set(id, readyCallback);
  }
  async disconnectedCallback() {
    if (!this.#root) {
      this.dispatchEvent(
        new CustomEvent("flow-portal-remove", {
          bubbles: true,
          cancelable: true,
          composed: true,
          detail: {
            children: this.#rendering,
            domNode: this
          }
        })
      );
    } else {
      this.#unmounting = Promise.resolve();
      await this.#unmounting;
      this.#root.unmount();
      this.#root = void 0;
    }
    this.#rootRendered = false;
    this.#rendering = void 0;
  }
  /**
   * A hook API for using stateful JS properties of the Web Component from
   * the React `render()`.
   *
   * @typeParam T - Type of the state value
   *
   * @param key - Web Component property name, which is used for two-way
   * value propagation from the server and back.
   * @param initialValue - Fallback initial value (optional). Only applies if
   * the Java component constructor does not invoke `setState`.
   * @returns A tuple with two values:
   * 1. The current state.
   * 2. The `set` function for changing the state and triggering render
   * @protected
   */
  useState(key, initialValue) {
    if (this.#stateSetters.has(key)) {
      return [this.#state[key], this.#stateSetters.get(key)];
    }
    const value = this[key] ?? initialValue;
    this.#state[key] = value;
    Object.defineProperty(this, key, {
      enumerable: true,
      get() {
        return this.#state[key];
      },
      set(nextValue) {
        this.#state[key] = nextValue;
        this.#dispatchFlowState({ type: "stateKeyChanged", key, value });
      }
    });
    const dispatchChangedEvent = this.useCustomEvent(`${key}-changed`, { detail: { value } });
    const setValue = (value2) => {
      this.#state[key] = value2;
      dispatchChangedEvent({ value: value2 });
      this.#dispatchFlowState({ type: "stateKeyChanged", key, value: value2 });
    };
    this.#stateSetters.set(key, setValue);
    return [value, setValue];
  }
  /**
   * A hook helper to simplify dispatching a `CustomEvent` on the Web
   * Component from React.
   *
   * @typeParam T - The type for `event.detail` value (optional).
   *
   * @param type - The `CustomEvent` type string.
   * @param options - The settings for the `CustomEvent`.
   * @returns The `dispatch` function. The function parameters change
   * depending on the `T` generic type:
   * - For `undefined` type (default), has no parameters.
   * - For other types, has one parameter for the `event.detail` value of that type.
   * @protected
   */
  useCustomEvent(type, options = {}) {
    if (!this.#customEvents.has(type)) {
      const dispatch = ((detail) => {
        const eventInitDict = detail === void 0 ? options : {
          ...options,
          detail
        };
        const event = new CustomEvent(type, eventInitDict);
        return this.dispatchEvent(event);
      });
      this.#customEvents.set(type, dispatch);
      return dispatch;
    }
    return this.#customEvents.get(type);
  }
  /**
   * Prepare content container for Flow to bind server Element to.
   *
   * @param name container name attribute matching server name attribute
   * @protected
   */
  useContent(name) {
    reactExports.useEffect(() => {
      this.#readyCallback.get(name)?.();
    }, []);
    return /* @__PURE__ */ reactExports.createElement("flow-content-container", { name, style: { display: "contents" } });
  }
  #maybeRenderRoot() {
    if (this.#rootRendered || !this.#root) {
      return;
    }
    this.#root.render(/* @__PURE__ */ reactExports.createElement(this.#Wrapper));
    this.#rootRendered = true;
  }
  #renderWrapper() {
    const [state, dispatchFlowState] = reactExports.useReducer(stateReducer, this.#state);
    this.#state = state;
    this.#dispatchFlowState = dispatchFlowState;
    return this.render(this.#renderHooks);
  }
  #markAsUsed() {
    let vaadinObject = window.Vaadin || {};
    if (vaadinObject.developmentMode) {
      vaadinObject.registrations = vaadinObject.registrations || [];
      vaadinObject.registrations.push({
        is: "ReactAdapterElement",
        version: "24.7.12"
      });
    }
  }
}
var _jsxFileName = "C:\\Users\\giova\\Desktop\\Developing\\sitiMiei\\sitoVetrinaJmix\\src\\main\\frontend\\generated\\jar-resources\\ReactRouterOutletElement.tsx";
class ReactRouterOutletElement extends ReactAdapterElement {
  async connectedCallback() {
    await super.connectedCallback();
    this.style.display = "contents";
  }
  render() {
    return jsxDEV(Outlet, {}, void 0, false, { fileName: _jsxFileName, lineNumber: 12, columnNumber: 12 }, this);
  }
}
customElements.define("react-router-outlet", ReactRouterOutletElement);
/**
 * @license
 * Copyright (c) 2017 - 2025 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
registerStyles$1("vaadin-select-item", item, { moduleId: "lumo-select-item" });
registerStyles$1("vaadin-select-list-box", listBox, { moduleId: "lumo-select-list-box" });
const select = css`
  :host {
    /* Disable pointer focus-ring for select, not supported yet */
    --lumo-input-field-pointer-focus-visible: 0;
  }

  :host(:not([theme*='align'])) ::slotted([slot='value']) {
    text-align: start;
  }

  [part='input-field'] {
    cursor: var(--lumo-clickable-cursor);
  }

  [part='input-field'] ::slotted([slot='value']) {
    font-weight: var(--vaadin-input-field-value-font-weight, 500);
  }

  [part='input-field'] ::slotted([slot='value']:not([placeholder])) {
    color: var(--vaadin-input-field-value-color, var(--lumo-body-text-color));
  }

  :host([readonly]) [part='input-field'] ::slotted([slot='value']:not([placeholder])) {
    color: var(--lumo-secondary-text-color);
  }

  /* placeholder styles */
  [part='input-field'] ::slotted([slot='value'][placeholder]) {
    color: var(--vaadin-input-field-placeholder-color, var(--lumo-secondary-text-color));
  }

  :host(:is([readonly], [disabled])) ::slotted([slot='value'][placeholder]) {
    opacity: 0;
  }

  [part='toggle-button']::before {
    content: var(--lumo-icons-dropdown);
  }

  /* Highlight the toggle button when hovering over the entire component */
  :host(:hover:not([readonly]):not([disabled])) [part='toggle-button'] {
    color: var(--lumo-contrast-80pct);
  }

  :host([theme~='small']) [part='input-field'] ::slotted([slot='value']) {
    --_lumo-selected-item-height: var(--lumo-size-s);
    --_lumo-selected-item-padding: 0;
  }
`;
registerStyles$1("vaadin-select", [inputFieldShared$1, select], { moduleId: "lumo-select" });
registerStyles$1(
  "vaadin-select-value-button",
  css`
    :host {
      font-family: var(--lumo-font-family);
      font-size: var(--vaadin-input-field-value-font-size, var(--lumo-font-size-m));
      padding: 0 0.25em;
      --_lumo-selected-item-height: var(--lumo-size-m);
      --_lumo-selected-item-padding: 0.5em;
    }

    ::slotted(*) {
      min-height: var(--_lumo-selected-item-height);
      padding-top: var(--_lumo-selected-item-padding);
      padding-bottom: var(--_lumo-selected-item-padding);
      font-size: inherit;
    }

    ::slotted(*:hover) {
      background-color: transparent;
    }
  `,
  { moduleId: "lumo-select-value-button" }
);
const selectOverlay = css`
  :host {
    --_lumo-item-selected-icon-display: block;
  }

  /* Small viewport adjustment */
  :host([phone]) {
    /* stylelint-disable declaration-block-no-redundant-longhand-properties */
    top: 0 !important;
    right: 0 !important;
    bottom: var(--vaadin-overlay-viewport-bottom, 0) !important;
    left: 0 !important;
    /* stylelint-enable declaration-block-no-redundant-longhand-properties */
    align-items: stretch;
    justify-content: flex-end;
  }

  :host([no-vertical-overlap][top-aligned]) [part='overlay'] {
    margin-block-start: var(--lumo-space-xs);
  }

  :host([no-vertical-overlap][bottom-aligned]) [part='overlay'] {
    margin-block-end: var(--lumo-space-xs);
  }

  :host([theme~='align-left']) {
    text-align: left;
  }

  :host([theme~='align-right']) {
    text-align: right;
  }

  :host([theme~='align-center']) {
    text-align: center;
  }
`;
registerStyles$1("vaadin-select-overlay", [menuOverlay, selectOverlay], { moduleId: "lumo-select-overlay" });
/**
 * @license
 * Copyright (c) 2017 - 2025 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
class SelectItem extends ItemMixin(ThemableMixin(DirMixin(PolymerElement))) {
  static get is() {
    return "vaadin-select-item";
  }
  static get template() {
    return html`
      <style>
        :host {
          display: inline-block;
        }

        :host([hidden]) {
          display: none !important;
        }
      </style>
      <span part="checkmark" aria-hidden="true"></span>
      <div part="content">
        <slot></slot>
      </div>
    `;
  }
  /** @protected */
  ready() {
    super.ready();
    this.setAttribute("role", "option");
  }
}
defineCustomElement(SelectItem);
/**
 * @license
 * Copyright (c) 2017 - 2025 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
class SelectListBox extends ListMixin(ThemableMixin(DirMixin(ControllerMixin(PolymerElement)))) {
  static get is() {
    return "vaadin-select-list-box";
  }
  static get template() {
    return html`
      <style>
        :host {
          display: flex;
        }

        :host([hidden]) {
          display: none !important;
        }

        [part='items'] {
          height: 100%;
          width: 100%;
          overflow-y: auto;
          -webkit-overflow-scrolling: touch;
        }
      </style>
      <div part="items">
        <slot></slot>
      </div>
    `;
  }
  static get properties() {
    return {
      // We don't need to define this property since super default is vertical,
      // but we don't want it to be modified, or be shown in the API docs.
      /** @private */
      orientation: {
        readOnly: true
      }
    };
  }
  /**
   * @return {!HTMLElement}
   * @protected
   * @override
   */
  get _scrollerElement() {
    return this.shadowRoot.querySelector('[part="items"]');
  }
  /** @protected */
  ready() {
    super.ready();
    this.setAttribute("role", "listbox");
  }
}
defineCustomElement(SelectListBox);
/**
 * @license
 * Copyright (c) 2017 - 2025 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const SelectOverlayMixin = (superClass) => class SelectOverlayMixin extends PositionMixin(OverlayMixin(DirMixin(superClass))) {
  static get observers() {
    return ["_updateOverlayWidth(opened, owner)"];
  }
  /** @protected */
  ready() {
    super.ready();
    this.restoreFocusOnClose = true;
  }
  /**
   * Override method inherited from `Overlay` to always close on outside click,
   * in order to avoid problem when using inside of the modeless dialog.
   *
   * @param {Event} event
   * @return {boolean}
   * @protected
   */
  _shouldCloseOnOutsideClick(_event) {
    return true;
  }
  /** @protected */
  _getMenuElement() {
    return Array.from(this.children).find((el) => el.localName !== "style");
  }
  /** @private */
  _updateOverlayWidth(opened, owner) {
    if (opened && owner) {
      const widthProperty = "--vaadin-select-overlay-width";
      const customWidth = getComputedStyle(owner).getPropertyValue(widthProperty);
      if (customWidth === "") {
        this.style.removeProperty(widthProperty);
      } else {
        this.style.setProperty(widthProperty, customWidth);
      }
    }
  }
  requestContentUpdate() {
    super.requestContentUpdate();
    if (this.owner) {
      const menuElement = this._getMenuElement();
      this.owner._assignMenuElement(menuElement);
    }
  }
};
/**
 * @license
 * Copyright (c) 2017 - 2025 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const selectOverlayStyles = css`
  :host {
    align-items: flex-start;
    justify-content: flex-start;
  }

  :host(:not([phone])) [part='overlay'] {
    min-width: var(--vaadin-select-overlay-width, var(--vaadin-select-text-field-width));
  }

  @media (forced-colors: active) {
    [part='overlay'] {
      outline: 3px solid;
    }
  }
`;
registerStyles$1("vaadin-select-overlay", [overlayStyles, selectOverlayStyles], {
  moduleId: "vaadin-select-overlay-styles"
});
class SelectOverlay extends SelectOverlayMixin(ThemableMixin(PolymerElement)) {
  static get is() {
    return "vaadin-select-overlay";
  }
  static get template() {
    return html`
      <div id="backdrop" part="backdrop" hidden$="[[!withBackdrop]]"></div>
      <div part="overlay" id="overlay" tabindex="0">
        <div part="content" id="content">
          <slot></slot>
        </div>
      </div>
    `;
  }
}
defineCustomElement(SelectOverlay);
/**
 * @license
 * Copyright (c) 2017 - 2025 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const valueButton = css`
  :host {
    display: inline-block;
    position: relative;
    outline: none;
    white-space: nowrap;
    -webkit-user-select: none;
    user-select: none;
    min-width: 0;
    width: 0;
  }

  ::slotted(*) {
    padding-left: 0;
    padding-right: 0;
    flex: auto;
  }

  /* placeholder styles */
  ::slotted(*:not([selected])) {
    line-height: 1;
  }

  .vaadin-button-container {
    display: inline-flex;
    align-items: center;
    justify-content: center;
    text-align: inherit;
    width: 100%;
    height: 100%;
    min-height: inherit;
    text-shadow: inherit;
  }

  [part='label'] {
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
    width: 100%;
    line-height: inherit;
  }
`;
/**
 * @license
 * Copyright (c) 2017 - 2025 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
registerStyles$1("vaadin-select-value-button", valueButton, { moduleId: "vaadin-select-value-button-styles" });
class SelectValueButton extends ButtonMixin(ThemableMixin(PolymerElement)) {
  static get is() {
    return "vaadin-select-value-button";
  }
  static get template() {
    return html`
      <div class="vaadin-button-container">
        <span part="label">
          <slot></slot>
        </span>
      </div>
    `;
  }
}
defineCustomElement(SelectValueButton);
/**
 * @license
 * Copyright (c) 2021 - 2025 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const screenReaderOnly = css`
  .sr-only {
    border: 0 !important;
    clip: rect(1px, 1px, 1px, 1px) !important;
    -webkit-clip-path: inset(50%) !important;
    clip-path: inset(50%) !important;
    height: 1px !important;
    margin: -1px !important;
    overflow: hidden !important;
    padding: 0 !important;
    position: absolute !important;
    width: 1px !important;
    white-space: nowrap !important;
  }
`;
/**
 * @license
 * Copyright (c) 2023 - 2025 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
class ButtonController extends SlotController {
  constructor(host) {
    super(host, "value", "vaadin-select-value-button", {
      initializer: (button2, host2) => {
        host2._setFocusElement(button2);
        host2.ariaTarget = button2;
        host2.stateTarget = button2;
        button2.setAttribute("aria-haspopup", "listbox");
      }
    });
  }
}
/**
 * @license
 * Copyright (c) 2017 - 2025 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const SelectBaseMixin = (superClass) => class SelectBaseMixin extends OverlayClassMixin(
  DelegateFocusMixin(DelegateStateMixin(KeyboardMixin(FieldMixin(superClass))))
) {
  static get properties() {
    return {
      /**
       * An array containing items that will be rendered as the options of the select.
       *
       * #### Example
       * ```js
       * select.items = [
       *   { label: 'Most recent first', value: 'recent' },
       *   { component: 'hr' },
       *   { label: 'Rating: low to high', value: 'rating-asc', className: 'asc' },
       *   { label: 'Rating: high to low', value: 'rating-desc', className: 'desc' },
       *   { component: 'hr' },
       *   { label: 'Price: low to high', value: 'price-asc', disabled: true },
       *   { label: 'Price: high to low', value: 'price-desc', disabled: true }
       * ];
       * ```
       *
       * Note: each item is rendered by default as the internal `<vaadin-select-item>` that is an extension of `<vaadin-item>`.
       * To render the item with a custom component, provide a tag name by the `component` property.
       *
       * @type {!Array<!SelectItem>}
       */
      items: {
        type: Array,
        observer: "__itemsChanged"
      },
      /**
       * Set when the select is open
       * @type {boolean}
       */
      opened: {
        type: Boolean,
        value: false,
        notify: true,
        reflectToAttribute: true,
        sync: true
      },
      /**
       * Custom function for rendering the content of the `<vaadin-select>`.
       * Receives two arguments:
       *
       * - `root` The `<vaadin-select-overlay>` internal container
       *   DOM element. Append your content to it.
       * - `select` The reference to the `<vaadin-select>` element.
       * @type {!SelectRenderer | undefined}
       */
      renderer: {
        type: Object
      },
      /**
       * The `value` property of the selected item, or an empty string
       * if no item is selected.
       * On change or initialization, the component finds the item which matches the
       * value and displays it.
       * If no value is provided to the component, it selects the first item without
       * value or empty value.
       * Hint: If you do not want to select any item by default, you can either set all
       * the values of inner vaadin-items, or set the vaadin-select value to
       * an inexistent value in the items list.
       * @type {string}
       */
      value: {
        type: String,
        value: "",
        notify: true,
        observer: "_valueChanged",
        sync: true
      },
      /**
       * The name of this element.
       */
      name: {
        type: String
      },
      /**
       * A hint to the user of what can be entered in the control.
       * The placeholder will be displayed in the case that there
       * is no item selected, or the selected item has an empty
       * string label, or the selected item has no label and it's
       * DOM content is empty.
       */
      placeholder: {
        type: String
      },
      /**
       * When present, it specifies that the element is read-only.
       * @type {boolean}
       */
      readonly: {
        type: Boolean,
        value: false,
        reflectToAttribute: true
      },
      /**
       * Defines whether the overlay should overlap the target element
       * in the y-axis, or be positioned right above/below it.
       *
       * @attr {boolean} no-vertical-overlap
       */
      noVerticalOverlap: {
        type: Boolean,
        value: false
      },
      /** @private */
      _phone: Boolean,
      /** @private */
      _phoneMediaQuery: {
        value: "(max-width: 450px), (max-height: 450px)"
      },
      /** @private */
      _inputContainer: Object,
      /** @private */
      _items: Object
    };
  }
  static get delegateAttrs() {
    return [...super.delegateAttrs, "invalid"];
  }
  static get observers() {
    return [
      "_updateAriaExpanded(opened, focusElement)",
      "_updateSelectedItem(value, _items, placeholder)",
      "_openedChanged(opened, _overlayElement)"
    ];
  }
  constructor() {
    super();
    this._itemId = `value-${this.localName}-${generateUniqueId()}`;
    this._srLabelController = new LabelController(this);
    this._srLabelController.slotName = "sr-label";
  }
  /** @protected */
  disconnectedCallback() {
    super.disconnectedCallback();
    this.opened = false;
  }
  /** @protected */
  ready() {
    super.ready();
    this._inputContainer = this.shadowRoot.querySelector('[part~="input-field"]');
    this._overlayElement = this.$.overlay;
    this._valueButtonController = new ButtonController(this);
    this.addController(this._valueButtonController);
    this.addController(this._srLabelController);
    this.addController(
      new MediaQueryController(this._phoneMediaQuery, (matches2) => {
        this._phone = matches2;
      })
    );
    this._tooltipController = new TooltipController(this);
    this._tooltipController.setPosition("top");
    this._tooltipController.setAriaTarget(this.focusElement);
    this.addController(this._tooltipController);
  }
  /**
   * Requests an update for the content of the select.
   * While performing the update, it invokes the renderer passed in the `renderer` property.
   *
   * It is not guaranteed that the update happens immediately (synchronously) after it is requested.
   */
  requestContentUpdate() {
    if (!this._overlayElement) {
      return;
    }
    this._overlayElement.requestContentUpdate();
    if (this._menuElement && this._menuElement.items) {
      this._updateSelectedItem(this.value, this._menuElement.items);
    }
  }
  /**
   * Override an observer from `FieldMixin`
   * to validate when required is removed.
   *
   * @protected
   * @override
   */
  _requiredChanged(required) {
    super._requiredChanged(required);
    if (required === false) {
      this._requestValidation();
    }
  }
  /**
   * @param {SelectItem[] | undefined | null} newItems
   * @param {SelectItem[] | undefined | null} oldItems
   * @private
   */
  __itemsChanged(newItems, oldItems) {
    if (newItems || oldItems) {
      this.requestContentUpdate();
    }
  }
  /**
   * @param {HTMLElement} menuElement
   * @protected
   */
  _assignMenuElement(menuElement) {
    if (menuElement && menuElement !== this.__lastMenuElement) {
      this._menuElement = menuElement;
      this.__initMenuItems(menuElement);
      menuElement.addEventListener("items-changed", () => {
        this.__initMenuItems(menuElement);
      });
      menuElement.addEventListener("selected-changed", () => this.__updateValueButton());
      menuElement.addEventListener("keydown", (e2) => this._onKeyDownInside(e2), true);
      menuElement.addEventListener(
        "click",
        (e2) => {
          const item2 = e2.composedPath().find((el) => el._hasVaadinItemMixin);
          this.__dispatchChangePending = Boolean(item2 && item2.value !== void 0 && item2.value !== this.value);
          this.opened = false;
        },
        true
      );
      this.__lastMenuElement = menuElement;
    }
  }
  /** @private */
  __initMenuItems(menuElement) {
    if (menuElement.items) {
      this._items = menuElement.items;
    }
  }
  /** @private */
  _valueChanged(value, oldValue) {
    this.toggleAttribute("has-value", Boolean(value));
    if (oldValue !== void 0 && !this.__dispatchChangePending) {
      this._requestValidation();
    }
  }
  /**
   * Opens the overlay if the field is not read-only.
   *
   * @private
   */
  _onClick(event) {
    if (this.disabled) {
      return;
    }
    event.preventDefault();
    this.opened = !this.readonly;
  }
  /** @private */
  _onToggleMouseDown(event) {
    event.preventDefault();
    if (!this.opened) {
      this.focusElement.focus();
    }
  }
  /**
   * @param {!KeyboardEvent} e
   * @protected
   * @override
   */
  _onKeyDown(e2) {
    if (e2.target === this.focusElement && !this.readonly && !this.disabled && !this.opened) {
      if (/^(Enter|SpaceBar|\s|ArrowDown|Down|ArrowUp|Up)$/u.test(e2.key)) {
        e2.preventDefault();
        this.opened = true;
      } else if (/[\p{L}\p{Nd}]/u.test(e2.key) && e2.key.length === 1) {
        const selected = this._menuElement.selected;
        const currentIdx = selected !== void 0 ? selected : -1;
        const newIdx = this._menuElement._searchKey(currentIdx, e2.key);
        if (newIdx >= 0) {
          this.__dispatchChangePending = true;
          this._updateAriaLive(true);
          this._menuElement.selected = newIdx;
        }
      }
    }
  }
  /**
   * @param {!KeyboardEvent} e
   * @protected
   */
  _onKeyDownInside(e2) {
    if (/^(Tab)$/u.test(e2.key)) {
      this.opened = false;
    }
  }
  /** @private */
  _openedChanged(opened, overlayElement) {
    if (!overlayElement) {
      return;
    }
    if (opened) {
      if (this.disabled || this.readonly) {
        this.opened = false;
        return;
      }
      this._updateAriaLive(false);
      overlayElement.style.setProperty("--vaadin-select-text-field-width", `${this._inputContainer.offsetWidth}px`);
      const hasFocusRing = this.hasAttribute("focus-ring");
      this._openedWithFocusRing = hasFocusRing;
      if (hasFocusRing) {
        this.removeAttribute("focus-ring");
      }
    } else if (this.__oldOpened) {
      if (this._openedWithFocusRing) {
        this.setAttribute("focus-ring", "");
      }
      if (!this.__dispatchChangePending && !this._keyboardActive) {
        this._requestValidation();
      }
    }
    this.__oldOpened = opened;
  }
  /** @private */
  _updateAriaExpanded(opened, focusElement) {
    if (focusElement) {
      focusElement.setAttribute("aria-expanded", opened ? "true" : "false");
    }
  }
  /** @private */
  _updateAriaLive(ariaLive) {
    if (this.focusElement) {
      if (ariaLive) {
        this.focusElement.setAttribute("aria-live", "polite");
      } else {
        this.focusElement.removeAttribute("aria-live");
      }
    }
  }
  /** @private */
  __attachSelectedItem(selected) {
    let labelItem;
    const label = selected.getAttribute("label");
    if (label) {
      labelItem = this.__createItemElement({ label });
    } else {
      labelItem = selected.cloneNode(true);
    }
    labelItem._sourceItem = selected;
    this.__appendValueItemElement(labelItem, this.focusElement);
    labelItem.selected = true;
  }
  /**
   * @param {!SelectItem} item
   * @private
   */
  __createItemElement(item2) {
    const itemElement = document.createElement(item2.component || "vaadin-select-item");
    if (item2.label) {
      itemElement.textContent = item2.label;
    }
    if (item2.value) {
      itemElement.value = item2.value;
    }
    if (item2.disabled) {
      itemElement.disabled = item2.disabled;
    }
    if (item2.className) {
      itemElement.className = item2.className;
    }
    return itemElement;
  }
  /**
   * @param {!HTMLElement} itemElement
   * @param {!HTMLElement} parent
   * @private
   */
  __appendValueItemElement(itemElement, parent) {
    parent.appendChild(itemElement);
    itemElement.removeAttribute("tabindex");
    itemElement.removeAttribute("aria-selected");
    itemElement.removeAttribute("role");
    itemElement.removeAttribute("focused");
    itemElement.removeAttribute("focus-ring");
    itemElement.removeAttribute("active");
    itemElement.setAttribute("id", this._itemId);
  }
  /**
   * @param {string} accessibleName
   * @protected
   */
  _accessibleNameChanged(accessibleName) {
    this._srLabelController.setLabel(accessibleName);
    this._setCustomAriaLabelledBy(accessibleName ? this._srLabelController.defaultId : null);
  }
  /**
   * @param {string} accessibleNameRef
   * @protected
   */
  _accessibleNameRefChanged(accessibleNameRef) {
    this._setCustomAriaLabelledBy(accessibleNameRef);
  }
  /**
   * @param {string} ariaLabelledby
   * @private
   */
  _setCustomAriaLabelledBy(ariaLabelledby) {
    const labelId = this._getLabelIdWithItemId(ariaLabelledby);
    this._fieldAriaController.setLabelId(labelId, true);
  }
  /**
   * @param {string | null} labelId
   * @returns string | null
   * @private
   */
  _getLabelIdWithItemId(labelId) {
    const selected = this._items ? this._items[this._menuElement.selected] : false;
    const itemId = selected || this.placeholder ? this._itemId : "";
    return labelId ? `${labelId} ${itemId}`.trim() : null;
  }
  /** @private */
  __updateValueButton() {
    const valueButton2 = this.focusElement;
    if (!valueButton2) {
      return;
    }
    valueButton2.innerHTML = "";
    const selected = this._items[this._menuElement.selected];
    valueButton2.removeAttribute("placeholder");
    if (this._hasContent(selected)) {
      this.__attachSelectedItem(selected);
    } else if (this.placeholder) {
      const item2 = this.__createItemElement({ label: this.placeholder });
      this.__appendValueItemElement(item2, valueButton2);
      valueButton2.setAttribute("placeholder", "");
    }
    if (!this._valueChanging && selected) {
      this._selectedChanging = true;
      this.value = selected.value || "";
      if (this.__dispatchChangePending) {
        this.__dispatchChange();
      }
      delete this._selectedChanging;
    }
    const labelledIdReferenceConfig = selected || this.placeholder ? { newId: this._itemId } : { oldId: this._itemId };
    setAriaIDReference(valueButton2, "aria-labelledby", labelledIdReferenceConfig);
    if (this.accessibleName || this.accessibleNameRef) {
      this._setCustomAriaLabelledBy(this.accessibleNameRef || this._srLabelController.defaultId);
    }
  }
  /** @private */
  _hasContent(item2) {
    if (!item2) {
      return false;
    }
    const hasText = Boolean(item2.hasAttribute("label") ? item2.getAttribute("label") : item2.textContent.trim());
    const hasChildren = item2.childElementCount > 0;
    return hasText || hasChildren;
  }
  /** @private */
  _updateSelectedItem(value, items) {
    if (items) {
      const valueAsString = value == null ? value : value.toString();
      this._menuElement.selected = items.reduce((prev, item2, idx) => {
        return prev === void 0 && item2.value === valueAsString ? idx : prev;
      }, void 0);
      if (!this._selectedChanging) {
        this._valueChanging = true;
        this.__updateValueButton();
        delete this._valueChanging;
      }
    }
  }
  /**
   * Override method inherited from `FocusMixin` to not remove focused
   * state when select is opened and focus moves to list-box.
   * @return {boolean}
   * @protected
   * @override
   */
  _shouldRemoveFocus() {
    return !this.opened;
  }
  /**
   * Override method inherited from `FocusMixin` to validate on blur.
   * @param {boolean} focused
   * @protected
   * @override
   */
  _setFocused(focused) {
    super._setFocused(focused);
    if (!focused && document.hasFocus()) {
      this._requestValidation();
    }
  }
  /**
   * Returns true if the current value satisfies all constraints (if any)
   *
   * @return {boolean}
   */
  checkValidity() {
    return !this.required || this.readonly || !!this.value;
  }
  /**
   * Renders items when they are provided by the `items` property and clears the content otherwise.
   * @param {!HTMLElement} root
   * @param {!Select} _select
   * @private
   */
  __defaultRenderer(root2, _select) {
    if (!this.items || this.items.length === 0) {
      root2.textContent = "";
      return;
    }
    let listBox2 = root2.firstElementChild;
    if (!listBox2) {
      listBox2 = document.createElement("vaadin-select-list-box");
      root2.appendChild(listBox2);
    }
    listBox2.textContent = "";
    this.items.forEach((item2) => {
      listBox2.appendChild(this.__createItemElement(item2));
    });
  }
  /** @private */
  async __dispatchChange() {
    if (this.updateComplete) {
      await this.updateComplete;
    }
    this._requestValidation();
    this.dispatchEvent(new CustomEvent("change", { bubbles: true }));
    this.__dispatchChangePending = false;
  }
};
/**
 * @license
 * Copyright (c) 2017 - 2025 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
registerStyles$1("vaadin-select", [fieldShared, inputFieldContainer, screenReaderOnly], {
  moduleId: "vaadin-select-styles"
});
class Select extends SelectBaseMixin(ElementMixin(ThemableMixin(PolymerElement))) {
  static get is() {
    return "vaadin-select";
  }
  static get template() {
    return html`
      <style>
        :host {
          position: relative;
        }

        ::slotted([slot='value']) {
          flex-grow: 1;
        }
      </style>

      <div class="vaadin-select-container">
        <div part="label" on-click="_onClick">
          <slot name="label"></slot>
          <span part="required-indicator" aria-hidden="true" on-click="focus"></span>
        </div>

        <vaadin-input-container
          part="input-field"
          readonly="[[readonly]]"
          disabled="[[disabled]]"
          invalid="[[invalid]]"
          theme$="[[_theme]]"
          on-click="_onClick"
        >
          <slot name="prefix" slot="prefix"></slot>
          <slot name="value"></slot>
          <div part="toggle-button" slot="suffix" aria-hidden="true" on-mousedown="_onToggleMouseDown"></div>
        </vaadin-input-container>

        <div part="helper-text">
          <slot name="helper"></slot>
        </div>

        <div part="error-message">
          <slot name="error-message"></slot>
        </div>
      </div>

      <vaadin-select-overlay
        id="overlay"
        owner="[[__overlayOwner]]"
        position-target="[[_inputContainer]]"
        opened="{{opened}}"
        with-backdrop="[[_phone]]"
        phone$="[[_phone]]"
        theme$="[[_theme]]"
        no-vertical-overlap$="[[noVerticalOverlap]]"
        on-vaadin-overlay-open="_onOverlayOpen"
      ></vaadin-select-overlay>

      <slot name="tooltip"></slot>
      <div class="sr-only">
        <slot name="sr-label"></slot>
      </div>
    `;
  }
  static get properties() {
    return {
      /** @private */
      __overlayOwner: {
        value() {
          return this;
        }
      }
    };
  }
  static get observers() {
    return ["_rendererChanged(renderer, _overlayElement)"];
  }
  /** @protected */
  ready() {
    super.ready();
    processTemplates(this);
  }
  /**
   * @param {SelectRenderer | undefined | null} renderer
   * @param {SelectOverlay | undefined} overlay
   * @private
   */
  _rendererChanged(renderer, overlay2) {
    if (!overlay2) {
      return;
    }
    overlay2.renderer = renderer || this.__defaultRenderer;
    this.requestContentUpdate();
  }
  /** @private */
  _onOverlayOpen() {
    if (this._menuElement) {
      this._menuElement.focus();
    }
  }
  /**
   * Fired when the user commits a value change.
   *
   * @event change
   */
}
defineCustomElement(Select);
window.Vaadin.Flow.selectConnector = {};
window.Vaadin.Flow.selectConnector.initLazy = (select2) => {
  if (select2.$connector) {
    return;
  }
  select2.$connector = {};
  select2.renderer = (root2) => {
    const listBox2 = select2.querySelector("vaadin-select-list-box");
    if (listBox2) {
      if (root2.firstChild) {
        root2.removeChild(root2.firstChild);
      }
      root2.appendChild(listBox2);
    }
  };
};
const _window$1 = window;
_window$1.Vaadin ||= {};
_window$1.Vaadin.Flow ||= {};
_window$1.Vaadin.Flow.tooltip ||= {};
Object.assign(_window$1.Vaadin.Flow.tooltip, {
  setDefaultHideDelay: (hideDelay) => Tooltip.setDefaultHideDelay(hideDelay),
  setDefaultFocusDelay: (focusDelay) => Tooltip.setDefaultFocusDelay(focusDelay),
  setDefaultHoverDelay: (hoverDelay) => Tooltip.setDefaultHoverDelay(hoverDelay)
});
const { defaultHideDelay, defaultFocusDelay, defaultHoverDelay } = _window$1.Vaadin.Flow.tooltip;
if (defaultHideDelay) {
  Tooltip.setDefaultHideDelay(defaultHideDelay);
}
if (defaultFocusDelay) {
  Tooltip.setDefaultFocusDelay(defaultFocusDelay);
}
if (defaultHoverDelay) {
  Tooltip.setDefaultHoverDelay(defaultHoverDelay);
}
document.addEventListener("click", (event) => {
  const target = event.composedPath().find((node) => node.hasAttribute && node.hasAttribute("disableonclick"));
  if (target) {
    target.disabled = true;
  }
});
const sideNavItemStyles = css`
  :host {
    --_focus-ring-color: var(--vaadin-focus-ring-color, var(--lumo-primary-color-50pct));
    --_focus-ring-width: var(--vaadin-focus-ring-width, 2px);
  }

  [part='link'] {
    width: 100%;
    gap: var(--lumo-space-xs);
    padding: var(--lumo-space-s);
    padding-inline-start: calc(var(--lumo-space-s) + var(--_child-indent, 0px));
    border-radius: var(--lumo-border-radius-m);
    transition:
      background-color 140ms,
      color 140ms;
    cursor: var(--lumo-clickable-cursor, default);
    min-height: var(--lumo-icon-size-m);
  }

  [part='link'][href] {
    cursor: pointer;
  }

  :host([disabled]) [part='link'] {
    color: var(--lumo-disabled-text-color);
  }

  [part='toggle-button'] {
    margin-inline-end: calc(var(--lumo-space-xs) * -1);
    width: var(--lumo-size-s);
    height: var(--lumo-size-s);
  }

  :host([has-children]) [part='content'] {
    padding-inline-end: var(--lumo-space-s);
  }

  @media (any-hover: hover) {
    [part='link']:hover {
      color: var(--lumo-header-text-color);
    }

    [part='toggle-button']:hover {
      color: var(--lumo-body-text-color);
    }
  }

  [part='link']:active:focus {
    background-color: var(--lumo-contrast-5pct);
  }

  [part='toggle-button']::before {
    content: var(--lumo-icons-dropdown);
    transform: rotate(-90deg);
    transition: transform 140ms;
  }

  :host([dir='rtl']) [part='toggle-button']::before {
    transform: rotate(90deg);
  }

  :host([expanded]) [part='toggle-button']::before {
    transform: none;
  }

  @supports selector(:focus-visible) {
    [part='link'],
    [part='toggle-button'] {
      outline: none;
    }

    [part='link']:focus-visible,
    [part='toggle-button']:focus-visible {
      border-radius: var(--lumo-border-radius-m);
      box-shadow: 0 0 0 var(--_focus-ring-width) var(--_focus-ring-color);
    }
  }

  [part='link']:active {
    color: var(--lumo-header-text-color);
  }

  slot:not([name]) {
    margin: 0 var(--lumo-space-s);
  }

  slot[name='prefix']::slotted(:is(vaadin-icon, [class*='icon'])) {
    padding: 0.1em;
    flex-shrink: 0;
    color: var(--lumo-contrast-60pct);
  }

  :host([disabled]) slot[name='prefix']::slotted(:is(vaadin-icon, [class*='icon'])) {
    color: var(--lumo-disabled-text-color);
  }

  :host([current]) slot[name='prefix']::slotted(:is(vaadin-icon, [class*='icon'])) {
    color: inherit;
  }

  slot[name='children'] {
    --_child-indent: calc(var(--_child-indent-2, 0px) + var(--vaadin-side-nav-child-indent, var(--lumo-space-l)));
  }

  slot[name='children']::slotted(*) {
    --_child-indent-2: var(--_child-indent);
  }

  :host([current]) [part='content'] {
    background-color: var(--lumo-primary-color-10pct);
    color: var(--vaadin-selection-color-text, var(--lumo-primary-text-color));
    border-radius: var(--lumo-border-radius-m);
  }
`;
registerStyles$1("vaadin-side-nav-item", [fieldButton, sideNavItemStyles], { moduleId: "lumo-side-nav-item" });
/**
 * @license
 * Copyright (c) 2023 - 2025 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
function containsQueryParams(actual, expected) {
  return [...expected.entries()].every(([key, value]) => {
    return actual.getAll(key).includes(value);
  });
}
function matchPaths(actual, expected, matchOptions = { matchNested: false }) {
  const base = document.baseURI;
  const actualUrl = new URL(actual, base);
  const expectedUrl = new URL(expected, base);
  const matchesOrigin = actualUrl.origin === expectedUrl.origin;
  const matchesPath = matchOptions.matchNested ? actualUrl.pathname === expectedUrl.pathname || actualUrl.pathname.startsWith(`${expectedUrl.pathname}/`) : actualUrl.pathname === expectedUrl.pathname;
  return matchesOrigin && matchesPath && containsQueryParams(actualUrl.searchParams, expectedUrl.searchParams);
}
/**
 * @license
 * Copyright (c) 2023 - 2025 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const location$1 = {
  get pathname() {
    return document.location.pathname;
  },
  get search() {
    return document.location.search;
  }
};
/**
 * @license
 * Copyright (c) 2023 - 2025 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const sideNavItemBaseStyles = css`
  :host {
    display: block;
  }

  :host([hidden]),
  [hidden] {
    display: none !important;
  }

  :host([disabled]) {
    pointer-events: none;
  }

  [part='content'] {
    display: flex;
    align-items: center;
  }

  [part='link'] {
    flex: auto;
    min-width: 0;
    display: flex;
    align-items: center;
    text-decoration: none;
    color: inherit;
    font: inherit;
  }

  button {
    -webkit-appearance: none;
    appearance: none;
    flex: none;
    position: relative;
    margin: 0;
    padding: 0;
    border: 0;
    background: transparent;
  }

  [part='children'] {
    padding: 0;
    margin: 0;
    list-style-type: none;
  }

  :host(:not([has-children])) button {
    display: none !important;
  }

  slot[name='prefix'],
  slot[name='suffix'] {
    flex: none;
  }

  slot:not([name]) {
    display: block;
    flex: auto;
    min-width: 0;
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
  }
`;
const sideNavBaseStyles = css`
  :host {
    display: block;
  }

  :host([hidden]) {
    display: none !important;
  }

  button {
    display: flex;
    align-items: center;
    justify-content: inherit;
    width: 100%;
    margin: 0;
    padding: 0;
    background-color: initial;
    color: inherit;
    border: initial;
    outline: none;
    font: inherit;
    text-align: inherit;
  }

  [part='children'] {
    padding: 0;
    margin: 0;
    list-style-type: none;
  }
`;
/**
 * @license
 * Copyright (c) 2023 - 2025 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
class ChildrenController extends SlotController {
  constructor(host, slotName) {
    super(host, slotName, null, { observe: true, multiple: true });
  }
  /**
   * @protected
   * @override
   */
  initAddedNode() {
    this.host.requestUpdate();
  }
  /**
   * @protected
   * @override
   */
  teardownNode() {
    this.host.requestUpdate();
  }
}
const SideNavChildrenMixin = (superClass) => class SideNavChildrenMixin extends superClass {
  static get properties() {
    return {
      /**
       * The object used to localize this component.
       *
       * To change the default localization, replace the entire
       * `i18n` object with a custom one.
       *
       * The object has the following structure and default values:
       * ```
       * {
       *   toggle: 'Toggle child items'
       * }
       * ```
       *
       * @type {SideNavI18n}
       * @default {English/US}
       */
      i18n: {
        type: Object,
        value: () => {
          return {
            toggle: "Toggle child items"
          };
        }
      },
      /**
       * Count of child items.
       * @protected
       */
      _itemsCount: {
        type: Number,
        value: 0
      }
    };
  }
  constructor() {
    super();
    this._childrenController = new ChildrenController(this, this._itemsSlotName);
  }
  /**
   * List of child items of this component.
   * @protected
   */
  get _items() {
    return this._childrenController.nodes;
  }
  /**
   * Name of the slot to be used for children.
   * @protected
   */
  get _itemsSlotName() {
    return "children";
  }
  /** @protected */
  firstUpdated() {
    super.firstUpdated();
    this.addController(this._childrenController);
  }
  /**
   * @protected
   * @override
   */
  willUpdate(props) {
    super.willUpdate(props);
    this._itemsCount = this._items.length;
  }
  /**
   * @protected
   * @override
   */
  updated(props) {
    super.updated(props);
    if (props.has("_itemsCount")) {
      this.toggleAttribute("has-children", this._itemsCount > 0);
    }
    if (props.has("_itemsCount") || props.has("i18n")) {
      this._items.forEach((item2) => {
        item2.i18n = this.i18n;
      });
    }
  }
};
/**
 * @license
 * Copyright (c) 2023 - 2025 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
class SideNavItem extends SideNavChildrenMixin(DisabledMixin(ElementMixin(ThemableMixin(PolylitMixin(LitElement))))) {
  static get is() {
    return "vaadin-side-nav-item";
  }
  static get properties() {
    return {
      /**
       * The path to navigate to
       */
      path: String,
      /**
       * The list of alternative paths matching this item
       *
       * @type {!Array<string>}
       */
      pathAliases: {
        type: Array,
        value: () => []
      },
      /**
       * Whether to show the child items or not
       *
       * @type {boolean}
       */
      expanded: {
        type: Boolean,
        value: false,
        notify: true,
        reflectToAttribute: true
      },
      /**
       * Whether to also match nested paths / routes. `false` by default.
       *
       * When enabled, an item with the path `/path` is considered current when
       * the browser URL is `/path`, `/path/child`, `/path/child/grandchild`,
       * etc.
       *
       * Note that this only affects matching of the URLs path, not the base
       * origin or query parameters.
       *
       * @type {boolean}
       * @attr {boolean} match-nested
       */
      matchNested: {
        type: Boolean,
        value: false
      },
      /**
       * Whether the item's path matches the current browser URL.
       *
       * A match occurs when both share the same base origin (like https://example.com),
       * the same path (like /path/to/page), and the browser URL contains at least
       * all the query parameters with the same values from the item's path.
       *
       * See [`matchNested`](#/elements/vaadin-side-nav-item#property-matchNested) for how to change the path matching behavior.
       *
       * The state is updated when the item is added to the DOM or when the browser
       * navigates to a new page.
       *
       * @type {boolean}
       */
      current: {
        type: Boolean,
        value: false,
        readOnly: true,
        reflectToAttribute: true
      },
      /**
       * The target of the link. Works only when `path` is set.
       */
      target: String,
      /**
       * Whether to exclude the item from client-side routing. When enabled,
       * this causes the item to behave like a regular anchor, causing a full
       * page reload. This only works with supported routers, such as the one
       * provided in Vaadin apps, or when using the side nav `onNavigate` hook.
       *
       * @type {boolean}
       * @attr {boolean} router-ignore
       */
      routerIgnore: {
        type: Boolean,
        value: false
      }
    };
  }
  static get styles() {
    return [sideNavItemBaseStyles];
  }
  constructor() {
    super();
    this.__boundUpdateCurrent = this.__updateCurrent.bind(this);
  }
  /** @protected */
  get _button() {
    return this.shadowRoot.querySelector("button");
  }
  /**
   * @protected
   * @override
   */
  firstUpdated() {
    super.firstUpdated();
    if (!this.hasAttribute("role")) {
      this.setAttribute("role", "listitem");
    }
  }
  /**
   * @protected
   * @override
   */
  updated(props) {
    super.updated(props);
    if (props.has("path") || props.has("pathAliases") || props.has("matchNested")) {
      this.__updateCurrent();
    }
    if (props.has("disabled") || props.has("_itemsCount")) {
      this._items.forEach((item2) => {
        item2.disabled = this.disabled;
      });
    }
  }
  /** @protected */
  connectedCallback() {
    super.connectedCallback();
    this.__updateCurrent();
    window.addEventListener("popstate", this.__boundUpdateCurrent);
    window.addEventListener("vaadin-navigated", this.__boundUpdateCurrent);
    window.addEventListener("side-nav-location-changed", this.__boundUpdateCurrent);
  }
  /** @protected */
  disconnectedCallback() {
    super.disconnectedCallback();
    window.removeEventListener("popstate", this.__boundUpdateCurrent);
    window.removeEventListener("vaadin-navigated", this.__boundUpdateCurrent);
    window.removeEventListener("side-nav-location-changed", this.__boundUpdateCurrent);
  }
  /** @protected */
  render() {
    return html$1`
      <div part="content" @click="${this._onContentClick}">
        <a
          id="link"
          ?disabled="${this.disabled}"
          tabindex="${this.disabled || this.path == null ? "-1" : "0"}"
          href="${ifDefined(this.disabled ? null : this.path)}"
          target="${ifDefined(this.target)}"
          ?router-ignore="${this.routerIgnore}"
          part="link"
          aria-current="${this.current ? "page" : "false"}"
        >
          <slot name="prefix"></slot>
          <slot></slot>
          <slot name="suffix"></slot>
        </a>
        <button
          part="toggle-button"
          ?disabled="${this.disabled}"
          @click="${this._onButtonClick}"
          aria-controls="children"
          aria-expanded="${this.expanded}"
          aria-labelledby="link i18n"
        ></button>
      </div>
      <ul part="children" role="list" ?hidden="${!this.expanded}" aria-hidden="${this.expanded ? "false" : "true"}">
        <slot name="children"></slot>
      </ul>
      <div hidden id="i18n">${this.i18n.toggle}</div>
    `;
  }
  /** @private */
  _onButtonClick(event) {
    event.stopPropagation();
    this.__toggleExpanded();
  }
  /** @private */
  _onContentClick() {
    if (this.path == null && this.hasAttribute("has-children")) {
      this.__toggleExpanded();
    }
  }
  /** @private */
  __toggleExpanded() {
    this.expanded = !this.expanded;
  }
  /** @private */
  __updateCurrent() {
    this._setCurrent(this.__isCurrent());
    if (this.current) {
      this.__expandParentItems();
      this.expanded = this._items.length > 0;
    }
  }
  /** @private */
  __expandParentItems() {
    const parentItem = this.__getParentItem();
    if (parentItem) {
      parentItem.__expandParentItems();
    }
    this.expanded = true;
  }
  /** @private */
  __getParentItem() {
    return this.parentElement instanceof SideNavItem ? this.parentElement : null;
  }
  /** @private */
  __isCurrent() {
    if (this.path == null) {
      return false;
    }
    const browserPath = `${location$1.pathname}${location$1.search}`;
    const matchOptions = { matchNested: this.matchNested };
    return matchPaths(browserPath, this.path, matchOptions) || this.pathAliases.some((alias) => matchPaths(browserPath, alias, matchOptions));
  }
}
defineCustomElement(SideNavItem);
const sideNavStyles = css`
  :host {
    font-family: var(--lumo-font-family);
    font-size: var(--lumo-font-size-m);
    font-weight: 500;
    line-height: var(--lumo-line-height-xs);
    color: var(--lumo-body-text-color);
    -webkit-tap-highlight-color: transparent;
    --_focus-ring-color: var(--vaadin-focus-ring-color, var(--lumo-primary-color-50pct));
    --_focus-ring-width: var(--vaadin-focus-ring-width, 2px);
  }

  [part='label'] {
    display: flex;
    align-items: center;
    width: 100%;
    outline: none;
    box-sizing: border-box;
    border-radius: var(--lumo-border-radius-m);
    font-family: var(--lumo-font-family);
    font-size: var(--lumo-font-size-s);
    font-weight: 500;
    line-height: var(--lumo-line-height-xs);
  }

  [part='label'] ::slotted([slot='label']) {
    color: var(--lumo-secondary-text-color);
    margin: var(--lumo-space-s);
  }

  :host([focus-ring]) [part='label'] {
    box-shadow: 0 0 0 var(--_focus-ring-width) var(--_focus-ring-color);
  }

  [part='toggle-button'] {
    display: inline-flex;
    align-items: center;
    justify-content: center;
    width: var(--lumo-size-s);
    height: var(--lumo-size-s);
    margin-inline: auto var(--lumo-space-xs);
    font-size: var(--lumo-icon-size-m);
    line-height: 1;
    color: var(--lumo-contrast-60pct);
    font-family: 'lumo-icons';
    cursor: var(--lumo-clickable-cursor);
  }

  [part='toggle-button']::before {
    content: var(--lumo-icons-angle-right);
    transition: transform 140ms;
  }

  :host(:not([collapsible])) [part='toggle-button'] {
    display: none !important;
  }

  :host(:not([collapsed])) [part='toggle-button']::before {
    transform: rotate(90deg);
  }

  :host([collapsed][dir='rtl']) [part='toggle-button']::before {
    transform: rotate(180deg);
  }

  @media (any-hover: hover) {
    [part='label']:hover [part='toggle-button'] {
      color: var(--lumo-body-text-color);
    }
  }
`;
registerStyles$1("vaadin-side-nav", sideNavStyles, { moduleId: "lumo-side-nav" });
/**
 * @license
 * Copyright (c) 2023 - 2025 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
class SideNav extends SideNavChildrenMixin(FocusMixin(ElementMixin(ThemableMixin(PolylitMixin(LitElement))))) {
  static get is() {
    return "vaadin-side-nav";
  }
  static get shadowRootOptions() {
    return { ...LitElement.shadowRootOptions, delegatesFocus: true };
  }
  static get properties() {
    return {
      /**
       * Whether the side nav is collapsible. When enabled, the toggle icon is shown.
       *
       * @type {boolean}
       */
      collapsible: {
        type: Boolean,
        value: false,
        reflectToAttribute: true
      },
      /**
       * Whether the side nav is collapsed. When collapsed, the items are hidden.
       *
       * @type {boolean}
       */
      collapsed: {
        type: Boolean,
        value: false,
        notify: true,
        reflectToAttribute: true
      },
      /**
       * Callback function for router integration.
       *
       * When a side nav item link is clicked, this function is called and the default click action is cancelled.
       * This delegates the responsibility of navigation to the function's logic.
       *
       * The click event action is not cancelled in the following cases:
       * - The click event has a modifier (e.g. `metaKey`, `shiftKey`)
       * - The click event is on an external link
       * - The click event is on a link with `target="_blank"`
       * - The function explicitly returns `false`
       *
       * The function receives an object with the properties of the clicked side-nav item:
       * - `path`: The path of the navigation item.
       * - `target`: The target of the navigation item.
       * - `current`: A boolean indicating whether the navigation item is currently selected.
       * - `expanded`: A boolean indicating whether the navigation item is expanded.
       * - `pathAliases`: An array of path aliases for the navigation item.
       * - `originalEvent`: The original DOM event that triggered the navigation.
       *
       * Also see the `location` property for updating the highlighted navigation item on route change.
       *
       * @type {function(Object): boolean | undefined}
       */
      onNavigate: {
        attribute: false
      },
      /**
       * A change to this property triggers an update of the highlighted item in the side navigation. While it typically
       * corresponds to the browser's URL, the specific value assigned to the property is irrelevant. The component has
       * its own internal logic for determining which item is highlighted.
       *
       * The main use case for this property is when the side navigation is used with a client-side router. In this case,
       * the component needs to be informed about route changes so it can update the highlighted item.
       *
       * @type {any}
       */
      location: {
        observer: "__locationChanged"
      }
    };
  }
  static get styles() {
    return sideNavBaseStyles;
  }
  constructor() {
    super();
    this._labelId = `side-nav-label-${generateUniqueId()}`;
    this.addEventListener("click", this.__onClick);
  }
  /**
   * Name of the slot to be used for children.
   * @protected
   * @override
   */
  get _itemsSlotName() {
    return "";
  }
  /** @protected */
  get focusElement() {
    return this.shadowRoot.querySelector("button");
  }
  /** @protected */
  firstUpdated() {
    super.firstUpdated();
    if (!this.hasAttribute("role")) {
      this.setAttribute("role", "navigation");
    }
  }
  /** @protected */
  render() {
    return html$1`
      ${this.collapsible ? html$1`
            <button
              part="label"
              @click="${this._onLabelClick}"
              aria-expanded="${!this.collapsed}"
              aria-controls="children"
            >
              <slot name="label" @slotchange="${this._onLabelSlotChange}"></slot>
              <span part="toggle-button" aria-hidden="true"></span>
            </button>
          ` : html$1`
            <div part="label">
              <slot name="label" @slotchange="${this._onLabelSlotChange}"></slot>
            </div>
          `}
      <ul
        id="children"
        role="list"
        part="children"
        ?hidden="${this.collapsed}"
        aria-hidden="${this.collapsed ? "true" : "false"}"
      >
        <slot></slot>
      </ul>
    `;
  }
  /**
   * @param {Event} event
   * @return {boolean}
   * @protected
   * @override
   */
  _shouldSetFocus(event) {
    return event.composedPath()[0] === this.focusElement;
  }
  /** @private */
  _onLabelClick() {
    if (this.collapsible) {
      this.__toggleCollapsed();
    }
  }
  /** @private */
  _onLabelSlotChange() {
    const label = this.querySelector('[slot="label"]');
    if (label) {
      if (!label.id) {
        label.id = this._labelId;
      }
      this.setAttribute("aria-labelledby", label.id);
    } else {
      this.removeAttribute("aria-labelledby");
    }
  }
  /** @private */
  __locationChanged() {
    window.dispatchEvent(new CustomEvent("side-nav-location-changed"));
  }
  /** @private */
  __toggleCollapsed() {
    this.collapsed = !this.collapsed;
  }
  /** @private */
  __onClick(e2) {
    if (!this.onNavigate) {
      return;
    }
    const hasModifier = e2.metaKey || e2.shiftKey;
    if (hasModifier) {
      return;
    }
    const composedPath = e2.composedPath();
    const item2 = composedPath.find((el) => el.localName && el.localName.includes("side-nav-item"));
    const anchor = composedPath.find((el) => el instanceof HTMLAnchorElement);
    if (!item2 || !item2.shadowRoot.contains(anchor)) {
      return;
    }
    const isRelative = anchor.href && anchor.href.startsWith(location.origin);
    if (!isRelative) {
      return;
    }
    if (item2.target === "_blank") {
      return;
    }
    if (item2.routerIgnore) {
      return;
    }
    const result = this.onNavigate({
      path: item2.path,
      target: item2.target,
      current: item2.current,
      expanded: item2.expanded,
      pathAliases: item2.pathAliases,
      originalEvent: e2
    });
    if (result !== false) {
      e2.preventDefault();
    }
  }
}
defineCustomElement(SideNav);
registerStyles$1(
  "vaadin-split-layout",
  css`
    [part='splitter'] {
      min-width: var(--lumo-space-s);
      min-height: var(--lumo-space-s);
      background-color: var(--lumo-contrast-5pct);
      transition: 0.1s background-color;
    }

    [part='handle'] {
      display: flex;
      align-items: center;
      justify-content: center;
      width: var(--lumo-size-m);
      height: var(--lumo-size-m);
    }

    [part='handle']::after {
      content: '';
      display: block;
      --_handle-size: 4px;
      width: var(--_handle-size);
      height: 100%;
      max-width: 100%;
      max-height: 100%;
      border-radius: var(--lumo-border-radius-s);
      background-color: var(--lumo-contrast-30pct);
      transition:
        0.1s opacity,
        0.1s background-color;
    }

    :host([orientation='vertical']) [part='handle']::after {
      width: 100%;
      height: var(--_handle-size);
    }

    /* Hover style */
    @media (any-hover: hover) {
      [part='splitter']:hover [part='handle']::after {
        background-color: var(--lumo-contrast-40pct);
      }
    }

    /* Active style */
    [part='splitter']:active [part='handle']::after {
      background-color: var(--lumo-contrast-50pct);
    }

    /* Small/minimal */
    :host([theme~='small']) > [part='splitter'] {
      border-left: 1px solid var(--lumo-contrast-10pct);
      border-top: 1px solid var(--lumo-contrast-10pct);
    }

    :host(:is([theme~='small'], [theme~='minimal'])) > [part='splitter'] {
      min-width: 0;
      min-height: 0;
      background-color: transparent;
    }

    :host(:is([theme~='small'], [theme~='minimal'])) > [part='splitter']::after {
      content: '';
      position: absolute;
      inset: -4px;
    }

    :host(:is([theme~='small'], [theme~='minimal'])) > [part='splitter'] > [part='handle'] {
      left: calc(50% - 0.5px);
      top: calc(50% - 0.5px);
    }

    :host(:is([theme~='small'], [theme~='minimal'])) > [part='splitter'] > [part='handle']::after {
      opacity: 0;
      --_handle-size: 5px;
    }

    :host(:is([theme~='small'], [theme~='minimal'])) > [part='splitter']:hover > [part='handle']::after,
    :host(:is([theme~='small'], [theme~='minimal'])) > [part='splitter']:active > [part='handle']::after {
      opacity: 1;
    }
  `,
  { moduleId: "lumo-split-layout" }
);
/**
 * @license
 * Copyright (c) 2016 - 2025 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const SplitLayoutMixin = (superClass) => class SplitLayoutMixin extends superClass {
  static get properties() {
    return {
      /**
       * The split layout's orientation. Possible values are: `horizontal|vertical`.
       * @type {string}
       */
      orientation: {
        type: String,
        reflectToAttribute: true,
        value: "horizontal"
      },
      /** @private */
      _previousPrimaryPointerEvents: String,
      /** @private */
      _previousSecondaryPointerEvents: String
    };
  }
  /** @protected */
  ready() {
    super.ready();
    this._processChildren();
    this.__observer = new MutationObserver((mutations) => {
      mutations.forEach((mutation) => {
        this._cleanupNodes(mutation.removedNodes);
      });
      this._processChildren();
    });
    this.__observer.observe(this, { childList: true });
    const splitter = this.$.splitter;
    addListener(splitter, "track", this._onHandleTrack.bind(this));
    addListener(splitter, "down", this._setPointerEventsNone.bind(this));
    addListener(splitter, "up", this._restorePointerEvents.bind(this));
  }
  /** @private */
  _cleanupNodes(nodes) {
    nodes.forEach((node) => {
      if (node.nodeType === Node.ELEMENT_NODE && !(node.parentElement instanceof this.constructor)) {
        const slot = node.getAttribute("slot");
        if (slot) {
          this[`_${slot}Child`] = null;
          node.removeAttribute("slot");
        }
      }
    });
  }
  /** @private */
  _processChildren() {
    const children = [...this.children];
    children.filter((child) => child.hasAttribute("slot")).forEach((child) => this._processChildWithSlot(child));
    children.filter((child) => !child.hasAttribute("slot")).forEach((child, i2) => this._processChildWithoutSlot(child, i2));
  }
  /** @private */
  _processChildWithSlot(child) {
    const slot = child.getAttribute("slot");
    if (child.__autoSlotted) {
      this[`_${slot}Child`] = null;
      child.removeAttribute("slot");
    } else {
      this[`_${slot}Child`] = child;
    }
  }
  /** @private */
  _processChildWithoutSlot(child, idx) {
    let slotName;
    if (this._primaryChild || this._secondaryChild) {
      slotName = this._primaryChild ? "secondary" : "primary";
    } else {
      slotName = idx === 0 ? "primary" : "secondary";
    }
    this[`_${slotName}Child`] = child;
    child.setAttribute("slot", slotName);
    child.__autoSlotted = true;
  }
  /** @private */
  _setFlexBasis(element, flexBasis, containerSize) {
    flexBasis = Math.max(0, Math.min(flexBasis, containerSize));
    if (flexBasis === 0) {
      flexBasis = 1e-6;
    }
    element.style.flex = `1 1 ${flexBasis}px`;
  }
  /** @private */
  _setPointerEventsNone(event) {
    if (!this._primaryChild || !this._secondaryChild) {
      return;
    }
    this._previousPrimaryPointerEvents = this._primaryChild.style.pointerEvents;
    this._previousSecondaryPointerEvents = this._secondaryChild.style.pointerEvents;
    this._primaryChild.style.pointerEvents = "none";
    this._secondaryChild.style.pointerEvents = "none";
    event.preventDefault();
  }
  /** @private */
  _restorePointerEvents() {
    if (!this._primaryChild || !this._secondaryChild) {
      return;
    }
    this._primaryChild.style.pointerEvents = this._previousPrimaryPointerEvents;
    this._secondaryChild.style.pointerEvents = this._previousSecondaryPointerEvents;
  }
  /** @private */
  _onHandleTrack(event) {
    if (!this._primaryChild || !this._secondaryChild) {
      return;
    }
    const size = this.orientation === "vertical" ? "height" : "width";
    if (event.detail.state === "start") {
      this._startSize = {
        container: this.getBoundingClientRect()[size] - this.$.splitter.getBoundingClientRect()[size],
        primary: this._primaryChild.getBoundingClientRect()[size],
        secondary: this._secondaryChild.getBoundingClientRect()[size]
      };
      return;
    }
    const distance = this.orientation === "vertical" ? event.detail.dy : event.detail.dx;
    const isRtl = this.orientation !== "vertical" && this.__isRTL;
    const dirDistance = isRtl ? -distance : distance;
    this._setFlexBasis(this._primaryChild, this._startSize.primary + dirDistance, this._startSize.container);
    this._setFlexBasis(this._secondaryChild, this._startSize.secondary - dirDistance, this._startSize.container);
    if (event.detail.state === "end") {
      this.dispatchEvent(new CustomEvent("splitter-dragend"));
      delete this._startSize;
    }
  }
};
/**
 * @license
 * Copyright (c) 2016 - 2025 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const splitLayoutStyles = css`
  :host {
    display: flex;
    overflow: hidden !important;
    transform: translateZ(0);
  }

  :host([hidden]) {
    display: none !important;
  }

  :host([orientation='vertical']) {
    flex-direction: column;
  }

  :host ::slotted(*) {
    flex: 1 1 auto;
    overflow: auto;
    -webkit-overflow-scrolling: touch;
  }

  [part='splitter'] {
    flex: none;
    position: relative;
    z-index: 1;
    overflow: visible;
    min-width: 8px;
    min-height: 8px;
  }

  :host(:not([orientation='vertical'])) > [part='splitter'] {
    cursor: ew-resize;
  }

  :host([orientation='vertical']) > [part='splitter'] {
    cursor: ns-resize;
  }

  [part='handle'] {
    width: 40px;
    height: 40px;
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate3d(-50%, -50%, 0);
  }

  @media (forced-colors: active) {
    [part~='splitter'] {
      outline: 1px solid;
    }

    [part~='handle']::after {
      background-color: AccentColor !important;
      forced-color-adjust: none;
    }
  }
`;
/**
 * @license
 * Copyright (c) 2016 - 2025 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
registerStyles$1("vaadin-split-layout", splitLayoutStyles, { moduleId: "vaadin-split-layout-styles" });
class SplitLayout extends SplitLayoutMixin(ElementMixin(ThemableMixin(PolymerElement))) {
  static get template() {
    return html`
      <slot id="primary" name="primary"></slot>
      <div part="splitter" id="splitter">
        <div part="handle"></div>
      </div>
      <slot id="secondary" name="secondary"></slot>
    `;
  }
  static get is() {
    return "vaadin-split-layout";
  }
  /**
   * Fired after dragging the splitter have ended.
   *
   * @event splitter-dragend
   */
}
defineCustomElement(SplitLayout);
registerStyles$1(
  "vaadin-tab",
  css`
    :host {
      box-sizing: border-box;
      padding: 0.5rem 0.75rem;
      font-family: var(--lumo-font-family);
      font-size: var(--lumo-font-size-m);
      line-height: var(--lumo-line-height-xs);
      font-weight: 500;
      opacity: 1;
      color: var(--lumo-secondary-text-color);
      transition:
        0.15s color,
        0.2s transform;
      flex-shrink: 0;
      display: flex;
      align-items: center;
      position: relative;
      cursor: var(--lumo-clickable-cursor);
      transform-origin: 50% 100%;
      outline: none;
      -webkit-font-smoothing: antialiased;
      -moz-osx-font-smoothing: grayscale;
      overflow: hidden;
      min-width: var(--lumo-size-m);
      -webkit-user-select: none;
      user-select: none;
      --_focus-ring-color: var(--vaadin-focus-ring-color, var(--lumo-primary-color-50pct));
      --_focus-ring-width: var(--vaadin-focus-ring-width, 2px);
      --_selection-color: var(--vaadin-selection-color, var(--lumo-primary-color));
      --_selection-color-text: var(--vaadin-selection-color-text, var(--lumo-primary-text-color));
    }

    :host(:not([orientation='vertical'])) {
      text-align: center;
    }

    :host([orientation='vertical']) {
      transform-origin: 0% 50%;
      padding: 0.25rem 1rem;
      min-height: var(--lumo-size-m);
      min-width: 0;
    }

    @media (forced-colors: active) {
      :host([focused]) {
        outline: 1px solid;
        outline-offset: -1px;
      }

      :host([orientation='vertical'][selected]) {
        border-bottom: none;
        border-left: 2px solid;
      }
    }

    :host(:hover),
    :host([focus-ring]) {
      color: var(--lumo-body-text-color);
    }

    :host([selected]) {
      color: var(--_selection-color-text);
      transition: 0.6s color;
    }

    :host([active]:not([selected])) {
      color: var(--_selection-color-text);
      transition-duration: 0.1s;
    }

    :host::before,
    :host::after {
      content: '';
      position: absolute;
      display: var(--_lumo-tab-marker-display, block);
      bottom: 0;
      left: 50%;
      width: var(--lumo-size-s);
      height: 2px;
      background-color: var(--lumo-contrast-60pct);
      border-radius: var(--lumo-border-radius-s) var(--lumo-border-radius-s) 0 0;
      transform: translateX(-50%) scale(0);
      transform-origin: 50% 100%;
      transition: 0.14s transform cubic-bezier(0.12, 0.32, 0.54, 1);
      will-change: transform;
    }

    :host([orientation='vertical'])::before,
    :host([orientation='vertical'])::after {
      left: 0;
      bottom: 50%;
      transform: translateY(50%) scale(0);
      width: 2px;
      height: var(--lumo-size-xs);
      border-radius: 0 var(--lumo-border-radius-s) var(--lumo-border-radius-s) 0;
      transform-origin: 100% 50%;
    }

    :host::after {
      box-shadow: 0 0 0 4px var(--_selection-color);
      opacity: 0.15;
      transition:
        0.15s 0.02s transform,
        0.8s 0.17s opacity;
    }

    :host([selected])::before,
    :host([selected])::after {
      background-color: var(--_selection-color);
      transform: translateX(-50%) scale(1);
      transition-timing-function: cubic-bezier(0.12, 0.32, 0.54, 1.5);
    }

    :host([orientation='vertical'][selected])::before,
    :host([orientation='vertical'][selected])::after {
      transform: translateY(50%) scale(1);
    }

    :host([selected]:not([active]))::after {
      opacity: 0;
    }

    :host(:not([orientation='vertical'])) ::slotted(a[href]) {
      justify-content: center;
    }

    :host ::slotted(a) {
      display: flex;
      width: 100%;
      align-items: center;
      height: 100%;
      margin: -0.5rem -0.75rem;
      padding: 0.5rem 0.75rem;
      outline: none;

      /*
          Override the CSS inherited from \`lumo-color\` and \`lumo-typography\`.
          Note: \`!important\` is needed because of the \`:slotted\` specificity.
        */
      text-decoration: none !important;
      color: inherit !important;
    }

    :host ::slotted(vaadin-icon) {
      margin: 0 4px;
      width: var(--lumo-icon-size-m);
      height: var(--lumo-icon-size-m);
    }

    /* Vaadin icons are based on a 16x16 grid (unlike Lumo and Material icons with 24x24), so they look too big by default */
    :host ::slotted(vaadin-icon[icon^='vaadin:']) {
      padding: 0.25rem;
      box-sizing: border-box !important;
    }

    :host(:not([dir='rtl'])) ::slotted(vaadin-icon:first-child) {
      margin-left: 0;
    }

    :host(:not([dir='rtl'])) ::slotted(vaadin-icon:last-child) {
      margin-right: 0;
    }

    :host([theme~='icon-on-top']) {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: space-around;
      text-align: center;
      padding-bottom: 0.5rem;
      padding-top: 0.25rem;
    }

    :host([theme~='icon-on-top']) ::slotted(a) {
      flex-direction: column;
      align-items: center;
      margin-top: -0.25rem;
      padding-top: 0.25rem;
    }

    :host([theme~='icon-on-top']) ::slotted(vaadin-icon) {
      margin: 0;
    }

    /* Disabled */

    :host([disabled]) {
      pointer-events: none;
      opacity: 1;
      color: var(--lumo-disabled-text-color);
    }

    /* Focus-ring */

    :host([focus-ring]) {
      box-shadow: inset 0 0 0 var(--_focus-ring-width) var(--_focus-ring-color);
      border-radius: var(--lumo-border-radius-m);
    }

    /* RTL specific styles */

    :host([dir='rtl'])::before,
    :host([dir='rtl'])::after {
      left: auto;
      right: 50%;
      transform: translateX(50%) scale(0);
    }

    :host([dir='rtl'][selected]:not([orientation='vertical']))::before,
    :host([dir='rtl'][selected]:not([orientation='vertical']))::after {
      transform: translateX(50%) scale(1);
    }

    :host([dir='rtl']) ::slotted(vaadin-icon:first-child) {
      margin-right: 0;
    }

    :host([dir='rtl']) ::slotted(vaadin-icon:last-child) {
      margin-left: 0;
    }

    :host([orientation='vertical'][dir='rtl']) {
      transform-origin: 100% 50%;
    }

    :host([dir='rtl'][orientation='vertical'])::before,
    :host([dir='rtl'][orientation='vertical'])::after {
      left: auto;
      right: 0;
      border-radius: var(--lumo-border-radius-s) 0 0 var(--lumo-border-radius-s);
      transform-origin: 0% 50%;
    }
  `,
  { moduleId: "lumo-tab" }
);
/**
 * @license
 * Copyright (c) 2017 - 2025 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const TabMixin = (superClass) => class TabMixinClass extends ItemMixin(superClass) {
  /** @protected */
  ready() {
    super.ready();
    this.setAttribute("role", "tab");
  }
  /**
   * Override an event listener from `KeyboardMixin`
   * to handle clicking anchors inside the tabs.
   * @param {!KeyboardEvent} event
   * @protected
   * @override
   */
  _onKeyUp(event) {
    const willClick = this.hasAttribute("active");
    super._onKeyUp(event);
    if (willClick) {
      const anchor = this.querySelector("a");
      if (anchor) {
        anchor.click();
      }
    }
  }
};
/**
 * @license
 * Copyright (c) 2017 - 2025 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const tabStyles = css`
  :host {
    display: block;
  }

  :host([hidden]) {
    display: none !important;
  }

  @media (forced-colors: active) {
    :host([focused]) {
      outline: 1px solid;
      outline-offset: -1px;
    }

    :host([selected]) {
      border-bottom: 2px solid;
    }
  }
`;
/**
 * @license
 * Copyright (c) 2017 - 2025 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
registerStyles$1("vaadin-tab", tabStyles, { moduleId: "vaadin-tab-styles" });
class Tab extends ElementMixin(ThemableMixin(TabMixin(ControllerMixin(PolymerElement)))) {
  static get template() {
    return html`
      <slot></slot>
      <slot name="tooltip"></slot>
    `;
  }
  static get is() {
    return "vaadin-tab";
  }
  /** @protected */
  ready() {
    super.ready();
    this._tooltipController = new TooltipController(this);
    this.addController(this._tooltipController);
  }
}
defineCustomElement(Tab);
registerStyles$1(
  "vaadin-tabs",
  css`
    :host {
      -webkit-tap-highlight-color: transparent;
    }

    :host(:not([orientation='vertical'])) {
      box-shadow: inset 0 -1px 0 0 var(--lumo-contrast-10pct);
      position: relative;
      min-height: var(--lumo-size-l);
    }

    :host([orientation='horizontal']) [part='tabs'] ::slotted(vaadin-tab:not([theme~='icon-on-top'])) {
      justify-content: center;
    }

    :host([orientation='vertical']) {
      box-shadow: -1px 0 0 0 var(--lumo-contrast-10pct);
    }

    :host([orientation='horizontal']) [part='tabs'] {
      margin: 0 0.75rem;
    }

    :host([orientation='vertical']) [part='tabs'] {
      width: 100%;
      margin: 0.5rem 0;
    }

    [part='forward-button'],
    [part='back-button'] {
      position: absolute;
      z-index: 1;
      font-family: lumo-icons;
      color: var(--lumo-tertiary-text-color);
      font-size: var(--lumo-icon-size-m);
      display: flex;
      align-items: center;
      justify-content: center;
      width: 1.5em;
      height: 100%;
      transition: 0.2s opacity;
      top: 0;
    }

    [part='forward-button']:hover,
    [part='back-button']:hover {
      color: inherit;
    }

    :host(:not([dir='rtl'])) [part='forward-button'] {
      right: 0;
    }

    [part='forward-button']::after {
      content: var(--lumo-icons-angle-right);
    }

    [part='back-button']::after {
      content: var(--lumo-icons-angle-left);
    }

    /* Tabs overflow */

    [part='tabs'] {
      --_lumo-tabs-overflow-mask-image: none;
      -webkit-mask-image: var(--_lumo-tabs-overflow-mask-image);
      mask-image: var(--_lumo-tabs-overflow-mask-image);
    }

    /* Horizontal tabs overflow */

    /* Both ends overflowing */
    :host([overflow~='start'][overflow~='end']:not([orientation='vertical'])) [part='tabs'] {
      --_lumo-tabs-overflow-mask-image: linear-gradient(
        90deg,
        transparent 2em,
        #000 4em,
        #000 calc(100% - 4em),
        transparent calc(100% - 2em)
      );
    }

    /* End overflowing */
    :host([overflow~='end']:not([orientation='vertical'])) [part='tabs'] {
      --_lumo-tabs-overflow-mask-image: linear-gradient(90deg, #000 calc(100% - 4em), transparent calc(100% - 2em));
    }

    /* Start overflowing */
    :host([overflow~='start']:not([orientation='vertical'])) [part='tabs'] {
      --_lumo-tabs-overflow-mask-image: linear-gradient(90deg, transparent 2em, #000 4em);
    }

    /* Vertical tabs overflow */

    /* Both ends overflowing */
    :host([overflow~='start'][overflow~='end'][orientation='vertical']) [part='tabs'] {
      --_lumo-tabs-overflow-mask-image: linear-gradient(transparent, #000 2em, #000 calc(100% - 2em), transparent);
    }

    /* End overflowing */
    :host([overflow~='end'][orientation='vertical']) [part='tabs'] {
      --_lumo-tabs-overflow-mask-image: linear-gradient(#000 calc(100% - 2em), transparent);
    }

    /* Start overflowing */
    :host([overflow~='start'][orientation='vertical']) [part='tabs'] {
      --_lumo-tabs-overflow-mask-image: linear-gradient(transparent, #000 2em);
    }

    :host [part='tabs'] ::slotted(:not(vaadin-tab)) {
      margin-left: var(--lumo-space-m);
    }

    /* Centered */

    :host([theme~='centered'][orientation='horizontal']) ::slotted(vaadin-tab:first-of-type) {
      margin-inline-start: auto;
    }

    :host([theme~='centered'][orientation='horizontal']) ::slotted(vaadin-tab:last-of-type) {
      margin-inline-end: auto;
    }

    /* Small */

    :host([theme~='small']),
    :host([theme~='small']) [part='tabs'] {
      min-height: var(--lumo-size-m);
    }

    :host([theme~='small']) [part='tabs'] ::slotted(vaadin-tab) {
      font-size: var(--lumo-font-size-s);
    }

    /* Minimal */

    :host([theme~='minimal']) {
      box-shadow: none;
      --_lumo-tab-marker-display: none;
    }

    /* Hide-scroll-buttons */

    :host([theme~='hide-scroll-buttons']) [part='back-button'],
    :host([theme~='hide-scroll-buttons']) [part='forward-button'] {
      display: none;
    }

    /* prettier-ignore */
    :host([theme~='hide-scroll-buttons'][overflow~='start'][overflow~='end']:not([orientation='vertical'])) [part='tabs'] {
      --_lumo-tabs-overflow-mask-image: linear-gradient(
        90deg,
        transparent,
        #000 2em,
        #000 calc(100% - 2em),
        transparent 100%
      );
    }

    :host([theme~='hide-scroll-buttons'][overflow~='end']:not([orientation='vertical'])) [part='tabs'] {
      --_lumo-tabs-overflow-mask-image: linear-gradient(90deg, #000 calc(100% - 2em), transparent 100%);
    }

    :host([theme~='hide-scroll-buttons'][overflow~='start']:not([orientation='vertical'])) [part='tabs'] {
      --_lumo-tabs-overflow-mask-image: linear-gradient(90deg, transparent, #000 2em);
    }

    /* Equal-width tabs */
    :host([theme~='equal-width-tabs']) {
      flex: auto;
    }

    :host([theme~='equal-width-tabs']) [part='tabs'] ::slotted(vaadin-tab) {
      flex: 1 0 0%;
    }

    /* RTL specific styles */

    :host([dir='rtl']) [part='forward-button']::after {
      content: var(--lumo-icons-angle-left);
    }

    :host([dir='rtl']) [part='back-button']::after {
      content: var(--lumo-icons-angle-right);
    }

    :host([orientation='vertical'][dir='rtl']) {
      box-shadow: 1px 0 0 0 var(--lumo-contrast-10pct);
    }

    :host([dir='rtl']) [part='forward-button'] {
      left: 0;
    }

    :host([dir='rtl']) [part='tabs'] ::slotted(:not(vaadin-tab)) {
      margin-left: 0;
      margin-right: var(--lumo-space-m);
    }

    /* Both ends overflowing */
    :host([dir='rtl'][overflow~='start'][overflow~='end']:not([orientation='vertical'])) [part='tabs'] {
      --_lumo-tabs-overflow-mask-image: linear-gradient(
        -90deg,
        transparent 2em,
        #000 4em,
        #000 calc(100% - 4em),
        transparent calc(100% - 2em)
      );
    }

    /* End overflowing */
    :host([dir='rtl'][overflow~='end']:not([orientation='vertical'])) [part='tabs'] {
      --_lumo-tabs-overflow-mask-image: linear-gradient(-90deg, #000 calc(100% - 4em), transparent calc(100% - 2em));
    }

    /* Start overflowing */
    :host([dir='rtl'][overflow~='start']:not([orientation='vertical'])) [part='tabs'] {
      --_lumo-tabs-overflow-mask-image: linear-gradient(-90deg, transparent 2em, #000 4em);
    }

    :host([dir='rtl'][theme~='hide-scroll-buttons'][overflow~='start'][overflow~='end']:not([orientation='vertical']))
      [part='tabs'] {
      --_lumo-tabs-overflow-mask-image: linear-gradient(
        -90deg,
        transparent,
        #000 2em,
        #000 calc(100% - 2em),
        transparent 100%
      );
    }

    :host([dir='rtl'][theme~='hide-scroll-buttons'][overflow~='end']:not([orientation='vertical'])) [part='tabs'] {
      --_lumo-tabs-overflow-mask-image: linear-gradient(-90deg, #000 calc(100% - 2em), transparent 100%);
    }

    :host([dir='rtl'][theme~='hide-scroll-buttons'][overflow~='start']:not([orientation='vertical'])) [part='tabs'] {
      --_lumo-tabs-overflow-mask-image: linear-gradient(-90deg, transparent, #000 2em);
    }
  `,
  { moduleId: "lumo-tabs" }
);
/**
 * @license
 * Copyright (c) 2017 - 2025 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const TabsMixin = (superClass) => class TabsMixinClass extends ResizeMixin(ListMixin(superClass)) {
  static get properties() {
    return {
      /**
       * Set tabs disposition. Possible values are `horizontal|vertical`
       * @type {!TabsOrientation}
       */
      orientation: {
        value: "horizontal",
        type: String,
        reflectToAttribute: true,
        sync: true
      },
      /**
       * The index of the selected tab.
       */
      selected: {
        value: 0,
        type: Number
      }
    };
  }
  static get observers() {
    return ["__tabsItemsChanged(items)"];
  }
  constructor() {
    super();
    this.__itemsResizeObserver = new ResizeObserver(() => {
      setTimeout(() => this._updateOverflow());
    });
  }
  /**
   * @return {number}
   * @protected
   */
  get _scrollOffset() {
    return this._vertical ? this._scrollerElement.offsetHeight : this._scrollerElement.offsetWidth;
  }
  /**
   * @return {!HTMLElement}
   * @protected
   * @override
   */
  get _scrollerElement() {
    return this.$.scroll;
  }
  /** @private */
  get __direction() {
    return !this._vertical && this.__isRTL ? 1 : -1;
  }
  /** @protected */
  ready() {
    super.ready();
    this._scrollerElement.addEventListener("scroll", () => this._updateOverflow());
    this.setAttribute("role", "tablist");
    afterNextRender(this, () => {
      this._updateOverflow();
    });
  }
  /**
   * @protected
   * @override
   */
  _onResize() {
    this._updateOverflow();
  }
  /** @private */
  __tabsItemsChanged(items) {
    this.__itemsResizeObserver.disconnect();
    (items || []).forEach((item2) => {
      this.__itemsResizeObserver.observe(item2);
    });
    this._updateOverflow();
  }
  /** @protected */
  _scrollForward() {
    const forwardButtonVisibleWidth = this._getNavigationButtonVisibleWidth("forward-button");
    const backButtonVisibleWidth = this._getNavigationButtonVisibleWidth("back-button");
    const scrollerRect = this._scrollerElement.getBoundingClientRect();
    const itemToScrollTo = [...this.items].reverse().find((item2) => this._isItemVisible(item2, forwardButtonVisibleWidth, backButtonVisibleWidth, scrollerRect));
    const itemRect = itemToScrollTo.getBoundingClientRect();
    const overflowIndicatorCompensation = 20;
    const totalCompensation = overflowIndicatorCompensation + this.shadowRoot.querySelector('[part="back-button"]').clientWidth;
    let scrollOffset;
    if (this.__isRTL) {
      const scrollerRightEdge = scrollerRect.right - totalCompensation;
      scrollOffset = itemRect.right - scrollerRightEdge;
    } else {
      const scrollerLeftEdge = scrollerRect.left + totalCompensation;
      scrollOffset = itemRect.left - scrollerLeftEdge;
    }
    if (-this.__direction * scrollOffset < 1) {
      scrollOffset = -this.__direction * (this._scrollOffset - totalCompensation);
    }
    this._scroll(scrollOffset);
  }
  /** @protected */
  _scrollBack() {
    const forwardButtonVisibleWidth = this._getNavigationButtonVisibleWidth("forward-button");
    const backButtonVisibleWidth = this._getNavigationButtonVisibleWidth("back-button");
    const scrollerRect = this._scrollerElement.getBoundingClientRect();
    const itemToScrollTo = this.items.find(
      (item2) => this._isItemVisible(item2, forwardButtonVisibleWidth, backButtonVisibleWidth, scrollerRect)
    );
    const itemRect = itemToScrollTo.getBoundingClientRect();
    const overflowIndicatorCompensation = 20;
    const totalCompensation = overflowIndicatorCompensation + this.shadowRoot.querySelector('[part="forward-button"]').clientWidth;
    let scrollOffset;
    if (this.__isRTL) {
      const scrollerLeftEdge = scrollerRect.left + totalCompensation;
      scrollOffset = itemRect.left - scrollerLeftEdge;
    } else {
      const scrollerRightEdge = scrollerRect.right - totalCompensation;
      scrollOffset = itemRect.right - scrollerRightEdge;
    }
    if (this.__direction * scrollOffset < 1) {
      scrollOffset = this.__direction * (this._scrollOffset - totalCompensation);
    }
    this._scroll(scrollOffset);
  }
  /** @private */
  _isItemVisible(item2, forwardButtonVisibleWidth, backButtonVisibleWidth, scrollerRect) {
    if (this._vertical) {
      throw new Error("Visibility check is only supported for horizontal tabs.");
    }
    const buttonOnTheRightWidth = this.__isRTL ? backButtonVisibleWidth : forwardButtonVisibleWidth;
    const buttonOnTheLeftWidth = this.__isRTL ? forwardButtonVisibleWidth : backButtonVisibleWidth;
    const scrollerRightEdge = scrollerRect.right - buttonOnTheRightWidth;
    const scrollerLeftEdge = scrollerRect.left + buttonOnTheLeftWidth;
    const itemRect = item2.getBoundingClientRect();
    return scrollerRightEdge > Math.floor(itemRect.left) && scrollerLeftEdge < Math.ceil(itemRect.right);
  }
  /** @private */
  _getNavigationButtonVisibleWidth(buttonPartName) {
    const navigationButton = this.shadowRoot.querySelector(`[part="${buttonPartName}"]`);
    if (window.getComputedStyle(navigationButton).opacity === "0") {
      return 0;
    }
    return navigationButton.clientWidth;
  }
  /** @private */
  _updateOverflow() {
    const scrollPosition = this._vertical ? this._scrollerElement.scrollTop : getNormalizedScrollLeft(this._scrollerElement, this.getAttribute("dir"));
    const scrollSize = this._vertical ? this._scrollerElement.scrollHeight : this._scrollerElement.scrollWidth;
    let overflow = Math.floor(scrollPosition) > 1 ? "start" : "";
    if (Math.ceil(scrollPosition) < Math.ceil(scrollSize - this._scrollOffset)) {
      overflow += " end";
    }
    if (this.__direction === 1) {
      overflow = overflow.replace(/start|end/giu, (matched) => {
        return matched === "start" ? "end" : "start";
      });
    }
    if (overflow) {
      this.setAttribute("overflow", overflow.trim());
    } else {
      this.removeAttribute("overflow");
    }
  }
};
/**
 * @license
 * Copyright (c) 2017 - 2025 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const tabsStyles = css`
  :host {
    display: flex;
    align-items: center;
  }

  :host([hidden]) {
    display: none !important;
  }

  :host([orientation='vertical']) {
    display: block;
  }

  :host([orientation='horizontal']) [part='tabs'] {
    flex-grow: 1;
    display: flex;
    align-self: stretch;
    overflow-x: auto;
    -webkit-overflow-scrolling: touch;
  }

  /* This seems more future-proof than \`overflow: -moz-scrollbars-none\` which is marked obsolete
         and is no longer guaranteed to work:
         https://developer.mozilla.org/en-US/docs/Web/CSS/overflow#Mozilla_Extensions */
  @-moz-document url-prefix() {
    :host([orientation='horizontal']) [part='tabs'] {
      overflow: hidden;
    }
  }

  :host([orientation='horizontal']) [part='tabs']::-webkit-scrollbar {
    display: none;
  }

  :host([orientation='vertical']) [part='tabs'] {
    height: 100%;
    overflow-y: auto;
    -webkit-overflow-scrolling: touch;
  }

  [part='back-button'],
  [part='forward-button'] {
    pointer-events: none;
    opacity: 0;
    cursor: default;
  }

  :host([overflow~='start']) [part='back-button'],
  :host([overflow~='end']) [part='forward-button'] {
    pointer-events: auto;
    opacity: 1;
  }

  [part='back-button']::after {
    content: '\\25C0';
  }

  [part='forward-button']::after {
    content: '\\25B6';
  }

  :host([orientation='vertical']) [part='back-button'],
  :host([orientation='vertical']) [part='forward-button'] {
    display: none;
  }

  /* RTL specific styles */

  :host([dir='rtl']) [part='back-button']::after {
    content: '\\25B6';
  }

  :host([dir='rtl']) [part='forward-button']::after {
    content: '\\25C0';
  }
`;
/**
 * @license
 * Copyright (c) 2017 - 2025 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
registerStyles$1("vaadin-tabs", tabsStyles, { moduleId: "vaadin-tabs-styles" });
class Tabs extends TabsMixin(ElementMixin(ThemableMixin(PolymerElement))) {
  static get template() {
    return html`
      <div on-click="_scrollBack" part="back-button" aria-hidden="true"></div>

      <div id="scroll" part="tabs">
        <slot></slot>
      </div>

      <div on-click="_scrollForward" part="forward-button" aria-hidden="true"></div>
    `;
  }
  static get is() {
    return "vaadin-tabs";
  }
}
defineCustomElement(Tabs);
const tabsheet$1 = css`
  :host {
    font-size: var(--lumo-font-size-m);
    line-height: var(--lumo-line-height-m);
    font-family: var(--lumo-font-family);
  }

  :host([theme~='bordered']) {
    border: 1px solid var(--lumo-contrast-20pct);
    border-radius: var(--lumo-border-radius-l);
  }

  [part='tabs-container'] {
    box-shadow: inset 0 -1px 0 0 var(--lumo-contrast-10pct);
    padding: var(--lumo-space-xs) var(--lumo-space-s);
    gap: var(--lumo-space-s);
  }

  ::slotted([slot='tabs']) {
    box-shadow: initial;
    margin: calc(var(--lumo-space-xs) * -1) calc(var(--lumo-space-s) * -1);
  }

  [part='content'] {
    padding: var(--lumo-space-s) var(--lumo-space-m);
    border-bottom-left-radius: inherit;
    border-bottom-right-radius: inherit;
  }

  :host([loading]) [part='content'] {
    display: flex;
    align-items: center;
    justify-content: center;
  }

  :host([theme~='no-padding']) [part='content'] {
    padding: 0;
  }
`;
registerStyles$1("vaadin-tabsheet", [tabsheet$1, loader], { moduleId: "lumo-tabsheet" });
/**
 * @license
 * Copyright (c) 2022 - 2025 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
class TabsheetScroller extends Scroller {
  static get is() {
    return "vaadin-tabsheet-scroller";
  }
}
defineCustomElement(TabsheetScroller);
/**
 * @license
 * Copyright (c) 2022 - 2025 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
class TabsSlotController extends SlotController {
  constructor(host) {
    super(host, "tabs");
    this.__tabsItemsChangedListener = this.__tabsItemsChangedListener.bind(this);
    this.__tabsSelectedChangedListener = this.__tabsSelectedChangedListener.bind(this);
    this.__tabIdObserver = new MutationObserver((mutations) => {
      mutations.forEach((mutation) => {
        const tab = mutation.target;
        host.__linkTabAndPanel(tab);
        if (tab.selected) {
          host.__togglePanels(tab);
        }
      });
    });
  }
  /** @private */
  __tabsItemsChangedListener() {
    this.__tabIdObserver.disconnect();
    const items = this.tabs.items || [];
    items.forEach((tab) => {
      this.__tabIdObserver.observe(tab, {
        attributeFilter: ["id"]
      });
    });
    this.host._setItems(items);
  }
  /** @private */
  __tabsSelectedChangedListener() {
    this.host.selected = this.tabs.selected;
  }
  initCustomNode(tabs) {
    if (!(tabs instanceof customElements.get("vaadin-tabs"))) {
      throw Error('The "tabs" slot of a <vaadin-tabsheet> must only contain a <vaadin-tabs> element!');
    }
    this.tabs = tabs;
    tabs.addEventListener("items-changed", this.__tabsItemsChangedListener);
    tabs.addEventListener("selected-changed", this.__tabsSelectedChangedListener);
    this.host.__tabs = tabs;
    this.host.stateTarget = tabs;
    this.__tabsItemsChangedListener();
  }
  teardownNode(tabs) {
    this.tabs = null;
    tabs.removeEventListener("items-changed", this.__tabsItemsChangedListener);
    tabs.removeEventListener("selected-changed", this.__tabsSelectedChangedListener);
    this.host.__tabs = null;
    this.host._setItems([]);
    this.host.stateTarget = void 0;
  }
}
const TabSheetMixin = (superClass) => class extends DelegateStateMixin(superClass) {
  static get properties() {
    return {
      /**
       * The list of `<vaadin-tab>`s from which a selection can be made.
       * It is populated from the elements passed inside the slotted
       * `<vaadin-tabs>`, and updated dynamically when adding or removing items.
       *
       * Note: unlike `<vaadin-combo-box>`, this property is read-only.
       * @type {!Array<!Tab> | undefined}
       */
      items: {
        type: Array,
        readOnly: true,
        notify: true
      },
      /**
       * The index of the selected tab.
       */
      selected: {
        value: 0,
        type: Number,
        notify: true
      },
      /**
       * The slotted <vaadin-tabs> element.
       */
      __tabs: {
        type: Object
      },
      /**
       * The panel elements.
       */
      __panels: {
        type: Array
      }
    };
  }
  static get observers() {
    return ["__itemsOrPanelsChanged(items, __panels)", "__selectedTabItemChanged(selected, items, __panels)"];
  }
  /** @override */
  static get delegateProps() {
    return ["selected", "_theme"];
  }
  /** @protected */
  ready() {
    super.ready();
    this.__overflowController = new OverflowController(this, this.shadowRoot.querySelector('[part="content"]'));
    this.addController(this.__overflowController);
    this._tabsSlotController = new TabsSlotController(this);
    this.addController(this._tabsSlotController);
    const panelSlot = this.shadowRoot.querySelector("#panel-slot");
    this.__panelsObserver = new SlotObserver(panelSlot, ({ addedNodes, removedNodes }) => {
      if (addedNodes.length) {
        addedNodes.forEach((node) => {
          if (node.nodeType === Node.ELEMENT_NODE && node.hidden) {
            node.__customHidden = true;
          }
        });
      }
      if (removedNodes.length) {
        removedNodes.forEach((node) => {
          if (node.nodeType === Node.ELEMENT_NODE && node.hidden) {
            if (node.__customHidden) {
              delete node.__customHidden;
            } else {
              node.hidden = false;
            }
          }
        });
      }
      this.__panels = Array.from(
        panelSlot.assignedNodes({
          flatten: true
        })
      ).filter((node) => node.nodeType === Node.ELEMENT_NODE);
    });
  }
  /**
   * Override method from `DelegateStateMixin` to set delegate `theme`
   * using attribute instead of property (needed for the Lit version).
   * @protected
   * @override
   */
  _delegateProperty(name, value) {
    if (!this.stateTarget) {
      return;
    }
    if (name === "_theme") {
      this._delegateAttribute("theme", value);
      return;
    }
    super._delegateProperty(name, value);
  }
  /**
   * An observer which applies the necessary roles and ARIA attributes
   * to associate the tab elements with the panels.
   * @private
   */
  __itemsOrPanelsChanged(items, panels) {
    if (!items || !panels) {
      return;
    }
    items.forEach((tabItem) => {
      this.__linkTabAndPanel(tabItem, panels);
    });
  }
  /**
   * An observer which toggles the visibility of the panels based on the selected tab.
   * @private
   */
  __selectedTabItemChanged(selected, items, panels) {
    if (!items || !panels || selected === void 0) {
      return;
    }
    this.__togglePanels(items[selected], panels);
  }
  /** @private */
  __togglePanels(selectedTab, panels = this.__panels) {
    const selectedTabId = selectedTab ? selectedTab.id : "";
    const selectedPanel = panels.find((panel) => panel.getAttribute("tab") === selectedTabId);
    const content = this.shadowRoot.querySelector('[part="content"]');
    this.toggleAttribute("loading", !selectedPanel);
    const hasOneVisiblePanel = panels.filter((panel) => !panel.hidden).length === 1;
    if (selectedPanel) {
      content.style.minHeight = "";
    } else if (hasOneVisiblePanel) {
      content.style.minHeight = `${content.offsetHeight}px`;
    }
    panels.forEach((panel) => {
      panel.hidden = panel !== selectedPanel;
    });
  }
  /** @private */
  __linkTabAndPanel(tab, panels = this.__panels) {
    const panel = panels.find((panel2) => panel2.getAttribute("tab") === tab.id);
    if (panel) {
      panel.role = "tabpanel";
      if (!panel.id) {
        panel.id = `tabsheet-panel-${generateUniqueId()}`;
      }
      panel.setAttribute("aria-labelledby", tab.id);
      tab.setAttribute("aria-controls", panel.id);
    }
  }
};
/**
 * @license
 * Copyright (c) 2022 - 2025 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
class TabSheet extends TabSheetMixin(ThemableMixin(ElementMixin(ControllerMixin(PolymerElement)))) {
  static get template() {
    return html`
      <style>
        :host([hidden]) {
          display: none !important;
        }

        :host {
          display: flex;
          flex-direction: column;
        }

        [part='tabs-container'] {
          position: relative;
          display: flex;
          align-items: center;
        }

        ::slotted([slot='tabs']) {
          flex: 1;
          align-self: stretch;
          min-width: 8em;
        }

        [part='content'] {
          position: relative;
          flex: 1;
          box-sizing: border-box;
        }
      </style>

      <div part="tabs-container">
        <slot name="prefix"></slot>
        <slot name="tabs"></slot>
        <slot name="suffix"></slot>
      </div>

      <vaadin-tabsheet-scroller part="content">
        <div part="loader"></div>
        <slot id="panel-slot"></slot>
      </vaadin-tabsheet-scroller>
    `;
  }
  static get is() {
    return "vaadin-tabsheet";
  }
}
defineCustomElement(TabSheet);
let memoizedTemplate;
class BigDecimalField extends TextField {
  static get template() {
    if (!memoizedTemplate) {
      memoizedTemplate = super.template.cloneNode(true);
      memoizedTemplate.innerHTML += `<style>
              :host {
                width: 8em;
              }

              :host([dir="rtl"]) [part="input-field"] {
                direction: ltr;
              }

              :host([dir="rtl"]) [part="input-field"] ::slotted(input) {
                --_lumo-text-field-overflow-mask-image: linear-gradient(to left, transparent, #000 1.25em) !important;
              }
        </style>`;
    }
    return memoizedTemplate;
  }
  static get is() {
    return "vaadin-big-decimal-field";
  }
  static get properties() {
    return {
      _decimalSeparator: {
        type: String,
        value: ".",
        observer: "__decimalSeparatorChanged"
      }
    };
  }
  ready() {
    super.ready();
    this.inputElement.setAttribute("inputmode", "decimal");
  }
  __decimalSeparatorChanged(separator, oldSeparator) {
    this.allowedCharPattern = "[-+\\d" + separator + "]";
    if (this.value && oldSeparator) {
      this.value = this.value.split(oldSeparator).join(separator);
    }
  }
}
defineCustomElement(BigDecimalField);
/**
 * @license
 * Copyright (c) 2021 - 2025 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const emailField = css`
  :host([dir='rtl']) [part='input-field'] ::slotted(input) {
    --_lumo-text-field-overflow-mask-image: linear-gradient(to left, transparent, #000 1.25em);
  }

  :host([dir='rtl']) [part='input-field'] ::slotted(input:placeholder-shown) {
    --_lumo-text-field-overflow-mask-image: none;
  }
`;
registerStyles$1("vaadin-email-field", [inputFieldShared$1, emailField], {
  moduleId: "lumo-email-field"
});
/**
 * @license
 * Copyright (c) 2021 - 2025 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const emailFieldStyles = css`
  :host([dir='rtl']) [part='input-field'] {
    direction: ltr;
  }

  :host([dir='rtl']) [part='input-field'] ::slotted(input)::placeholder {
    direction: rtl;
    text-align: left;
  }
`;
/**
 * @license
 * Copyright (c) 2021 - 2025 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
registerStyles$1("vaadin-email-field", emailFieldStyles, { moduleId: "vaadin-email-field-styles" });
class EmailField extends TextField {
  static get is() {
    return "vaadin-email-field";
  }
  constructor() {
    super();
    this._setType("email");
    this.pattern = "^[a-zA-Z0-9_\\-+]+(?:\\.[a-zA-Z0-9_\\-+]+)*@[a-zA-Z0-9\\-.]+\\.[a-zA-Z0-9\\-]{2,}$";
  }
  /** @protected */
  ready() {
    super.ready();
    if (this.inputElement) {
      this.inputElement.autocapitalize = "off";
    }
  }
}
defineCustomElement(EmailField);
/**
 * @license
 * Copyright (c) 2021 - 2025 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const numberField = css`
  :host([step-buttons-visible]:not([theme~='align-right'])) ::slotted(input) {
    text-align: center;
  }

  :host(:not([disabled])) [part$='button'][disabled] {
    opacity: 0.2;
  }

  :host([step-buttons-visible]) [part='input-field'] {
    padding: 0;
  }

  [part='decrease-button'],
  [part='increase-button'] {
    cursor: pointer;
    width: 1.5em;
    height: 1.5em;
  }

  [part='decrease-button']::before,
  [part='increase-button']::before {
    margin-top: 0.25em;
  }

  [part='decrease-button']::before {
    content: var(--lumo-icons-minus);
  }

  [part='increase-button']::before {
    content: var(--lumo-icons-plus);
  }

  /* RTL specific styles */
  :host([dir='rtl']:not([theme~='align-right'])) ::slotted(input) {
    --_lumo-text-field-overflow-mask-image: linear-gradient(to left, transparent, #000 1.25em);
  }
`;
registerStyles$1("vaadin-number-field", [inputFieldShared$1, numberField], {
  moduleId: "lumo-number-field"
});
/**
 * @license
 * Copyright (c) 2021 - 2025 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const BAD_INPUT_STRING = "NaN";
const NumberFieldMixin = (superClass) => class NumberFieldMixinClass extends InputFieldMixin(superClass) {
  static get properties() {
    return {
      /**
       * The minimum value of the field.
       */
      min: {
        type: Number
      },
      /**
       * The maximum value of the field.
       */
      max: {
        type: Number
      },
      /**
       * Specifies the allowed number intervals of the field.
       * @type {number}
       */
      step: {
        type: Number
      },
      /**
       * Set to true to show increase/decrease buttons.
       * @attr {boolean} step-buttons-visible
       */
      stepButtonsVisible: {
        type: Boolean,
        value: false,
        reflectToAttribute: true
      }
    };
  }
  static get observers() {
    return ["_stepChanged(step, inputElement)"];
  }
  static get delegateProps() {
    return [...super.delegateProps, "min", "max"];
  }
  static get constraints() {
    return [...super.constraints, "min", "max", "step"];
  }
  constructor() {
    super();
    this._setType("number");
    this.__onWheel = this.__onWheel.bind(this);
  }
  /** @protected */
  get slotStyles() {
    const tag = this.localName;
    return [
      `
          ${tag} input[type="number"]::-webkit-outer-spin-button,
          ${tag} input[type="number"]::-webkit-inner-spin-button {
            -webkit-appearance: none;
            margin: 0;
          }

          ${tag} input[type="number"] {
            -moz-appearance: textfield;
          }

          ${tag}[dir='rtl'] input[type="number"]::placeholder {
            direction: rtl;
          }

          ${tag}[dir='rtl']:not([step-buttons-visible]) input[type="number"]::placeholder {
            text-align: left;
          }
        `
    ];
  }
  /**
   * Used by `InputControlMixin` as a reference to the clear button element.
   * @protected
   */
  get clearElement() {
    return this.$.clearButton;
  }
  /**
   * Whether the input element's value is unparsable.
   *
   * @private
   */
  get __hasUnparsableValue() {
    return this._inputElementValue === BAD_INPUT_STRING;
  }
  /** @protected */
  ready() {
    super.ready();
    this.addController(
      new InputController(this, (input) => {
        this._setInputElement(input);
        this._setFocusElement(input);
        this.stateTarget = input;
        this.ariaTarget = input;
      })
    );
    this.addController(new LabelledInputController(this.inputElement, this._labelController));
    this._tooltipController = new TooltipController(this);
    this.addController(this._tooltipController);
    this._tooltipController.setPosition("top");
    this._tooltipController.setAriaTarget(this.inputElement);
  }
  /**
   * Override the method from `InputConstraintsMixin`
   * to enforce HTML constraint validation even if
   * the user didn't add any constraints explicitly:
   * the field has to be regardless checked for bad input.
   *
   * @override
   */
  checkValidity() {
    if (this.inputElement) {
      return this.inputElement.checkValidity();
    }
    return !this.invalid;
  }
  /**
   * Override the method from `InputMixin` to add
   * a wheel event listener to the input element.
   *
   * @param {HTMLElement} input
   * @override
   * @protected
   */
  _addInputListeners(input) {
    super._addInputListeners(input);
    input.addEventListener("wheel", this.__onWheel);
  }
  /**
   * Override the method from `InputMixin` to remove
   * the wheel event listener from the input element.
   *
   * @param {HTMLElement} input
   * @override
   * @protected
   */
  _removeInputListeners(input) {
    super._removeInputListeners(input);
    input.removeEventListener("wheel", this.__onWheel);
  }
  /**
   * Prevents default browser behavior for wheel events on the input element
   * when it's focused. More precisely, this prevents the browser from attempting
   * to increment or decrement the value when the mouse wheel is used within
   * the input element.
   *
   * CAVEAT: As a side-effect, this also prevents page scrolling when
   * the pointer is positioned over the field and the field is focused.
   *
   * @param {WheelEvent} event
   * @private
   */
  __onWheel(event) {
    if (this.hasAttribute("focused")) {
      event.preventDefault();
    }
  }
  /** @protected */
  _onDecreaseButtonTouchend(e2) {
    if (e2.cancelable) {
      e2.preventDefault();
      this.__blurActiveElement();
      this._decreaseValue();
    }
  }
  /** @protected */
  _onIncreaseButtonTouchend(e2) {
    if (e2.cancelable) {
      e2.preventDefault();
      this.__blurActiveElement();
      this._increaseValue();
    }
  }
  /** @private */
  __blurActiveElement() {
    const activeElement = getDeepActiveElement();
    if (activeElement && activeElement !== this.inputElement) {
      activeElement.blur();
    }
  }
  /** @protected */
  _onDecreaseButtonClick() {
    this._decreaseValue();
  }
  /** @protected */
  _onIncreaseButtonClick() {
    this._increaseValue();
  }
  /** @private */
  _decreaseValue() {
    this._incrementValue(-1);
  }
  /** @private */
  _increaseValue() {
    this._incrementValue(1);
  }
  /** @private */
  _incrementValue(incr) {
    if (this.disabled || this.readonly) {
      return;
    }
    const step = this.step || 1;
    let value = parseFloat(this.value);
    if (!this.value) {
      if (this.min === 0 && incr < 0 || this.max === 0 && incr > 0 || this.max === 0 && this.min === 0) {
        incr = 0;
        value = 0;
      } else if ((this.max == null || this.max >= 0) && (this.min == null || this.min <= 0)) {
        value = 0;
      } else if (this.min > 0) {
        value = this.min;
        if (this.max < 0 && incr < 0) {
          value = this.max;
        }
        incr = 0;
      } else if (this.max < 0) {
        value = this.max;
        if (incr < 0) {
          incr = 0;
        } else if (this._getIncrement(1, value - step) > this.max) {
          value -= 2 * step;
        } else {
          value -= step;
        }
      }
    } else if (value < this.min) {
      incr = 0;
      value = this.min;
    } else if (value > this.max) {
      incr = 0;
      value = this.max;
    }
    const newValue = this._getIncrement(incr, value);
    if (!this.value || incr === 0 || this._incrementIsInsideTheLimits(incr, value)) {
      this.inputElement.value = String(parseFloat(newValue));
      this.inputElement.dispatchEvent(new Event("input", { bubbles: true, composed: true }));
      this.__commitValueChange();
    }
  }
  /** @private */
  _getIncrement(incr, currentValue) {
    let step = this.step || 1, min = this.min || 0;
    const multiplier = Math.max(
      this._getMultiplier(currentValue),
      this._getMultiplier(step),
      this._getMultiplier(min)
    );
    step *= multiplier;
    currentValue = Math.round(currentValue * multiplier);
    min *= multiplier;
    const margin = (currentValue - min) % step;
    if (incr > 0) {
      return (currentValue - margin + step) / multiplier;
    } else if (incr < 0) {
      return (currentValue - (margin || step)) / multiplier;
    }
    return currentValue / multiplier;
  }
  /** @private */
  _getDecimalCount(number) {
    const s3 = String(number);
    const i2 = s3.indexOf(".");
    return i2 === -1 ? 1 : s3.length - i2 - 1;
  }
  /** @private */
  _getMultiplier(number) {
    if (!isNaN(number)) {
      return 10 ** this._getDecimalCount(number);
    }
  }
  /** @private */
  _incrementIsInsideTheLimits(incr, value) {
    if (incr < 0) {
      return this.min == null || this._getIncrement(incr, value) >= this.min;
    } else if (incr > 0) {
      return this.max == null || this._getIncrement(incr, value) <= this.max;
    }
    return this._getIncrement(incr, value) <= this.max && this._getIncrement(incr, value) >= this.min;
  }
  /** @protected */
  _isButtonEnabled(sign) {
    const incr = sign * (this.step || 1);
    const value = parseFloat(this.value);
    return !this.value || !this.disabled && this._incrementIsInsideTheLimits(incr, value);
  }
  /**
   * @param {number} step
   * @param {HTMLElement | undefined} inputElement
   * @protected
   */
  _stepChanged(step, inputElement) {
    if (inputElement) {
      inputElement.step = step || "any";
    }
  }
  /**
   * @param {unknown} newVal
   * @param {unknown} oldVal
   * @protected
   * @override
   */
  _valueChanged(newVal, oldVal) {
    if (newVal && isNaN(parseFloat(newVal))) {
      this.value = "";
    } else if (typeof this.value !== "string") {
      this.value = String(this.value);
    }
    super._valueChanged(this.value, oldVal);
    if (!this.__keepCommittedValue) {
      this.__committedValue = this.value;
      this.__committedUnparsableValueStatus = false;
    }
  }
  /**
   * Override an event listener from `InputControlMixin`
   * to avoid adding a separate listener.
   * @param {!KeyboardEvent} event
   * @protected
   * @override
   */
  _onKeyDown(event) {
    if (event.key === "ArrowUp") {
      event.preventDefault();
      this._increaseValue();
    } else if (event.key === "ArrowDown") {
      event.preventDefault();
      this._decreaseValue();
    }
    super._onKeyDown(event);
  }
  /**
   * Override this method from `InputMixin` to prevent
   * the value change caused by user input from being treated
   * as initiated programmatically by the developer and therefore
   * from getting silently committed by the value observer without
   * any change event. The value change will be committed later
   * on blur or Enter.
   *
   * @param {InputEvent} event
   * @override
   * @protected
   */
  _onInput(event) {
    this.__keepCommittedValue = true;
    super._onInput(event);
    this.__keepCommittedValue = false;
  }
  /**
   * Override this method from `InputControlMixin`
   * to stop propagation of the native change event.
   *
   * @param {Event}
   * @override
   * @protected
   */
  _onChange(event) {
    event.stopPropagation();
  }
  /**
   * Override this method from `ClearButtonMixin`
   * to properly commit the empty value since
   * the change handler doesn't do that anymore.
   *
   * @param {MouseEvent} event
   * @override
   * @protected
   */
  _onClearAction(event) {
    super._onClearAction(event);
    this.__commitValueChange();
  }
  /**
   * Override this method from `FocusMixin`
   * to commit a possible pending value change on blur.
   *
   * @param {boolean} focused
   * @override
   * @protected
   */
  _setFocused(focused) {
    super._setFocused(focused);
    if (!focused) {
      this.__commitValueChange();
    }
  }
  /**
   * Override this method from `KeyboardMixin`
   * to commit a possible pending value change on Enter.
   *
   * @param {KeyboardEvent} event
   * @override
   * @protected
   */
  _onEnter(event) {
    super._onEnter(event);
    this.__commitValueChange();
  }
  /**
   * Depending on the nature of the value change that has occurred since
   * the last commit attempt, triggers validation and fires an event:
   *
   * Value change             | Event
   * :------------------------|:------------------
   * empty => parsable        | change
   * empty => unparsable      | unparsable-change
   * parsable => empty        | change
   * parsable => parsable     | change
   * parsable => unparsable   | change
   * unparsable => empty      | unparsable-change
   * unparsable => parsable   | change
   * unparsable => unparsable | -
   *
   * Note, there is currently no way to detect unparsable => unparsable changes
   * because the browser doesn't provide access to unparsable values of native
   * [type=number] inputs.
   *
   * @private
   */
  __commitValueChange() {
    if (this.__committedValue !== this.value) {
      this._requestValidation();
      this.dispatchEvent(new CustomEvent("change", { bubbles: true }));
    } else if (this.__committedUnparsableValueStatus !== this.__hasUnparsableValue) {
      this._requestValidation();
      this.dispatchEvent(new CustomEvent("unparsable-change"));
    }
    this.__committedValue = this.value;
    this.__committedUnparsableValueStatus = this.__hasUnparsableValue;
  }
  /** @override */
  get _inputElementValue() {
    if (this.inputElement && this.inputElement.validity.badInput) {
      return BAD_INPUT_STRING;
    }
    return super._inputElementValue;
  }
  /** @override */
  set _inputElementValue(value) {
    super._inputElementValue = value;
  }
};
/**
 * @license
 * Copyright (c) 2021 - 2025 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const numberFieldStyles = css`
  :host([readonly]) [part$='button'] {
    pointer-events: none;
  }

  [part='decrease-button']::before {
    content: '\\2212';
  }

  [part='increase-button']::before {
    content: '+';
  }

  [part='decrease-button'],
  [part='increase-button'] {
    -webkit-user-select: none;
    user-select: none;
  }

  :host([dir='rtl']) [part='input-field'] {
    direction: ltr;
  }
`;
/**
 * @license
 * Copyright (c) 2021 - 2025 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
registerStyles$1("vaadin-number-field", [inputFieldShared, numberFieldStyles], {
  moduleId: "vaadin-number-field-styles"
});
class NumberField extends NumberFieldMixin(ThemableMixin(ElementMixin(PolymerElement))) {
  static get is() {
    return "vaadin-number-field";
  }
  static get template() {
    return html`
      <div class="vaadin-field-container">
        <div part="label">
          <slot name="label"></slot>
          <span part="required-indicator" aria-hidden="true" on-click="focus"></span>
        </div>

        <vaadin-input-container
          part="input-field"
          readonly="[[readonly]]"
          disabled="[[disabled]]"
          invalid="[[invalid]]"
          theme$="[[_theme]]"
        >
          <div
            disabled$="[[!_isButtonEnabled(-1, value, min, max, step)]]"
            part="decrease-button"
            on-click="_onDecreaseButtonClick"
            on-touchend="_onDecreaseButtonTouchend"
            hidden$="[[!stepButtonsVisible]]"
            aria-hidden="true"
            slot="prefix"
          ></div>
          <slot name="prefix" slot="prefix"></slot>
          <slot name="input"></slot>
          <slot name="suffix" slot="suffix"></slot>
          <div id="clearButton" part="clear-button" slot="suffix" aria-hidden="true"></div>
          <div
            disabled$="[[!_isButtonEnabled(1, value, min, max, step)]]"
            part="increase-button"
            on-click="_onIncreaseButtonClick"
            on-touchend="_onIncreaseButtonTouchend"
            hidden$="[[!stepButtonsVisible]]"
            aria-hidden="true"
            slot="suffix"
          ></div>
        </vaadin-input-container>

        <div part="helper-text">
          <slot name="helper"></slot>
        </div>

        <div part="error-message">
          <slot name="error-message"></slot>
        </div>
      </div>

      <slot name="tooltip"></slot>
    `;
  }
}
defineCustomElement(NumberField);
/**
 * @license
 * Copyright (c) 2021 - 2025 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
class IntegerField extends NumberField {
  static get is() {
    return "vaadin-integer-field";
  }
  constructor() {
    super();
    this.allowedCharPattern = "[-+\\d]";
  }
  /**
   * Override an observer from `InputMixin` to clear the value
   * when trying to type invalid characters.
   * @param {string | undefined} newVal
   * @param {string | undefined} oldVal
   * @protected
   * @override
   */
  _valueChanged(newVal, oldVal) {
    if (newVal !== "" && !this.__isInteger(newVal)) {
      console.warn(`Trying to set non-integer value "${newVal}" to <vaadin-integer-field>. Clearing the value.`);
      this.value = "";
      return;
    }
    super._valueChanged(newVal, oldVal);
  }
  /**
   * Override an observer from `NumberField` to reset the step
   * property when an invalid step is set.
   * @param {number} newVal
   * @param {HTMLElement | undefined} inputElement
   * @protected
   * @override
   */
  _stepChanged(step, inputElement) {
    if (step != null && !this.__hasOnlyDigits(step)) {
      console.warn(
        `<vaadin-integer-field> The \`step\` property must be a positive integer but \`${step}\` was provided, so the property was reset to \`null\`.`
      );
      this.step = null;
      return;
    }
    super._stepChanged(step, inputElement);
  }
  /** @private */
  __isInteger(value) {
    return /^(-\d)?\d*$/u.test(String(value));
  }
  /** @private */
  __hasOnlyDigits(value) {
    return /^\d+$/u.test(String(value));
  }
}
defineCustomElement(IntegerField);
/**
 * @license
 * Copyright 2020 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
class LiveDirective extends Directive {
  constructor(partInfo) {
    super(partInfo);
    if (!(partInfo.type === PartType.PROPERTY || partInfo.type === PartType.ATTRIBUTE || partInfo.type === PartType.BOOLEAN_ATTRIBUTE)) {
      throw new Error("The `live` directive is not allowed on child or event bindings");
    }
    if (!isSingleExpression(partInfo)) {
      throw new Error("`live` bindings can only contain a single expression");
    }
  }
  render(value) {
    return value;
  }
  update(part, [value]) {
    if (value === noChange || value === nothing) {
      return value;
    }
    const element = part.element;
    const name = part.name;
    if (part.type === PartType.PROPERTY) {
      if (value === element[name]) {
        return noChange;
      }
    } else if (part.type === PartType.BOOLEAN_ATTRIBUTE) {
      if (!!value === element.hasAttribute(name)) {
        return noChange;
      }
    } else if (part.type === PartType.ATTRIBUTE) {
      if (element.getAttribute(name) === String(value)) {
        return noChange;
      }
    }
    setCommittedValue(part);
    return value;
  }
}
const live = directive(LiveDirective);
const _window = window;
_window.Vaadin = _window.Vaadin || {};
_window.Vaadin.setLitRenderer = (component, rendererName, templateExpression, returnChannel, clientCallables, propertyNamespace, appId) => {
  const callablesCreator = (itemKey) => {
    return clientCallables.map((clientCallable) => (...args) => {
      if (itemKey !== void 0) {
        returnChannel(clientCallable, itemKey, args[0] instanceof Event ? [] : [...args]);
      }
    });
  };
  const fnArgs = [
    "html",
    "root",
    "live",
    "appId",
    "itemKey",
    "model",
    "item",
    "index",
    ...clientCallables,
    `return html\`${templateExpression}\``
  ];
  const htmlGenerator = new Function(...fnArgs);
  const renderFunction = (root2, model, itemKey) => {
    const { item: item2, index } = model;
    render(htmlGenerator(html$1, root2, live, appId, itemKey, model, item2, index, ...callablesCreator(itemKey)), root2);
  };
  const renderer = (root2, _, model) => {
    const { item: item2 } = model;
    if (root2.__litRenderer !== renderer) {
      root2.innerHTML = "";
      delete root2._$litPart$;
      root2.__litRenderer = renderer;
    }
    const mappedItem = {};
    for (const key in item2) {
      if (key.startsWith(propertyNamespace)) {
        mappedItem[key.replace(propertyNamespace, "")] = item2[key];
      }
    }
    renderFunction(root2, { ...model, item: mappedItem }, item2.key);
  };
  renderer.__rendererId = propertyNamespace;
  component[rendererName] = renderer;
};
_window.Vaadin.unsetLitRenderer = (component, rendererName, rendererId) => {
  if (component[rendererName]?.__rendererId === rendererId) {
    component[rendererName] = void 0;
  }
};
registerStyles$1(
  "vaadin-grid-tree-toggle",
  css`
    :host {
      --vaadin-grid-tree-toggle-level-offset: 2em;
      align-items: center;
      vertical-align: middle;
      transform: translateX(calc(var(--lumo-space-s) * -1));
      -webkit-tap-highlight-color: transparent;
    }

    :host(:not([leaf])) {
      cursor: default;
    }

    [part='toggle'] {
      display: inline-block;
      font-size: 1.5em;
      line-height: 1;
      width: 1em;
      height: 1em;
      text-align: center;
      color: var(--lumo-contrast-50pct);
      cursor: var(--lumo-clickable-cursor);
      /* Increase touch target area */
      padding: calc(1em / 3);
      margin: calc(1em / -3);
    }

    :host(:not([dir='rtl'])) [part='toggle'] {
      margin-right: 0;
    }

    @media (hover: hover) {
      :host(:hover) [part='toggle'] {
        color: var(--lumo-contrast-80pct);
      }
    }

    [part='toggle']::before {
      font-family: 'lumo-icons';
      display: inline-block;
      height: 100%;
    }

    :host(:not([expanded])) [part='toggle']::before {
      content: var(--lumo-icons-angle-right);
    }

    :host([expanded]) [part='toggle']::before {
      content: var(--lumo-icons-angle-right);
      transform: rotate(90deg);
    }

    /* Experimental support for hierarchy connectors, using an unsupported selector */
    :host([theme~='connectors']) #level-spacer {
      position: relative;
      z-index: -1;
      font-size: 1em;
      height: 1.5em;
    }

    :host([theme~='connectors']) #level-spacer::before {
      display: block;
      content: '';
      margin-top: calc(var(--lumo-space-m) * -1);
      height: calc(var(--lumo-space-m) + 3em);
      background-image: linear-gradient(
        to right,
        transparent calc(var(--vaadin-grid-tree-toggle-level-offset) - 1px),
        var(--lumo-contrast-10pct) calc(var(--vaadin-grid-tree-toggle-level-offset) - 1px)
      );
      background-size: var(--vaadin-grid-tree-toggle-level-offset) var(--vaadin-grid-tree-toggle-level-offset);
      background-position: calc(var(--vaadin-grid-tree-toggle-level-offset) / 2 - 2px) 0;
    }

    /* RTL specific styles */

    :host([dir='rtl']) {
      margin-left: 0;
      margin-right: calc(var(--lumo-space-s) * -1);
    }

    :host([dir='rtl']) [part='toggle'] {
      margin-left: 0;
    }

    :host([dir='rtl'][expanded]) [part='toggle']::before {
      transform: rotate(-90deg);
    }

    :host([dir='rtl'][theme~='connectors']) #level-spacer::before {
      background-image: linear-gradient(
        to left,
        transparent calc(var(--vaadin-grid-tree-toggle-level-offset) - 1px),
        var(--lumo-contrast-10pct) calc(var(--vaadin-grid-tree-toggle-level-offset) - 1px)
      );
      background-position: calc(100% - (var(--vaadin-grid-tree-toggle-level-offset) / 2 - 2px)) 0;
    }

    :host([dir='rtl']:not([expanded])) [part='toggle']::before,
    :host([dir='rtl'][expanded]) [part='toggle']::before {
      content: var(--lumo-icons-angle-left);
    }
  `,
  { moduleId: "lumo-grid-tree-toggle" }
);
/**
 * @license
 * Copyright (c) 2016 - 2025 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const template$2 = document.createElement("template");
template$2.innerHTML = `
  <style>
    @font-face {
      font-family: "vaadin-grid-tree-icons";
      src: url(data:application/font-woff;charset=utf-8;base64,d09GRgABAAAAAAQkAA0AAAAABrwAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAABGRlRNAAAECAAAABoAAAAcgHwa6EdERUYAAAPsAAAAHAAAAB4AJwAOT1MvMgAAAZQAAAA/AAAAYA8TBIJjbWFwAAAB8AAAAFUAAAFeGJvXWmdhc3AAAAPkAAAACAAAAAgAAAAQZ2x5ZgAAAlwAAABLAAAAhIrPOhFoZWFkAAABMAAAACsAAAA2DsJI02hoZWEAAAFcAAAAHQAAACQHAgPHaG10eAAAAdQAAAAZAAAAHAxVAgBsb2NhAAACSAAAABIAAAASAIAAVG1heHAAAAF8AAAAGAAAACAACgAFbmFtZQAAAqgAAAECAAACTwflzbdwb3N0AAADrAAAADYAAABZQ7Ajh3icY2BkYGAA4twv3Vfi+W2+MnCzMIDANSOmbGSa2YEZRHEwMIEoAAoiB6sAeJxjYGRgYD7w/wADAwsDCDA7MDAyoAI2AFEEAtIAAAB4nGNgZGBg4GBgZgDRDAxMDGgAAAGbABB4nGNgZp7JOIGBlYGBaSbTGQYGhn4IzfiawZiRkwEVMAqgCTA4MDA+38d84P8BBgdmIAapQZJVYGAEAGc/C54AeJxjYYAAxlAIzQTELAwMBxgZGB0ACy0BYwAAAHicY2BgYGaAYBkGRgYQiADyGMF8FgYbIM3FwMHABISMDArP9/3/+/8/WJXC8z0Q9v8nEp5gHVwMMMAIMo+RDYiZoQJMQIKJARUA7WBhGN4AACFKDtoAAAAAAAAAAAgACAAQABgAJgA0AEIAAHichYvBEYBADAKBVHBjBT4swl9KS2k05o0XHd/yW1hAfBFwCv9sIlJu3nZaNS3PXAaXXHI8Lge7DlzF7C1RgXc7xkK6+gvcD2URmQB4nK2RQWoCMRiFX3RUqtCli65yADModOMBLLgQSqHddRFnQghIAnEUvEA3vUUP0LP0Fj1G+yb8R5iEhO9/ef/7FwFwj28o9EthiVp4hBlehcfUP4Ur8o/wBAv8CU+xVFvhOR7UB7tUdUdlVRJ6HnHWTnhM/V24In8JT5j/KzzFSi2E53hUz7jCcrcIiDDwyKSW1JEct2HdIPH1DFytbUM0PofWdNk5E5oUqb/Q6HHBiVGZpfOXkyUMEj5IyBuNmYZQjBobfsuassvnkKLe1OuBBj0VQ8cRni2xjLWsHaM0jrjx3peYA0/vrdmUYqe9iy7bzrX6eNP7Jh1SijX+AaUVbB8AAHicY2BiwA84GBgYmRiYGJkZmBlZGFkZ2djScyoLMgzZS/MyDQwMwLSruZMzlHaB0q4A76kLlwAAAAEAAf//AA94nGNgZGBg4AFiMSBmYmAEQnYgZgHzGAAD6wA2eJxjYGBgZACCKxJigiD6mhFTNowGACmcA/8AAA==) format('woff');
      font-weight: normal;
      font-style: normal;
    }
  </style>
`;
document.head.appendChild(template$2.content);
registerStyles$1(
  "vaadin-grid-tree-toggle",
  css`
    :host {
      display: inline-flex;
      align-items: baseline;
      max-width: 100%;

      /* CSS API for :host */
      --vaadin-grid-tree-toggle-level-offset: 1em;
      --_collapsed-icon: '\\e7be\\00a0';
    }

    :host([dir='rtl']) {
      --_collapsed-icon: '\\e7bd\\00a0';
    }

    :host([hidden]) {
      display: none !important;
    }

    :host(:not([leaf])) {
      cursor: pointer;
    }

    #level-spacer,
    [part='toggle'] {
      flex: none;
    }

    #level-spacer {
      display: inline-block;
      width: calc(var(--_level, '0') * var(--vaadin-grid-tree-toggle-level-offset));
    }

    [part='toggle']::before {
      font-family: 'vaadin-grid-tree-icons';
      line-height: 1em; /* make icon font metrics not affect baseline */
    }

    :host(:not([expanded])) [part='toggle']::before {
      content: var(--_collapsed-icon);
    }

    :host([expanded]) [part='toggle']::before {
      content: '\\e7bc\\00a0'; /* icon glyph + single non-breaking space */
    }

    :host([leaf]) [part='toggle'] {
      visibility: hidden;
    }

    slot {
      display: block;
      overflow: hidden;
      text-overflow: ellipsis;
    }
  `,
  { moduleId: "vaadin-grid-tree-toggle-styles" }
);
const GridTreeToggleMixin = (superClass) => class extends superClass {
  static get properties() {
    return {
      /**
       * Current level of the tree represented with a horizontal offset
       * of the toggle button.
       * @type {number}
       */
      level: {
        type: Number,
        value: 0,
        observer: "_levelChanged",
        sync: true
      },
      /**
       * Hides the toggle icon and disables toggling a tree sublevel.
       * @type {boolean}
       */
      leaf: {
        type: Boolean,
        value: false,
        reflectToAttribute: true
      },
      /**
       * Sublevel toggle state.
       * @type {boolean}
       */
      expanded: {
        type: Boolean,
        value: false,
        reflectToAttribute: true,
        notify: true,
        sync: true
      }
    };
  }
  constructor() {
    super();
    this.addEventListener("click", (e2) => this._onClick(e2));
  }
  /** @private */
  _onClick(e2) {
    if (this.leaf) {
      return;
    }
    if (isFocusable(e2.target) || e2.target instanceof HTMLLabelElement) {
      return;
    }
    e2.preventDefault();
    this.expanded = !this.expanded;
  }
  /** @private */
  _levelChanged(level) {
    const value = Number(level).toString();
    this.style.setProperty("--_level", value);
  }
};
/**
 * @license
 * Copyright (c) 2016 - 2025 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
class GridTreeToggle extends GridTreeToggleMixin(ThemableMixin(DirMixin(PolymerElement))) {
  static get is() {
    return "vaadin-grid-tree-toggle";
  }
  static get template() {
    return html`
      <span id="level-spacer"></span>
      <span part="toggle"></span>
      <slot></slot>
    `;
  }
}
defineCustomElement(GridTreeToggle);
registerStyles$1(
  "vaadin-upload",
  css`
    :host {
      line-height: var(--lumo-line-height-m);
    }

    :host(:not([nodrop])) {
      overflow: hidden;
      border: 1px dashed var(--lumo-contrast-20pct);
      border-radius: var(--lumo-border-radius-l);
      padding: var(--lumo-space-m);
      transition:
        background-color 0.6s,
        border-color 0.6s;
    }

    [part='drop-label'] {
      display: inline-block;
      white-space: normal;
      padding: 0 var(--lumo-space-s);
      color: var(--lumo-secondary-text-color);
      font-family: var(--lumo-font-family);
    }

    :host([dragover-valid]) {
      border-color: var(--lumo-primary-color-50pct);
      background: var(--lumo-primary-color-10pct);
      transition:
        background-color 0.1s,
        border-color 0.1s;
    }

    :host([dragover-valid]) [part='drop-label'] {
      color: var(--lumo-primary-text-color);
    }

    :host([disabled]) [part='drop-label'],
    :host([max-files-reached]) [part='drop-label'] {
      color: var(--lumo-disabled-text-color);
    }
  `,
  { moduleId: "lumo-upload" }
);
registerStyles$1(
  "vaadin-upload-icon",
  css`
    :host::before {
      content: var(--lumo-icons-upload);
      font-family: lumo-icons;
      font-size: var(--lumo-icon-size-m);
      line-height: 1;
      vertical-align: -0.25em;
    }
  `,
  { moduleId: "lumo-upload-icon" }
);
registerStyles$1(
  "vaadin-upload-file-list",
  css`
    ::slotted(li:not(:first-of-type)) {
      border-top: 1px solid var(--lumo-contrast-10pct);
    }
  `,
  { moduleId: "lumo-upload-file-list" }
);
const uploadFile = css`
  :host {
    padding: var(--lumo-space-s) 0;
    outline: none;
    --_focus-ring-color: var(--vaadin-focus-ring-color, var(--lumo-primary-color-50pct));
    --_focus-ring-width: var(--vaadin-focus-ring-width, 2px);
  }

  :host([focus-ring]) [part='row'] {
    border-radius: var(--lumo-border-radius-s);
    box-shadow: 0 0 0 var(--_focus-ring-width) var(--_focus-ring-color);
  }

  [part='row'] {
    display: flex;
    align-items: baseline;
    justify-content: space-between;
  }

  [part='status'],
  [part='error'] {
    color: var(--lumo-secondary-text-color);
    font-size: var(--lumo-font-size-s);
  }

  [part='info'] {
    display: flex;
    align-items: baseline;
    flex: auto;
  }

  [part='meta'] {
    width: 0.001px;
    flex: 1 1 auto;
  }

  [part='name'] {
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
  }

  [part='commands'] {
    display: flex;
    align-items: baseline;
    flex: none;
  }

  [part$='icon'] {
    margin-right: var(--lumo-space-xs);
    font-size: var(--lumo-icon-size-m);
    font-family: 'lumo-icons';
    line-height: 1;
  }

  /* When both icons are hidden, let us keep space for one */
  [part='done-icon'][hidden] + [part='warning-icon'][hidden] {
    display: block !important;
    visibility: hidden;
  }

  [part$='button'] {
    flex: none;
    margin-left: var(--lumo-space-xs);
    cursor: var(--lumo-clickable-cursor);
  }

  [part$='button']:focus {
    outline: none;
    border-radius: var(--lumo-border-radius-s);
    box-shadow: 0 0 0 var(--_focus-ring-width) var(--_focus-ring-color);
  }

  [part$='icon']::before,
  [part$='button']::before {
    vertical-align: -0.25em;
  }

  [part='done-icon']::before {
    content: var(--lumo-icons-checkmark);
    color: var(--lumo-primary-text-color);
  }

  [part='warning-icon']::before {
    content: var(--lumo-icons-error);
    color: var(--lumo-error-text-color);
  }

  [part='start-button']::before {
    content: var(--lumo-icons-play);
  }

  [part='retry-button']::before {
    content: var(--lumo-icons-reload);
  }

  [part='remove-button']::before {
    content: var(--lumo-icons-cross);
  }

  [part='error'] {
    color: var(--lumo-error-text-color);
  }

  ::slotted([slot='progress']) {
    width: auto;
    margin-left: calc(var(--lumo-icon-size-m) + var(--lumo-space-xs));
    margin-right: calc(var(--lumo-icon-size-m) + var(--lumo-space-xs));
  }
`;
registerStyles$1("vaadin-upload-file", [fieldButton, uploadFile], { moduleId: "lumo-upload-file" });
/**
 * @license
 * Copyright (c) 2016 - 2025 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
class UploadIcon extends ThemableMixin(PolymerElement) {
  static get is() {
    return "vaadin-upload-icon";
  }
  static get template() {
    return html`
      <style>
        :host {
          display: inline-block;
        }

        :host([hidden]) {
          display: none !important;
        }
      </style>
    `;
  }
}
defineCustomElement(UploadIcon);
/**
 * @license
 * Copyright (c) 2016 - 2025 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const template$1 = document.createElement("template");
template$1.innerHTML = `
  <style>
    @font-face {
      font-family: 'vaadin-upload-icons';
      src: url(data:application/font-woff;charset=utf-8;base64,d09GRgABAAAAAAasAAsAAAAABmAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAABPUy8yAAABCAAAAGAAAABgDxIF5mNtYXAAAAFoAAAAVAAAAFQXVtKMZ2FzcAAAAbwAAAAIAAAACAAAABBnbHlmAAABxAAAAfQAAAH0bBJxYWhlYWQAAAO4AAAANgAAADYPD267aGhlYQAAA/AAAAAkAAAAJAfCA8tobXR4AAAEFAAAACgAAAAoHgAAx2xvY2EAAAQ8AAAAFgAAABYCSgHsbWF4cAAABFQAAAAgAAAAIAAOADVuYW1lAAAEdAAAAhYAAAIWmmcHf3Bvc3QAAAaMAAAAIAAAACAAAwAAAAMDtwGQAAUAAAKZAswAAACPApkCzAAAAesAMwEJAAAAAAAAAAAAAAAAAAAAARAAAAAAAAAAAAAAAAAAAAAAQAAA6QUDwP/AAEADwABAAAAAAQAAAAAAAAAAAAAAIAAAAAAAAwAAAAMAAAAcAAEAAwAAABwAAwABAAAAHAAEADgAAAAKAAgAAgACAAEAIOkF//3//wAAAAAAIOkA//3//wAB/+MXBAADAAEAAAAAAAAAAAAAAAEAAf//AA8AAQAAAAAAAAAAAAIAADc5AQAAAAABAAAAAAAAAAAAAgAANzkBAAAAAAEAAAAAAAAAAAACAAA3OQEAAAAAAgAA/8AEAAPAABkAMgAAEz4DMzIeAhczLgMjIg4CBycRIScFIRcOAyMiLgInIx4DMzI+AjcXphZGWmo6SH9kQwyADFiGrmJIhXJbIEYBAFoDWv76YBZGXGw8Rn5lRQyADFmIrWBIhHReIkYCWjJVPSIyVnVDXqN5RiVEYTxG/wBa2loyVT0iMlZ1Q16jeUYnRWE5RgAAAAABAIAAAAOAA4AAAgAAExEBgAMAA4D8gAHAAAAAAwAAAAAEAAOAAAIADgASAAAJASElIiY1NDYzMhYVFAYnETMRAgD+AAQA/gAdIyMdHSMjXYADgPyAgCMdHSMjHR0jwAEA/wAAAQANADMD5gNaAAUAACUBNwUBFwHT/jptATMBppMzAU2a4AIgdAAAAAEAOv/6A8YDhgALAAABJwkBBwkBFwkBNwEDxoz+xv7GjAFA/sCMAToBOoz+wAL6jP7AAUCM/sb+xowBQP7AjAE6AAAAAwAA/8AEAAPAAAcACwASAAABFSE1IREhEQEjNTMJAjMRIRECwP6A/sAEAP0AgIACQP7A/sDAAQABQICA/oABgP8AgAHAAUD+wP6AAYAAAAABAAAAAQAAdhiEdV8PPPUACwQAAAAAANX4FR8AAAAA1fgVHwAA/8AEAAPAAAAACAACAAAAAAAAAAEAAAPA/8AAAAQAAAAAAAQAAAEAAAAAAAAAAAAAAAAAAAAKBAAAAAAAAAAAAAAAAgAAAAQAAAAEAACABAAAAAQAAA0EAAA6BAAAAAAAAAAACgAUAB4AagB4AJwAsADSAPoAAAABAAAACgAzAAMAAAAAAAIAAAAAAAAAAAAAAAAAAAAAAAAADgCuAAEAAAAAAAEAEwAAAAEAAAAAAAIABwDMAAEAAAAAAAMAEwBaAAEAAAAAAAQAEwDhAAEAAAAAAAUACwA5AAEAAAAAAAYAEwCTAAEAAAAAAAoAGgEaAAMAAQQJAAEAJgATAAMAAQQJAAIADgDTAAMAAQQJAAMAJgBtAAMAAQQJAAQAJgD0AAMAAQQJAAUAFgBEAAMAAQQJAAYAJgCmAAMAAQQJAAoANAE0dmFhZGluLXVwbG9hZC1pY29ucwB2AGEAYQBkAGkAbgAtAHUAcABsAG8AYQBkAC0AaQBjAG8AbgBzVmVyc2lvbiAxLjAAVgBlAHIAcwBpAG8AbgAgADEALgAwdmFhZGluLXVwbG9hZC1pY29ucwB2AGEAYQBkAGkAbgAtAHUAcABsAG8AYQBkAC0AaQBjAG8AbgBzdmFhZGluLXVwbG9hZC1pY29ucwB2AGEAYQBkAGkAbgAtAHUAcABsAG8AYQBkAC0AaQBjAG8AbgBzUmVndWxhcgBSAGUAZwB1AGwAYQBydmFhZGluLXVwbG9hZC1pY29ucwB2AGEAYQBkAGkAbgAtAHUAcABsAG8AYQBkAC0AaQBjAG8AbgBzRm9udCBnZW5lcmF0ZWQgYnkgSWNvTW9vbi4ARgBvAG4AdAAgAGcAZQBuAGUAcgBhAHQAZQBkACAAYgB5ACAASQBjAG8ATQBvAG8AbgAuAAAAAwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA==) format('woff');
      font-weight: normal;
      font-style: normal;
    }
  </style>
`;
document.head.appendChild(template$1.content);
/**
 * @license
 * Copyright (c) 2016 - 2025 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const UploadFileMixin = (superClass) => class UploadFileMixin extends FocusMixin(superClass) {
  static get properties() {
    return {
      /**
       * If true, the user cannot interact with this element.
       */
      disabled: {
        type: Boolean,
        value: false,
        reflectToAttribute: true
      },
      /**
       * True if uploading is completed, false otherwise.
       */
      complete: {
        type: Boolean,
        value: false,
        reflectToAttribute: true
      },
      /**
       * Error message returned by the server, if any.
       */
      errorMessage: {
        type: String,
        value: "",
        observer: "_errorMessageChanged"
      },
      /**
       * The object representing a file.
       */
      file: {
        type: Object
      },
      /**
       * Name of the uploading file.
       */
      fileName: {
        type: String
      },
      /**
       * True if uploading is not started, false otherwise.
       */
      held: {
        type: Boolean,
        value: false
      },
      /**
       * True if remaining time is unknown, false otherwise.
       */
      indeterminate: {
        type: Boolean,
        value: false,
        reflectToAttribute: true
      },
      /**
       * The object used to localize this component.
       */
      i18n: {
        type: Object
      },
      /**
       * Number representing the uploading progress.
       */
      progress: {
        type: Number
      },
      /**
       * Uploading status.
       */
      status: {
        type: String
      },
      /**
       * Indicates whether the element can be focused and where it participates in sequential keyboard navigation.
       * @protected
       */
      tabindex: {
        type: Number,
        value: 0
      },
      /**
       * True if uploading is in progress, false otherwise.
       */
      uploading: {
        type: Boolean,
        value: false,
        reflectToAttribute: true
      },
      /** @private */
      _progress: {
        type: Object
      }
    };
  }
  static get observers() {
    return ["__updateTabindex(tabindex, disabled)", "__updateProgress(_progress, progress, indeterminate)"];
  }
  /** @protected */
  ready() {
    super.ready();
    this.addController(
      new SlotController(this, "progress", "vaadin-progress-bar", {
        initializer: (progress) => {
          this._progress = progress;
        }
      })
    );
    this.shadowRoot.addEventListener("focusin", (e2) => {
      const target = e2.composedPath()[0];
      if (target.getAttribute("part").endsWith("button")) {
        this._setFocused(false);
      }
    });
    this.shadowRoot.addEventListener("focusout", (e2) => {
      if (e2.relatedTarget === this) {
        this._setFocused(true);
      }
    });
  }
  /**
   * Override method inherited from `FocusMixin` to mark the file as focused
   * only when the host is focused.
   * @param {Event} event
   * @return {boolean}
   * @protected
   */
  _shouldSetFocus(event) {
    return event.composedPath()[0] === this;
  }
  /** @private */
  __disabledChanged(disabled) {
    if (disabled) {
      this.removeAttribute("tabindex");
    } else {
      this.setAttribute("tabindex", this.tabindex);
    }
  }
  /** @private */
  _errorMessageChanged(errorMessage) {
    this.toggleAttribute("error", Boolean(errorMessage));
  }
  /** @private */
  __updateTabindex(tabindex, disabled) {
    if (disabled) {
      this.removeAttribute("tabindex");
    } else {
      this.setAttribute("tabindex", tabindex);
    }
  }
  /** @private */
  __updateProgress(progress, value, indeterminate) {
    if (progress) {
      progress.value = isNaN(value) ? 0 : value / 100;
      progress.indeterminate = indeterminate;
    }
  }
  /** @private */
  _fireFileEvent(e2) {
    e2.preventDefault();
    return this.dispatchEvent(
      new CustomEvent(e2.target.getAttribute("file-event"), {
        detail: { file: this.file },
        bubbles: true,
        composed: true
      })
    );
  }
};
/**
 * @license
 * Copyright (c) 2016 - 2025 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const uploadFileStyles = css`
  :host {
    display: block;
  }

  [hidden] {
    display: none;
  }

  [part='row'] {
    list-style-type: none;
  }

  button {
    background: transparent;
    padding: 0;
    border: none;
    box-shadow: none;
  }

  :host([complete]) ::slotted([slot='progress']),
  :host([error]) ::slotted([slot='progress']) {
    display: none !important;
  }
`;
/**
 * @license
 * Copyright (c) 2016 - 2025 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
registerStyles$1("vaadin-upload-file", uploadFileStyles, { moduleId: "vaadin-upload-file-styles" });
class UploadFile extends UploadFileMixin(ThemableMixin(ControllerMixin(PolymerElement))) {
  static get template() {
    return html`
      <div part="row">
        <div part="info">
          <div part="done-icon" hidden$="[[!complete]]" aria-hidden="true"></div>
          <div part="warning-icon" hidden$="[[!errorMessage]]" aria-hidden="true"></div>

          <div part="meta">
            <div part="name" id="name">[[fileName]]</div>
            <div part="status" hidden$="[[!status]]" id="status">[[status]]</div>
            <div part="error" id="error" hidden$="[[!errorMessage]]">[[errorMessage]]</div>
          </div>
        </div>
        <div part="commands">
          <button
            type="button"
            part="start-button"
            file-event="file-start"
            on-click="_fireFileEvent"
            hidden$="[[!held]]"
            disabled$="[[disabled]]"
            aria-label$="[[i18n.file.start]]"
            aria-describedby="name"
          ></button>
          <button
            type="button"
            part="retry-button"
            file-event="file-retry"
            on-click="_fireFileEvent"
            hidden$="[[!errorMessage]]"
            disabled$="[[disabled]]"
            aria-label$="[[i18n.file.retry]]"
            aria-describedby="name"
          ></button>
          <button
            type="button"
            part="remove-button"
            file-event="file-abort"
            on-click="_fireFileEvent"
            disabled$="[[disabled]]"
            aria-label$="[[i18n.file.remove]]"
            aria-describedby="name"
          ></button>
        </div>
      </div>

      <slot name="progress"></slot>
    `;
  }
  static get is() {
    return "vaadin-upload-file";
  }
  /**
   * Fired when the retry button is pressed. It is listened by `vaadin-upload`
   * which will start a new upload process of this file.
   *
   * @event file-retry
   * @param {Object} detail
   * @param {Object} detail.file file to retry upload of
   */
  /**
   * Fired when the start button is pressed. It is listened by `vaadin-upload`
   * which will start a new upload process of this file.
   *
   * @event file-start
   * @param {Object} detail
   * @param {Object} detail.file file to start upload of
   */
  /**
   * Fired when abort button is pressed. It is listened by `vaadin-upload` which
   * will abort the upload in progress, and then remove the file from the list.
   *
   * @event file-abort
   * @param {Object} detail
   * @param {Object} detail.file file to abort upload of
   */
}
defineCustomElement(UploadFile);
/**
 * @license
 * Copyright (c) 2016 - 2025 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const UploadFileListMixin = (superClass) => class UploadFileListMixin extends superClass {
  static get properties() {
    return {
      /**
       * The array of files being processed, or already uploaded.
       */
      items: {
        type: Array
      },
      /**
       * The object used to localize upload files.
       */
      i18n: {
        type: Object
      },
      /**
       * If true, the user cannot interact with this element.
       */
      disabled: {
        type: Boolean,
        value: false,
        reflectToAttribute: true
      }
    };
  }
  static get observers() {
    return ["__updateItems(items, i18n, disabled)"];
  }
  /** @private */
  __updateItems(items, i18n) {
    if (items && i18n) {
      this.requestContentUpdate();
    }
  }
  /**
   * Requests an update for the `vaadin-upload-file` elements.
   *
   * It is not guaranteed that the update happens immediately (synchronously) after it is requested.
   */
  requestContentUpdate() {
    const { items, i18n, disabled } = this;
    render(
      html$1`
          ${items.map(
        (file) => html$1`
              <li>
                <vaadin-upload-file
                  .disabled="${disabled}"
                  .file="${file}"
                  .complete="${file.complete}"
                  .errorMessage="${file.error}"
                  .fileName="${file.name}"
                  .held="${file.held}"
                  .indeterminate="${file.indeterminate}"
                  .progress="${file.progress}"
                  .status="${file.status}"
                  .uploading="${file.uploading}"
                  .i18n="${i18n}"
                ></vaadin-upload-file>
              </li>
            `
      )}
        `,
      this
    );
  }
};
/**
 * @license
 * Copyright (c) 2016 - 2025 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
class UploadFileList extends UploadFileListMixin(ThemableMixin(PolymerElement)) {
  static get is() {
    return "vaadin-upload-file-list";
  }
  static get template() {
    return html`
      <style>
        :host {
          display: block;
        }

        :host([hidden]) {
          display: none !important;
        }

        [part='list'] {
          padding: 0;
          margin: 0;
          list-style-type: none;
        }
      </style>
      <ul part="list">
        <slot></slot>
      </ul>
    `;
  }
}
defineCustomElement(UploadFileList);
/**
 * @license
 * Copyright (c) 2016 - 2025 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
class AddButtonController extends SlotController {
  constructor(host) {
    super(host, "add-button", "vaadin-button");
  }
  /**
   * Override method inherited from `SlotController`
   * to add listeners to default and custom node.
   *
   * @param {Node} node
   * @protected
   * @override
   */
  initNode(node) {
    if (node._isDefault) {
      this.defaultNode = node;
    }
    node.addEventListener("touchend", (e2) => {
      this.host._onAddFilesTouchEnd(e2);
    });
    node.addEventListener("click", (e2) => {
      this.host._onAddFilesClick(e2);
    });
    this.host._addButton = node;
  }
}
class DropLabelController extends SlotController {
  constructor(host) {
    super(host, "drop-label", "span");
  }
  /**
   * Override method inherited from `SlotController`
   * to add listeners to default and custom node.
   *
   * @param {Node} node
   * @protected
   * @override
   */
  initNode(node) {
    if (node._isDefault) {
      this.defaultNode = node;
    }
    this.host._dropLabel = node;
  }
}
const UploadMixin = (superClass) => class UploadMixin extends superClass {
  static get properties() {
    return {
      /**
       * If true, the user cannot interact with this element.
       * @type {boolean}
       */
      disabled: {
        type: Boolean,
        value: false,
        reflectToAttribute: true
      },
      /**
       * Define whether the element supports dropping files on it for uploading.
       * By default it's enabled in desktop and disabled in touch devices
       * because mobile devices do not support drag events in general. Setting
       * it false means that drop is enabled even in touch-devices, and true
       * disables drop in all devices.
       *
       * @type {boolean}
       * @default true in touch-devices, false otherwise.
       */
      nodrop: {
        type: Boolean,
        reflectToAttribute: true,
        value: isTouch
      },
      /**
       * The server URL. The default value is an empty string, which means that
       * _window.location_ will be used.
       * @type {string}
       */
      target: {
        type: String,
        value: ""
      },
      /**
       * HTTP Method used to send the files. Only POST and PUT are allowed.
       * @type {!UploadMethod}
       */
      method: {
        type: String,
        value: "POST"
      },
      /**
       * Key-Value map to send to the server. If you set this property as an
       * attribute, use a valid JSON string, for example:
       * ```
       * <vaadin-upload headers='{"X-Foo": "Bar"}'></vaadin-upload>
       * ```
       * @type {object | string}
       */
      headers: {
        type: Object,
        value: {}
      },
      /**
       * Max time in milliseconds for the entire upload process, if exceeded the
       * request will be aborted. Zero means that there is no timeout.
       * @type {number}
       */
      timeout: {
        type: Number,
        value: 0
      },
      /** @private */
      _dragover: {
        type: Boolean,
        value: false,
        observer: "_dragoverChanged"
      },
      /**
       * The array of files being processed, or already uploaded.
       *
       * Each element is a [`File`](https://developer.mozilla.org/en-US/docs/Web/API/File)
       * object with a number of extra properties  to track the upload process:
       * - `uploadTarget`: The target URL used to upload this file.
       * - `elapsed`: Elapsed time since the upload started.
       * - `elapsedStr`: Human-readable elapsed time.
       * - `remaining`: Number of seconds remaining for the upload to finish.
       * - `remainingStr`: Human-readable remaining time for the upload to finish.
       * - `progress`: Percentage of the file already uploaded.
       * - `speed`: Upload speed in kB/s.
       * - `size`: File size in bytes.
       * - `totalStr`: Human-readable total size of the file.
       * - `loaded`: Bytes transferred so far.
       * - `loadedStr`: Human-readable uploaded size at the moment.
       * - `status`: Status of the upload process.
       * - `error`: Error message in case the upload failed.
       * - `abort`: True if the file was canceled by the user.
       * - `complete`: True when the file was transferred to the server.
       * - `uploading`: True while transferring data to the server.
       * @type {!Array<!UploadFile>}
       */
      files: {
        type: Array,
        notify: true,
        value: () => [],
        sync: true
      },
      /**
       * Limit of files to upload, by default it is unlimited. If the value is
       * set to one, native file browser will prevent selecting multiple files.
       * @attr {number} max-files
       * @type {number}
       */
      maxFiles: {
        type: Number,
        value: Infinity,
        sync: true
      },
      /**
       * Specifies if the maximum number of files have been uploaded
       * @attr {boolean} max-files-reached
       * @type {boolean}
       */
      maxFilesReached: {
        type: Boolean,
        value: false,
        notify: true,
        readOnly: true,
        reflectToAttribute: true
      },
      /**
       * Specifies the types of files that the server accepts.
       * Syntax: a comma-separated list of MIME type patterns (wildcards are
       * allowed) or file extensions.
       * Notice that MIME types are widely supported, while file extensions
       * are only implemented in certain browsers, so avoid using it.
       * Example: accept="video/*,image/tiff" or accept=".pdf,audio/mp3"
       * @type {string}
       */
      accept: {
        type: String,
        value: ""
      },
      /**
       * Specifies the maximum file size in bytes allowed to upload.
       * Notice that it is a client-side constraint, which will be checked before
       * sending the request. Obviously you need to do the same validation in
       * the server-side and be sure that they are aligned.
       * @attr {number} max-file-size
       * @type {number}
       */
      maxFileSize: {
        type: Number,
        value: Infinity
      },
      /**
       * Specifies if the dragover is validated with maxFiles and
       * accept properties.
       * @private
       */
      _dragoverValid: {
        type: Boolean,
        value: false,
        observer: "_dragoverValidChanged"
      },
      /**
       * Specifies the 'name' property at Content-Disposition
       * @attr {string} form-data-name
       * @type {string}
       */
      formDataName: {
        type: String,
        value: "file"
      },
      /**
       * Prevents upload(s) from immediately uploading upon adding file(s).
       * When set, you must manually trigger uploads using the `uploadFiles` method
       * @attr {boolean} no-auto
       * @type {boolean}
       */
      noAuto: {
        type: Boolean,
        value: false
      },
      /**
       * Set the withCredentials flag on the request.
       * @attr {boolean} with-credentials
       * @type {boolean}
       */
      withCredentials: {
        type: Boolean,
        value: false
      },
      /**
       * Pass-through to input's capture attribute. Allows user to trigger device inputs
       * such as camera or microphone immediately.
       */
      capture: String,
      /**
       * The object used to localize this component.
       * For changing the default localization, change the entire
       * _i18n_ object or just the property you want to modify.
       *
       * The object has the following JSON structure and default values:
       *
       * ```
       * {
       *   dropFiles: {
       *     one: 'Drop file here',
       *     many: 'Drop files here'
       *   },
       *   addFiles: {
       *     one: 'Upload File...',
       *     many: 'Upload Files...'
       *   },
       *   error: {
       *     tooManyFiles: 'Too Many Files.',
       *     fileIsTooBig: 'File is Too Big.',
       *     incorrectFileType: 'Incorrect File Type.'
       *   },
       *   uploading: {
       *     status: {
       *       connecting: 'Connecting...',
       *       stalled: 'Stalled',
       *       processing: 'Processing File...',
       *       held: 'Queued'
       *     },
       *     remainingTime: {
       *       prefix: 'remaining time: ',
       *       unknown: 'unknown remaining time'
       *     },
       *     error: {
       *       serverUnavailable: 'Upload failed, please try again later',
       *       unexpectedServerError: 'Upload failed due to server error',
       *       forbidden: 'Upload forbidden'
       *     }
       *   },
       *   file: {
       *     retry: 'Retry',
       *     start: 'Start',
       *     remove: 'Remove'
       *   },
       *   units: {
       *     size: ['B', 'kB', 'MB', 'GB', 'TB', 'PB', 'EB', 'ZB', 'YB'],
       *     sizeBase: 1000
       *   },
       *   formatSize: function(bytes) {
       *     // returns the size followed by the best suitable unit
       *   },
       *   formatTime: function(seconds, [secs, mins, hours]) {
       *     // returns a 'HH:MM:SS' string
       *   }
       * }
       * ```
       *
       * @type {!UploadI18n}
       * @default {English}
       */
      i18n: {
        type: Object,
        value() {
          return {
            dropFiles: {
              one: "Drop file here",
              many: "Drop files here"
            },
            addFiles: {
              one: "Upload File...",
              many: "Upload Files..."
            },
            error: {
              tooManyFiles: "Too Many Files.",
              fileIsTooBig: "File is Too Big.",
              incorrectFileType: "Incorrect File Type."
            },
            uploading: {
              status: {
                connecting: "Connecting...",
                stalled: "Stalled",
                processing: "Processing File...",
                held: "Queued"
              },
              remainingTime: {
                prefix: "remaining time: ",
                unknown: "unknown remaining time"
              },
              error: {
                serverUnavailable: "Upload failed, please try again later",
                unexpectedServerError: "Upload failed due to server error",
                forbidden: "Upload forbidden"
              }
            },
            file: {
              retry: "Retry",
              start: "Start",
              remove: "Remove"
            },
            units: {
              size: ["B", "kB", "MB", "GB", "TB", "PB", "EB", "ZB", "YB"]
            }
          };
        }
      },
      /** @private */
      _addButton: {
        type: Object
      },
      /** @private */
      _dropLabel: {
        type: Object
      },
      /** @private */
      _fileList: {
        type: Object
      },
      /** @private */
      _files: {
        type: Array
      }
    };
  }
  static get observers() {
    return [
      "__updateAddButton(_addButton, maxFiles, i18n, maxFilesReached, disabled)",
      "__updateDropLabel(_dropLabel, maxFiles, i18n)",
      "__updateFileList(_fileList, files, i18n, disabled)",
      "__updateMaxFilesReached(maxFiles, files)"
    ];
  }
  /** @private */
  get __acceptRegexp() {
    if (!this.accept) {
      return null;
    }
    const processedTokens = this.accept.split(",").map((token) => {
      let processedToken = token.trim();
      processedToken = processedToken.replace(/[+.]/gu, "\\$&");
      if (processedToken.startsWith("\\.")) {
        processedToken = `.*${processedToken}$`;
      }
      return processedToken.replace(/\/\*/gu, "/.*");
    });
    return new RegExp(`^(${processedTokens.join("|")})$`, "iu");
  }
  /** @protected */
  ready() {
    super.ready();
    this.addEventListener("dragover", this._onDragover.bind(this));
    this.addEventListener("dragleave", this._onDragleave.bind(this));
    this.addEventListener("drop", this._onDrop.bind(this));
    this.addEventListener("file-retry", this._onFileRetry.bind(this));
    this.addEventListener("file-abort", this._onFileAbort.bind(this));
    this.addEventListener("file-start", this._onFileStart.bind(this));
    this.addEventListener("file-reject", this._onFileReject.bind(this));
    this.addEventListener("upload-start", this._onUploadStart.bind(this));
    this.addEventListener("upload-success", this._onUploadSuccess.bind(this));
    this.addEventListener("upload-error", this._onUploadError.bind(this));
    this._addButtonController = new AddButtonController(this);
    this.addController(this._addButtonController);
    this._dropLabelController = new DropLabelController(this);
    this.addController(this._dropLabelController);
    this.addController(
      new SlotController(this, "file-list", "vaadin-upload-file-list", {
        initializer: (list) => {
          this._fileList = list;
        }
      })
    );
    this.addController(new SlotController(this, "drop-label-icon", "vaadin-upload-icon"));
  }
  /** @private */
  _formatSize(bytes) {
    if (typeof this.i18n.formatSize === "function") {
      return this.i18n.formatSize(bytes);
    }
    const base = this.i18n.units.sizeBase || 1e3;
    const unit = ~~(Math.log(bytes) / Math.log(base));
    const dec = Math.max(0, Math.min(3, unit - 1));
    const size = parseFloat((bytes / base ** unit).toFixed(dec));
    return `${size} ${this.i18n.units.size[unit]}`;
  }
  /** @private */
  _splitTimeByUnits(time) {
    const unitSizes = [60, 60, 24, Infinity];
    const timeValues = [0];
    for (let i2 = 0; i2 < unitSizes.length && time > 0; i2++) {
      timeValues[i2] = time % unitSizes[i2];
      time = Math.floor(time / unitSizes[i2]);
    }
    return timeValues;
  }
  /** @private */
  _formatTime(seconds, split2) {
    if (typeof this.i18n.formatTime === "function") {
      return this.i18n.formatTime(seconds, split2);
    }
    while (split2.length < 3) {
      split2.push(0);
    }
    return split2.reverse().map((number) => {
      return (number < 10 ? "0" : "") + number;
    }).join(":");
  }
  /** @private */
  _formatFileProgress(file) {
    const remainingTime = file.loaded > 0 ? this.i18n.uploading.remainingTime.prefix + file.remainingStr : this.i18n.uploading.remainingTime.unknown;
    return `${file.totalStr}: ${file.progress}% (${remainingTime})`;
  }
  /** @private */
  __updateMaxFilesReached(maxFiles, files) {
    this._setMaxFilesReached(maxFiles >= 0 && files.length >= maxFiles);
  }
  /** @private */
  __updateAddButton(addButton, maxFiles, i18n, maxFilesReached, disabled) {
    if (addButton) {
      addButton.disabled = disabled || maxFilesReached;
      if (addButton === this._addButtonController.defaultNode) {
        addButton.textContent = this._i18nPlural(maxFiles, i18n.addFiles);
      }
    }
  }
  /** @private */
  __updateDropLabel(dropLabel, maxFiles, i18n) {
    if (dropLabel && dropLabel === this._dropLabelController.defaultNode) {
      dropLabel.textContent = this._i18nPlural(maxFiles, i18n.dropFiles);
    }
  }
  /** @private */
  __updateFileList(list, files, i18n, disabled) {
    if (list) {
      list.items = [...files];
      list.i18n = i18n;
      list.disabled = disabled;
    }
  }
  /** @private */
  _onDragover(event) {
    event.preventDefault();
    if (!this.nodrop && !this._dragover) {
      this._dragoverValid = !this.maxFilesReached && !this.disabled;
      this._dragover = true;
    }
    event.dataTransfer.dropEffect = !this._dragoverValid || this.nodrop ? "none" : "copy";
  }
  /** @private */
  _onDragleave(event) {
    event.preventDefault();
    if (this._dragover && !this.nodrop) {
      this._dragover = this._dragoverValid = false;
    }
  }
  /** @private */
  async _onDrop(event) {
    if (!this.nodrop && !this.disabled) {
      event.preventDefault();
      this._dragover = this._dragoverValid = false;
      const files = await this.__getFilesFromDropEvent(event);
      this._addFiles(files);
    }
  }
  /**
   * Get the files from the drop event. The dropped items may contain a
   * combination of files and directories. If a dropped item is a directory,
   * it will be recursively traversed to get all files.
   *
   * @param {!DragEvent} dropEvent - The drop event
   * @returns {Promise<File[]>} - The files from the drop event
   * @private
   */
  __getFilesFromDropEvent(dropEvent) {
    async function getFilesFromEntry(entry) {
      if (entry.isFile) {
        return new Promise((resolve) => {
          entry.file(resolve, () => resolve([]));
        });
      } else if (entry.isDirectory) {
        const reader = entry.createReader();
        const entries = await new Promise((resolve) => {
          reader.readEntries(resolve, () => resolve([]));
        });
        const files = await Promise.all(entries.map(getFilesFromEntry));
        return files.flat();
      }
    }
    const containsFolders = Array.from(dropEvent.dataTransfer.items).filter((item2) => !!item2).filter((item2) => typeof item2.webkitGetAsEntry === "function").map((item2) => item2.webkitGetAsEntry()).some((entry) => !!entry && entry.isDirectory);
    if (!containsFolders) {
      return Promise.resolve(dropEvent.dataTransfer.files ? Array.from(dropEvent.dataTransfer.files) : []);
    }
    const filePromises = Array.from(dropEvent.dataTransfer.items).map((item2) => item2.webkitGetAsEntry()).filter((entry) => !!entry).map(getFilesFromEntry);
    return Promise.all(filePromises).then((files) => files.flat());
  }
  /** @private */
  _createXhr() {
    return new XMLHttpRequest();
  }
  /** @private */
  _configureXhr(xhr) {
    if (typeof this.headers === "string") {
      try {
        this.headers = JSON.parse(this.headers);
      } catch (_) {
        this.headers = void 0;
      }
    }
    Object.entries(this.headers).forEach(([key, value]) => {
      xhr.setRequestHeader(key, value);
    });
    if (this.timeout) {
      xhr.timeout = this.timeout;
    }
    xhr.withCredentials = this.withCredentials;
  }
  /** @private */
  _setStatus(file, total, loaded, elapsed) {
    file.elapsed = elapsed;
    file.elapsedStr = this._formatTime(file.elapsed, this._splitTimeByUnits(file.elapsed));
    file.remaining = Math.ceil(elapsed * (total / loaded - 1));
    file.remainingStr = this._formatTime(file.remaining, this._splitTimeByUnits(file.remaining));
    file.speed = ~~(total / elapsed / 1024);
    file.totalStr = this._formatSize(total);
    file.loadedStr = this._formatSize(loaded);
    file.status = this._formatFileProgress(file);
  }
  /**
   * Triggers the upload of any files that are not completed
   *
   * @param {!UploadFile | !Array<!UploadFile>=} files - Files being uploaded. Defaults to all outstanding files
   */
  uploadFiles(files = this.files) {
    if (files && !Array.isArray(files)) {
      files = [files];
    }
    files = files.filter((file) => !file.complete);
    Array.prototype.forEach.call(files, this._uploadFile.bind(this));
  }
  /** @private */
  _uploadFile(file) {
    if (file.uploading) {
      return;
    }
    const ini = Date.now();
    const xhr = file.xhr = this._createXhr();
    let stalledId, last;
    xhr.upload.onprogress = (e2) => {
      clearTimeout(stalledId);
      last = Date.now();
      const elapsed = (last - ini) / 1e3;
      const loaded = e2.loaded, total = e2.total, progress = ~~(loaded / total * 100);
      file.loaded = loaded;
      file.progress = progress;
      file.indeterminate = loaded <= 0 || loaded >= total;
      if (file.error) {
        file.indeterminate = file.status = void 0;
      } else if (!file.abort) {
        if (progress < 100) {
          this._setStatus(file, total, loaded, elapsed);
          stalledId = setTimeout(() => {
            file.status = this.i18n.uploading.status.stalled;
            this._renderFileList();
          }, 2e3);
        } else {
          file.loadedStr = file.totalStr;
          file.status = this.i18n.uploading.status.processing;
        }
      }
      this._renderFileList();
      this.dispatchEvent(new CustomEvent("upload-progress", { detail: { file, xhr } }));
    };
    xhr.onreadystatechange = () => {
      if (xhr.readyState === 4) {
        clearTimeout(stalledId);
        file.indeterminate = file.uploading = false;
        if (file.abort) {
          return;
        }
        file.status = "";
        const evt2 = this.dispatchEvent(
          new CustomEvent("upload-response", {
            detail: { file, xhr },
            cancelable: true
          })
        );
        if (!evt2) {
          return;
        }
        if (xhr.status === 0) {
          file.error = this.i18n.uploading.error.serverUnavailable;
        } else if (xhr.status >= 500) {
          file.error = this.i18n.uploading.error.unexpectedServerError;
        } else if (xhr.status >= 400) {
          file.error = this.i18n.uploading.error.forbidden;
        }
        file.complete = !file.error;
        this.dispatchEvent(
          new CustomEvent(`upload-${file.error ? "error" : "success"}`, {
            detail: { file, xhr }
          })
        );
        this._renderFileList();
      }
    };
    const formData = new FormData();
    if (!file.uploadTarget) {
      file.uploadTarget = this.target || "";
    }
    file.formDataName = this.formDataName;
    const evt = this.dispatchEvent(
      new CustomEvent("upload-before", {
        detail: { file, xhr },
        cancelable: true
      })
    );
    if (!evt) {
      return;
    }
    formData.append(file.formDataName, file, file.name);
    xhr.open(this.method, file.uploadTarget, true);
    this._configureXhr(xhr);
    file.status = this.i18n.uploading.status.connecting;
    file.uploading = file.indeterminate = true;
    file.complete = file.abort = file.error = file.held = false;
    xhr.upload.onloadstart = () => {
      this.dispatchEvent(
        new CustomEvent("upload-start", {
          detail: { file, xhr }
        })
      );
      this._renderFileList();
    };
    const uploadEvt = this.dispatchEvent(
      new CustomEvent("upload-request", {
        detail: { file, xhr, formData },
        cancelable: true
      })
    );
    if (uploadEvt) {
      xhr.send(formData);
    }
  }
  /** @private */
  _retryFileUpload(file) {
    const evt = this.dispatchEvent(
      new CustomEvent("upload-retry", {
        detail: { file, xhr: file.xhr },
        cancelable: true
      })
    );
    if (evt) {
      this._uploadFile(file);
      this._updateFocus(this.files.indexOf(file));
    }
  }
  /** @private */
  _abortFileUpload(file) {
    const evt = this.dispatchEvent(
      new CustomEvent("upload-abort", {
        detail: { file, xhr: file.xhr },
        cancelable: true
      })
    );
    if (evt) {
      file.abort = true;
      if (file.xhr) {
        file.xhr.abort();
      }
      this._removeFile(file);
    }
  }
  /** @private */
  _renderFileList() {
    if (this._fileList && typeof this._fileList.requestContentUpdate === "function") {
      this._fileList.requestContentUpdate();
    }
  }
  /** @private */
  _addFiles(files) {
    Array.prototype.forEach.call(files, this._addFile.bind(this));
  }
  /**
   * Add the file for uploading. Called internally for each file after picking files from dialog or dropping files.
   *
   * @param {!UploadFile} file File being added
   * @protected
   */
  _addFile(file) {
    if (this.maxFilesReached) {
      this.dispatchEvent(
        new CustomEvent("file-reject", {
          detail: { file, error: this.i18n.error.tooManyFiles }
        })
      );
      return;
    }
    if (this.maxFileSize >= 0 && file.size > this.maxFileSize) {
      this.dispatchEvent(
        new CustomEvent("file-reject", {
          detail: { file, error: this.i18n.error.fileIsTooBig }
        })
      );
      return;
    }
    const re2 = this.__acceptRegexp;
    if (re2 && !(re2.test(file.type) || re2.test(file.name))) {
      this.dispatchEvent(
        new CustomEvent("file-reject", {
          detail: { file, error: this.i18n.error.incorrectFileType }
        })
      );
      return;
    }
    file.loaded = 0;
    file.held = true;
    file.status = this.i18n.uploading.status.held;
    this.files = [file, ...this.files];
    if (!this.noAuto) {
      this._uploadFile(file);
    }
  }
  /** @private */
  _updateFocus(fileIndex) {
    if (this.files.length === 0) {
      this._addButton.focus();
      return;
    }
    const lastFileRemoved = fileIndex === this.files.length;
    if (lastFileRemoved) {
      fileIndex -= 1;
    }
    this._fileList.children[fileIndex].firstElementChild.focus();
  }
  /**
   * Remove file from upload list. Called internally if file upload was canceled.
   * @param {!UploadFile} file File to remove
   * @protected
   */
  _removeFile(file) {
    const fileIndex = this.files.indexOf(file);
    if (fileIndex >= 0) {
      this.files = this.files.filter((i2) => i2 !== file);
      this.dispatchEvent(
        new CustomEvent("file-remove", {
          detail: { file },
          bubbles: true,
          composed: true
        })
      );
      this._updateFocus(fileIndex);
    }
  }
  /** @private */
  _onAddFilesTouchEnd(e2) {
    e2.preventDefault();
    this._onAddFilesClick(e2);
  }
  /** @private */
  _onAddFilesClick(e2) {
    if (this.maxFilesReached) {
      return;
    }
    e2.stopPropagation();
    this.$.fileInput.value = "";
    this.$.fileInput.click();
  }
  /** @private */
  _onFileInputChange(event) {
    this._addFiles(event.target.files);
  }
  /** @private */
  _onFileStart(event) {
    this._uploadFile(event.detail.file);
  }
  /** @private */
  _onFileRetry(event) {
    this._retryFileUpload(event.detail.file);
  }
  /** @private */
  _onFileAbort(event) {
    this._abortFileUpload(event.detail.file);
  }
  /** @private */
  _onFileReject(event) {
    announce(`${event.detail.file.name}: ${event.detail.error}`, { mode: "alert" });
  }
  /** @private */
  _onUploadStart(event) {
    announce(`${event.detail.file.name}: 0%`, { mode: "alert" });
  }
  /** @private */
  _onUploadSuccess(event) {
    announce(`${event.detail.file.name}: 100%`, { mode: "alert" });
  }
  /** @private */
  _onUploadError(event) {
    announce(`${event.detail.file.name}: ${event.detail.file.error}`, { mode: "alert" });
  }
  /** @private */
  _dragoverChanged(dragover) {
    if (dragover) {
      this.setAttribute("dragover", dragover);
    } else {
      this.removeAttribute("dragover");
    }
  }
  /** @private */
  _dragoverValidChanged(dragoverValid) {
    if (dragoverValid) {
      this.setAttribute("dragover-valid", dragoverValid);
    } else {
      this.removeAttribute("dragover-valid");
    }
  }
  /** @private */
  _i18nPlural(value, plural) {
    return value === 1 ? plural.one : plural.many;
  }
  /** @protected */
  _isMultiple(maxFiles) {
    return maxFiles !== 1;
  }
};
/**
 * @license
 * Copyright (c) 2016 - 2025 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
class Upload extends UploadMixin(ElementMixin(ThemableMixin(ControllerMixin(PolymerElement)))) {
  static get template() {
    return html`
      <style>
        :host {
          display: block;
          position: relative;
          box-sizing: border-box;
        }

        :host([hidden]) {
          display: none !important;
        }

        [hidden] {
          display: none !important;
        }
      </style>

      <div part="primary-buttons">
        <slot name="add-button"></slot>
        <div part="drop-label" hidden$="[[nodrop]]" id="dropLabelContainer" aria-hidden="true">
          <slot name="drop-label-icon"></slot>
          <slot name="drop-label"></slot>
        </div>
      </div>
      <slot name="file-list"></slot>
      <slot></slot>
      <input
        type="file"
        id="fileInput"
        hidden
        on-change="_onFileInputChange"
        accept$="{{accept}}"
        multiple$="[[_isMultiple(maxFiles)]]"
        capture$="[[capture]]"
      />
    `;
  }
  static get is() {
    return "vaadin-upload";
  }
  /**
   * Fired when a file cannot be added to the queue due to a constrain:
   *  file-size, file-type or maxFiles
   *
   * @event file-reject
   * @param {Object} detail
   * @param {Object} detail.file the file added
   * @param {string} detail.error the cause
   */
  /**
   * Fired before the XHR is opened. Could be used for changing the request
   * URL. If the default is prevented, then XHR would not be opened.
   *
   * @event upload-before
   * @param {Object} detail
   * @param {Object} detail.xhr the xhr
   * @param {Object} detail.file the file being uploaded
   * @param {Object} detail.file.uploadTarget the upload request URL, initialized with the value of vaadin-upload `target` property
   */
  /**
   * Fired when the XHR has been opened but not sent yet. Useful for appending
   * data keys to the FormData object, for changing some parameters like
   * headers, etc. If the event is defaultPrevented, `vaadin-upload` will not
   * send the request allowing the user to do something on his own.
   *
   * @event upload-request
   * @param {Object} detail
   * @param {Object} detail.xhr the xhr
   * @param {Object} detail.file the file being uploaded
   * @param {Object} detail.formData the FormData object
   */
  /**
   * Fired when the XHR is sent.
   *
   * @event upload-start
   * @param {Object} detail
   * @param {Object} detail.xhr the xhr
   * @param {Object} detail.file the file being uploaded
   */
  /**
   * Fired as many times as the progress is updated.
   *
   * @event upload-progress
   * @param {Object} detail
   * @param {Object} detail.xhr the xhr
   * @param {Object} detail.file the file being uploaded with loaded info
   */
  /**
   * Fired when we have the actual server response, and before the component
   * analyses it. It's useful for developers to make the upload fail depending
   * on the server response. If the event is defaultPrevented the vaadin-upload
   * will return allowing the user to do something on his own like retry the
   * upload, etc. since he has full access to the `xhr` and `file` objects.
   * Otherwise, if the event is not prevented default `vaadin-upload` continues
   * with the normal workflow checking the `xhr.status` and `file.error`
   * which also might be modified by the user to force a customized response.
   *
   * @event upload-response
   * @param {Object} detail
   * @param {Object} detail.xhr the xhr
   * @param {Object} detail.file the file being uploaded
   */
  /**
   * Fired in case the upload process succeed.
   *
   * @event upload-success
   * @param {Object} detail
   * @param {Object} detail.xhr the xhr
   * @param {Object} detail.file the file being uploaded with loaded info
   */
  /**
   * Fired in case the upload process failed.
   *
   * @event upload-error
   * @param {Object} detail
   * @param {Object} detail.xhr the xhr
   * @param {Object} detail.file the file being uploaded
   */
  /**
   * Fired when retry upload is requested. If the default is prevented, then
   * retry would not be performed.
   *
   * @event upload-retry
   * @param {Object} detail
   * @param {Object} detail.xhr the previous upload xhr
   * @param {Object} detail.file the file being uploaded
   */
  /**
   * Fired when retry abort is requested. If the default is prevented, then the
   * file upload would not be aborted.
   *
   * @event upload-abort
   * @param {Object} detail
   * @param {Object} detail.xhr the xhr
   * @param {Object} detail.file the file being uploaded
   */
}
defineCustomElement(Upload);
/**
 * @license
 * Copyright (c) 2021 - 2025 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const VirtualListMixin = (superClass) => class VirtualListMixinClass extends ControllerMixin(superClass) {
  static get properties() {
    return {
      /**
       * An array containing items determining how many instances to render.
       * @type {Array<!VirtualListItem> | undefined}
       */
      items: { type: Array, sync: true },
      /**
       * Custom function for rendering the content of every item.
       * Receives three arguments:
       *
       * - `root` The render target element representing one item at a time.
       * - `virtualList` The reference to the `<vaadin-virtual-list>` element.
       * - `model` The object with the properties related with the rendered
       *   item, contains:
       *   - `model.index` The index of the rendered item.
       *   - `model.item` The item.
       * @type {VirtualListRenderer | undefined}
       */
      renderer: { type: Function, sync: true },
      /**
       * A function that generates accessible names for virtual list items.
       * The function gets the item as an argument and the
       * return value should be a string representing that item. The
       * result gets applied to the corresponding virtual list child element
       * as an `aria-label` attribute.
       */
      itemAccessibleNameGenerator: {
        type: Function,
        sync: true
      },
      /** @private */
      __virtualizer: Object
    };
  }
  static get observers() {
    return ["__itemsOrRendererChanged(items, renderer, __virtualizer, itemAccessibleNameGenerator)"];
  }
  /**
   * Gets the index of the first visible item in the viewport.
   *
   * @return {number}
   */
  get firstVisibleIndex() {
    return this.__virtualizer.firstVisibleIndex;
  }
  /**
   * Gets the index of the last visible item in the viewport.
   *
   * @return {number}
   */
  get lastVisibleIndex() {
    return this.__virtualizer.lastVisibleIndex;
  }
  constructor() {
    super();
    this.__onDocumentDragStart = this.__onDocumentDragStart.bind(this);
  }
  /** @protected */
  ready() {
    super.ready();
    this.__virtualizer = new Virtualizer({
      createElements: this.__createElements,
      updateElement: this.__updateElement.bind(this),
      elementsContainer: this,
      scrollTarget: this,
      scrollContainer: this.shadowRoot.querySelector("#items"),
      reorderElements: true
    });
    this.__overflowController = new OverflowController(this);
    this.addController(this.__overflowController);
    processTemplates(this);
    this.__updateAria();
  }
  /** @protected */
  connectedCallback() {
    super.connectedCallback();
    document.addEventListener("dragstart", this.__onDocumentDragStart, { capture: true });
    this.__virtualizer.hostConnected();
  }
  /** @protected */
  disconnectedCallback() {
    super.disconnectedCallback();
    document.removeEventListener("dragstart", this.__onDocumentDragStart, { capture: true });
  }
  /**
   * Scroll to a specific index in the virtual list.
   *
   * @param {number} index Index to scroll to
   */
  scrollToIndex(index) {
    this.__virtualizer.scrollToIndex(index);
  }
  /** @private */
  __createElements(count) {
    return [...Array(count)].map(() => document.createElement("div"));
  }
  /** @private */
  __updateAria() {
    this.role = "list";
  }
  /** @private */
  __updateElement(el, index) {
    const item2 = this.items[index];
    el.ariaSetSize = String(this.items.length);
    el.ariaPosInSet = String(index + 1);
    el.ariaLabel = this.itemAccessibleNameGenerator ? this.itemAccessibleNameGenerator(item2) : null;
    this.__updateElementRole(el);
    if (el.__renderer !== this.renderer) {
      el.__renderer = this.renderer;
      this.__clearRenderTargetContent(el);
    }
    if (this.renderer) {
      this.renderer(el, this, { item: item2, index });
    }
  }
  /** @private */
  __updateElementRole(el) {
    el.role = "listitem";
  }
  /**
   * Clears the content of a render target.
   * @private
   */
  __clearRenderTargetContent(element) {
    element.innerHTML = "";
    delete element._$litPart$;
  }
  /** @private */
  __itemsOrRendererChanged(items, renderer, virtualizer) {
    const hasRenderedItems = this.childElementCount > 0;
    if ((renderer || hasRenderedItems) && virtualizer) {
      virtualizer.size = (items || []).length;
      virtualizer.update();
    }
  }
  /**
   * Webkit-based browsers have issues with generating drag images
   * for elements that have children with massive heights. Chromium
   * browsers crash, while Safari experiences significant performance
   * issues. To mitigate these issues, we hide the items container
   * when drag starts to remove it from the drag image.
   *
   * Virtual lists with fewer rows also have issues on Chromium and Safari
   * where the drag image is not properly clipped and may include
   * content outside the virtual list. Temporary inline styles are applied
   * to mitigate this issue.
   *
   * Related issues:
   * - https://github.com/vaadin/web-components/issues/7985
   * - https://issues.chromium.org/issues/383356871
   * - https://github.com/vaadin/web-components/issues/8386
   *
   * @private
   */
  __onDocumentDragStart(e2) {
    if (e2.target.contains(this)) {
      const elements = [e2.target, this.$.items];
      const originalInlineStyles = elements.map((element) => element.style.cssText);
      if (this.scrollHeight > 2e4) {
        this.$.items.style.display = "none";
      }
      if (isChrome) {
        e2.target.style.willChange = "transform";
      }
      if (isSafari) {
        this.$.items.style.maxHeight = "100%";
      }
      requestAnimationFrame(() => {
        elements.forEach((element, index) => {
          element.style.cssText = originalInlineStyles[index];
        });
      });
    }
  }
  /**
   * Requests an update for the content of the rows.
   * While performing the update, it invokes the renderer passed in the `renderer` property for each visible row.
   *
   * It is not guaranteed that the update happens immediately (synchronously) after it is requested.
   */
  requestContentUpdate() {
    if (this.__virtualizer) {
      this.__virtualizer.update();
    }
  }
};
/**
 * @license
 * Copyright (c) 2017 - 2025 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const virtualListStyles = css`
  :host {
    display: block;
    height: 400px;
    overflow: auto;
    flex: auto;
    align-self: stretch;
  }

  :host([hidden]) {
    display: none !important;
  }

  :host(:not([grid])) #items > ::slotted(*) {
    width: 100%;
  }

  #items {
    position: relative;
  }
`;
/**
 * @license
 * Copyright (c) 2021 - 2025 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
registerStyles$1("vaadin-virtual-list", virtualListStyles, { moduleId: "vaadin-virtual-list-styles" });
class VirtualList extends ElementMixin(ThemableMixin(VirtualListMixin(PolymerElement))) {
  static get template() {
    return html`
      <div id="items">
        <slot></slot>
      </div>
    `;
  }
  static get is() {
    return "vaadin-virtual-list";
  }
}
defineCustomElement(VirtualList);
window.Vaadin.Flow.virtualListConnector = {
  initLazy: function(list) {
    if (list.$connector) {
      return;
    }
    const extraItemsBuffer = 20;
    let lastRequestedRange = [0, 0];
    list.$connector = {};
    list.$connector.placeholderItem = { __placeholder: true };
    list.itemAccessibleNameGenerator = (item2) => item2 && item2.accessibleName;
    const updateRequestedItem = function() {
      const visibleIndexes = [...list.children].filter((el) => "__virtualListIndex" in el).map((el) => el.__virtualListIndex);
      const firstNeededItem = Math.min(...visibleIndexes);
      const lastNeededItem = Math.max(...visibleIndexes);
      let first = Math.max(0, firstNeededItem - extraItemsBuffer);
      let last = Math.min(lastNeededItem + extraItemsBuffer, list.items.length);
      if (lastRequestedRange[0] != first || lastRequestedRange[1] != last) {
        lastRequestedRange = [first, last];
        const count = 1 + last - first;
        list.$server.setRequestedRange(first, count);
      }
    };
    const scheduleUpdateRequest = function() {
      list.__requestDebounce = Debouncer2.debounce(list.__requestDebounce, timeOut.after(50), updateRequestedItem);
    };
    requestAnimationFrame(() => updateRequestedItem);
    list.patchVirtualListRenderer = function() {
      if (!list.renderer || list.renderer.__virtualListConnectorPatched) {
        return;
      }
      const originalRenderer = list.renderer;
      const renderer = (root2, list2, model) => {
        root2.__virtualListIndex = model.index;
        if (model.item === void 0) {
          if (list2.$connector.placeholderElement) {
            if (!root2.__hasComponentRendererPlaceholder) {
              root2.innerHTML = "";
              delete root2._$litPart$;
              root2.appendChild(list2.$connector.placeholderElement.cloneNode(true));
              root2.__hasComponentRendererPlaceholder = true;
            }
          } else {
            originalRenderer.call(list2, root2, list2, {
              ...model,
              item: list2.$connector.placeholderItem
            });
          }
        } else {
          if (root2.__hasComponentRendererPlaceholder) {
            root2.innerHTML = "";
            root2.__hasComponentRendererPlaceholder = false;
          }
          originalRenderer.call(list2, root2, list2, model);
        }
        scheduleUpdateRequest();
      };
      renderer.__virtualListConnectorPatched = true;
      renderer.__rendererId = originalRenderer.__rendererId;
      list.renderer = renderer;
    };
    list._createPropertyObserver("renderer", "patchVirtualListRenderer", true);
    list.patchVirtualListRenderer();
    list.items = [];
    list.$connector.set = function(index, items) {
      list.items.splice(index, items.length, ...items);
      list.items = [...list.items];
    };
    list.$connector.clear = function(index, length) {
      const clearCount = Math.min(length, list.items.length - index);
      list.$connector.set(index, [...Array(clearCount)]);
    };
    list.$connector.updateData = function(items) {
      const updatedItemsMap = items.reduce((map, item2) => {
        map[item2.key] = item2;
        return map;
      }, {});
      list.items = list.items.map((item2) => {
        if (!item2) {
          return item2;
        }
        return updatedItemsMap[item2.key] || item2;
      });
    };
    list.$connector.updateSize = function(newSize) {
      const delta = newSize - list.items.length;
      if (delta > 0) {
        list.items = [...list.items, ...Array(delta)];
      } else if (delta < 0) {
        list.items = list.items.slice(0, newSize);
      }
    };
    list.$connector.setPlaceholderItem = function(placeholderItem = {}, appId) {
      placeholderItem.__placeholder = true;
      list.$connector.placeholderItem = placeholderItem;
      const nodeId = Object.entries(placeholderItem).find(([key]) => key.endsWith("_nodeid"));
      list.$connector.placeholderElement = nodeId ? Vaadin.Flow.clients[appId].getByNodeId(nodeId[1]) : null;
    };
  }
};
/**
 * @license
 * Copyright (c) 2017 - 2025 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
const template = document.createElement("template");
template.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg"><defs>
<g id="lumo:align-center"><path d="M167 217c0-18 17-33 38-34H795c21 0 38 15 38 34 0 18-17 33-38 33H205C184 250 167 235 167 217z m83 191c0-18 13-33 29-33H721c16 0 29 15 29 33 0 18-13 33-29 34H279C263 442 250 427 250 408zM250 792c0-18 13-33 29-34H721c16 0 29 15 29 34s-13 33-29 33H279C263 825 250 810 250 792z m-83-192c0-18 17-33 38-33H795c21 0 38 15 38 33s-17 33-38 33H205C184 633 167 618 167 600z" fill-rule="evenodd" clip-rule="evenodd"></path></g>
<g id="lumo:align-left"><path d="M167 217c0-18 17-33 38-34H795c21 0 38 15 38 34 0 18-17 33-38 33H205C184 250 167 235 167 217z m0 191c0-18 13-33 28-33H638c16 0 29 15 29 33 0 18-13 33-29 34H195C179 442 167 427 167 408zM167 792c0-18 13-33 28-34H638c16 0 29 15 29 34s-13 33-29 33H195C179 825 167 810 167 792z m0-192c0-18 17-33 38-33H795c21 0 38 15 38 33s-17 33-38 33H205C184 633 167 618 167 600z" fill-rule="evenodd" clip-rule="evenodd"></path></g>
<g id="lumo:align-right"><path d="M167 217c0-18 17-33 38-34H795c21 0 38 15 38 34 0 18-17 33-38 33H205C184 250 167 235 167 217z m166 191c0-18 13-33 29-33H805c16 0 29 15 28 33 0 18-13 33-28 34H362C346 442 333 427 333 408zM333 792c0-18 13-33 29-34H805c16 0 29 15 28 34s-13 33-28 33H362C346 825 333 810 333 792z m-166-192c0-18 17-33 38-33H795c21 0 38 15 38 33s-17 33-38 33H205C184 633 167 618 167 600z" fill-rule="evenodd" clip-rule="evenodd"></path></g>
<g id="lumo:angle-down"><path d="M283 391c-18-16-46-15-63 4-16 18-15 46 3 63l244 224c17 15 43 15 60 0l250-229c18-16 20-45 3-63-16-18-45-20-63-4l-220 203-214-198z"></path></g>
<g id="lumo:angle-left"><path d="M601 710c16 18 15 46-3 63-18 16-46 15-63-4l-224-244c-15-17-15-43 0-59l229-250c16-18 45-20 63-4 18 16 20 45 3 63l-203 220 198 215z"></path></g>
<g id="lumo:angle-right"><path d="M399 275c-16-18-15-46 3-63 18-16 46-15 63 4l224 244c15 17 15 43 0 59l-229 250c-16 18-45 20-63 4-18-16-20-45-3-63l203-220-198-215z"></path></g>
<g id="lumo:angle-up"><path d="M283 635c-18 16-46 15-63-3-16-18-15-46 3-63l244-224c17-15 43-15 60 0l250 229c18 16 20 45 3 63-16 18-45 20-63 3l-220-202L283 635z"></path></g>
<g id="lumo:arrow-down"><path d="M538 646l125-112c15-14 39-12 53 4 14 15 12 39-4 53l-187 166c0 0 0 0 0 0-14 13-36 12-50 0l-187-166c-15-14-17-37-4-53 14-15 37-17 53-4L462 646V312c0-21 17-38 38-37s38 17 37 37v334z"></path></g>
<g id="lumo:arrow-left"><path d="M375 538l111 125c14 15 12 39-3 53-15 14-39 12-53-4l-166-187c0 0 0 0 0 0-13-14-12-36 0-50l166-187c14-15 37-17 53-4 15 14 17 37 3 53L375 463h333c21 0 38 17 38 37 0 21-17 38-38 38h-333z"></path></g>
<g id="lumo:arrow-right"><path d="M625 538h-333c-21 0-38-17-38-38 0-21 17-38 38-37h333l-111-126c-14-15-12-39 3-53 15-14 39-12 53 4l166 187c13 14 13 36 0 50 0 0 0 0 0 0l-166 187c-14 15-37 17-53 4-15-14-17-37-3-53l111-125z"></path></g>
<g id="lumo:arrow-up"><path d="M538 354V688c0 21-17 38-38 37s-38-17-38-38V354l-125 112c-15 14-39 12-53-4-14-15-12-39 4-53l187-166c14-13 36-13 50 0 0 0 0 0 0 0l187 166c15 14 17 37 4 53-14 15-37 17-53 4L538 354z"></path></g>
<g id="lumo:bar-chart"><path d="M175 500h108c28 0 50 22 50 50v233c0 28-22 50-50 50H175c-28 0-50-22-50-50v-233c0-28 22-50 50-50z m33 67c-9 0-17 7-16 16v167c0 9 7 17 16 17h42c9 0 17-7 17-17v-167c0-9-7-17-17-16H208zM446 167h108c28 0 50 22 50 50v566c0 28-22 50-50 50h-108c-28 0-50-22-50-50V217c0-28 22-50 50-50z m33 66c-9 0-17 7-17 17v500c0 9 7 17 17 17h42c9 0 17-7 16-17V250c0-9-7-17-16-17h-42zM717 333h108c28 0 50 22 50 50v400c0 28-22 50-50 50h-108c-28 0-50-22-50-50V383c0-28 22-50 50-50z m33 67c-9 0-17 7-17 17v333c0 9 7 17 17 17h42c9 0 17-7 16-17v-333c0-9-7-17-16-17h-42z"></path></g>
<g id="lumo:bell"><path d="M367 675H292v-258C292 325 366 250 459 250H458V208c0-23 18-42 42-41 23 0 42 18 42 41v42h-1C634 250 708 325 708 417V675h-75v-258c0-51-41-92-91-92h-84C408 325 367 366 367 417V675z m-159 37c0-21 17-38 38-37h508c21 0 37 17 38 37 0 21-17 38-38 38H246C225 750 208 733 208 713z m230 71h125v32c0 17-14 31-32 31h-62c-17 0-32-14-31-31v-32z"></path></g>
<g id="lumo:calendar"><path d="M375 208h250v-20C625 176 634 167 646 167h41C699 167 708 176 708 188V208h74c23 0 41 19 41 42v42C823 315 804 333 782 333H218C196 333 177 315 177 292V250C177 227 196 208 218 208H292v-20C292 176 301 167 313 167h41C366 167 375 176 375 188V208zM229 375h42C283 375 292 384 292 396v41C292 449 282 458 271 458h-42C217 458 208 449 208 437v-41C208 384 218 375 229 375z m125 0h42C408 375 417 384 417 396v41C417 449 407 458 396 458h-42C342 458 333 449 333 437v-41C333 384 343 375 354 375z m125 0h42C533 375 542 384 542 396v41C542 449 532 458 521 458h-42C467 458 458 449 458 437v-41C458 384 468 375 479 375z m-250 125h42C283 500 292 509 292 521v41C292 574 282 583 271 583h-42C217 583 208 574 208 562v-41C208 509 218 500 229 500z m125 0h42C408 500 417 509 417 521v41C417 574 407 583 396 583h-42C342 583 333 574 333 562v-41C333 509 343 500 354 500z m125 0h42c12 0 21 9 21 21v41C542 574 532 583 521 583h-42C467 583 458 574 458 562v-41C458 509 468 500 479 500z m-250 125h42C283 625 292 634 292 646v41C292 699 282 708 271 708h-42C217 708 208 699 208 687v-41C208 634 218 625 229 625z m125 0h42C408 625 417 634 417 646v41C417 699 407 708 396 708h-42C342 708 333 699 333 687v-41C333 634 343 625 354 625z m125 0h42c12 0 21 9 21 21v41C542 699 532 708 521 708h-42C467 708 458 699 458 687v-41C458 634 468 625 479 625z m125-250h42C658 375 667 384 667 396v41C667 449 657 458 646 458h-42C592 458 583 449 583 437v-41C583 384 593 375 604 375z m0 125h42c12 0 21 9 21 21v41C667 574 657 583 646 583h-42C592 583 583 574 583 562v-41C583 509 593 500 604 500z m0 125h42c12 0 21 9 21 21v41C667 699 657 708 646 708h-42C592 708 583 699 583 687v-41C583 634 593 625 604 625z m125 0h42c12 0 21 9 21 21v41C792 699 782 708 771 708h-42C717 708 708 699 708 687v-41C708 634 718 625 729 625z m-500 125h42C283 750 292 759 292 771v41C292 824 282 833 271 833h-42C217 833 208 824 208 812v-41C208 759 218 750 229 750z m125 0h42C408 750 417 759 417 771v41C417 824 407 833 396 833h-42C342 833 333 824 333 812v-41C333 759 343 750 354 750z m125 0h42c12 0 21 9 21 21v41C542 824 532 833 521 833h-42C467 833 458 824 458 812v-41C458 759 468 750 479 750z m125 0h42c12 0 21 9 21 21v41C667 824 657 833 646 833h-42C592 833 583 824 583 812v-41C583 759 593 750 604 750z m125 0h42c12 0 21 9 21 21v41C792 824 782 833 771 833h-42C717 833 708 824 708 812v-41C708 759 718 750 729 750z m0-250h42c12 0 21 9 21 21v41C792 574 782 583 771 583h-42C717 583 708 574 708 562v-41C708 509 718 500 729 500z m0-125h42C783 375 792 384 792 396v41C792 449 782 458 771 458h-42C717 458 708 449 708 437v-41C708 384 718 375 729 375z"></path></g>
<g id="lumo:checkmark"><path d="M318 493c-15-15-38-15-53 0-15 15-15 38 0 53l136 136c15 15 38 15 53 0l323-322c15-15 15-38 0-53-15-15-38-15-54 0l-295 296-110-110z"></path></g>
<g id="lumo:chevron-down"><path d="M533 654l210-199c9-9 9-23 0-32C739 419 733 417 726 417H274C261 417 250 427 250 439c0 6 2 12 7 16l210 199c18 17 48 17 66 0z"></path></g>
<g id="lumo:chevron-left"><path d="M346 533l199 210c9 9 23 9 32 0 4-4 7-10 6-17V274C583 261 573 250 561 250c-6 0-12 2-16 7l-199 210c-17 18-17 48 0 66z"></path></g>
<g id="lumo:chevron-right"><path d="M654 533L455 743c-9 9-23 9-32 0C419 739 417 733 417 726V274C417 261 427 250 439 250c6 0 12 2 16 7l199 210c17 18 17 48 0 66z"></path></g>
<g id="lumo:chevron-up"><path d="M533 346l210 199c9 9 9 23 0 32-4 4-10 7-17 6H274C261 583 250 573 250 561c0-6 2-12 7-16l210-199c18-17 48-17 66 0z"></path></g>
<g id="lumo:clock"><path d="M538 489l85 85c15 15 15 38 0 53-15 15-38 15-53 0l-93-93a38 38 0 0 1-2-2C467 525 462 515 462 504V308c0-21 17-38 38-37 21 0 38 17 37 37v181zM500 833c-184 0-333-149-333-333s149-333 333-333 333 149 333 333-149 333-333 333z m0-68c146 0 265-118 265-265 0-146-118-265-265-265-146 0-265 118-265 265 0 146 118 265 265 265z"></path></g>
<g id="lumo:cog"><path d="M833 458l-81-18c-8-25-17-50-29-75L767 292 708 233l-72 49c-21-12-46-25-75-30L542 167h-84l-19 79c-25 8-50 17-71 30L296 233 233 296l47 69c-12 21-21 46-29 71L167 458v84l84 25c8 25 17 50 29 75L233 708 292 767l76-44c21 12 46 25 75 29L458 833h84l19-81c25-8 50-17 75-29L708 767l59-59-44-66c12-21 25-46 29-75L833 542v-84z m-333 217c-96 0-175-79-175-175 0-96 79-175 175-175 96 0 175 79 175 175 0 96-79 175-175 175z"></path></g>
<g id="lumo:cross"><path d="M445 500l-142-141c-15-15-15-40 0-56 15-15 40-15 56 0L500 445l141-142c15-15 40-15 56 0 15 15 15 40 0 56L555 500l142 141c15 15 15 40 0 56-15 15-40 15-56 0L500 555l-141 142c-15 15-40 15-56 0-15-15-15-40 0-56L445 500z"></path></g>
<g id="lumo:download"><path d="M538 521l125-112c15-14 39-12 53 4 14 15 12 39-4 53l-187 166a38 38 0 0 1 0 0c-14 13-36 12-50 0l-187-166c-15-14-17-37-4-53 14-15 37-17 53-4L462 521V188c0-21 17-38 38-38s38 17 37 38v333zM758 704c0-21 17-38 38-37 21 0 38 17 37 37v92c0 21-17 38-37 37H204c-21 0-38-17-37-37v-92c0-21 17-38 37-37s38 17 38 37v54h516v-54z"></path></g>
<g id="lumo:drag-handle"><path d="M458 292c0 35-28 63-62 62C361 354 333 326 333 292s28-63 63-63c35 0 63 28 62 63Zm0 208c0 35-28 63-62 62-35 0-63-28-63-62s28-63 63-63c35 0 63 28 62 63Zm0 208c0 35-28 63-62 63-35 0-63-28-63-63s28-63 63-62c35 0 63 28 62 62Zm209-416c0 35-28 63-63 62S542 326 542 292s28-63 62-63S667 257 667 292Zm0 208c0 35-28 63-63 62S542 535 542 500s28-63 62-63 63 28 63 63Zm0 208c0 35-28 63-63 63S542 743 542 708s28-63 62-62 63 28 63 62Z"></path></g>
<g id="lumo:dropdown"><path d="M317 393c-15-14-39-13-53 3-14 15-13 39 3 53l206 189c14 13 36 13 50 0l210-193c15-14 17-38 3-53-14-15-38-17-53-3l-185 171L317 393z"></path></g>
<g id="lumo:edit"><path d="M673 281l62 56-205 233c-9 10-38 24-85 39a8 8 0 0 1-5 0c-4-1-7-6-6-10l0 0c14-47 25-76 35-86l204-232z m37-42l52-59c15-17 41-18 58-2 17 16 18 42 3 59L772 295l-62-56zM626 208l-67 75h-226C305 283 283 306 283 333v334C283 695 306 717 333 717h334c28 0 50-22 50-50v-185L792 398v269C792 736 736 792 667 792H333C264 792 208 736 208 667V333C208 264 264 208 333 208h293z"></path></g>
<g id="lumo:error"><path d="M500 833c-184 0-333-149-333-333s149-333 333-333 333 149 333 333-149 333-333 333z m0-68c146 0 265-118 265-265 0-146-118-265-265-265-146 0-265 118-265 265 0 146 118 265 265 265zM479 292h42c12 0 21 9 20 20l-11 217c0 8-6 13-13 13h-34c-7 0-13-6-13-13l-11-217C459 301 468 292 479 292zM483 608h34c12 0 21 9 20 21v33c0 12-9 21-20 21h-34c-12 0-21-9-21-21v-33c0-12 9-21 21-21z"></path></g>
<g id="lumo:eye"><path d="M500 750c-187 0-417-163-417-250s230-250 417-250 417 163 417 250-230 250-417 250z m-336-231c20 22 47 46 78 69C322 644 411 678 500 678s178-34 258-90c31-22 59-46 78-69 6-7 12-14 16-19-4-6-9-12-16-19-20-22-47-46-78-69C678 356 589 322 500 322s-178 34-258 90c-31 22-59 46-78 69-6 7-12 14-16 19 4 6 9 12 16 19zM500 646c-81 0-146-65-146-146s65-146 146-146 146 65 146 146-65 146-146 146z m0-75c39 0 71-32 71-71 0-39-32-71-71-71-39 0-71 32-71 71 0 39 32 71 71 71z"></path></g>
<g id="lumo:eye-disabled"><path d="M396 735l60-60c15 2 30 3 44 3 89 0 178-34 258-90 31-22 59-46 78-69 6-7 12-14 16-19-4-6-9-12-16-19-20-22-47-46-78-69-8-5-15-11-23-15l50-51C862 397 917 458 917 500c0 87-230 250-417 250-34 0-69-5-104-15zM215 654C138 603 83 542 83 500c0-87 230-250 417-250 34 0 69 5 104 15l-59 60c-15-2-30-3-45-3-89 0-178 34-258 90-31 22-59 46-78 69-6 7-12 14-16 19 4 6 9 12 16 19 20 22 47 46 78 69 8 5 16 11 24 16L215 654z m271-9l159-159c0 5 1 9 1 14 0 81-65 146-146 146-5 0-9 0-14-1z m-131-131C354 510 354 505 354 500c0-81 65-146 146-146 5 0 10 0 14 1l-159 159z m-167 257L780 179c12-12 32-12 44 0 12 12 12 32 0 44L232 815c-12 12-32 12-44 0s-12-32 0-44z"></path></g>
<g id="lumo:menu"><path d="M167 292c0-23 19-42 41-42h584C815 250 833 268 833 292c0 23-19 42-41 41H208C185 333 167 315 167 292z m0 208c0-23 19-42 41-42h584C815 458 833 477 833 500c0 23-19 42-41 42H208C185 542 167 523 167 500z m0 208c0-23 19-42 41-41h584C815 667 833 685 833 708c0 23-19 42-41 42H208C185 750 167 732 167 708z"></path></g>
<g id="lumo:minus"><path d="M261 461c-22 0-39 18-39 39 0 22 18 39 39 39h478c22 0 39-18 39-39 0-22-18-39-39-39H261z"></path></g>
<g id="lumo:ordered-list"><path d="M138 333V198H136l-43 28v-38l45-31h45V333H138z m-61 128c0-35 27-59 68-59 39 0 66 21 66 53 0 20-11 37-43 64l-29 27v2h74V583H80v-30l55-52c26-24 32-33 33-43 0-13-10-22-24-22-15 0-26 10-26 25v1h-41v-1zM123 759v-31h21c15 0 25-8 25-21 0-13-10-21-25-21-15 0-26 9-26 23h-41c1-34 27-56 68-57 39 0 66 20 66 49 0 20-14 36-33 39v3c24 3 40 19 39 41 0 32-30 54-73 54-41 0-69-22-70-57h43c1 13 11 22 28 22 16 0 27-9 27-22 0-14-10-22-28-22h-21zM333 258c0-18 15-33 34-33h516c18 0 33 15 34 33 0 18-15 33-34 34H367c-18 0-33-15-34-34z m0 250c0-18 15-33 34-33h516c18 0 33 15 34 33s-15 33-34 34H367c-18 0-33-15-34-34z m0 250c0-18 15-33 34-33h516c18 0 33 15 34 33s-15 33-34 34H367c-18 0-33-15-34-34z"></path></g>
<g id="lumo:phone"><path d="M296 208l42-37c17-15 44-13 58 4a42 42 0 0 1 5 7L459 282c12 20 5 45-15 57l-7 4c-17 10-25 30-19 48l20 66a420 420 0 0 0 93 157l41 45c13 14 35 17 51 8l7-5c20-12 45-5 57 16L745 777c12 20 5 45-15 57a42 42 0 0 1-8 4l-52 17c-61 21-129 4-174-43l-50-52c-81-85-141-189-175-302l-24-78c-19-62 0-129 49-172z"></path></g>
<g id="lumo:photo"><path d="M208 167h584c69 0 125 56 125 125v416c0 69-56 125-125 125H208c-69 0-125-56-125-125V292c0-69 56-125 125-125z m584 75H208c-28 0-50 22-50 50v416c0 28 22 50 50 50h584c28 0 50-22 50-50V292c0-28-22-50-50-50zM239 740l167-167c12-12 31-14 45-6l73 43 172-201c13-15 34-18 50-7l95 67v92l-111-78-169 199c-12 14-32 17-47 8l-76-43-111 111H229c2-7 5-13 10-18zM458 427C458 490 407 542 344 542S229 490 229 427c0-63 51-115 115-115S458 364 458 427z m-62 0C396 398 373 375 344 375S292 398 292 427c0 29 23 52 52 52s52-23 52-52z"></path></g>
<g id="lumo:play"><path d="M689 528l-298 175c-13 8-34 8-48 0-6-4-10-9-10-14V311C333 300 348 292 367 292c9 0 17 2 24 5l298 175c26 15 26 40 0 56z"></path></g>
<g id="lumo:plus"><path d="M461 461H261c-22 0-39 18-39 39 0 22 18 39 39 39h200v200c0 22 18 39 39 39 22 0 39-18 39-39v-200h200c22 0 39-18 39-39 0-22-18-39-39-39h-200V261c0-22-18-39-39-39-22 0-39 18-39 39v200z"></path></g>
<g id="lumo:redo"><path d="M290 614C312 523 393 458 491 458c55 0 106 22 144 57l-88 88c-3 3-5 7-5 11 0 8 6 15 15 15l193-5c17 0 31-15 31-32l5-192c0-4-1-8-4-11-6-6-16-6-22 0l-66 67C641 406 570 375 491 375c-136 0-248 90-281 215-1 2-1 5-1 8-8 44 45 68 73 32 4-5 7-11 8-16z"></path></g>
<g id="lumo:reload"><path d="M500 233V137c0-9 7-16 15-16 4 0 8 2 10 4l133 140c12 12 12 32 0 45l-133 140c-6 6-15 6-21 0C502 447 500 443 500 438V308c-117 0-212 95-212 213 0 117 95 212 212 212 117 0 212-95 212-212 0-21 17-38 38-38s38 17 37 38c0 159-129 288-287 287-159 0-288-129-288-287 0-159 129-288 288-288z"></path></g>
<g id="lumo:resize-handle"><path d="M772 311c12 12 12 32 0 44L355 772c-12 12-32 12-44 0s-12-32 0-44L728 311c12-12 32-12 44 0Zm0 188c12 12 12 32 0 44l-229 229c-12 12-32 12-44 0-12-12-12-32 0-44l229-229c12-12 32-12 44 0Zm0 187c12 12 12 32 0 44l-42 42c-12 12-32 12-44 0-12-12-12-32 0-44l42-42c12-12 32-12 44 0Z" fill-rule="evenodd" clip-rule="evenodd"></path></g>
<g id="lumo:search"><path d="M662 603l131 131c16 16 16 42 0 59-16 16-43 16-59 0l-131-131C562 691 512 708 458 708c-138 0-250-112-250-250 0-138 112-250 250-250 138 0 250 112 250 250 0 54-17 104-46 145zM458 646c104 0 188-84 188-188S562 271 458 271 271 355 271 458s84 188 187 188z"></path></g>
<g id="lumo:undo"><path d="M710 614C688 523 607 458 509 458c-55 0-106 22-144 57l88 88c3 3 5 7 5 11 0 8-6 15-15 15l-193-5c-17 0-31-15-31-32L214 400c0-4 1-8 4-11 6-6 16-6 22 0l66 67C359 406 430 375 509 375c136 0 248 90 281 215 1 2 1 5 1 8 8 44-45 68-73 32-4-5-7-11-8-16z"></path></g>
<g id="lumo:unordered-list"><path d="M146 325c-42 0-67-26-67-63 0-37 25-63 67-63 42 0 67 26 67 63 0 37-25 63-67 63z m0 250c-42 0-67-26-67-63 0-37 25-63 67-63 42 0 67 26 67 63 0 37-25 63-67 63z m0 250c-42 0-67-26-67-63 0-37 25-63 67-63 42 0 67 26 67 63 0 37-25 63-67 63zM333 258c0-18 15-33 34-33h516c18 0 33 15 34 33 0 18-15 33-34 34H367c-18 0-33-15-34-34z m0 250c0-18 15-33 34-33h516c18 0 33 15 34 33s-15 33-34 34H367c-18 0-33-15-34-34z m0 250c0-18 15-33 34-33h516c18 0 33 15 34 33s-15 33-34 34H367c-18 0-33-15-34-34z"></path></g>
<g id="lumo:upload"><path d="M454 271V604c0 21-17 38-37 38s-38-17-38-38V271L254 382c-15 14-39 12-53-3-14-15-12-39 3-53L391 160c14-13 36-13 51-1 0 0 0 0 0 1l187 166c15 14 17 37 3 53-14 15-37 17-53 3L454 271zM675 704c0-21 17-38 37-37 21 0 38 17 38 37v92c0 21-17 38-38 37H121c-21 0-38-17-38-37v-92c0-21 17-38 38-37s38 17 37 37v54h517v-54z"></path></g>
<g id="lumo:user"><path d="M500 500c-69 0-125-56-125-125s56-125 125-125 125 56 125 125-56 125-125 125z m-292 292c0-115 131-208 292-209s292 93 292 209H208z"></path></g>
</defs></svg>`;
Iconset$1.register("lumo", 1e3, template);
const SwitchMixin = (superclass) => class SwitchMixinClass extends FieldMixin(CheckedMixin(DelegateFocusMixin(ActiveMixin(superclass)))) {
  static get properties() {
    return {
      /**
       * The name of the switch.
       *
       * @type {string}
       */
      name: {
        type: String,
        value: ""
      },
      /**
       * When true, the user cannot modify the value of the switch.
       * The difference between `disabled` and `readonly` is that the
       * read-only switch remains focusable, is announced by screen
       * readers and its value can be submitted as part of the form.
       */
      readonly: {
        type: Boolean,
        value: false,
        reflectToAttribute: true
      },
      /**
       * Indicates whether the element can be focused and where it participates in sequential keyboard navigation.
       *
       * @override
       * @protected
       */
      tabindex: {
        type: Number,
        value: 0,
        reflectToAttribute: true
      }
    };
  }
  static get observers() {
    return ["__readonlyChanged(readonly, inputElement)"];
  }
  /** @override */
  static get delegateAttrs() {
    return [...super.delegateAttrs, "name", "invalid", "required"];
  }
  constructor() {
    super();
    this._setType("checkbox");
    this._boundOnInputClick = this._onInputClick.bind(this);
    this.value = "on";
  }
  /** @protected */
  ready() {
    super.ready();
    this.addController(
      new InputController(this, (input) => {
        this._setInputElement(input);
        this._setFocusElement(input);
        this.stateTarget = input;
        this.ariaTarget = input;
      })
    );
    this.addController(new LabelledInputController(this.inputElement, this._labelController));
    this._createMethodObserver("_checkedChanged(checked)");
  }
  /**
   * Override method inherited from `ActiveMixin` to prevent setting `active`
   * attribute when readonly, or when clicking a link placed inside the label,
   * or when clicking slotted helper or error message element.
   *
   * @param {Event} event
   * @return {boolean}
   * @protected
   * @override
   */
  _shouldSetActive(event) {
    if (this.readonly || event.target.localName === "a" || event.target === this._helperNode || event.target === this._errorNode) {
      return false;
    }
    return super._shouldSetActive(event);
  }
  /**
   * Override method inherited from `InputMixin`.
   * @param {!HTMLElement} input
   * @protected
   * @override
   */
  _addInputListeners(input) {
    super._addInputListeners(input);
    input.addEventListener("click", this._boundOnInputClick);
  }
  /**
   * Override method inherited from `InputMixin`.
   * @param {!HTMLElement} input
   * @protected
   * @override
   */
  _removeInputListeners(input) {
    super._removeInputListeners(input);
    input.removeEventListener("click", this._boundOnInputClick);
  }
  /** @private */
  _onInputClick(event) {
    if (this.readonly) {
      event.preventDefault();
    }
  }
  /** @private */
  __readonlyChanged(readonly, inputElement) {
    if (!inputElement) {
      return;
    }
    if (readonly) {
      inputElement.setAttribute("aria-readonly", "true");
    } else {
      inputElement.removeAttribute("aria-readonly");
    }
  }
  /**
   * @override
   * @return {boolean}
   */
  checkValidity() {
    return !this.required || !!this.checked;
  }
  /**
   * Override method inherited from `FocusMixin` to validate on blur.
   * @param {boolean} focused
   * @protected
   */
  _setFocused(focused) {
    super._setFocused(focused);
    if (!focused && document.hasFocus()) {
      this._requestValidation();
    }
  }
  /** @private */
  _checkedChanged(checked) {
    if (checked || this.__oldChecked) {
      this._requestValidation();
    }
    this.__oldChecked = checked;
  }
  /**
   * Override an observer from `FieldMixin`
   * to validate when required is removed.
   *
   * @protected
   * @override
   */
  _requiredChanged(required) {
    super._requiredChanged(required);
    if (required === false) {
      this._requestValidation();
    }
  }
  /** @private */
  _onRequiredIndicatorClick() {
    this._labelNode.click();
  }
};
const switchStyles = css`
    
    :host {
        display: inline-block;
    }
    
    :host([hidden]) {
        display: none !important;
    }
    
    :host([disabled]) {
        -webkit-tap-highlight-color: transparent;
    }
    
    .jmix-switch-container {
        display: grid;
        grid-template-columns: auto 1fr;
        align-items: baseline;
    }
    
    [part='switch'],
    ::slotted(input),
    [part='label'] {
        grid-row: 1;
    }
    
    [part='switch'],
    ::slotted(input) {
        grid-column: 1;
    }

    [part='helper-text'],
    [part='error-message'] {
        grid-column: 2;
    }

    :host(:not([has-helper])) [part='helper-text'],
    :host(:not([has-error-message])) [part='error-message'] {
        display: none;
    }

    [part='switch'] {
        display: inline-flex;
        align-items: center;
        align-self: anchor-center;

        width: calc(var(--jmix-switch-size, calc(2.75em / 2)) * 2);
        height: var(--jmix-switch-size, calc(2.75em / 2));
        
        --_input-border-width: var(--vaadin-input-field-border-width, 0);
        --_input-border-color: var(--vaadin-input-field-border-color, transparent);
        box-shadow: inset 0 0 0 var(--_input-border-width, 0) var(--_input-border-color);
    }
    
    [part='switch'] .indicator {
        --_input-border-width: var(--vaadin-input-field-border-width, 0);
        --_input-border-color: var(--vaadin-input-field-border-color, transparent);
        box-shadow: inset 0 0 0 var(--_input-border-width, 0) var(--_input-border-color);
    }

    /* visually hidden */
    ::slotted(input) {
        opacity: 0;
        cursor: inherit;
        margin: 0;
        align-self: stretch;
        -webkit-appearance: none;
        width: initial;
        height: initial;
    }
`;
registerStyles$1("jmix-switch", switchStyles, { moduleId: "jmix-switch-styles" });
class JmixSwitch extends SwitchMixin(ElementMixin(ThemableMixin(PolymerElement))) {
  static get is() {
    return "jmix-switch";
  }
  static get template() {
    return html`
            <div class="jmix-switch-container">
                <div part="switch" aria-hidden="true">
                    <span class="indicator"></span>
                </div>
                <slot name="input"></slot>
                <div part="label">
                    <slot name="label"></slot>
                    <div part="required-indicator" on-click="_onRequiredIndicatorClick"></div>
                </div>
                <div part="helper-text">
                    <slot name="helper"></slot>
                </div>
                <div part="error-message">
                    <slot name="error-message"></slot>
                </div>
            </div>
            <slot name="tooltip"></slot>
        `;
  }
  /** @protected */
  ready() {
    super.ready();
    this._tooltipController = new TooltipController(this);
    this._tooltipController.setAriaTarget(this.inputElement);
    this.addController(this._tooltipController);
  }
}
defineCustomElement(JmixSwitch);
registerStyles$1(
  "jmix-switch",
  css`
        :host {
            color: var(--jmix-switch-label-color, var(--lumo-body-text-color));
            font-size: var(--jmix-switch-label-font-size, var(--lumo-font-size-m));
            font-family: var(--lumo-font-family);
            line-height: var(--lumo-line-height-s);
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
            -webkit-tap-highlight-color: transparent;
            -webkit-user-select: none;
            -moz-user-select: none;
            user-select: none;
            cursor: default;
            outline: none;
            
            --_switch-size: var(--jmix-switch-size, calc(var(--lumo-size-l) / 2));
            --_switch-background: var(--jmix-switch-background, var(--lumo-contrast-20pct));
            --_switch-indicator-size: var(--jmix-switch-indicator-size, calc(var(--lumo-size-m) / 2));
            --_focus-ring-color: var(--vaadin-focus-ring-color, var(--lumo-primary-color-50pct));
            --_focus-ring-width: var(--vaadin-focus-ring-width, 2px);
            --_selection-color: var(--vaadin-selection-color, var(--lumo-primary-color));
            --_invalid-background: var(--vaadin-input-field-invalid-background, var(--lumo-error-color-10pct));
            --_disabled-checked-indicator-color: var(--jmix-switch-disabled-checked-indicator-color, var(--lumo-contrast-30pct));
        }

        [part='label'] {
            display: flex;
            position: relative;
            max-width: max-content;
        }

        :host([has-label]) ::slotted(label) {
            padding: var(
                    --jmix-switch-label-padding,
                    var(--lumo-space-xs) var(--lumo-space-s) var(--lumo-space-xs) var(--lumo-space-xs)
            );
        }

        :host([dir='rtl'][has-label]) ::slotted(label) {
            padding: var(--lumo-space-xs) var(--lumo-space-xs) var(--lumo-space-xs) var(--lumo-space-s);
        }

        :host([has-label][required]) ::slotted(label) {
            padding-inline-end: var(--lumo-space-m);
        }

        [part='switch'] {
            box-sizing: border-box;
            width: calc(var(--_switch-size) * 2);
            height: var(--_switch-size);

            margin: var(--lumo-space-xs);

            position: relative;
            border-radius: var(--jmix-switch-border-radius, calc(var(--_switch-size) / 2));
            background: var(--_switch-background);
            transition: transform 0.2s cubic-bezier(0.12, 0.32, 0.54, 2),
            background-color 0.15s;
            cursor: var(--lumo-clickable-cursor);

            /* Default field border color */
            --_input-border-color: var(--vaadin-input-field-border-color, var(--lumo-contrast-50pct));
        }
        
        :host([checked]) {
            --vaadin-input-field-border-color: transparent;
        }
        
        :host([checked]) [part='switch'] {
            background-color: var(--_selection-color);
        }

        /* Checked indicator */

        [part='switch'] .indicator {
            width: var(--_switch-indicator-size);
            height: var(--_switch-indicator-size);
            border-radius: 50%;

            background-color: var(--jmix-switch-indicator-color, var(--lumo-tint-90pct));
            border: none;
            box-sizing: border-box;
            
            margin-inline-start: calc(var(--lumo-space-xs) / 2);
            transform: none;

            opacity: 1;
            transition: margin-inline-start 0.2s ease;

            /* Default field border color */
            --_input-border-color: var(--vaadin-input-field-border-color, var(--lumo-contrast-50pct));
        }

        :host([checked]) [part='switch'] .indicator {
            margin-inline-start: calc(100% - var(--_switch-indicator-size) - calc(var(--lumo-space-xs) / 2));
            background-color: var(--jmix-switch-checked-indicator-color, var(--lumo-primary-contrast-color));
        }

        /* Readonly */
        
        :host([readonly]:not([checked])) {
            color: var(--lumo-secondary-text-color);
        }

        :host([readonly]:not([checked])) [part='switch'] {
            background: transparent;
            box-shadow: none;
            border: var(--vaadin-input-field-readonly-border, 1px dashed var(--lumo-contrast-50pct));
        }

        :host([readonly]:not([checked])) [part='switch'] .indicator {
            background: transparent;
            box-shadow: none;
            border-radius: inherit;
            border: var(--vaadin-input-field-readonly-border, 1px dashed var(--lumo-contrast-50pct));
        }

        /* Focus ring */

        :host([focus-ring]) [part='switch'] {
            box-shadow: 0 0 0 1px var(--lumo-base-color),
            0 0 0 calc(var(--_focus-ring-width) + 1px) var(--_focus-ring-color),
            inset 0 0 0 var(--_input-border-width, 0) var(--_input-border-color);
        }

        :host([focus-ring][readonly]:not([checked])) [part='switch'] {
            box-shadow: 0 0 0 1px var(--lumo-base-color),
            0 0 0 calc(var(--_focus-ring-width) + 1px) var(--_focus-ring-color);
        }

        /* Disabled */

        :host([disabled]) {
            pointer-events: none;
            --vaadin-input-field-border-color: var(--lumo-contrast-20pct);
        }

        :host([disabled]) ::slotted(label) {
            color: inherit;
        }

        :host([disabled]) [part='switch'] {
            background-color: var(--jmix-switch-disabled-background, var(--lumo-contrast-10pct));
        }

        :host([disabled]) [part='switch'] .indicator {
            background-color: var(--_disabled-checked-indicator-color);
        }

        :host([disabled]) [part='label'],
        :host([disabled]) [part='helper-text'] {
            color: var(--lumo-disabled-text-color);
            -webkit-text-fill-color: var(--lumo-disabled-text-color);
        }

        :host([readonly][checked]:not([disabled])) [part='switch'] {
            background-color: var(--jmix-switch-readonly-checked-background, var(--lumo-contrast-70pct));
        }

        /* Used for activation "halo" */
        
        [part='switch']::after {
            position: absolute;
            content: "";
            pointer-events: none;
            color: transparent;
            width: 100%;
            height: 100%;
            line-height: var(--_switch-size);
            border-radius: inherit;
            background-color: inherit;
            transform: scale(1.2);
            opacity: 0;
            transition: transform 0.1s, opacity 0.8s;
        }

        /* Hover */

        :host(:not([checked]):not([disabled]):not([readonly]):not([invalid]):hover) [part='switch'] {
            background: var(--jmix-switch-background-hover, var(--lumo-contrast-30pct));
        }

        /* Disable hover for touch devices */
        
        @media (pointer: coarse) {
            /* prettier-ignore */
            :host(:not([checked]):not([disabled]):not([readonly]):not([invalid]):hover) [part='switch'] {
                background: var(--_switch-background);
            }
        }

        /* Active */

        :host([active]) [part='switch'] {
            transform: none;
        }

        :host([active]:not([checked])) [part='switch']::after {
            transition-duration: 0.01s, 0.01s;
            transform: scale(0);
            opacity: 0.4;
        }

        /* Must be defined in the Lumo theme in order to override the default styles */
        @media (prefers-reduced-motion: reduce) {
            [part='switch']::after {
                content: none;
            }
        }

        @media (forced-colors: active) {
            [part='switch'] {
                outline: 1px solid;
                outline-offset: -1px;
            }

            [part='switch'] .indicator {
                outline: 1px solid;
                outline-offset: -1px;
                border-radius: inherit;
                background-color: buttontext;
            }

            :host([disabled]) [part='switch'],
            :host([disabled]) [part='switch'] .indicator {
                outline-color: GrayText;
            }

            :host(:is([checked])) [part='switch'] {
                background: highlight;
            }

            :host(:is([checked])) [part='switch'] .indicator {
                outline: 1px solid;
                outline-offset: -1px;
                border-radius: inherit;
            }

            :host([focused]) [part='switch'] {
                outline-width: 2px;
            }
        }

        /* Required */
        
        :host([required]) [part='required-indicator'] {
            position: absolute;
            top: var(--lumo-space-xs);
            right: var(--lumo-space-xs);
        }

        :host([required][dir='rtl']) [part='required-indicator'] {
            right: auto;
            left: var(--lumo-space-xs);
        }

        :host([required]) [part='required-indicator']::after {
            content: var(--lumo-required-field-indicator, '\\2022');
            transition: opacity 0.2s;
            color: var(--lumo-required-field-indicator-color, var(--lumo-primary-text-color));
            width: 1em;
            text-align: center;
        }

        :host(:not([has-label])) [part='required-indicator'] {
            display: none;
        }

        /* Invalid */

        :host([invalid]) {
            --vaadin-input-field-border-color: var(--lumo-error-color);
        }

        :host([invalid]) [part='switch'] {
            background: var(--_invalid-background);
            background-image: linear-gradient(var(--_invalid-background) 0%, var(--_invalid-background) 100%);
        }

        :host([invalid]:hover) [part='switch'] {
            background-image: linear-gradient(var(--_invalid-background) 0%, var(--_invalid-background) 100%),
            linear-gradient(var(--_invalid-background) 0%, var(--_invalid-background) 100%);
        }

        :host([invalid][focus-ring]) {
            --_focus-ring-color: var(--lumo-error-color-50pct);
        }

        :host([invalid]) [part='required-indicator']::after {
            color: var(--lumo-required-field-indicator-color, var(--lumo-error-text-color));
        }

        /* Error message */

        [part='error-message'] {
            font-size: var(--vaadin-input-field-error-font-size, var(--lumo-font-size-xs));
            line-height: var(--lumo-line-height-xs);
            font-weight: var(--vaadin-input-field-error-font-weight, 400);
            color: var(--vaadin-input-field-error-color, var(--lumo-error-text-color));
            will-change: max-height;
            transition: 0.4s max-height;
            max-height: 5em;
            padding-inline-start: var(--lumo-space-xs);
        }

        :host([has-error-message]) [part='error-message']::after,
        :host([has-helper]) [part='helper-text']::after {
            content: '';
            display: block;
            height: 0.4em;
        }

        :host(:not([invalid])) [part='error-message'] {
            max-height: 0;
            overflow: hidden;
        }

        /* Helper */

        [part='helper-text'] {
            display: block;
            color: var(--vaadin-input-field-helper-color, var(--lumo-secondary-text-color));
            font-size: var(--vaadin-input-field-helper-font-size, var(--lumo-font-size-xs));
            line-height: var(--lumo-line-height-xs);
            font-weight: var(--vaadin-input-field-helper-font-weight, 400);
            margin-left: calc(var(--lumo-border-radius-m) / 4);
            transition: color 0.2s;
            padding-inline-start: var(--lumo-space-xs);
        }

        :host(:hover:not([readonly])) [part='helper-text'] {
            color: var(--lumo-body-text-color);
        }

        :host([has-error-message]) ::slotted(label),
        :host([has-helper]) ::slotted(label) {
            padding-bottom: 0;
        }
    `,
  // TODO: kd, workaround for https://github.com/vaadin/web-components/issues/2176
  //  rename to 'lumo-switch' after vaadin style order support
  { moduleId: "jmix-lumo-switch" }
);
const codeEditor = css`
  [part='input-field'],
  [part='input-field'] ::slotted(textarea) {
    height: auto;
    box-sizing: border-box;
  }

  [part='input-field'] {
    /* Equal to the implicit padding in vaadin-text-field */
    padding-top: calc((var(--lumo-text-field-size) - 1em * var(--lumo-line-height-s)) / 2);
    padding-bottom: calc((var(--lumo-text-field-size) - 1em * var(--lumo-line-height-s)) / 2);
    transition: background-color 0.1s;
    line-height: var(--lumo-line-height-s);
  }

  :host(:not([readonly])) [part='input-field']::after {
    display: none;
  }

  :host([readonly]) [part='input-field'] {
    border: 1px dashed var(--lumo-contrast-30pct);
  }

  :host([readonly]) [part='input-field']::after {
    border: none;
  }

  [part='input-field'] ::slotted(textarea) {
    line-height: inherit;
    --_lumo-text-field-overflow-mask-image: none;
  }
`;
registerStyles$1("jmix-code-editor", [inputFieldShared$1, codeEditor], { moduleId: "lumo-code-editor" });
var ace$1 = { exports: {} };
var hasRequiredAce;
function requireAce() {
  if (hasRequiredAce) return ace$1.exports;
  hasRequiredAce = 1;
  (function(module2, exports2) {
    (function() {
      var ACE_NAMESPACE = "ace";
      var global2 = /* @__PURE__ */ (function() {
        return this;
      })();
      if (!global2 && typeof window != "undefined") global2 = window;
      var define2 = function(module3, deps, payload) {
        if (typeof module3 !== "string") {
          if (define2.original)
            define2.original.apply(this, arguments);
          else {
            console.error("dropping module because define wasn't a string.");
            console.trace();
          }
          return;
        }
        if (arguments.length == 2)
          payload = deps;
        if (!define2.modules[module3]) {
          define2.payloads[module3] = payload;
          define2.modules[module3] = null;
        }
      };
      define2.modules = {};
      define2.payloads = {};
      var _require = function(parentId, module3, callback) {
        if (typeof module3 === "string") {
          var payload = lookup(parentId, module3);
          if (payload != void 0) {
            callback && callback();
            return payload;
          }
        } else if (Object.prototype.toString.call(module3) === "[object Array]") {
          var params = [];
          for (var i2 = 0, l = module3.length; i2 < l; ++i2) {
            var dep = lookup(parentId, module3[i2]);
            if (dep == void 0 && require2.original)
              return;
            params.push(dep);
          }
          return callback && callback.apply(null, params) || true;
        }
      };
      var require2 = function(module3, callback) {
        var packagedModule = _require("", module3, callback);
        if (packagedModule == void 0 && require2.original)
          return require2.original.apply(this, arguments);
        return packagedModule;
      };
      var normalizeModule = function(parentId, moduleName) {
        if (moduleName.indexOf("!") !== -1) {
          var chunks = moduleName.split("!");
          return normalizeModule(parentId, chunks[0]) + "!" + normalizeModule(parentId, chunks[1]);
        }
        if (moduleName.charAt(0) == ".") {
          var base = parentId.split("/").slice(0, -1).join("/");
          moduleName = base + "/" + moduleName;
          while (moduleName.indexOf(".") !== -1 && previous != moduleName) {
            var previous = moduleName;
            moduleName = moduleName.replace(/\/\.\//, "/").replace(/[^\/]+\/\.\.\//, "");
          }
        }
        return moduleName;
      };
      var lookup = function(parentId, moduleName) {
        moduleName = normalizeModule(parentId, moduleName);
        var module3 = define2.modules[moduleName];
        if (!module3) {
          module3 = define2.payloads[moduleName];
          if (typeof module3 === "function") {
            var exports3 = {};
            var mod = {
              id: moduleName,
              uri: "",
              exports: exports3,
              packaged: true
            };
            var req = function(module4, callback) {
              return _require(moduleName, module4, callback);
            };
            var returnValue = module3(req, exports3, mod);
            exports3 = returnValue || mod.exports;
            define2.modules[moduleName] = exports3;
            delete define2.payloads[moduleName];
          }
          module3 = define2.modules[moduleName] = exports3 || module3;
        }
        return module3;
      };
      function exportAce(ns) {
        var root2 = global2;
        {
          if (!global2[ns])
            global2[ns] = {};
          root2 = global2[ns];
        }
        if (!root2.define || !root2.define.packaged) {
          define2.original = root2.define;
          root2.define = define2;
          root2.define.packaged = true;
        }
        if (!root2.require || !root2.require.packaged) {
          require2.original = root2.require;
          root2.require = require2;
          root2.require.packaged = true;
        }
      }
      exportAce(ACE_NAMESPACE);
    })();
    ace.define("ace/lib/es6-shim", ["require", "exports", "module"], function(require2, exports3, module3) {
      function defineProp(obj, name, val) {
        Object.defineProperty(obj, name, {
          value: val,
          enumerable: false,
          writable: true,
          configurable: true
        });
      }
      if (!String.prototype.startsWith) {
        defineProp(String.prototype, "startsWith", function(searchString, position) {
          position = position || 0;
          return this.lastIndexOf(searchString, position) === position;
        });
      }
      if (!String.prototype.endsWith) {
        defineProp(String.prototype, "endsWith", function(searchString, position) {
          var subjectString = this;
          if (position === void 0 || position > subjectString.length) {
            position = subjectString.length;
          }
          position -= searchString.length;
          var lastIndex = subjectString.indexOf(searchString, position);
          return lastIndex !== -1 && lastIndex === position;
        });
      }
      if (!String.prototype.repeat) {
        defineProp(String.prototype, "repeat", function(count) {
          var result = "";
          var string = this;
          while (count > 0) {
            if (count & 1)
              result += string;
            if (count >>= 1)
              string += string;
          }
          return result;
        });
      }
      if (!String.prototype.includes) {
        defineProp(String.prototype, "includes", function(str, position) {
          return this.indexOf(str, position) != -1;
        });
      }
      if (!Object.assign) {
        Object.assign = function(target) {
          if (target === void 0 || target === null) {
            throw new TypeError("Cannot convert undefined or null to object");
          }
          var output = Object(target);
          for (var index = 1; index < arguments.length; index++) {
            var source = arguments[index];
            if (source !== void 0 && source !== null) {
              Object.keys(source).forEach(function(key) {
                output[key] = source[key];
              });
            }
          }
          return output;
        };
      }
      if (!Object.values) {
        Object.values = function(o) {
          return Object.keys(o).map(function(k2) {
            return o[k2];
          });
        };
      }
      if (!Array.prototype.find) {
        defineProp(Array.prototype, "find", function(predicate) {
          var len = this.length;
          var thisArg = arguments[1];
          for (var k2 = 0; k2 < len; k2++) {
            var kValue = this[k2];
            if (predicate.call(thisArg, kValue, k2, this)) {
              return kValue;
            }
          }
        });
      }
      if (!Array.prototype.findIndex) {
        defineProp(Array.prototype, "findIndex", function(predicate) {
          var len = this.length;
          var thisArg = arguments[1];
          for (var k2 = 0; k2 < len; k2++) {
            var kValue = this[k2];
            if (predicate.call(thisArg, kValue, k2, this)) {
              return k2;
            }
          }
        });
      }
      if (!Array.prototype.includes) {
        defineProp(Array.prototype, "includes", function(item2, position) {
          return this.indexOf(item2, position) != -1;
        });
      }
      if (!Array.prototype.fill) {
        defineProp(Array.prototype, "fill", function(value) {
          var O2 = this;
          var len = O2.length >>> 0;
          var start = arguments[1];
          var relativeStart = start >> 0;
          var k2 = relativeStart < 0 ? Math.max(len + relativeStart, 0) : Math.min(relativeStart, len);
          var end = arguments[2];
          var relativeEnd = end === void 0 ? len : end >> 0;
          var final = relativeEnd < 0 ? Math.max(len + relativeEnd, 0) : Math.min(relativeEnd, len);
          while (k2 < final) {
            O2[k2] = value;
            k2++;
          }
          return O2;
        });
      }
      if (!Array.of) {
        defineProp(Array, "of", function() {
          return Array.prototype.slice.call(arguments);
        });
      }
    });
    ace.define("ace/lib/fixoldbrowsers", ["require", "exports", "module", "ace/lib/es6-shim"], function(require2, exports3, module3) {
      require2("./es6-shim");
    });
    ace.define("ace/lib/deep_copy", ["require", "exports", "module"], function(require2, exports3, module3) {
      exports3.deepCopy = function deepCopy(obj) {
        if (typeof obj !== "object" || !obj)
          return obj;
        var copy;
        if (Array.isArray(obj)) {
          copy = [];
          for (var key = 0; key < obj.length; key++) {
            copy[key] = deepCopy(obj[key]);
          }
          return copy;
        }
        if (Object.prototype.toString.call(obj) !== "[object Object]")
          return obj;
        copy = {};
        for (var key in obj)
          copy[key] = deepCopy(obj[key]);
        return copy;
      };
    });
    ace.define("ace/lib/lang", ["require", "exports", "module", "ace/lib/deep_copy"], function(require2, exports3, module3) {
      exports3.last = function(a3) {
        return a3[a3.length - 1];
      };
      exports3.stringReverse = function(string) {
        return string.split("").reverse().join("");
      };
      exports3.stringRepeat = function(string, count) {
        var result = "";
        while (count > 0) {
          if (count & 1)
            result += string;
          if (count >>= 1)
            string += string;
        }
        return result;
      };
      var trimBeginRegexp = /^\s\s*/;
      var trimEndRegexp = /\s\s*$/;
      exports3.stringTrimLeft = function(string) {
        return string.replace(trimBeginRegexp, "");
      };
      exports3.stringTrimRight = function(string) {
        return string.replace(trimEndRegexp, "");
      };
      exports3.copyObject = function(obj) {
        var copy = {};
        for (var key in obj) {
          copy[key] = obj[key];
        }
        return copy;
      };
      exports3.copyArray = function(array) {
        var copy = [];
        for (var i2 = 0, l = array.length; i2 < l; i2++) {
          if (array[i2] && typeof array[i2] == "object")
            copy[i2] = this.copyObject(array[i2]);
          else
            copy[i2] = array[i2];
        }
        return copy;
      };
      exports3.deepCopy = require2("./deep_copy").deepCopy;
      exports3.arrayToMap = function(arr) {
        var map = {};
        for (var i2 = 0; i2 < arr.length; i2++) {
          map[arr[i2]] = 1;
        }
        return map;
      };
      exports3.createMap = function(props) {
        var map = /* @__PURE__ */ Object.create(null);
        for (var i2 in props) {
          map[i2] = props[i2];
        }
        return map;
      };
      exports3.arrayRemove = function(array, value) {
        for (var i2 = 0; i2 <= array.length; i2++) {
          if (value === array[i2]) {
            array.splice(i2, 1);
          }
        }
      };
      exports3.escapeRegExp = function(str) {
        return str.replace(/([.*+?^${}()|[\]\/\\])/g, "\\$1");
      };
      exports3.escapeHTML = function(str) {
        return ("" + str).replace(/&/g, "&#38;").replace(/"/g, "&#34;").replace(/'/g, "&#39;").replace(/</g, "&#60;");
      };
      exports3.getMatchOffsets = function(string, regExp) {
        var matches2 = [];
        string.replace(regExp, function(str) {
          matches2.push({
            offset: arguments[arguments.length - 2],
            length: str.length
          });
        });
        return matches2;
      };
      exports3.deferredCall = function(fcn) {
        var timer = null;
        var callback = function() {
          timer = null;
          fcn();
        };
        var deferred = function(timeout) {
          deferred.cancel();
          timer = setTimeout(callback, timeout || 0);
          return deferred;
        };
        deferred.schedule = deferred;
        deferred.call = function() {
          this.cancel();
          fcn();
          return deferred;
        };
        deferred.cancel = function() {
          clearTimeout(timer);
          timer = null;
          return deferred;
        };
        deferred.isPending = function() {
          return timer;
        };
        return deferred;
      };
      exports3.delayedCall = function(fcn, defaultTimeout) {
        var timer = null;
        var callback = function() {
          timer = null;
          fcn();
        };
        var _self = function(timeout) {
          if (timer == null)
            timer = setTimeout(callback, timeout || defaultTimeout);
        };
        _self.delay = function(timeout) {
          timer && clearTimeout(timer);
          timer = setTimeout(callback, timeout || defaultTimeout);
        };
        _self.schedule = _self;
        _self.call = function() {
          this.cancel();
          fcn();
        };
        _self.cancel = function() {
          timer && clearTimeout(timer);
          timer = null;
        };
        _self.isPending = function() {
          return timer;
        };
        return _self;
      };
      exports3.supportsLookbehind = function() {
        try {
          new RegExp("(?<=.)");
        } catch (e2) {
          return false;
        }
        return true;
      };
      exports3.skipEmptyMatch = function(line, last, supportsUnicodeFlag) {
        return supportsUnicodeFlag && line.codePointAt(last) > 65535 ? 2 : 1;
      };
    });
    ace.define("ace/lib/useragent", ["require", "exports", "module"], function(require2, exports3, module3) {
      exports3.OS = {
        LINUX: "LINUX",
        MAC: "MAC",
        WINDOWS: "WINDOWS"
      };
      exports3.getOS = function() {
        if (exports3.isMac) {
          return exports3.OS.MAC;
        } else if (exports3.isLinux) {
          return exports3.OS.LINUX;
        } else {
          return exports3.OS.WINDOWS;
        }
      };
      var _navigator = typeof navigator == "object" ? navigator : {};
      var os = (/mac|win|linux/i.exec(_navigator.platform) || ["other"])[0].toLowerCase();
      var ua = _navigator.userAgent || "";
      var appName = _navigator.appName || "";
      exports3.isWin = os == "win";
      exports3.isMac = os == "mac";
      exports3.isLinux = os == "linux";
      exports3.isIE = appName == "Microsoft Internet Explorer" || appName.indexOf("MSAppHost") >= 0 ? parseFloat((ua.match(/(?:MSIE |Trident\/[0-9]+[\.0-9]+;.*rv:)([0-9]+[\.0-9]+)/) || [])[1]) : parseFloat((ua.match(/(?:Trident\/[0-9]+[\.0-9]+;.*rv:)([0-9]+[\.0-9]+)/) || [])[1]);
      exports3.isOldIE = exports3.isIE && exports3.isIE < 9;
      exports3.isGecko = exports3.isMozilla = ua.match(/ Gecko\/\d+/);
      exports3.isOpera = typeof opera == "object" && Object.prototype.toString.call(window["opera"]) == "[object Opera]";
      exports3.isWebKit = parseFloat(ua.split("WebKit/")[1]) || void 0;
      exports3.isChrome = parseFloat(ua.split(" Chrome/")[1]) || void 0;
      exports3.isSafari = parseFloat(ua.split(" Safari/")[1]) && !exports3.isChrome || void 0;
      exports3.isEdge = parseFloat(ua.split(" Edge/")[1]) || void 0;
      exports3.isAIR = ua.indexOf("AdobeAIR") >= 0;
      exports3.isAndroid = ua.indexOf("Android") >= 0;
      exports3.isChromeOS = ua.indexOf(" CrOS ") >= 0;
      exports3.isIOS = /iPad|iPhone|iPod/.test(ua) && !window["MSStream"];
      if (exports3.isIOS)
        exports3.isMac = true;
      exports3.isMobile = exports3.isIOS || exports3.isAndroid;
    });
    ace.define("ace/lib/dom", ["require", "exports", "module", "ace/lib/useragent"], function(require2, exports3, module3) {
      var useragent = require2("./useragent");
      var XHTML_NS = "http://www.w3.org/1999/xhtml";
      exports3.buildDom = function buildDom(arr, parent, refs) {
        if (typeof arr == "string" && arr) {
          var txt = document.createTextNode(arr);
          if (parent)
            parent.appendChild(txt);
          return txt;
        }
        if (!Array.isArray(arr)) {
          if (arr && arr.appendChild && parent)
            parent.appendChild(arr);
          return arr;
        }
        if (typeof arr[0] != "string" || !arr[0]) {
          var els = [];
          for (var i2 = 0; i2 < arr.length; i2++) {
            var ch = buildDom(arr[i2], parent, refs);
            ch && els.push(ch);
          }
          return els;
        }
        var el = document.createElement(arr[0]);
        var options = arr[1];
        var childIndex = 1;
        if (options && typeof options == "object" && !Array.isArray(options))
          childIndex = 2;
        for (var i2 = childIndex; i2 < arr.length; i2++)
          buildDom(arr[i2], el, refs);
        if (childIndex == 2) {
          Object.keys(options).forEach(function(n) {
            var val = options[n];
            if (n === "class") {
              el.className = Array.isArray(val) ? val.join(" ") : val;
            } else if (typeof val == "function" || n == "value" || n[0] == "$") {
              el[n] = val;
            } else if (n === "ref") {
              if (refs)
                refs[val] = el;
            } else if (n === "style") {
              if (typeof val == "string")
                el.style.cssText = val;
            } else if (val != null) {
              el.setAttribute(n, val);
            }
          });
        }
        if (parent)
          parent.appendChild(el);
        return el;
      };
      exports3.getDocumentHead = function(doc) {
        if (!doc)
          doc = document;
        return doc.head || doc.getElementsByTagName("head")[0] || doc.documentElement;
      };
      exports3.createElement = function(tag, ns) {
        return document.createElementNS ? document.createElementNS(ns || XHTML_NS, tag) : document.createElement(tag);
      };
      exports3.removeChildren = function(element) {
        element.innerHTML = "";
      };
      exports3.createTextNode = function(textContent, element) {
        var doc = element ? element.ownerDocument : document;
        return doc.createTextNode(textContent);
      };
      exports3.createFragment = function(element) {
        var doc = element ? element.ownerDocument : document;
        return doc.createDocumentFragment();
      };
      exports3.hasCssClass = function(el, name) {
        var classes = (el.className + "").split(/\s+/g);
        return classes.indexOf(name) !== -1;
      };
      exports3.addCssClass = function(el, name) {
        if (!exports3.hasCssClass(el, name)) {
          el.className += " " + name;
        }
      };
      exports3.removeCssClass = function(el, name) {
        var classes = el.className.split(/\s+/g);
        while (true) {
          var index = classes.indexOf(name);
          if (index == -1) {
            break;
          }
          classes.splice(index, 1);
        }
        el.className = classes.join(" ");
      };
      exports3.toggleCssClass = function(el, name) {
        var classes = el.className.split(/\s+/g), add = true;
        while (true) {
          var index = classes.indexOf(name);
          if (index == -1) {
            break;
          }
          add = false;
          classes.splice(index, 1);
        }
        if (add)
          classes.push(name);
        el.className = classes.join(" ");
        return add;
      };
      exports3.setCssClass = function(node, className, include) {
        if (include) {
          exports3.addCssClass(node, className);
        } else {
          exports3.removeCssClass(node, className);
        }
      };
      exports3.hasCssString = function(id, doc) {
        var index = 0, sheets;
        doc = doc || document;
        if (sheets = doc.querySelectorAll("style")) {
          while (index < sheets.length) {
            if (sheets[index++].id === id) {
              return true;
            }
          }
        }
      };
      exports3.removeElementById = function(id, doc) {
        doc = doc || document;
        if (doc.getElementById(id)) {
          doc.getElementById(id).remove();
        }
      };
      var strictCSP;
      var cssCache = [];
      exports3.useStrictCSP = function(value) {
        strictCSP = value;
        if (value == false)
          insertPendingStyles();
        else if (!cssCache)
          cssCache = [];
      };
      function insertPendingStyles() {
        var cache = cssCache;
        cssCache = null;
        cache && cache.forEach(function(item2) {
          importCssString(item2[0], item2[1]);
        });
      }
      function importCssString(cssText, id, target) {
        if (typeof document == "undefined")
          return;
        if (cssCache) {
          if (target) {
            insertPendingStyles();
          } else if (target === false) {
            return cssCache.push([cssText, id]);
          }
        }
        if (strictCSP)
          return;
        var container = target;
        if (!target || !target.getRootNode) {
          container = document;
        } else {
          container = target.getRootNode();
          if (!container || container == target)
            container = document;
        }
        var doc = container.ownerDocument || container;
        if (id && exports3.hasCssString(id, container))
          return null;
        if (id)
          cssText += "\n/*# sourceURL=ace/css/" + id + " */";
        var style = exports3.createElement("style");
        style.appendChild(doc.createTextNode(cssText));
        if (id)
          style.id = id;
        if (container == doc)
          container = exports3.getDocumentHead(doc);
        container.insertBefore(style, container.firstChild);
      }
      exports3.importCssString = importCssString;
      exports3.importCssStylsheet = function(uri, doc) {
        exports3.buildDom(["link", { rel: "stylesheet", href: uri }], exports3.getDocumentHead(doc));
      };
      exports3.scrollbarWidth = function(doc) {
        var inner = exports3.createElement("ace_inner");
        inner.style.width = "100%";
        inner.style.minWidth = "0px";
        inner.style.height = "200px";
        inner.style.display = "block";
        var outer = exports3.createElement("ace_outer");
        var style = outer.style;
        style.position = "absolute";
        style.left = "-10000px";
        style.overflow = "hidden";
        style.width = "200px";
        style.minWidth = "0px";
        style.height = "150px";
        style.display = "block";
        outer.appendChild(inner);
        var body = doc && doc.documentElement || document && document.documentElement;
        if (!body)
          return 0;
        body.appendChild(outer);
        var noScrollbar = inner.offsetWidth;
        style.overflow = "scroll";
        var withScrollbar = inner.offsetWidth;
        if (noScrollbar === withScrollbar) {
          withScrollbar = outer.clientWidth;
        }
        body.removeChild(outer);
        return noScrollbar - withScrollbar;
      };
      exports3.computedStyle = function(element, style) {
        return window.getComputedStyle(element, "") || {};
      };
      exports3.setStyle = function(styles2, property, value) {
        if (styles2[property] !== value) {
          styles2[property] = value;
        }
      };
      exports3.HAS_CSS_ANIMATION = false;
      exports3.HAS_CSS_TRANSFORMS = false;
      exports3.HI_DPI = useragent.isWin ? typeof window !== "undefined" && window.devicePixelRatio >= 1.5 : true;
      if (useragent.isChromeOS)
        exports3.HI_DPI = false;
      if (typeof document !== "undefined") {
        var div = document.createElement("div");
        if (exports3.HI_DPI && div.style.transform !== void 0)
          exports3.HAS_CSS_TRANSFORMS = true;
        if (!useragent.isEdge && typeof div.style.animationName !== "undefined")
          exports3.HAS_CSS_ANIMATION = true;
        div = null;
      }
      if (exports3.HAS_CSS_TRANSFORMS) {
        exports3.translate = function(element, tx, ty) {
          element.style.transform = "translate(" + Math.round(tx) + "px, " + Math.round(ty) + "px)";
        };
      } else {
        exports3.translate = function(element, tx, ty) {
          element.style.top = Math.round(ty) + "px";
          element.style.left = Math.round(tx) + "px";
        };
      }
    });
    ace.define("ace/lib/net", ["require", "exports", "module", "ace/lib/dom"], function(require2, exports3, module3) {
      /*
      * based on code from:
      *
      * @license RequireJS text 0.25.0 Copyright (c) 2010-2011, The Dojo Foundation All Rights Reserved.
      * Available via the MIT or new BSD license.
      * see: http://github.com/jrburke/requirejs for details
      */
      var dom = require2("./dom");
      exports3.get = function(url, callback) {
        var xhr = new XMLHttpRequest();
        xhr.open("GET", url, true);
        xhr.onreadystatechange = function() {
          if (xhr.readyState === 4) {
            callback(xhr.responseText);
          }
        };
        xhr.send(null);
      };
      exports3.loadScript = function(path, callback) {
        var head = dom.getDocumentHead();
        var s3 = document.createElement("script");
        s3.src = path;
        head.appendChild(s3);
        s3.onload = s3.onreadystatechange = function(_, isAbort) {
          if (isAbort || !s3.readyState || s3.readyState == "loaded" || s3.readyState == "complete") {
            s3 = s3.onload = s3.onreadystatechange = null;
            if (!isAbort)
              callback();
          }
        };
      };
      exports3.qualifyURL = function(url) {
        var a3 = document.createElement("a");
        a3.href = url;
        return a3.href;
      };
    });
    ace.define("ace/lib/oop", ["require", "exports", "module"], function(require2, exports3, module3) {
      exports3.inherits = function(ctor, superCtor) {
        ctor.super_ = superCtor;
        ctor.prototype = Object.create(superCtor.prototype, {
          constructor: {
            value: ctor,
            enumerable: false,
            writable: true,
            configurable: true
          }
        });
      };
      exports3.mixin = function(obj, mixin) {
        for (var key in mixin) {
          obj[key] = mixin[key];
        }
        return obj;
      };
      exports3.implement = function(proto2, mixin) {
        exports3.mixin(proto2, mixin);
      };
    });
    ace.define("ace/lib/event_emitter", ["require", "exports", "module"], function(require2, exports3, module3) {
      var EventEmitter = {};
      var stopPropagation = function() {
        this.propagationStopped = true;
      };
      var preventDefault = function() {
        this.defaultPrevented = true;
      };
      EventEmitter._emit = EventEmitter._dispatchEvent = function(eventName, e2) {
        this._eventRegistry || (this._eventRegistry = {});
        this._defaultHandlers || (this._defaultHandlers = {});
        var listeners = this._eventRegistry[eventName] || [];
        var defaultHandler = this._defaultHandlers[eventName];
        if (!listeners.length && !defaultHandler)
          return;
        if (typeof e2 != "object" || !e2)
          e2 = {};
        if (!e2.type)
          e2.type = eventName;
        if (!e2.stopPropagation)
          e2.stopPropagation = stopPropagation;
        if (!e2.preventDefault)
          e2.preventDefault = preventDefault;
        listeners = listeners.slice();
        for (var i2 = 0; i2 < listeners.length; i2++) {
          listeners[i2](e2, this);
          if (e2.propagationStopped)
            break;
        }
        if (defaultHandler && !e2.defaultPrevented)
          return defaultHandler(e2, this);
      };
      EventEmitter._signal = function(eventName, e2) {
        var listeners = (this._eventRegistry || {})[eventName];
        if (!listeners)
          return;
        listeners = listeners.slice();
        for (var i2 = 0; i2 < listeners.length; i2++)
          listeners[i2](e2, this);
      };
      EventEmitter.once = function(eventName, callback) {
        var _self = this;
        this.on(eventName, function newCallback() {
          _self.off(eventName, newCallback);
          callback.apply(null, arguments);
        });
        if (!callback) {
          return new Promise(function(resolve) {
            callback = resolve;
          });
        }
      };
      EventEmitter.setDefaultHandler = function(eventName, callback) {
        var handlers = this._defaultHandlers;
        if (!handlers)
          handlers = this._defaultHandlers = { _disabled_: {} };
        if (handlers[eventName]) {
          var old = handlers[eventName];
          var disabled = handlers._disabled_[eventName];
          if (!disabled)
            handlers._disabled_[eventName] = disabled = [];
          disabled.push(old);
          var i2 = disabled.indexOf(callback);
          if (i2 != -1)
            disabled.splice(i2, 1);
        }
        handlers[eventName] = callback;
      };
      EventEmitter.removeDefaultHandler = function(eventName, callback) {
        var handlers = this._defaultHandlers;
        if (!handlers)
          return;
        var disabled = handlers._disabled_[eventName];
        if (handlers[eventName] == callback) {
          if (disabled)
            this.setDefaultHandler(eventName, disabled.pop());
        } else if (disabled) {
          var i2 = disabled.indexOf(callback);
          if (i2 != -1)
            disabled.splice(i2, 1);
        }
      };
      EventEmitter.on = EventEmitter.addEventListener = function(eventName, callback, capturing) {
        this._eventRegistry = this._eventRegistry || {};
        var listeners = this._eventRegistry[eventName];
        if (!listeners)
          listeners = this._eventRegistry[eventName] = [];
        if (listeners.indexOf(callback) == -1)
          listeners[capturing ? "unshift" : "push"](callback);
        return callback;
      };
      EventEmitter.off = EventEmitter.removeListener = EventEmitter.removeEventListener = function(eventName, callback) {
        this._eventRegistry = this._eventRegistry || {};
        var listeners = this._eventRegistry[eventName];
        if (!listeners)
          return;
        var index = listeners.indexOf(callback);
        if (index !== -1)
          listeners.splice(index, 1);
      };
      EventEmitter.removeAllListeners = function(eventName) {
        if (!eventName)
          this._eventRegistry = this._defaultHandlers = void 0;
        if (this._eventRegistry)
          this._eventRegistry[eventName] = void 0;
        if (this._defaultHandlers)
          this._defaultHandlers[eventName] = void 0;
      };
      exports3.EventEmitter = EventEmitter;
    });
    ace.define("ace/lib/report_error", ["require", "exports", "module"], function(require2, exports3, module3) {
      exports3.reportError = function reportError(msg, data) {
        var e2 = new Error(msg);
        e2["data"] = data;
        if (typeof console == "object" && console.error)
          console.error(e2);
        setTimeout(function() {
          throw e2;
        });
      };
    });
    ace.define("ace/lib/default_english_messages", ["require", "exports", "module"], function(require2, exports3, module3) {
      var defaultEnglishMessages = {
        "autocomplete.popup.aria-roledescription": "Autocomplete suggestions",
        "autocomplete.popup.aria-label": "Autocomplete suggestions",
        "autocomplete.popup.item.aria-roledescription": "item",
        "autocomplete.loading": "Loading...",
        "editor.scroller.aria-roledescription": "editor",
        "editor.scroller.aria-label": "Editor content, press Enter to start editing, press Escape to exit",
        "editor.gutter.aria-roledescription": "editor gutter",
        "editor.gutter.aria-label": "Editor gutter, press Enter to interact with controls using arrow keys, press Escape to exit",
        "error-marker.good-state": "Looks good!",
        "prompt.recently-used": "Recently used",
        "prompt.other-commands": "Other commands",
        "prompt.no-matching-commands": "No matching commands",
        "search-box.find.placeholder": "Search for",
        "search-box.find-all.text": "All",
        "search-box.replace.placeholder": "Replace with",
        "search-box.replace-next.text": "Replace",
        "search-box.replace-all.text": "All",
        "search-box.toggle-replace.title": "Toggle Replace mode",
        "search-box.toggle-regexp.title": "RegExp Search",
        "search-box.toggle-case.title": "CaseSensitive Search",
        "search-box.toggle-whole-word.title": "Whole Word Search",
        "search-box.toggle-in-selection.title": "Search In Selection",
        "search-box.search-counter": "$0 of $1",
        "text-input.aria-roledescription": "editor",
        "text-input.aria-label": "Cursor at row $0",
        "gutter.code-folding.range.aria-label": "Toggle code folding, rows $0 through $1",
        "gutter.code-folding.closed.aria-label": "Toggle code folding, rows $0 through $1",
        "gutter.code-folding.open.aria-label": "Toggle code folding, row $0",
        "gutter.code-folding.closed.title": "Unfold code",
        "gutter.code-folding.open.title": "Fold code",
        "gutter.annotation.aria-label.error": "Error, read annotations row $0",
        "gutter.annotation.aria-label.warning": "Warning, read annotations row $0",
        "gutter.annotation.aria-label.info": "Info, read annotations row $0",
        "inline-fold.closed.title": "Unfold code",
        "gutter-tooltip.aria-label.error.singular": "error",
        "gutter-tooltip.aria-label.error.plural": "errors",
        "gutter-tooltip.aria-label.warning.singular": "warning",
        "gutter-tooltip.aria-label.warning.plural": "warnings",
        "gutter-tooltip.aria-label.info.singular": "information message",
        "gutter-tooltip.aria-label.info.plural": "information messages",
        "gutter.annotation.aria-label.security": "Security finding, read annotations row $0",
        "gutter.annotation.aria-label.hint": "Suggestion, read annotations row $0",
        "gutter-tooltip.aria-label.security.singular": "security finding",
        "gutter-tooltip.aria-label.security.plural": "security findings",
        "gutter-tooltip.aria-label.hint.singular": "suggestion",
        "gutter-tooltip.aria-label.hint.plural": "suggestions"
      };
      exports3.defaultEnglishMessages = defaultEnglishMessages;
    });
    ace.define("ace/lib/app_config", ["require", "exports", "module", "ace/lib/oop", "ace/lib/event_emitter", "ace/lib/report_error", "ace/lib/default_english_messages"], function(require2, exports3, module3) {
      "no use strict";
      var oop = require2("./oop");
      var EventEmitter = require2("./event_emitter").EventEmitter;
      var reportError = require2("./report_error").reportError;
      var defaultEnglishMessages = require2("./default_english_messages").defaultEnglishMessages;
      var optionsProvider = {
        setOptions: function(optList) {
          Object.keys(optList).forEach(function(key) {
            this.setOption(key, optList[key]);
          }, this);
        },
        getOptions: function(optionNames) {
          var result = {};
          if (!optionNames) {
            var options = this.$options;
            optionNames = Object.keys(options).filter(function(key) {
              return !options[key].hidden;
            });
          } else if (!Array.isArray(optionNames)) {
            result = optionNames;
            optionNames = Object.keys(result);
          }
          optionNames.forEach(function(key) {
            result[key] = this.getOption(key);
          }, this);
          return result;
        },
        setOption: function(name, value) {
          if (this["$" + name] === value)
            return;
          var opt = this.$options[name];
          if (!opt) {
            return warn('misspelled option "' + name + '"');
          }
          if (opt.forwardTo)
            return this[opt.forwardTo] && this[opt.forwardTo].setOption(name, value);
          if (!opt.handlesSet)
            this["$" + name] = value;
          if (opt && opt.set)
            opt.set.call(this, value);
        },
        getOption: function(name) {
          var opt = this.$options[name];
          if (!opt) {
            return warn('misspelled option "' + name + '"');
          }
          if (opt.forwardTo)
            return this[opt.forwardTo] && this[opt.forwardTo].getOption(name);
          return opt && opt.get ? opt.get.call(this) : this["$" + name];
        }
      };
      function warn(message) {
        if (typeof console != "undefined" && console.warn)
          console.warn.apply(console, arguments);
      }
      var messages;
      var nlsPlaceholders;
      var AppConfig = (
        /** @class */
        (function() {
          function AppConfig2() {
            this.$defaultOptions = {};
            messages = defaultEnglishMessages;
            nlsPlaceholders = "dollarSigns";
          }
          AppConfig2.prototype.defineOptions = function(obj, path, options) {
            if (!obj.$options)
              this.$defaultOptions[path] = obj.$options = {};
            Object.keys(options).forEach(function(key) {
              var opt = options[key];
              if (typeof opt == "string")
                opt = { forwardTo: opt };
              opt.name || (opt.name = key);
              obj.$options[opt.name] = opt;
              if ("initialValue" in opt)
                obj["$" + opt.name] = opt.initialValue;
            });
            oop.implement(obj, optionsProvider);
            return this;
          };
          AppConfig2.prototype.resetOptions = function(obj) {
            Object.keys(obj.$options).forEach(function(key) {
              var opt = obj.$options[key];
              if ("value" in opt)
                obj.setOption(key, opt.value);
            });
          };
          AppConfig2.prototype.setDefaultValue = function(path, name, value) {
            if (!path) {
              for (path in this.$defaultOptions)
                if (this.$defaultOptions[path][name])
                  break;
              if (!this.$defaultOptions[path][name])
                return false;
            }
            var opts = this.$defaultOptions[path] || (this.$defaultOptions[path] = {});
            if (opts[name]) {
              if (opts.forwardTo)
                this.setDefaultValue(opts.forwardTo, name, value);
              else
                opts[name].value = value;
            }
          };
          AppConfig2.prototype.setDefaultValues = function(path, optionHash) {
            Object.keys(optionHash).forEach(function(key) {
              this.setDefaultValue(path, key, optionHash[key]);
            }, this);
          };
          AppConfig2.prototype.setMessages = function(value, options) {
            messages = value;
            if (options && options.placeholders) {
              nlsPlaceholders = options.placeholders;
            }
          };
          AppConfig2.prototype.nls = function(key, defaultString, params) {
            if (!messages[key]) {
              warn("No message found for the key '" + key + "' in messages with id " + messages.$id + ", trying to find a translation for the default string '" + defaultString + "'.");
              if (!messages[defaultString]) {
                warn("No message found for the default string '" + defaultString + "' in the provided messages. Falling back to the default English message.");
              }
            }
            var translated = messages[key] || messages[defaultString] || defaultString;
            if (params) {
              if (nlsPlaceholders === "dollarSigns") {
                translated = translated.replace(/\$(\$|[\d]+)/g, function(_, dollarMatch) {
                  if (dollarMatch == "$")
                    return "$";
                  return params[dollarMatch];
                });
              }
              if (nlsPlaceholders === "curlyBrackets") {
                translated = translated.replace(/\{([^\}]+)\}/g, function(_, curlyBracketMatch) {
                  return params[curlyBracketMatch];
                });
              }
            }
            return translated;
          };
          return AppConfig2;
        })()
      );
      AppConfig.prototype.warn = warn;
      AppConfig.prototype.reportError = reportError;
      oop.implement(AppConfig.prototype, EventEmitter);
      exports3.AppConfig = AppConfig;
    });
    ace.define("ace/theme/textmate-css", ["require", "exports", "module"], function(require2, exports3, module3) {
      module3.exports = '.ace-tm .ace_gutter {\n  background: #f0f0f0;\n  color: #333;\n}\n\n.ace-tm .ace_print-margin {\n  width: 1px;\n  background: #e8e8e8;\n}\n\n.ace-tm .ace_fold {\n    background-color: #6B72E6;\n}\n\n.ace-tm {\n  background-color: #FFFFFF;\n  color: black;\n}\n\n.ace-tm .ace_cursor {\n  color: black;\n}\n        \n.ace-tm .ace_invisible {\n  color: rgb(191, 191, 191);\n}\n\n.ace-tm .ace_storage,\n.ace-tm .ace_keyword {\n  color: blue;\n}\n\n.ace-tm .ace_constant {\n  color: rgb(197, 6, 11);\n}\n\n.ace-tm .ace_constant.ace_buildin {\n  color: rgb(88, 72, 246);\n}\n\n.ace-tm .ace_constant.ace_language {\n  color: rgb(88, 92, 246);\n}\n\n.ace-tm .ace_constant.ace_library {\n  color: rgb(6, 150, 14);\n}\n\n.ace-tm .ace_invalid {\n  background-color: rgba(255, 0, 0, 0.1);\n  color: red;\n}\n\n.ace-tm .ace_support.ace_function {\n  color: rgb(60, 76, 114);\n}\n\n.ace-tm .ace_support.ace_constant {\n  color: rgb(6, 150, 14);\n}\n\n.ace-tm .ace_support.ace_type,\n.ace-tm .ace_support.ace_class {\n  color: rgb(109, 121, 222);\n}\n\n.ace-tm .ace_keyword.ace_operator {\n  color: rgb(104, 118, 135);\n}\n\n.ace-tm .ace_string {\n  color: rgb(3, 106, 7);\n}\n\n.ace-tm .ace_comment {\n  color: rgb(76, 136, 107);\n}\n\n.ace-tm .ace_comment.ace_doc {\n  color: rgb(0, 102, 255);\n}\n\n.ace-tm .ace_comment.ace_doc.ace_tag {\n  color: rgb(128, 159, 191);\n}\n\n.ace-tm .ace_constant.ace_numeric {\n  color: rgb(0, 0, 205);\n}\n\n.ace-tm .ace_variable {\n  color: rgb(49, 132, 149);\n}\n\n.ace-tm .ace_xml-pe {\n  color: rgb(104, 104, 91);\n}\n\n.ace-tm .ace_entity.ace_name.ace_function {\n  color: #0000A2;\n}\n\n\n.ace-tm .ace_heading {\n  color: rgb(12, 7, 255);\n}\n\n.ace-tm .ace_list {\n  color:rgb(185, 6, 144);\n}\n\n.ace-tm .ace_meta.ace_tag {\n  color:rgb(0, 22, 142);\n}\n\n.ace-tm .ace_string.ace_regex {\n  color: rgb(255, 0, 0)\n}\n\n.ace-tm .ace_marker-layer .ace_selection {\n  background: rgb(181, 213, 255);\n}\n.ace-tm.ace_multiselect .ace_selection.ace_start {\n  box-shadow: 0 0 3px 0px white;\n}\n.ace-tm .ace_marker-layer .ace_step {\n  background: rgb(252, 255, 0);\n}\n\n.ace-tm .ace_marker-layer .ace_stack {\n  background: rgb(164, 229, 101);\n}\n\n.ace-tm .ace_marker-layer .ace_bracket {\n  margin: -1px 0 0 -1px;\n  border: 1px solid rgb(192, 192, 192);\n}\n\n.ace-tm .ace_marker-layer .ace_active-line {\n  background: rgba(0, 0, 0, 0.07);\n}\n\n.ace-tm .ace_gutter-active-line {\n    background-color : #dcdcdc;\n}\n\n.ace-tm .ace_marker-layer .ace_selected-word {\n  background: rgb(250, 250, 255);\n  border: 1px solid rgb(200, 200, 250);\n}\n\n.ace-tm .ace_indent-guide {\n  background: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAACCAYAAACZgbYnAAAAE0lEQVQImWP4////f4bLly//BwAmVgd1/w11/gAAAABJRU5ErkJggg==") right repeat-y;\n}\n\n.ace-tm .ace_indent-guide-active {\n  background: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAACCAYAAACZgbYnAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAIGNIUk0AAHolAACAgwAA+f8AAIDpAAB1MAAA6mAAADqYAAAXb5JfxUYAAAAZSURBVHjaYvj///9/hivKyv8BAAAA//8DACLqBhbvk+/eAAAAAElFTkSuQmCC") right repeat-y;\n}\n';
    });
    ace.define("ace/theme/textmate", ["require", "exports", "module", "ace/theme/textmate-css", "ace/lib/dom"], function(require2, exports3, module3) {
      exports3.isDark = false;
      exports3.cssClass = "ace-tm";
      exports3.cssText = require2("./textmate-css");
      exports3.$id = "ace/theme/textmate";
      var dom = require2("../lib/dom");
      dom.importCssString(exports3.cssText, exports3.cssClass, false);
    });
    ace.define("ace/config", ["require", "exports", "module", "ace/lib/lang", "ace/lib/net", "ace/lib/dom", "ace/lib/app_config", "ace/theme/textmate"], function(require2, exports3, module3) {
      "no use strict";
      var lang = require2("./lib/lang");
      var net = require2("./lib/net");
      var dom = require2("./lib/dom");
      var AppConfig = require2("./lib/app_config").AppConfig;
      module3.exports = exports3 = new AppConfig();
      var options = {
        packaged: false,
        workerPath: null,
        modePath: null,
        themePath: null,
        basePath: "",
        suffix: ".js",
        $moduleUrls: {},
        loadWorkerFromBlob: true,
        sharedPopups: false,
        useStrictCSP: null
      };
      exports3.get = function(key) {
        if (!options.hasOwnProperty(key))
          throw new Error("Unknown config key: " + key);
        return options[key];
      };
      exports3.set = function(key, value) {
        if (options.hasOwnProperty(key))
          options[key] = value;
        else if (this.setDefaultValue("", key, value) == false)
          throw new Error("Unknown config key: " + key);
        if (key == "useStrictCSP")
          dom.useStrictCSP(value);
      };
      exports3.all = function() {
        return lang.copyObject(options);
      };
      exports3.$modes = {};
      exports3.moduleUrl = function(name, component) {
        if (options.$moduleUrls[name])
          return options.$moduleUrls[name];
        var parts = name.split("/");
        component = component || parts[parts.length - 2] || "";
        var sep = component == "snippets" ? "/" : "-";
        var base = parts[parts.length - 1];
        if (component == "worker" && sep == "-") {
          var re2 = new RegExp("^" + component + "[\\-_]|[\\-_]" + component + "$", "g");
          base = base.replace(re2, "");
        }
        if ((!base || base == component) && parts.length > 1)
          base = parts[parts.length - 2];
        var path = options[component + "Path"];
        if (path == null) {
          path = options.basePath;
        } else if (sep == "/") {
          component = sep = "";
        }
        if (path && path.slice(-1) != "/")
          path += "/";
        return path + component + sep + base + this.get("suffix");
      };
      exports3.setModuleUrl = function(name, subst) {
        return options.$moduleUrls[name] = subst;
      };
      var loader2 = function(moduleName, cb) {
        if (moduleName === "ace/theme/textmate" || moduleName === "./theme/textmate")
          return cb(null, require2("./theme/textmate"));
        if (customLoader)
          return customLoader(moduleName, cb);
        console.error("loader is not configured");
      };
      var customLoader;
      exports3.setLoader = function(cb) {
        customLoader = cb;
      };
      exports3.dynamicModules = /* @__PURE__ */ Object.create(null);
      exports3.$loading = {};
      exports3.$loaded = {};
      exports3.loadModule = function(moduleId, onLoad) {
        var loadedModule;
        if (Array.isArray(moduleId)) {
          var moduleType = moduleId[0];
          var moduleName = moduleId[1];
        } else if (typeof moduleId == "string") {
          var moduleName = moduleId;
        }
        var load = function(module4) {
          if (module4 && !exports3.$loading[moduleName])
            return onLoad && onLoad(module4);
          if (!exports3.$loading[moduleName])
            exports3.$loading[moduleName] = [];
          exports3.$loading[moduleName].push(onLoad);
          if (exports3.$loading[moduleName].length > 1)
            return;
          var afterLoad = function() {
            loader2(moduleName, function(err, module5) {
              if (module5)
                exports3.$loaded[moduleName] = module5;
              exports3._emit("load.module", { name: moduleName, module: module5 });
              var listeners = exports3.$loading[moduleName];
              exports3.$loading[moduleName] = null;
              listeners.forEach(function(onLoad2) {
                onLoad2 && onLoad2(module5);
              });
            });
          };
          if (!exports3.get("packaged"))
            return afterLoad();
          net.loadScript(exports3.moduleUrl(moduleName, moduleType), afterLoad);
          reportErrorIfPathIsNotConfigured();
        };
        if (exports3.dynamicModules[moduleName]) {
          exports3.dynamicModules[moduleName]().then(function(module4) {
            if (module4.default) {
              load(module4.default);
            } else {
              load(module4);
            }
          });
        } else {
          try {
            loadedModule = this.$require(moduleName);
          } catch (e2) {
          }
          load(loadedModule || exports3.$loaded[moduleName]);
        }
      };
      exports3.$require = function(moduleName) {
        if (typeof module3["require"] == "function") {
          var req = "require";
          return module3[req](moduleName);
        }
      };
      exports3.setModuleLoader = function(moduleName, onLoad) {
        exports3.dynamicModules[moduleName] = onLoad;
      };
      var reportErrorIfPathIsNotConfigured = function() {
        if (!options.basePath && !options.workerPath && !options.modePath && !options.themePath && !Object.keys(options.$moduleUrls).length) {
          console.error("Unable to infer path to ace from script src,", "use ace.config.set('basePath', 'path') to enable dynamic loading of modes and themes", "or with webpack use ace/webpack-resolver");
          reportErrorIfPathIsNotConfigured = function() {
          };
        }
      };
      exports3.version = "1.39.0";
    });
    ace.define("ace/loader_build", ["require", "exports", "module", "ace/lib/fixoldbrowsers", "ace/config"], function(require2, exports3, module3) {
      require2("./lib/fixoldbrowsers");
      var config = require2("./config");
      config.setLoader(function(moduleName, cb) {
        require2([moduleName], function(module4) {
          cb(null, module4);
        });
      });
      var global2 = /* @__PURE__ */ (function() {
        return this || typeof window != "undefined" && window;
      })();
      module3.exports = function(ace2) {
        config.init = init2;
        config.$require = require2;
        ace2.require = require2;
      };
      init2(true);
      function init2(packaged) {
        if (!global2 || !global2.document)
          return;
        config.set("packaged", packaged || require2.packaged || module3.packaged || global2.define && (void 0).packaged);
        var scriptOptions = {};
        var scriptUrl = "";
        var currentScript = document.currentScript || document._currentScript;
        var currentDocument = currentScript && currentScript.ownerDocument || document;
        if (currentScript && currentScript.src) {
          scriptUrl = currentScript.src.split(/[?#]/)[0].split("/").slice(0, -1).join("/") || "";
        }
        var scripts = currentDocument.getElementsByTagName("script");
        for (var i2 = 0; i2 < scripts.length; i2++) {
          var script = scripts[i2];
          var src = script.src || script.getAttribute("src");
          if (!src)
            continue;
          var attributes = script.attributes;
          for (var j = 0, l = attributes.length; j < l; j++) {
            var attr = attributes[j];
            if (attr.name.indexOf("data-ace-") === 0) {
              scriptOptions[deHyphenate(attr.name.replace(/^data-ace-/, ""))] = attr.value;
            }
          }
          var m3 = src.match(/^(.*)\/ace([\-.]\w+)?\.js(\?|$)/);
          if (m3)
            scriptUrl = m3[1];
        }
        if (scriptUrl) {
          scriptOptions.base = scriptOptions.base || scriptUrl;
          scriptOptions.packaged = true;
        }
        scriptOptions.basePath = scriptOptions.base;
        scriptOptions.workerPath = scriptOptions.workerPath || scriptOptions.base;
        scriptOptions.modePath = scriptOptions.modePath || scriptOptions.base;
        scriptOptions.themePath = scriptOptions.themePath || scriptOptions.base;
        delete scriptOptions.base;
        for (var key in scriptOptions)
          if (typeof scriptOptions[key] !== "undefined")
            config.set(key, scriptOptions[key]);
      }
      function deHyphenate(str) {
        return str.replace(/-(.)/g, function(m3, m1) {
          return m1.toUpperCase();
        });
      }
    });
    ace.define("ace/range", ["require", "exports", "module"], function(require2, exports3, module3) {
      var Range = (
        /** @class */
        (function() {
          function Range2(startRow, startColumn, endRow, endColumn) {
            this.start = {
              row: startRow,
              column: startColumn
            };
            this.end = {
              row: endRow,
              column: endColumn
            };
          }
          Range2.prototype.isEqual = function(range) {
            return this.start.row === range.start.row && this.end.row === range.end.row && this.start.column === range.start.column && this.end.column === range.end.column;
          };
          Range2.prototype.toString = function() {
            return "Range: [" + this.start.row + "/" + this.start.column + "] -> [" + this.end.row + "/" + this.end.column + "]";
          };
          Range2.prototype.contains = function(row, column) {
            return this.compare(row, column) == 0;
          };
          Range2.prototype.compareRange = function(range) {
            var cmp, end = range.end, start = range.start;
            cmp = this.compare(end.row, end.column);
            if (cmp == 1) {
              cmp = this.compare(start.row, start.column);
              if (cmp == 1) {
                return 2;
              } else if (cmp == 0) {
                return 1;
              } else {
                return 0;
              }
            } else if (cmp == -1) {
              return -2;
            } else {
              cmp = this.compare(start.row, start.column);
              if (cmp == -1) {
                return -1;
              } else if (cmp == 1) {
                return 42;
              } else {
                return 0;
              }
            }
          };
          Range2.prototype.comparePoint = function(p) {
            return this.compare(p.row, p.column);
          };
          Range2.prototype.containsRange = function(range) {
            return this.comparePoint(range.start) == 0 && this.comparePoint(range.end) == 0;
          };
          Range2.prototype.intersects = function(range) {
            var cmp = this.compareRange(range);
            return cmp == -1 || cmp == 0 || cmp == 1;
          };
          Range2.prototype.isEnd = function(row, column) {
            return this.end.row == row && this.end.column == column;
          };
          Range2.prototype.isStart = function(row, column) {
            return this.start.row == row && this.start.column == column;
          };
          Range2.prototype.setStart = function(row, column) {
            if (typeof row == "object") {
              this.start.column = row.column;
              this.start.row = row.row;
            } else {
              this.start.row = row;
              this.start.column = column;
            }
          };
          Range2.prototype.setEnd = function(row, column) {
            if (typeof row == "object") {
              this.end.column = row.column;
              this.end.row = row.row;
            } else {
              this.end.row = row;
              this.end.column = column;
            }
          };
          Range2.prototype.inside = function(row, column) {
            if (this.compare(row, column) == 0) {
              if (this.isEnd(row, column) || this.isStart(row, column)) {
                return false;
              } else {
                return true;
              }
            }
            return false;
          };
          Range2.prototype.insideStart = function(row, column) {
            if (this.compare(row, column) == 0) {
              if (this.isEnd(row, column)) {
                return false;
              } else {
                return true;
              }
            }
            return false;
          };
          Range2.prototype.insideEnd = function(row, column) {
            if (this.compare(row, column) == 0) {
              if (this.isStart(row, column)) {
                return false;
              } else {
                return true;
              }
            }
            return false;
          };
          Range2.prototype.compare = function(row, column) {
            if (!this.isMultiLine()) {
              if (row === this.start.row) {
                return column < this.start.column ? -1 : column > this.end.column ? 1 : 0;
              }
            }
            if (row < this.start.row)
              return -1;
            if (row > this.end.row)
              return 1;
            if (this.start.row === row)
              return column >= this.start.column ? 0 : -1;
            if (this.end.row === row)
              return column <= this.end.column ? 0 : 1;
            return 0;
          };
          Range2.prototype.compareStart = function(row, column) {
            if (this.start.row == row && this.start.column == column) {
              return -1;
            } else {
              return this.compare(row, column);
            }
          };
          Range2.prototype.compareEnd = function(row, column) {
            if (this.end.row == row && this.end.column == column) {
              return 1;
            } else {
              return this.compare(row, column);
            }
          };
          Range2.prototype.compareInside = function(row, column) {
            if (this.end.row == row && this.end.column == column) {
              return 1;
            } else if (this.start.row == row && this.start.column == column) {
              return -1;
            } else {
              return this.compare(row, column);
            }
          };
          Range2.prototype.clipRows = function(firstRow, lastRow) {
            if (this.end.row > lastRow)
              var end = { row: lastRow + 1, column: 0 };
            else if (this.end.row < firstRow)
              var end = { row: firstRow, column: 0 };
            if (this.start.row > lastRow)
              var start = { row: lastRow + 1, column: 0 };
            else if (this.start.row < firstRow)
              var start = { row: firstRow, column: 0 };
            return Range2.fromPoints(start || this.start, end || this.end);
          };
          Range2.prototype.extend = function(row, column) {
            var cmp = this.compare(row, column);
            if (cmp == 0)
              return this;
            else if (cmp == -1)
              var start = { row, column };
            else
              var end = { row, column };
            return Range2.fromPoints(start || this.start, end || this.end);
          };
          Range2.prototype.isEmpty = function() {
            return this.start.row === this.end.row && this.start.column === this.end.column;
          };
          Range2.prototype.isMultiLine = function() {
            return this.start.row !== this.end.row;
          };
          Range2.prototype.clone = function() {
            return Range2.fromPoints(this.start, this.end);
          };
          Range2.prototype.collapseRows = function() {
            if (this.end.column == 0)
              return new Range2(this.start.row, 0, Math.max(this.start.row, this.end.row - 1), 0);
            else
              return new Range2(this.start.row, 0, this.end.row, 0);
          };
          Range2.prototype.toScreenRange = function(session) {
            var screenPosStart = session.documentToScreenPosition(this.start);
            var screenPosEnd = session.documentToScreenPosition(this.end);
            return new Range2(screenPosStart.row, screenPosStart.column, screenPosEnd.row, screenPosEnd.column);
          };
          Range2.prototype.moveBy = function(row, column) {
            this.start.row += row;
            this.start.column += column;
            this.end.row += row;
            this.end.column += column;
          };
          return Range2;
        })()
      );
      Range.fromPoints = function(start, end) {
        return new Range(start.row, start.column, end.row, end.column);
      };
      Range.comparePoints = function(p1, p2) {
        return p1.row - p2.row || p1.column - p2.column;
      };
      exports3.Range = Range;
    });
    ace.define("ace/lib/keys", ["require", "exports", "module", "ace/lib/oop"], function(require2, exports3, module3) {
      var oop = require2("./oop");
      var Keys = {
        MODIFIER_KEYS: {
          16: "Shift",
          17: "Ctrl",
          18: "Alt",
          224: "Meta",
          91: "MetaLeft",
          92: "MetaRight",
          93: "ContextMenu"
        },
        KEY_MODS: {
          "ctrl": 1,
          "alt": 2,
          "option": 2,
          "shift": 4,
          "super": 8,
          "meta": 8,
          "command": 8,
          "cmd": 8,
          "control": 1
        },
        FUNCTION_KEYS: {
          8: "Backspace",
          9: "Tab",
          13: "Return",
          19: "Pause",
          27: "Esc",
          32: "Space",
          33: "PageUp",
          34: "PageDown",
          35: "End",
          36: "Home",
          37: "Left",
          38: "Up",
          39: "Right",
          40: "Down",
          44: "Print",
          45: "Insert",
          46: "Delete",
          "-13": "NumpadEnter",
          144: "Numlock",
          145: "Scrolllock"
        },
        PRINTABLE_KEYS: {
          32: " ",
          59: ";",
          61: "=",
          107: "+",
          109: "-",
          110: ".",
          186: ";",
          187: "=",
          188: ",",
          189: "-",
          190: ".",
          191: "/",
          192: "`",
          219: "[",
          220: "\\",
          221: "]",
          222: "'",
          111: "/",
          106: "*"
        }
      };
      var codeToKeyCode = {
        Command: 224,
        Backspace: 8,
        Tab: 9,
        Return: 13,
        Enter: 13,
        Pause: 19,
        Escape: 27,
        PageUp: 33,
        PageDown: 34,
        End: 35,
        Home: 36,
        Insert: 45,
        Delete: 46,
        ArrowLeft: 37,
        ArrowUp: 38,
        ArrowRight: 39,
        ArrowDown: 40,
        Backquote: 192,
        Minus: 189,
        Equal: 187,
        BracketLeft: 219,
        Backslash: 220,
        BracketRight: 221,
        Semicolon: 186,
        Quote: 222,
        Comma: 188,
        Period: 190,
        Slash: 191,
        Space: 32,
        NumpadAdd: 107,
        NumpadDecimal: 110,
        NumpadSubtract: 109,
        NumpadDivide: 111,
        NumpadMultiply: 106
      };
      for (var i2 = 0; i2 < 10; i2++) {
        codeToKeyCode["Digit" + i2] = 48 + i2;
        codeToKeyCode["Numpad" + i2] = 96 + i2;
        Keys.PRINTABLE_KEYS[48 + i2] = "" + i2;
        Keys.FUNCTION_KEYS[96 + i2] = "Numpad" + i2;
      }
      for (var i2 = 65; i2 < 91; i2++) {
        var chr = String.fromCharCode(i2 + 32);
        codeToKeyCode["Key" + chr.toUpperCase()] = i2;
        Keys.PRINTABLE_KEYS[i2] = chr;
      }
      for (var i2 = 1; i2 < 13; i2++) {
        codeToKeyCode["F" + i2] = 111 + i2;
        Keys.FUNCTION_KEYS[111 + i2] = "F" + i2;
      }
      var modifiers = {
        Shift: 16,
        Control: 17,
        Alt: 18,
        Meta: 224
      };
      for (var mod in modifiers) {
        codeToKeyCode[mod] = codeToKeyCode[mod + "Left"] = codeToKeyCode[mod + "Right"] = modifiers[mod];
      }
      exports3.$codeToKeyCode = codeToKeyCode;
      Keys.PRINTABLE_KEYS[173] = "-";
      for (var j in Keys.FUNCTION_KEYS) {
        var name = Keys.FUNCTION_KEYS[j].toLowerCase();
        Keys[name] = parseInt(j, 10);
      }
      for (var j in Keys.PRINTABLE_KEYS) {
        var name = Keys.PRINTABLE_KEYS[j].toLowerCase();
        Keys[name] = parseInt(j, 10);
      }
      oop.mixin(Keys, Keys.MODIFIER_KEYS);
      oop.mixin(Keys, Keys.PRINTABLE_KEYS);
      oop.mixin(Keys, Keys.FUNCTION_KEYS);
      Keys.enter = Keys["return"];
      Keys.escape = Keys.esc;
      Keys.del = Keys["delete"];
      (function() {
        var mods = ["cmd", "ctrl", "alt", "shift"];
        for (var i3 = Math.pow(2, mods.length); i3--; ) {
          Keys.KEY_MODS[i3] = mods.filter(function(x2) {
            return i3 & Keys.KEY_MODS[x2];
          }).join("-") + "-";
        }
      })();
      Keys.KEY_MODS[0] = "";
      Keys.KEY_MODS[-1] = "input-";
      oop.mixin(exports3, Keys);
      exports3.default = exports3;
      exports3.keyCodeToString = function(keyCode) {
        var keyString = Keys[keyCode];
        if (typeof keyString != "string")
          keyString = String.fromCharCode(keyCode);
        return keyString.toLowerCase();
      };
    });
    ace.define("ace/lib/event", ["require", "exports", "module", "ace/lib/keys", "ace/lib/useragent"], function(require2, exports3, module3) {
      var keys = require2("./keys");
      var useragent = require2("./useragent");
      var pressedKeys = null;
      var ts = 0;
      var activeListenerOptions;
      function detectListenerOptionsSupport() {
        activeListenerOptions = false;
        try {
          document.createComment("").addEventListener("test", function() {
          }, {
            get passive() {
              activeListenerOptions = { passive: false };
              return true;
            }
          });
        } catch (e2) {
        }
      }
      function getListenerOptions() {
        if (activeListenerOptions == void 0)
          detectListenerOptionsSupport();
        return activeListenerOptions;
      }
      function EventListener(elem, type, callback) {
        this.elem = elem;
        this.type = type;
        this.callback = callback;
      }
      EventListener.prototype.destroy = function() {
        removeListener2(this.elem, this.type, this.callback);
        this.elem = this.type = this.callback = void 0;
      };
      var addListener2 = exports3.addListener = function(elem, type, callback, destroyer) {
        elem.addEventListener(type, callback, getListenerOptions());
        if (destroyer)
          destroyer.$toDestroy.push(new EventListener(elem, type, callback));
      };
      var removeListener2 = exports3.removeListener = function(elem, type, callback) {
        elem.removeEventListener(type, callback, getListenerOptions());
      };
      exports3.stopEvent = function(e2) {
        exports3.stopPropagation(e2);
        exports3.preventDefault(e2);
        return false;
      };
      exports3.stopPropagation = function(e2) {
        if (e2.stopPropagation)
          e2.stopPropagation();
      };
      exports3.preventDefault = function(e2) {
        if (e2.preventDefault)
          e2.preventDefault();
      };
      exports3.getButton = function(e2) {
        if (e2.type == "dblclick")
          return 0;
        if (e2.type == "contextmenu" || useragent.isMac && (e2.ctrlKey && !e2.altKey && !e2.shiftKey))
          return 2;
        return e2.button;
      };
      exports3.capture = function(el, eventHandler, releaseCaptureHandler) {
        var ownerDocument = el && el.ownerDocument || document;
        function onMouseUp(e2) {
          eventHandler && eventHandler(e2);
          releaseCaptureHandler && releaseCaptureHandler(e2);
          removeListener2(ownerDocument, "mousemove", eventHandler);
          removeListener2(ownerDocument, "mouseup", onMouseUp);
          removeListener2(ownerDocument, "dragstart", onMouseUp);
        }
        addListener2(ownerDocument, "mousemove", eventHandler);
        addListener2(ownerDocument, "mouseup", onMouseUp);
        addListener2(ownerDocument, "dragstart", onMouseUp);
        return onMouseUp;
      };
      exports3.addMouseWheelListener = function(el, callback, destroyer) {
        addListener2(el, "wheel", function(e2) {
          var factor = 0.15;
          var deltaX = e2.deltaX || 0;
          var deltaY = e2.deltaY || 0;
          switch (e2.deltaMode) {
            case e2.DOM_DELTA_PIXEL:
              e2.wheelX = deltaX * factor;
              e2.wheelY = deltaY * factor;
              break;
            case e2.DOM_DELTA_LINE:
              var linePixels = 15;
              e2.wheelX = deltaX * linePixels;
              e2.wheelY = deltaY * linePixels;
              break;
            case e2.DOM_DELTA_PAGE:
              var pagePixels = 150;
              e2.wheelX = deltaX * pagePixels;
              e2.wheelY = deltaY * pagePixels;
              break;
          }
          callback(e2);
        }, destroyer);
      };
      exports3.addMultiMouseDownListener = function(elements, timeouts2, eventHandler, callbackName, destroyer) {
        var clicks = 0;
        var startX, startY, timer;
        var eventNames = {
          2: "dblclick",
          3: "tripleclick",
          4: "quadclick"
        };
        function onMousedown(e2) {
          if (exports3.getButton(e2) !== 0) {
            clicks = 0;
          } else if (e2.detail > 1) {
            clicks++;
            if (clicks > 4)
              clicks = 1;
          } else {
            clicks = 1;
          }
          if (useragent.isIE) {
            var isNewClick = Math.abs(e2.clientX - startX) > 5 || Math.abs(e2.clientY - startY) > 5;
            if (!timer || isNewClick)
              clicks = 1;
            if (timer)
              clearTimeout(timer);
            timer = setTimeout(function() {
              timer = null;
            }, timeouts2[clicks - 1] || 600);
            if (clicks == 1) {
              startX = e2.clientX;
              startY = e2.clientY;
            }
          }
          e2._clicks = clicks;
          eventHandler[callbackName]("mousedown", e2);
          if (clicks > 4)
            clicks = 0;
          else if (clicks > 1)
            return eventHandler[callbackName](eventNames[clicks], e2);
        }
        if (!Array.isArray(elements))
          elements = [elements];
        elements.forEach(function(el) {
          addListener2(el, "mousedown", onMousedown, destroyer);
        });
      };
      function getModifierHash(e2) {
        return 0 | (e2.ctrlKey ? 1 : 0) | (e2.altKey ? 2 : 0) | (e2.shiftKey ? 4 : 0) | (e2.metaKey ? 8 : 0);
      }
      exports3.getModifierString = function(e2) {
        return keys.KEY_MODS[getModifierHash(e2)];
      };
      function normalizeCommandKeys(callback, e2, keyCode) {
        var hashId = getModifierHash(e2);
        if (!keyCode && e2.code) {
          keyCode = keys.$codeToKeyCode[e2.code] || keyCode;
        }
        if (!useragent.isMac && pressedKeys) {
          if (e2.getModifierState && (e2.getModifierState("OS") || e2.getModifierState("Win")))
            hashId |= 8;
          if (pressedKeys.altGr) {
            if ((3 & hashId) != 3)
              pressedKeys.altGr = 0;
            else
              return;
          }
          if (keyCode === 18 || keyCode === 17) {
            var location2 = e2.location;
            if (keyCode === 17 && location2 === 1) {
              if (pressedKeys[keyCode] == 1)
                ts = e2.timeStamp;
            } else if (keyCode === 18 && hashId === 3 && location2 === 2) {
              var dt = e2.timeStamp - ts;
              if (dt < 50)
                pressedKeys.altGr = true;
            }
          }
        }
        if (keyCode in keys.MODIFIER_KEYS) {
          keyCode = -1;
        }
        if (!hashId && keyCode === 13) {
          if (e2.location === 3) {
            callback(e2, hashId, -keyCode);
            if (e2.defaultPrevented)
              return;
          }
        }
        if (useragent.isChromeOS && hashId & 8) {
          callback(e2, hashId, keyCode);
          if (e2.defaultPrevented)
            return;
          else
            hashId &= -9;
        }
        if (!hashId && !(keyCode in keys.FUNCTION_KEYS) && !(keyCode in keys.PRINTABLE_KEYS)) {
          return false;
        }
        return callback(e2, hashId, keyCode);
      }
      exports3.addCommandKeyListener = function(el, callback, destroyer) {
        var lastDefaultPrevented = null;
        addListener2(el, "keydown", function(e2) {
          pressedKeys[e2.keyCode] = (pressedKeys[e2.keyCode] || 0) + 1;
          var result = normalizeCommandKeys(callback, e2, e2.keyCode);
          lastDefaultPrevented = e2.defaultPrevented;
          return result;
        }, destroyer);
        addListener2(el, "keypress", function(e2) {
          if (lastDefaultPrevented && (e2.ctrlKey || e2.altKey || e2.shiftKey || e2.metaKey)) {
            exports3.stopEvent(e2);
            lastDefaultPrevented = null;
          }
        }, destroyer);
        addListener2(el, "keyup", function(e2) {
          pressedKeys[e2.keyCode] = null;
        }, destroyer);
        if (!pressedKeys) {
          resetPressedKeys();
          addListener2(window, "focus", resetPressedKeys);
        }
      };
      function resetPressedKeys() {
        pressedKeys = /* @__PURE__ */ Object.create(null);
      }
      if (typeof window == "object" && window.postMessage && !useragent.isOldIE) {
        var postMessageId = 1;
        exports3.nextTick = function(callback, win) {
          win = win || window;
          var messageName = "zero-timeout-message-" + postMessageId++;
          var listener = function(e2) {
            if (e2.data == messageName) {
              exports3.stopPropagation(e2);
              removeListener2(win, "message", listener);
              callback();
            }
          };
          addListener2(win, "message", listener);
          win.postMessage(messageName, "*");
        };
      }
      exports3.$idleBlocked = false;
      exports3.onIdle = function(cb, timeout) {
        return setTimeout(function handler() {
          if (!exports3.$idleBlocked) {
            cb();
          } else {
            setTimeout(handler, 100);
          }
        }, timeout);
      };
      exports3.$idleBlockId = null;
      exports3.blockIdle = function(delay) {
        if (exports3.$idleBlockId)
          clearTimeout(exports3.$idleBlockId);
        exports3.$idleBlocked = true;
        exports3.$idleBlockId = setTimeout(function() {
          exports3.$idleBlocked = false;
        }, delay || 100);
      };
      exports3.nextFrame = typeof window == "object" && (window.requestAnimationFrame || window["mozRequestAnimationFrame"] || window["webkitRequestAnimationFrame"] || window["msRequestAnimationFrame"] || window["oRequestAnimationFrame"]);
      if (exports3.nextFrame)
        exports3.nextFrame = exports3.nextFrame.bind(window);
      else
        exports3.nextFrame = function(callback) {
          setTimeout(callback, 17);
        };
    });
    ace.define("ace/clipboard", ["require", "exports", "module"], function(require2, exports3, module3) {
      var $cancelT;
      module3.exports = {
        lineMode: false,
        pasteCancelled: function() {
          if ($cancelT && $cancelT > Date.now() - 50)
            return true;
          return $cancelT = false;
        },
        cancel: function() {
          $cancelT = Date.now();
        }
      };
    });
    ace.define("ace/keyboard/textinput", ["require", "exports", "module", "ace/lib/event", "ace/config", "ace/lib/useragent", "ace/lib/dom", "ace/lib/lang", "ace/clipboard", "ace/lib/keys"], function(require2, exports3, module3) {
      var event = require2("../lib/event");
      var nls = require2("../config").nls;
      var useragent = require2("../lib/useragent");
      var dom = require2("../lib/dom");
      var lang = require2("../lib/lang");
      var clipboard = require2("../clipboard");
      var BROKEN_SETDATA = useragent.isChrome < 18;
      var USE_IE_MIME_TYPE = useragent.isIE;
      var HAS_FOCUS_ARGS = useragent.isChrome > 63;
      var MAX_LINE_LENGTH = 400;
      var KEYS = require2("../lib/keys");
      var MODS = KEYS.KEY_MODS;
      var isIOS2 = useragent.isIOS;
      var valueResetRegex = isIOS2 ? /\s/ : /\n/;
      var isMobile = useragent.isMobile;
      var TextInput;
      TextInput = function(parentNode, host) {
        var text = dom.createElement("textarea");
        text.className = "ace_text-input";
        text.setAttribute("wrap", "off");
        text.setAttribute("autocorrect", "off");
        text.setAttribute("autocapitalize", "off");
        text.setAttribute("spellcheck", "false");
        text.style.opacity = "0";
        parentNode.insertBefore(text, parentNode.firstChild);
        var copied = false;
        var pasted = false;
        var inComposition = false;
        var sendingText = false;
        var tempStyle = "";
        if (!isMobile)
          text.style.fontSize = "1px";
        var commandMode = false;
        var ignoreFocusEvents = false;
        var lastValue = "";
        var lastSelectionStart = 0;
        var lastSelectionEnd = 0;
        var lastRestoreEnd = 0;
        var rowStart = Number.MAX_SAFE_INTEGER;
        var rowEnd = Number.MIN_SAFE_INTEGER;
        var numberOfExtraLines = 0;
        try {
          var isFocused = document.activeElement === text;
        } catch (e2) {
        }
        this.setNumberOfExtraLines = function(number) {
          rowStart = Number.MAX_SAFE_INTEGER;
          rowEnd = Number.MIN_SAFE_INTEGER;
          if (number < 0) {
            numberOfExtraLines = 0;
            return;
          }
          numberOfExtraLines = number;
        };
        this.setAriaLabel = function() {
          var ariaLabel = "";
          if (host.$textInputAriaLabel) {
            ariaLabel += "".concat(host.$textInputAriaLabel, ", ");
          }
          if (host.session) {
            var row = host.session.selection.cursor.row;
            ariaLabel += nls("text-input.aria-label", "Cursor at row $0", [row + 1]);
          }
          text.setAttribute("aria-label", ariaLabel);
        };
        this.setAriaOptions = function(options) {
          if (options.activeDescendant) {
            text.setAttribute("aria-haspopup", "true");
            text.setAttribute("aria-autocomplete", options.inline ? "both" : "list");
            text.setAttribute("aria-activedescendant", options.activeDescendant);
          } else {
            text.setAttribute("aria-haspopup", "false");
            text.setAttribute("aria-autocomplete", "both");
            text.removeAttribute("aria-activedescendant");
          }
          if (options.role) {
            text.setAttribute("role", options.role);
          }
          if (options.setLabel) {
            text.setAttribute("aria-roledescription", nls("text-input.aria-roledescription", "editor"));
            this.setAriaLabel();
          }
        };
        this.setAriaOptions({ role: "textbox" });
        event.addListener(text, "blur", function(e2) {
          if (ignoreFocusEvents)
            return;
          host.onBlur(e2);
          isFocused = false;
        }, host);
        event.addListener(text, "focus", function(e2) {
          if (ignoreFocusEvents)
            return;
          isFocused = true;
          if (useragent.isEdge) {
            try {
              if (!document.hasFocus())
                return;
            } catch (e3) {
            }
          }
          host.onFocus(e2);
          if (useragent.isEdge)
            setTimeout(resetSelection);
          else
            resetSelection();
        }, host);
        this.$focusScroll = false;
        this.focus = function() {
          this.setAriaOptions({
            setLabel: host.renderer.enableKeyboardAccessibility
          });
          if (tempStyle || HAS_FOCUS_ARGS || this.$focusScroll == "browser")
            return text.focus({ preventScroll: true });
          var top = text.style.top;
          text.style.position = "fixed";
          text.style.top = "0px";
          try {
            var isTransformed = text.getBoundingClientRect().top != 0;
          } catch (e2) {
            return;
          }
          var ancestors = [];
          if (isTransformed) {
            var t2 = text.parentElement;
            while (t2 && t2.nodeType == 1) {
              ancestors.push(t2);
              t2.setAttribute("ace_nocontext", "true");
              if (!t2.parentElement && t2.getRootNode)
                t2 = t2.getRootNode()["host"];
              else
                t2 = t2.parentElement;
            }
          }
          text.focus({ preventScroll: true });
          if (isTransformed) {
            ancestors.forEach(function(p) {
              p.removeAttribute("ace_nocontext");
            });
          }
          setTimeout(function() {
            text.style.position = "";
            if (text.style.top == "0px")
              text.style.top = top;
          }, 0);
        };
        this.blur = function() {
          text.blur();
        };
        this.isFocused = function() {
          return isFocused;
        };
        host.on("beforeEndOperation", function() {
          var curOp = host.curOp;
          var commandName = curOp && curOp.command && curOp.command.name;
          if (commandName == "insertstring")
            return;
          var isUserAction = commandName && (curOp.docChanged || curOp.selectionChanged);
          if (inComposition && isUserAction) {
            lastValue = text.value = "";
            onCompositionEnd();
          }
          resetSelection();
        });
        host.on("changeSelection", this.setAriaLabel);
        var positionToSelection = function(row, column) {
          var selection = column;
          for (var i2 = 1; i2 <= row - rowStart && i2 < 2 * numberOfExtraLines + 1; i2++) {
            selection += host.session.getLine(row - i2).length + 1;
          }
          return selection;
        };
        var resetSelection = isIOS2 ? function(value) {
          if (!isFocused || copied && !value || sendingText)
            return;
          if (!value)
            value = "";
          var newValue = "\n ab" + value + "cde fg\n";
          if (newValue != text.value)
            text.value = lastValue = newValue;
          var selectionStart = 4;
          var selectionEnd = 4 + (value.length || (host.selection.isEmpty() ? 0 : 1));
          if (lastSelectionStart != selectionStart || lastSelectionEnd != selectionEnd) {
            text.setSelectionRange(selectionStart, selectionEnd);
          }
          lastSelectionStart = selectionStart;
          lastSelectionEnd = selectionEnd;
        } : function() {
          if (inComposition || sendingText)
            return;
          if (!isFocused && !afterContextMenu)
            return;
          inComposition = true;
          var selectionStart = 0;
          var selectionEnd = 0;
          var line = "";
          if (host.session) {
            var selection = host.selection;
            var range = selection.getRange();
            var row = selection.cursor.row;
            if (row === rowEnd + 1) {
              rowStart = rowEnd + 1;
              rowEnd = rowStart + 2 * numberOfExtraLines;
            } else if (row === rowStart - 1) {
              rowEnd = rowStart - 1;
              rowStart = rowEnd - 2 * numberOfExtraLines;
            } else if (row < rowStart - 1 || row > rowEnd + 1) {
              rowStart = row > numberOfExtraLines ? row - numberOfExtraLines : 0;
              rowEnd = row > numberOfExtraLines ? row + numberOfExtraLines : 2 * numberOfExtraLines;
            }
            var lines = [];
            for (var i2 = rowStart; i2 <= rowEnd; i2++) {
              lines.push(host.session.getLine(i2));
            }
            line = lines.join("\n");
            selectionStart = positionToSelection(range.start.row, range.start.column);
            selectionEnd = positionToSelection(range.end.row, range.end.column);
            if (range.start.row < rowStart) {
              var prevLine = host.session.getLine(rowStart - 1);
              selectionStart = range.start.row < rowStart - 1 ? 0 : selectionStart;
              selectionEnd += prevLine.length + 1;
              line = prevLine + "\n" + line;
            } else if (range.end.row > rowEnd) {
              var nextLine = host.session.getLine(rowEnd + 1);
              selectionEnd = range.end.row > rowEnd + 1 ? nextLine.length : range.end.column;
              selectionEnd += line.length + 1;
              line = line + "\n" + nextLine;
            } else if (isMobile && row > 0) {
              line = "\n" + line;
              selectionEnd += 1;
              selectionStart += 1;
            }
            if (line.length > MAX_LINE_LENGTH) {
              if (selectionStart < MAX_LINE_LENGTH && selectionEnd < MAX_LINE_LENGTH) {
                line = line.slice(0, MAX_LINE_LENGTH);
              } else {
                line = "\n";
                if (selectionStart == selectionEnd) {
                  selectionStart = selectionEnd = 0;
                } else {
                  selectionStart = 0;
                  selectionEnd = 1;
                }
              }
            }
            var newValue = line + "\n\n";
            if (newValue != lastValue) {
              text.value = lastValue = newValue;
              lastSelectionStart = lastSelectionEnd = newValue.length;
            }
          }
          if (afterContextMenu) {
            lastSelectionStart = text.selectionStart;
            lastSelectionEnd = text.selectionEnd;
          }
          if (lastSelectionEnd != selectionEnd || lastSelectionStart != selectionStart || text.selectionEnd != lastSelectionEnd) {
            try {
              text.setSelectionRange(selectionStart, selectionEnd);
              lastSelectionStart = selectionStart;
              lastSelectionEnd = selectionEnd;
            } catch (e2) {
            }
          }
          inComposition = false;
        };
        this.resetSelection = resetSelection;
        if (isFocused)
          host.onFocus();
        var isAllSelected = function(text2) {
          return text2.selectionStart === 0 && text2.selectionEnd >= lastValue.length && text2.value === lastValue && lastValue && text2.selectionEnd !== lastSelectionEnd;
        };
        var onSelect = function(e2) {
          if (inComposition)
            return;
          if (copied) {
            copied = false;
          } else if (isAllSelected(text)) {
            host.selectAll();
            resetSelection();
          } else if (isMobile && text.selectionStart != lastSelectionStart) {
            resetSelection();
          }
        };
        var inputHandler = null;
        this.setInputHandler = function(cb) {
          inputHandler = cb;
        };
        this.getInputHandler = function() {
          return inputHandler;
        };
        var afterContextMenu = false;
        var sendText = function(value, fromInput) {
          if (afterContextMenu)
            afterContextMenu = false;
          if (pasted) {
            resetSelection();
            if (value)
              host.onPaste(value);
            pasted = false;
            return "";
          } else {
            var selectionStart = text.selectionStart;
            var selectionEnd = text.selectionEnd;
            var extendLeft = lastSelectionStart;
            var extendRight = lastValue.length - lastSelectionEnd;
            var inserted = value;
            var restoreStart = value.length - selectionStart;
            var restoreEnd = value.length - selectionEnd;
            var i2 = 0;
            while (extendLeft > 0 && lastValue[i2] == value[i2]) {
              i2++;
              extendLeft--;
            }
            inserted = inserted.slice(i2);
            i2 = 1;
            while (extendRight > 0 && lastValue.length - i2 > lastSelectionStart - 1 && lastValue[lastValue.length - i2] == value[value.length - i2]) {
              i2++;
              extendRight--;
            }
            restoreStart -= i2 - 1;
            restoreEnd -= i2 - 1;
            var endIndex = inserted.length - i2 + 1;
            if (endIndex < 0) {
              extendLeft = -endIndex;
              endIndex = 0;
            }
            inserted = inserted.slice(0, endIndex);
            if (!fromInput && !inserted && !restoreStart && !extendLeft && !extendRight && !restoreEnd)
              return "";
            sendingText = true;
            var shouldReset = false;
            if (useragent.isAndroid && inserted == ". ") {
              inserted = "  ";
              shouldReset = true;
            }
            if (inserted && !extendLeft && !extendRight && !restoreStart && !restoreEnd || commandMode) {
              host.onTextInput(inserted);
            } else {
              host.onTextInput(inserted, {
                extendLeft,
                extendRight,
                restoreStart,
                restoreEnd
              });
            }
            sendingText = false;
            lastValue = value;
            lastSelectionStart = selectionStart;
            lastSelectionEnd = selectionEnd;
            lastRestoreEnd = restoreEnd;
            return shouldReset ? "\n" : inserted;
          }
        };
        var onInput = function(e2) {
          if (inComposition)
            return onCompositionUpdate();
          if (e2 && e2.inputType) {
            if (e2.inputType == "historyUndo")
              return host.execCommand("undo");
            if (e2.inputType == "historyRedo")
              return host.execCommand("redo");
          }
          var data = text.value;
          var inserted = sendText(data, true);
          if (data.length > MAX_LINE_LENGTH + 100 || valueResetRegex.test(inserted) || isMobile && lastSelectionStart < 1 && lastSelectionStart == lastSelectionEnd) {
            resetSelection();
          }
        };
        var handleClipboardData = function(e2, data, forceIEMime) {
          var clipboardData = e2.clipboardData || window["clipboardData"];
          if (!clipboardData || BROKEN_SETDATA)
            return;
          var mime = USE_IE_MIME_TYPE || forceIEMime ? "Text" : "text/plain";
          try {
            if (data) {
              return clipboardData.setData(mime, data) !== false;
            } else {
              return clipboardData.getData(mime);
            }
          } catch (e3) {
            if (!forceIEMime)
              return handleClipboardData(e3, data, true);
          }
        };
        var doCopy = function(e2, isCut) {
          var data = host.getCopyText();
          if (!data)
            return event.preventDefault(e2);
          if (handleClipboardData(e2, data)) {
            if (isIOS2) {
              resetSelection(data);
              copied = data;
              setTimeout(function() {
                copied = false;
              }, 10);
            }
            isCut ? host.onCut() : host.onCopy();
            event.preventDefault(e2);
          } else {
            copied = true;
            text.value = data;
            text.select();
            setTimeout(function() {
              copied = false;
              resetSelection();
              isCut ? host.onCut() : host.onCopy();
            });
          }
        };
        var onCut = function(e2) {
          doCopy(e2, true);
        };
        var onCopy = function(e2) {
          doCopy(e2, false);
        };
        var onPaste = function(e2) {
          var data = handleClipboardData(e2);
          if (clipboard.pasteCancelled())
            return;
          if (typeof data == "string") {
            if (data)
              host.onPaste(data, e2);
            if (useragent.isIE)
              setTimeout(resetSelection);
            event.preventDefault(e2);
          } else {
            text.value = "";
            pasted = true;
          }
        };
        event.addCommandKeyListener(text, function(e2, hashId, keyCode) {
          if (inComposition)
            return;
          return host.onCommandKey(e2, hashId, keyCode);
        }, host);
        event.addListener(text, "select", onSelect, host);
        event.addListener(text, "input", onInput, host);
        event.addListener(text, "cut", onCut, host);
        event.addListener(text, "copy", onCopy, host);
        event.addListener(text, "paste", onPaste, host);
        if (!("oncut" in text) || !("oncopy" in text) || !("onpaste" in text)) {
          event.addListener(parentNode, "keydown", function(e2) {
            if (useragent.isMac && !e2.metaKey || !e2.ctrlKey)
              return;
            switch (e2.keyCode) {
              case 67:
                onCopy(e2);
                break;
              case 86:
                onPaste(e2);
                break;
              case 88:
                onCut(e2);
                break;
            }
          }, host);
        }
        var onCompositionStart = function(e2) {
          if (inComposition || !host.onCompositionStart || host.$readOnly)
            return;
          inComposition = {};
          if (commandMode)
            return;
          if (e2.data)
            inComposition.useTextareaForIME = false;
          setTimeout(onCompositionUpdate, 0);
          host._signal("compositionStart");
          host.on("mousedown", cancelComposition);
          var range = host.getSelectionRange();
          range.end.row = range.start.row;
          range.end.column = range.start.column;
          inComposition.markerRange = range;
          inComposition.selectionStart = lastSelectionStart;
          host.onCompositionStart(inComposition);
          if (inComposition.useTextareaForIME) {
            lastValue = text.value = "";
            lastSelectionStart = 0;
            lastSelectionEnd = 0;
          } else {
            if (text.msGetInputContext)
              inComposition.context = text.msGetInputContext();
            if (text.getInputContext)
              inComposition.context = text.getInputContext();
          }
        };
        var onCompositionUpdate = function() {
          if (!inComposition || !host.onCompositionUpdate || host.$readOnly)
            return;
          if (commandMode)
            return cancelComposition();
          if (inComposition.useTextareaForIME) {
            host.onCompositionUpdate(text.value);
          } else {
            var data = text.value;
            sendText(data);
            if (inComposition.markerRange) {
              if (inComposition.context) {
                inComposition.markerRange.start.column = inComposition.selectionStart = inComposition.context.compositionStartOffset;
              }
              inComposition.markerRange.end.column = inComposition.markerRange.start.column + lastSelectionEnd - inComposition.selectionStart + lastRestoreEnd;
            }
          }
        };
        var onCompositionEnd = function(e2) {
          if (!host.onCompositionEnd || host.$readOnly)
            return;
          inComposition = false;
          host.onCompositionEnd();
          host.off("mousedown", cancelComposition);
          if (e2)
            onInput();
        };
        function cancelComposition() {
          ignoreFocusEvents = true;
          text.blur();
          text.focus();
          ignoreFocusEvents = false;
        }
        var syncComposition = lang.delayedCall(onCompositionUpdate, 50).schedule.bind(null, null);
        function onKeyup(e2) {
          if (e2.keyCode == 27 && text.value.length < text.selectionStart) {
            if (!inComposition)
              lastValue = text.value;
            lastSelectionStart = lastSelectionEnd = -1;
            resetSelection();
          }
          syncComposition();
        }
        event.addListener(text, "compositionstart", onCompositionStart, host);
        event.addListener(text, "compositionupdate", onCompositionUpdate, host);
        event.addListener(text, "keyup", onKeyup, host);
        event.addListener(text, "keydown", syncComposition, host);
        event.addListener(text, "compositionend", onCompositionEnd, host);
        this.getElement = function() {
          return text;
        };
        this.setCommandMode = function(value) {
          commandMode = value;
          text.readOnly = false;
        };
        this.setReadOnly = function(readOnly) {
          if (!commandMode)
            text.readOnly = readOnly;
        };
        this.setCopyWithEmptySelection = function(value) {
        };
        this.onContextMenu = function(e2) {
          afterContextMenu = true;
          resetSelection();
          host._emit("nativecontextmenu", { target: host, domEvent: e2 });
          this.moveToMouse(e2, true);
        };
        this.moveToMouse = function(e2, bringToFront) {
          if (!tempStyle)
            tempStyle = text.style.cssText;
          text.style.cssText = (bringToFront ? "z-index:100000;" : "") + (useragent.isIE ? "opacity:0.1;" : "") + "text-indent: -" + (lastSelectionStart + lastSelectionEnd) * host.renderer.characterWidth * 0.5 + "px;";
          var rect = host.container.getBoundingClientRect();
          var style = dom.computedStyle(host.container);
          var top = rect.top + (parseInt(style.borderTopWidth) || 0);
          var left = rect.left + (parseInt(style.borderLeftWidth) || 0);
          var maxTop = rect.bottom - top - text.clientHeight - 2;
          var move = function(e3) {
            dom.translate(text, e3.clientX - left - 2, Math.min(e3.clientY - top - 2, maxTop));
          };
          move(e2);
          if (e2.type != "mousedown")
            return;
          host.renderer.$isMousePressed = true;
          clearTimeout(closeTimeout);
          if (useragent.isWin)
            event.capture(host.container, move, onContextMenuClose);
        };
        this.onContextMenuClose = onContextMenuClose;
        var closeTimeout;
        function onContextMenuClose() {
          clearTimeout(closeTimeout);
          closeTimeout = setTimeout(function() {
            if (tempStyle) {
              text.style.cssText = tempStyle;
              tempStyle = "";
            }
            host.renderer.$isMousePressed = false;
            if (host.renderer.$keepTextAreaAtCursor)
              host.renderer.$moveTextAreaToCursor();
          }, 0);
        }
        var onContextMenu = function(e2) {
          host.textInput.onContextMenu(e2);
          onContextMenuClose();
        };
        event.addListener(text, "mouseup", onContextMenu, host);
        event.addListener(text, "mousedown", function(e2) {
          e2.preventDefault();
          onContextMenuClose();
        }, host);
        event.addListener(host.renderer.scroller, "contextmenu", onContextMenu, host);
        event.addListener(text, "contextmenu", onContextMenu, host);
        if (isIOS2)
          addIosSelectionHandler(parentNode, host, text);
        function addIosSelectionHandler(parentNode2, host2, text2) {
          var typingResetTimeout = null;
          var typing = false;
          text2.addEventListener("keydown", function(e2) {
            if (typingResetTimeout)
              clearTimeout(typingResetTimeout);
            typing = true;
          }, true);
          text2.addEventListener("keyup", function(e2) {
            typingResetTimeout = setTimeout(function() {
              typing = false;
            }, 100);
          }, true);
          var detectArrowKeys = function(e2) {
            if (document.activeElement !== text2)
              return;
            if (typing || inComposition || host2.$mouseHandler.isMousePressed)
              return;
            if (copied) {
              return;
            }
            var selectionStart = text2.selectionStart;
            var selectionEnd = text2.selectionEnd;
            var key = null;
            var modifier = 0;
            if (selectionStart == 0) {
              key = KEYS.up;
            } else if (selectionStart == 1) {
              key = KEYS.home;
            } else if (selectionEnd > lastSelectionEnd && lastValue[selectionEnd] == "\n") {
              key = KEYS.end;
            } else if (selectionStart < lastSelectionStart && lastValue[selectionStart - 1] == " ") {
              key = KEYS.left;
              modifier = MODS.option;
            } else if (selectionStart < lastSelectionStart || selectionStart == lastSelectionStart && lastSelectionEnd != lastSelectionStart && selectionStart == selectionEnd) {
              key = KEYS.left;
            } else if (selectionEnd > lastSelectionEnd && lastValue.slice(0, selectionEnd).split("\n").length > 2) {
              key = KEYS.down;
            } else if (selectionEnd > lastSelectionEnd && lastValue[selectionEnd - 1] == " ") {
              key = KEYS.right;
              modifier = MODS.option;
            } else if (selectionEnd > lastSelectionEnd || selectionEnd == lastSelectionEnd && lastSelectionEnd != lastSelectionStart && selectionStart == selectionEnd) {
              key = KEYS.right;
            }
            if (selectionStart !== selectionEnd)
              modifier |= MODS.shift;
            if (key) {
              var result = host2.onCommandKey({}, modifier, key);
              if (!result && host2.commands) {
                key = KEYS.keyCodeToString(key);
                var command = host2.commands.findKeyCommand(modifier, key);
                if (command)
                  host2.execCommand(command);
              }
              lastSelectionStart = selectionStart;
              lastSelectionEnd = selectionEnd;
              resetSelection("");
            }
          };
          document.addEventListener("selectionchange", detectArrowKeys);
          host2.on("destroy", function() {
            document.removeEventListener("selectionchange", detectArrowKeys);
          });
        }
        this.destroy = function() {
          if (text.parentElement)
            text.parentElement.removeChild(text);
        };
      };
      exports3.TextInput = TextInput;
      exports3.$setUserAgentForTests = function(_isMobile, _isIOS) {
        isMobile = _isMobile;
        isIOS2 = _isIOS;
      };
    });
    ace.define("ace/mouse/default_handlers", ["require", "exports", "module", "ace/lib/useragent"], function(require2, exports3, module3) {
      var useragent = require2("../lib/useragent");
      var DRAG_OFFSET = 0;
      var SCROLL_COOLDOWN_T = 550;
      var DefaultHandlers = (
        /** @class */
        (function() {
          function DefaultHandlers2(mouseHandler) {
            mouseHandler.$clickSelection = null;
            var editor = mouseHandler.editor;
            editor.setDefaultHandler("mousedown", this.onMouseDown.bind(mouseHandler));
            editor.setDefaultHandler("dblclick", this.onDoubleClick.bind(mouseHandler));
            editor.setDefaultHandler("tripleclick", this.onTripleClick.bind(mouseHandler));
            editor.setDefaultHandler("quadclick", this.onQuadClick.bind(mouseHandler));
            editor.setDefaultHandler("mousewheel", this.onMouseWheel.bind(mouseHandler));
            var exports4 = [
              "select",
              "startSelect",
              "selectEnd",
              "selectAllEnd",
              "selectByWordsEnd",
              "selectByLinesEnd",
              "dragWait",
              "dragWaitEnd",
              "focusWait"
            ];
            exports4.forEach(function(x2) {
              mouseHandler[x2] = this[x2];
            }, this);
            mouseHandler["selectByLines"] = this.extendSelectionBy.bind(mouseHandler, "getLineRange");
            mouseHandler["selectByWords"] = this.extendSelectionBy.bind(mouseHandler, "getWordRange");
          }
          DefaultHandlers2.prototype.onMouseDown = function(ev) {
            var inSelection = ev.inSelection();
            var pos = ev.getDocumentPosition();
            this.mousedownEvent = ev;
            var editor = this.editor;
            var button2 = ev.getButton();
            if (button2 !== 0) {
              var selectionRange = editor.getSelectionRange();
              var selectionEmpty = selectionRange.isEmpty();
              if (selectionEmpty || button2 == 1)
                editor.selection.moveToPosition(pos);
              if (button2 == 2) {
                editor.textInput.onContextMenu(ev.domEvent);
                if (!useragent.isMozilla)
                  ev.preventDefault();
              }
              return;
            }
            this.mousedownEvent.time = Date.now();
            if (inSelection && !editor.isFocused()) {
              editor.focus();
              if (this.$focusTimeout && !this.$clickSelection && !editor.inMultiSelectMode) {
                this.setState("focusWait");
                this.captureMouse(ev);
                return;
              }
            }
            this.captureMouse(ev);
            this.startSelect(pos, ev.domEvent._clicks > 1);
            return ev.preventDefault();
          };
          DefaultHandlers2.prototype.startSelect = function(pos, waitForClickSelection) {
            pos = pos || this.editor.renderer.screenToTextCoordinates(this.x, this.y);
            var editor = this.editor;
            if (!this.mousedownEvent)
              return;
            if (this.mousedownEvent.getShiftKey())
              editor.selection.selectToPosition(pos);
            else if (!waitForClickSelection)
              editor.selection.moveToPosition(pos);
            if (!waitForClickSelection)
              this.select();
            editor.setStyle("ace_selecting");
            this.setState("select");
          };
          DefaultHandlers2.prototype.select = function() {
            var anchor, editor = this.editor;
            var cursor = editor.renderer.screenToTextCoordinates(this.x, this.y);
            if (this.$clickSelection) {
              var cmp = this.$clickSelection.comparePoint(cursor);
              if (cmp == -1) {
                anchor = this.$clickSelection.end;
              } else if (cmp == 1) {
                anchor = this.$clickSelection.start;
              } else {
                var orientedRange = calcRangeOrientation(this.$clickSelection, cursor);
                cursor = orientedRange.cursor;
                anchor = orientedRange.anchor;
              }
              editor.selection.setSelectionAnchor(anchor.row, anchor.column);
            }
            editor.selection.selectToPosition(cursor);
            editor.renderer.scrollCursorIntoView();
          };
          DefaultHandlers2.prototype.extendSelectionBy = function(unitName) {
            var anchor, editor = this.editor;
            var cursor = editor.renderer.screenToTextCoordinates(this.x, this.y);
            var range = editor.selection[unitName](cursor.row, cursor.column);
            if (this.$clickSelection) {
              var cmpStart = this.$clickSelection.comparePoint(range.start);
              var cmpEnd = this.$clickSelection.comparePoint(range.end);
              if (cmpStart == -1 && cmpEnd <= 0) {
                anchor = this.$clickSelection.end;
                if (range.end.row != cursor.row || range.end.column != cursor.column)
                  cursor = range.start;
              } else if (cmpEnd == 1 && cmpStart >= 0) {
                anchor = this.$clickSelection.start;
                if (range.start.row != cursor.row || range.start.column != cursor.column)
                  cursor = range.end;
              } else if (cmpStart == -1 && cmpEnd == 1) {
                cursor = range.end;
                anchor = range.start;
              } else {
                var orientedRange = calcRangeOrientation(this.$clickSelection, cursor);
                cursor = orientedRange.cursor;
                anchor = orientedRange.anchor;
              }
              editor.selection.setSelectionAnchor(anchor.row, anchor.column);
            }
            editor.selection.selectToPosition(cursor);
            editor.renderer.scrollCursorIntoView();
          };
          DefaultHandlers2.prototype.selectByLinesEnd = function() {
            this.$clickSelection = null;
            this.editor.unsetStyle("ace_selecting");
          };
          DefaultHandlers2.prototype.focusWait = function() {
            var distance = calcDistance(this.mousedownEvent.x, this.mousedownEvent.y, this.x, this.y);
            var time = Date.now();
            if (distance > DRAG_OFFSET || time - this.mousedownEvent.time > this.$focusTimeout)
              this.startSelect(this.mousedownEvent.getDocumentPosition());
          };
          DefaultHandlers2.prototype.onDoubleClick = function(ev) {
            var pos = ev.getDocumentPosition();
            var editor = this.editor;
            var session = editor.session;
            var range = session.getBracketRange(pos);
            if (range) {
              if (range.isEmpty()) {
                range.start.column--;
                range.end.column++;
              }
              this.setState("select");
            } else {
              range = editor.selection.getWordRange(pos.row, pos.column);
              this.setState("selectByWords");
            }
            this.$clickSelection = range;
            this.select();
          };
          DefaultHandlers2.prototype.onTripleClick = function(ev) {
            var pos = ev.getDocumentPosition();
            var editor = this.editor;
            this.setState("selectByLines");
            var range = editor.getSelectionRange();
            if (range.isMultiLine() && range.contains(pos.row, pos.column)) {
              this.$clickSelection = editor.selection.getLineRange(range.start.row);
              this.$clickSelection.end = editor.selection.getLineRange(range.end.row).end;
            } else {
              this.$clickSelection = editor.selection.getLineRange(pos.row);
            }
            this.select();
          };
          DefaultHandlers2.prototype.onQuadClick = function(ev) {
            var editor = this.editor;
            editor.selectAll();
            this.$clickSelection = editor.getSelectionRange();
            this.setState("selectAll");
          };
          DefaultHandlers2.prototype.onMouseWheel = function(ev) {
            if (ev.getAccelKey())
              return;
            if (ev.getShiftKey() && ev.wheelY && !ev.wheelX) {
              ev.wheelX = ev.wheelY;
              ev.wheelY = 0;
            }
            var editor = this.editor;
            if (!this.$lastScroll)
              this.$lastScroll = { t: 0, vx: 0, vy: 0, allowed: 0 };
            var prevScroll = this.$lastScroll;
            var t2 = ev.domEvent.timeStamp;
            var dt = t2 - prevScroll.t;
            var vx = dt ? ev.wheelX / dt : prevScroll.vx;
            var vy = dt ? ev.wheelY / dt : prevScroll.vy;
            if (dt < SCROLL_COOLDOWN_T) {
              vx = (vx + prevScroll.vx) / 2;
              vy = (vy + prevScroll.vy) / 2;
            }
            var direction = Math.abs(vx / vy);
            var canScroll = false;
            if (direction >= 1 && editor.renderer.isScrollableBy(ev.wheelX * ev.speed, 0))
              canScroll = true;
            if (direction <= 1 && editor.renderer.isScrollableBy(0, ev.wheelY * ev.speed))
              canScroll = true;
            if (canScroll) {
              prevScroll.allowed = t2;
            } else if (t2 - prevScroll.allowed < SCROLL_COOLDOWN_T) {
              var isSlower = Math.abs(vx) <= 1.5 * Math.abs(prevScroll.vx) && Math.abs(vy) <= 1.5 * Math.abs(prevScroll.vy);
              if (isSlower) {
                canScroll = true;
                prevScroll.allowed = t2;
              } else {
                prevScroll.allowed = 0;
              }
            }
            prevScroll.t = t2;
            prevScroll.vx = vx;
            prevScroll.vy = vy;
            if (canScroll) {
              editor.renderer.scrollBy(ev.wheelX * ev.speed, ev.wheelY * ev.speed);
              return ev.stop();
            }
          };
          return DefaultHandlers2;
        })()
      );
      DefaultHandlers.prototype.selectEnd = DefaultHandlers.prototype.selectByLinesEnd;
      DefaultHandlers.prototype.selectAllEnd = DefaultHandlers.prototype.selectByLinesEnd;
      DefaultHandlers.prototype.selectByWordsEnd = DefaultHandlers.prototype.selectByLinesEnd;
      exports3.DefaultHandlers = DefaultHandlers;
      function calcDistance(ax, ay, bx, by) {
        return Math.sqrt(Math.pow(bx - ax, 2) + Math.pow(by - ay, 2));
      }
      function calcRangeOrientation(range, cursor) {
        if (range.start.row == range.end.row)
          var cmp = 2 * cursor.column - range.start.column - range.end.column;
        else if (range.start.row == range.end.row - 1 && !range.start.column && !range.end.column)
          var cmp = cursor.column - 4;
        else
          var cmp = 2 * cursor.row - range.start.row - range.end.row;
        if (cmp < 0)
          return { cursor: range.start, anchor: range.end };
        else
          return { cursor: range.end, anchor: range.start };
      }
    });
    ace.define("ace/lib/scroll", ["require", "exports", "module"], function(require2, exports3, module3) {
      exports3.preventParentScroll = function preventParentScroll(event) {
        event.stopPropagation();
        var target = event.currentTarget;
        var contentOverflows = target.scrollHeight > target.clientHeight;
        if (!contentOverflows) {
          event.preventDefault();
        }
      };
    });
    ace.define("ace/tooltip", ["require", "exports", "module", "ace/lib/dom", "ace/lib/event", "ace/range", "ace/lib/scroll"], function(require2, exports3, module3) {
      var __extends = this && this.__extends || /* @__PURE__ */ (function() {
        var extendStatics = function(d3, b2) {
          extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d4, b3) {
            d4.__proto__ = b3;
          } || function(d4, b3) {
            for (var p in b3) if (Object.prototype.hasOwnProperty.call(b3, p)) d4[p] = b3[p];
          };
          return extendStatics(d3, b2);
        };
        return function(d3, b2) {
          if (typeof b2 !== "function" && b2 !== null)
            throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
          extendStatics(d3, b2);
          function __() {
            this.constructor = d3;
          }
          d3.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
        };
      })();
      var __values = this && this.__values || function(o) {
        var s3 = typeof Symbol === "function" && Symbol.iterator, m3 = s3 && o[s3], i2 = 0;
        if (m3) return m3.call(o);
        if (o && typeof o.length === "number") return {
          next: function() {
            if (o && i2 >= o.length) o = void 0;
            return { value: o && o[i2++], done: !o };
          }
        };
        throw new TypeError(s3 ? "Object is not iterable." : "Symbol.iterator is not defined.");
      };
      var dom = require2("./lib/dom");
      require2("./lib/event");
      var Range = require2("./range").Range;
      var preventParentScroll = require2("./lib/scroll").preventParentScroll;
      var CLASSNAME = "ace_tooltip";
      var Tooltip2 = (
        /** @class */
        (function() {
          function Tooltip3(parentNode) {
            this.isOpen = false;
            this.$element = null;
            this.$parentNode = parentNode;
          }
          Tooltip3.prototype.$init = function() {
            this.$element = dom.createElement("div");
            this.$element.className = CLASSNAME;
            this.$element.style.display = "none";
            this.$parentNode.appendChild(this.$element);
            return this.$element;
          };
          Tooltip3.prototype.getElement = function() {
            return this.$element || this.$init();
          };
          Tooltip3.prototype.setText = function(text) {
            this.getElement().textContent = text;
          };
          Tooltip3.prototype.setHtml = function(html3) {
            this.getElement().innerHTML = html3;
          };
          Tooltip3.prototype.setPosition = function(x2, y3) {
            this.getElement().style.left = x2 + "px";
            this.getElement().style.top = y3 + "px";
          };
          Tooltip3.prototype.setClassName = function(className) {
            dom.addCssClass(this.getElement(), className);
          };
          Tooltip3.prototype.setTheme = function(theme) {
            this.$element.className = CLASSNAME + " " + (theme.isDark ? "ace_dark " : "") + (theme.cssClass || "");
          };
          Tooltip3.prototype.show = function(text, x2, y3) {
            if (text != null)
              this.setText(text);
            if (x2 != null && y3 != null)
              this.setPosition(x2, y3);
            if (!this.isOpen) {
              this.getElement().style.display = "block";
              this.isOpen = true;
            }
          };
          Tooltip3.prototype.hide = function(e2) {
            if (this.isOpen) {
              this.getElement().style.display = "none";
              this.getElement().className = CLASSNAME;
              this.isOpen = false;
            }
          };
          Tooltip3.prototype.getHeight = function() {
            return this.getElement().offsetHeight;
          };
          Tooltip3.prototype.getWidth = function() {
            return this.getElement().offsetWidth;
          };
          Tooltip3.prototype.destroy = function() {
            this.isOpen = false;
            if (this.$element && this.$element.parentNode) {
              this.$element.parentNode.removeChild(this.$element);
            }
          };
          return Tooltip3;
        })()
      );
      var PopupManager = (
        /** @class */
        (function() {
          function PopupManager2() {
            this.popups = [];
          }
          PopupManager2.prototype.addPopup = function(popup) {
            this.popups.push(popup);
            this.updatePopups();
          };
          PopupManager2.prototype.removePopup = function(popup) {
            var index = this.popups.indexOf(popup);
            if (index !== -1) {
              this.popups.splice(index, 1);
              this.updatePopups();
            }
          };
          PopupManager2.prototype.updatePopups = function() {
            var e_1, _a, e_2, _b;
            this.popups.sort(function(a3, b2) {
              return b2.priority - a3.priority;
            });
            var visiblepopups = [];
            try {
              for (var _c = __values(this.popups), _d = _c.next(); !_d.done; _d = _c.next()) {
                var popup = _d.value;
                var shouldDisplay = true;
                try {
                  for (var visiblepopups_1 = (e_2 = void 0, __values(visiblepopups)), visiblepopups_1_1 = visiblepopups_1.next(); !visiblepopups_1_1.done; visiblepopups_1_1 = visiblepopups_1.next()) {
                    var visiblePopup = visiblepopups_1_1.value;
                    if (this.doPopupsOverlap(visiblePopup, popup)) {
                      shouldDisplay = false;
                      break;
                    }
                  }
                } catch (e_2_1) {
                  e_2 = { error: e_2_1 };
                } finally {
                  try {
                    if (visiblepopups_1_1 && !visiblepopups_1_1.done && (_b = visiblepopups_1.return)) _b.call(visiblepopups_1);
                  } finally {
                    if (e_2) throw e_2.error;
                  }
                }
                if (shouldDisplay) {
                  visiblepopups.push(popup);
                } else {
                  popup.hide();
                }
              }
            } catch (e_1_1) {
              e_1 = { error: e_1_1 };
            } finally {
              try {
                if (_d && !_d.done && (_a = _c.return)) _a.call(_c);
              } finally {
                if (e_1) throw e_1.error;
              }
            }
          };
          PopupManager2.prototype.doPopupsOverlap = function(popupA, popupB) {
            var rectA = popupA.getElement().getBoundingClientRect();
            var rectB = popupB.getElement().getBoundingClientRect();
            return rectA.left < rectB.right && rectA.right > rectB.left && rectA.top < rectB.bottom && rectA.bottom > rectB.top;
          };
          return PopupManager2;
        })()
      );
      var popupManager = new PopupManager();
      exports3.popupManager = popupManager;
      exports3.Tooltip = Tooltip2;
      var HoverTooltip = (
        /** @class */
        (function(_super) {
          __extends(HoverTooltip2, _super);
          function HoverTooltip2(parentNode) {
            if (parentNode === void 0) {
              parentNode = document.body;
            }
            var _this = _super.call(this, parentNode) || this;
            _this.timeout = void 0;
            _this.lastT = 0;
            _this.idleTime = 350;
            _this.lastEvent = void 0;
            _this.onMouseOut = _this.onMouseOut.bind(_this);
            _this.onMouseMove = _this.onMouseMove.bind(_this);
            _this.waitForHover = _this.waitForHover.bind(_this);
            _this.hide = _this.hide.bind(_this);
            var el = _this.getElement();
            el.style.whiteSpace = "pre-wrap";
            el.style.pointerEvents = "auto";
            el.addEventListener("mouseout", _this.onMouseOut);
            el.tabIndex = -1;
            el.addEventListener("blur", (function() {
              if (!el.contains(document.activeElement))
                this.hide();
            }).bind(_this));
            el.addEventListener("wheel", preventParentScroll);
            return _this;
          }
          HoverTooltip2.prototype.addToEditor = function(editor) {
            editor.on("mousemove", this.onMouseMove);
            editor.on("mousedown", this.hide);
            editor.renderer.getMouseEventTarget().addEventListener("mouseout", this.onMouseOut, true);
          };
          HoverTooltip2.prototype.removeFromEditor = function(editor) {
            editor.off("mousemove", this.onMouseMove);
            editor.off("mousedown", this.hide);
            editor.renderer.getMouseEventTarget().removeEventListener("mouseout", this.onMouseOut, true);
            if (this.timeout) {
              clearTimeout(this.timeout);
              this.timeout = null;
            }
          };
          HoverTooltip2.prototype.onMouseMove = function(e2, editor) {
            this.lastEvent = e2;
            this.lastT = Date.now();
            var isMousePressed = editor.$mouseHandler.isMousePressed;
            if (this.isOpen) {
              var pos = this.lastEvent && this.lastEvent.getDocumentPosition();
              if (!this.range || !this.range.contains(pos.row, pos.column) || isMousePressed || this.isOutsideOfText(this.lastEvent)) {
                this.hide();
              }
            }
            if (this.timeout || isMousePressed)
              return;
            this.lastEvent = e2;
            this.timeout = setTimeout(this.waitForHover, this.idleTime);
          };
          HoverTooltip2.prototype.waitForHover = function() {
            if (this.timeout)
              clearTimeout(this.timeout);
            var dt = Date.now() - this.lastT;
            if (this.idleTime - dt > 10) {
              this.timeout = setTimeout(this.waitForHover, this.idleTime - dt);
              return;
            }
            this.timeout = null;
            if (this.lastEvent && !this.isOutsideOfText(this.lastEvent)) {
              this.$gatherData(this.lastEvent, this.lastEvent.editor);
            }
          };
          HoverTooltip2.prototype.isOutsideOfText = function(e2) {
            var editor = e2.editor;
            var docPos = e2.getDocumentPosition();
            var line = editor.session.getLine(docPos.row);
            if (docPos.column == line.length) {
              var screenPos = editor.renderer.pixelToScreenCoordinates(e2.clientX, e2.clientY);
              var clippedPos = editor.session.documentToScreenPosition(docPos.row, docPos.column);
              if (clippedPos.column != screenPos.column || clippedPos.row != screenPos.row) {
                return true;
              }
            }
            return false;
          };
          HoverTooltip2.prototype.setDataProvider = function(value) {
            this.$gatherData = value;
          };
          HoverTooltip2.prototype.showForRange = function(editor, range, domNode, startingEvent) {
            var MARGIN = 10;
            if (startingEvent && startingEvent != this.lastEvent)
              return;
            if (this.isOpen && document.activeElement == this.getElement())
              return;
            var renderer = editor.renderer;
            if (!this.isOpen) {
              popupManager.addPopup(this);
              this.$registerCloseEvents();
              this.setTheme(renderer.theme);
            }
            this.isOpen = true;
            this.addMarker(range, editor.session);
            this.range = Range.fromPoints(range.start, range.end);
            var position = renderer.textToScreenCoordinates(range.start.row, range.start.column);
            var rect = renderer.scroller.getBoundingClientRect();
            if (position.pageX < rect.left)
              position.pageX = rect.left;
            var element = this.getElement();
            element.innerHTML = "";
            element.appendChild(domNode);
            element.style.maxHeight = "";
            element.style.display = "block";
            var labelHeight = element.clientHeight;
            var labelWidth = element.clientWidth;
            var spaceBelow = window.innerHeight - position.pageY - renderer.lineHeight;
            var isAbove = true;
            if (position.pageY - labelHeight < 0 && position.pageY < spaceBelow) {
              isAbove = false;
            }
            element.style.maxHeight = (isAbove ? position.pageY : spaceBelow) - MARGIN + "px";
            element.style.top = isAbove ? "" : position.pageY + renderer.lineHeight + "px";
            element.style.bottom = isAbove ? window.innerHeight - position.pageY + "px" : "";
            element.style.left = Math.min(position.pageX, window.innerWidth - labelWidth - MARGIN) + "px";
          };
          HoverTooltip2.prototype.addMarker = function(range, session) {
            if (this.marker) {
              this.$markerSession.removeMarker(this.marker);
            }
            this.$markerSession = session;
            this.marker = session && session.addMarker(range, "ace_highlight-marker", "text");
          };
          HoverTooltip2.prototype.hide = function(e2) {
            if (!e2 && document.activeElement == this.getElement())
              return;
            if (e2 && e2.target && (e2.type != "keydown" || e2.ctrlKey || e2.metaKey) && this.$element.contains(e2.target))
              return;
            this.lastEvent = null;
            if (this.timeout)
              clearTimeout(this.timeout);
            this.timeout = null;
            this.addMarker(null);
            if (this.isOpen) {
              this.$removeCloseEvents();
              this.getElement().style.display = "none";
              this.isOpen = false;
              popupManager.removePopup(this);
            }
          };
          HoverTooltip2.prototype.$registerCloseEvents = function() {
            window.addEventListener("keydown", this.hide, true);
            window.addEventListener("wheel", this.hide, true);
            window.addEventListener("mousedown", this.hide, true);
          };
          HoverTooltip2.prototype.$removeCloseEvents = function() {
            window.removeEventListener("keydown", this.hide, true);
            window.removeEventListener("wheel", this.hide, true);
            window.removeEventListener("mousedown", this.hide, true);
          };
          HoverTooltip2.prototype.onMouseOut = function(e2) {
            if (this.timeout) {
              clearTimeout(this.timeout);
              this.timeout = null;
            }
            this.lastEvent = null;
            if (!this.isOpen)
              return;
            if (!e2.relatedTarget || this.getElement().contains(e2.relatedTarget))
              return;
            if (e2 && e2.currentTarget.contains(e2.relatedTarget))
              return;
            if (!e2.relatedTarget.classList.contains("ace_content"))
              this.hide();
          };
          return HoverTooltip2;
        })(Tooltip2)
      );
      exports3.HoverTooltip = HoverTooltip;
    });
    ace.define("ace/mouse/default_gutter_handler", ["require", "exports", "module", "ace/lib/dom", "ace/lib/event", "ace/tooltip", "ace/config"], function(require2, exports3, module3) {
      var __extends = this && this.__extends || /* @__PURE__ */ (function() {
        var extendStatics = function(d3, b2) {
          extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d4, b3) {
            d4.__proto__ = b3;
          } || function(d4, b3) {
            for (var p in b3) if (Object.prototype.hasOwnProperty.call(b3, p)) d4[p] = b3[p];
          };
          return extendStatics(d3, b2);
        };
        return function(d3, b2) {
          if (typeof b2 !== "function" && b2 !== null)
            throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
          extendStatics(d3, b2);
          function __() {
            this.constructor = d3;
          }
          d3.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
        };
      })();
      var __values = this && this.__values || function(o) {
        var s3 = typeof Symbol === "function" && Symbol.iterator, m3 = s3 && o[s3], i2 = 0;
        if (m3) return m3.call(o);
        if (o && typeof o.length === "number") return {
          next: function() {
            if (o && i2 >= o.length) o = void 0;
            return { value: o && o[i2++], done: !o };
          }
        };
        throw new TypeError(s3 ? "Object is not iterable." : "Symbol.iterator is not defined.");
      };
      var dom = require2("../lib/dom");
      var event = require2("../lib/event");
      var Tooltip2 = require2("../tooltip").Tooltip;
      var nls = require2("../config").nls;
      var GUTTER_TOOLTIP_LEFT_OFFSET = 5;
      var GUTTER_TOOLTIP_TOP_OFFSET = 3;
      exports3.GUTTER_TOOLTIP_LEFT_OFFSET = GUTTER_TOOLTIP_LEFT_OFFSET;
      exports3.GUTTER_TOOLTIP_TOP_OFFSET = GUTTER_TOOLTIP_TOP_OFFSET;
      function GutterHandler(mouseHandler) {
        var editor = mouseHandler.editor;
        var gutter = editor.renderer.$gutterLayer;
        var tooltip = new GutterTooltip(editor, true);
        mouseHandler.editor.setDefaultHandler("guttermousedown", function(e2) {
          if (!editor.isFocused() || e2.getButton() != 0)
            return;
          var gutterRegion = gutter.getRegion(e2);
          if (gutterRegion == "foldWidgets")
            return;
          var row = e2.getDocumentPosition().row;
          var selection = editor.session.selection;
          if (e2.getShiftKey())
            selection.selectTo(row, 0);
          else {
            if (e2.domEvent.detail == 2) {
              editor.selectAll();
              return e2.preventDefault();
            }
            mouseHandler.$clickSelection = editor.selection.getLineRange(row);
          }
          mouseHandler.setState("selectByLines");
          mouseHandler.captureMouse(e2);
          return e2.preventDefault();
        });
        var tooltipTimeout, mouseEvent;
        function showTooltip() {
          var row = mouseEvent.getDocumentPosition().row;
          var maxRow = editor.session.getLength();
          if (row == maxRow) {
            var screenRow = editor.renderer.pixelToScreenCoordinates(0, mouseEvent.y).row;
            var pos = mouseEvent.$pos;
            if (screenRow > editor.session.documentToScreenRow(pos.row, pos.column))
              return hideTooltip();
          }
          tooltip.showTooltip(row);
          if (!tooltip.isOpen)
            return;
          editor.on("mousewheel", hideTooltip);
          editor.on("changeSession", hideTooltip);
          window.addEventListener("keydown", hideTooltip, true);
          if (mouseHandler.$tooltipFollowsMouse) {
            moveTooltip(mouseEvent);
          } else {
            var gutterRow = mouseEvent.getGutterRow();
            var gutterCell = gutter.$lines.get(gutterRow);
            if (gutterCell) {
              var gutterElement = gutterCell.element.querySelector(".ace_gutter_annotation");
              var rect = gutterElement.getBoundingClientRect();
              var style = tooltip.getElement().style;
              style.left = rect.right - GUTTER_TOOLTIP_LEFT_OFFSET + "px";
              style.top = rect.bottom - GUTTER_TOOLTIP_TOP_OFFSET + "px";
            } else {
              moveTooltip(mouseEvent);
            }
          }
        }
        function hideTooltip(e2) {
          if (e2 && e2.type === "keydown" && (e2.ctrlKey || e2.metaKey))
            return;
          if (e2 && e2.type === "mouseout" && (!e2.relatedTarget || tooltip.getElement().contains(e2.relatedTarget)))
            return;
          if (tooltipTimeout)
            tooltipTimeout = clearTimeout(tooltipTimeout);
          if (tooltip.isOpen) {
            tooltip.hideTooltip();
            editor.off("mousewheel", hideTooltip);
            editor.off("changeSession", hideTooltip);
            window.removeEventListener("keydown", hideTooltip, true);
          }
        }
        function moveTooltip(e2) {
          tooltip.setPosition(e2.x, e2.y);
        }
        mouseHandler.editor.setDefaultHandler("guttermousemove", function(e2) {
          var target = e2.domEvent.target || e2.domEvent.srcElement;
          if (dom.hasCssClass(target, "ace_fold-widget"))
            return hideTooltip();
          if (tooltip.isOpen && mouseHandler.$tooltipFollowsMouse)
            moveTooltip(e2);
          mouseEvent = e2;
          if (tooltipTimeout)
            return;
          tooltipTimeout = setTimeout(function() {
            tooltipTimeout = null;
            if (mouseEvent && !mouseHandler.isMousePressed)
              showTooltip();
          }, 50);
        });
        event.addListener(editor.renderer.$gutter, "mouseout", function(e2) {
          mouseEvent = null;
          if (!tooltip.isOpen)
            return;
          tooltipTimeout = setTimeout(function() {
            tooltipTimeout = null;
            hideTooltip(e2);
          }, 50);
        }, editor);
      }
      exports3.GutterHandler = GutterHandler;
      var GutterTooltip = (
        /** @class */
        (function(_super) {
          __extends(GutterTooltip2, _super);
          function GutterTooltip2(editor, isHover) {
            if (isHover === void 0) {
              isHover = false;
            }
            var _this = _super.call(this, editor.container) || this;
            _this.editor = editor;
            _this.visibleTooltipRow;
            var el = _this.getElement();
            el.setAttribute("role", "tooltip");
            el.style.pointerEvents = "auto";
            if (isHover) {
              _this.onMouseOut = _this.onMouseOut.bind(_this);
              el.addEventListener("mouseout", _this.onMouseOut);
            }
            return _this;
          }
          GutterTooltip2.prototype.onMouseOut = function(e2) {
            if (!this.isOpen)
              return;
            if (!e2.relatedTarget || this.getElement().contains(e2.relatedTarget))
              return;
            if (e2 && e2.currentTarget.contains(e2.relatedTarget))
              return;
            this.hideTooltip();
          };
          GutterTooltip2.prototype.setPosition = function(x2, y3) {
            var windowWidth = window.innerWidth || document.documentElement.clientWidth;
            var windowHeight = window.innerHeight || document.documentElement.clientHeight;
            var width = this.getWidth();
            var height = this.getHeight();
            x2 += 15;
            y3 += 15;
            if (x2 + width > windowWidth) {
              x2 -= x2 + width - windowWidth;
            }
            if (y3 + height > windowHeight) {
              y3 -= 20 + height;
            }
            Tooltip2.prototype.setPosition.call(this, x2, y3);
          };
          Object.defineProperty(GutterTooltip2, "annotationLabels", {
            get: function() {
              return {
                error: {
                  singular: nls("gutter-tooltip.aria-label.error.singular", "error"),
                  plural: nls("gutter-tooltip.aria-label.error.plural", "errors")
                },
                security: {
                  singular: nls("gutter-tooltip.aria-label.security.singular", "security finding"),
                  plural: nls("gutter-tooltip.aria-label.security.plural", "security findings")
                },
                warning: {
                  singular: nls("gutter-tooltip.aria-label.warning.singular", "warning"),
                  plural: nls("gutter-tooltip.aria-label.warning.plural", "warnings")
                },
                info: {
                  singular: nls("gutter-tooltip.aria-label.info.singular", "information message"),
                  plural: nls("gutter-tooltip.aria-label.info.plural", "information messages")
                },
                hint: {
                  singular: nls("gutter-tooltip.aria-label.hint.singular", "suggestion"),
                  plural: nls("gutter-tooltip.aria-label.hint.plural", "suggestions")
                }
              };
            },
            enumerable: false,
            configurable: true
          });
          GutterTooltip2.prototype.showTooltip = function(row) {
            var _a;
            var gutter = this.editor.renderer.$gutterLayer;
            var annotationsInRow = gutter.$annotations[row];
            var annotation;
            if (annotationsInRow)
              annotation = {
                displayText: Array.from(annotationsInRow.displayText),
                type: Array.from(annotationsInRow.type)
              };
            else
              annotation = { displayText: [], type: [] };
            var fold = gutter.session.getFoldLine(row);
            if (fold && gutter.$showFoldedAnnotations) {
              var annotationsInFold = { error: [], security: [], warning: [], info: [], hint: [] };
              var severityRank = { error: 1, security: 2, warning: 3, info: 4, hint: 5 };
              var mostSevereAnnotationTypeInFold;
              for (var i2 = row + 1; i2 <= fold.end.row; i2++) {
                if (!gutter.$annotations[i2])
                  continue;
                for (var j = 0; j < gutter.$annotations[i2].text.length; j++) {
                  var annotationType = gutter.$annotations[i2].type[j];
                  annotationsInFold[annotationType].push(gutter.$annotations[i2].text[j]);
                  if (!mostSevereAnnotationTypeInFold || severityRank[annotationType] < severityRank[mostSevereAnnotationTypeInFold]) {
                    mostSevereAnnotationTypeInFold = annotationType;
                  }
                }
              }
              if (["error", "security", "warning"].includes(mostSevereAnnotationTypeInFold)) {
                var summaryFoldedAnnotations = "".concat(GutterTooltip2.annotationsToSummaryString(annotationsInFold), " in folded code.");
                annotation.displayText.push(summaryFoldedAnnotations);
                annotation.type.push(mostSevereAnnotationTypeInFold + "_fold");
              }
            }
            if (annotation.displayText.length === 0)
              return this.hideTooltip();
            var annotationMessages = { error: [], security: [], warning: [], info: [], hint: [] };
            var iconClassName = gutter.$useSvgGutterIcons ? "ace_icon_svg" : "ace_icon";
            for (var i2 = 0; i2 < annotation.displayText.length; i2++) {
              var lineElement = dom.createElement("span");
              var iconElement = dom.createElement("span");
              (_a = iconElement.classList).add.apply(_a, ["ace_".concat(annotation.type[i2]), iconClassName]);
              iconElement.setAttribute("aria-label", "".concat(GutterTooltip2.annotationLabels[annotation.type[i2].replace("_fold", "")].singular));
              iconElement.setAttribute("role", "img");
              iconElement.appendChild(dom.createTextNode(" "));
              lineElement.appendChild(iconElement);
              lineElement.appendChild(dom.createTextNode(annotation.displayText[i2]));
              lineElement.appendChild(dom.createElement("br"));
              annotationMessages[annotation.type[i2].replace("_fold", "")].push(lineElement);
            }
            var tooltipElement = this.getElement();
            dom.removeChildren(tooltipElement);
            annotationMessages.error.forEach(function(el) {
              return tooltipElement.appendChild(el);
            });
            annotationMessages.security.forEach(function(el) {
              return tooltipElement.appendChild(el);
            });
            annotationMessages.warning.forEach(function(el) {
              return tooltipElement.appendChild(el);
            });
            annotationMessages.info.forEach(function(el) {
              return tooltipElement.appendChild(el);
            });
            annotationMessages.hint.forEach(function(el) {
              return tooltipElement.appendChild(el);
            });
            tooltipElement.setAttribute("aria-live", "polite");
            if (!this.isOpen) {
              this.setTheme(this.editor.renderer.theme);
              this.setClassName("ace_gutter-tooltip");
            }
            this.show();
            this.visibleTooltipRow = row;
            this.editor._signal("showGutterTooltip", this);
          };
          GutterTooltip2.prototype.hideTooltip = function() {
            if (!this.isOpen) {
              return;
            }
            this.$element.removeAttribute("aria-live");
            this.hide();
            this.visibleTooltipRow = void 0;
            this.editor._signal("hideGutterTooltip", this);
          };
          GutterTooltip2.annotationsToSummaryString = function(annotations) {
            var e_1, _a;
            var summary = [];
            var annotationTypes = ["error", "security", "warning", "info", "hint"];
            try {
              for (var annotationTypes_1 = __values(annotationTypes), annotationTypes_1_1 = annotationTypes_1.next(); !annotationTypes_1_1.done; annotationTypes_1_1 = annotationTypes_1.next()) {
                var annotationType = annotationTypes_1_1.value;
                if (!annotations[annotationType].length)
                  continue;
                var label = annotations[annotationType].length === 1 ? GutterTooltip2.annotationLabels[annotationType].singular : GutterTooltip2.annotationLabels[annotationType].plural;
                summary.push("".concat(annotations[annotationType].length, " ").concat(label));
              }
            } catch (e_1_1) {
              e_1 = { error: e_1_1 };
            } finally {
              try {
                if (annotationTypes_1_1 && !annotationTypes_1_1.done && (_a = annotationTypes_1.return)) _a.call(annotationTypes_1);
              } finally {
                if (e_1) throw e_1.error;
              }
            }
            return summary.join(", ");
          };
          return GutterTooltip2;
        })(Tooltip2)
      );
      exports3.GutterTooltip = GutterTooltip;
    });
    ace.define("ace/mouse/mouse_event", ["require", "exports", "module", "ace/lib/event", "ace/lib/useragent"], function(require2, exports3, module3) {
      var event = require2("../lib/event");
      var useragent = require2("../lib/useragent");
      var MouseEvent2 = (
        /** @class */
        (function() {
          function MouseEvent3(domEvent, editor) {
            this.speed;
            this.wheelX;
            this.wheelY;
            this.domEvent = domEvent;
            this.editor = editor;
            this.x = this.clientX = domEvent.clientX;
            this.y = this.clientY = domEvent.clientY;
            this.$pos = null;
            this.$inSelection = null;
            this.propagationStopped = false;
            this.defaultPrevented = false;
          }
          MouseEvent3.prototype.stopPropagation = function() {
            event.stopPropagation(this.domEvent);
            this.propagationStopped = true;
          };
          MouseEvent3.prototype.preventDefault = function() {
            event.preventDefault(this.domEvent);
            this.defaultPrevented = true;
          };
          MouseEvent3.prototype.stop = function() {
            this.stopPropagation();
            this.preventDefault();
          };
          MouseEvent3.prototype.getDocumentPosition = function() {
            if (this.$pos)
              return this.$pos;
            this.$pos = this.editor.renderer.screenToTextCoordinates(this.clientX, this.clientY);
            return this.$pos;
          };
          MouseEvent3.prototype.getGutterRow = function() {
            var documentRow = this.getDocumentPosition().row;
            var screenRow = this.editor.session.documentToScreenRow(documentRow, 0);
            var screenTopRow = this.editor.session.documentToScreenRow(this.editor.renderer.$gutterLayer.$lines.get(0).row, 0);
            return screenRow - screenTopRow;
          };
          MouseEvent3.prototype.inSelection = function() {
            if (this.$inSelection !== null)
              return this.$inSelection;
            var editor = this.editor;
            var selectionRange = editor.getSelectionRange();
            if (selectionRange.isEmpty())
              this.$inSelection = false;
            else {
              var pos = this.getDocumentPosition();
              this.$inSelection = selectionRange.contains(pos.row, pos.column);
            }
            return this.$inSelection;
          };
          MouseEvent3.prototype.getButton = function() {
            return event.getButton(this.domEvent);
          };
          MouseEvent3.prototype.getShiftKey = function() {
            return this.domEvent.shiftKey;
          };
          MouseEvent3.prototype.getAccelKey = function() {
            return useragent.isMac ? this.domEvent.metaKey : this.domEvent.ctrlKey;
          };
          return MouseEvent3;
        })()
      );
      exports3.MouseEvent = MouseEvent2;
    });
    ace.define("ace/mouse/dragdrop_handler", ["require", "exports", "module", "ace/lib/dom", "ace/lib/event", "ace/lib/useragent"], function(require2, exports3, module3) {
      var dom = require2("../lib/dom");
      var event = require2("../lib/event");
      var useragent = require2("../lib/useragent");
      var AUTOSCROLL_DELAY = 200;
      var SCROLL_CURSOR_DELAY = 200;
      var SCROLL_CURSOR_HYSTERESIS = 5;
      function DragdropHandler(mouseHandler) {
        var editor = mouseHandler.editor;
        var dragImage = dom.createElement("div");
        dragImage.style.cssText = "top:-100px;position:absolute;z-index:2147483647;opacity:0.5";
        dragImage.textContent = "";
        var exports4 = ["dragWait", "dragWaitEnd", "startDrag", "dragReadyEnd", "onMouseDrag"];
        exports4.forEach(function(x3) {
          mouseHandler[x3] = this[x3];
        }, this);
        editor.on("mousedown", this.onMouseDown.bind(mouseHandler));
        var mouseTarget = editor.container;
        var dragSelectionMarker, x2, y3;
        var timerId, range;
        var dragCursor, counter = 0;
        var dragOperation;
        var isInternal;
        var autoScrollStartTime;
        var cursorMovedTime;
        var cursorPointOnCaretMoved;
        this.onDragStart = function(e2) {
          if (this.cancelDrag || !mouseTarget.draggable) {
            var self2 = this;
            setTimeout(function() {
              self2.startSelect();
              self2.captureMouse(e2);
            }, 0);
            return e2.preventDefault();
          }
          range = editor.getSelectionRange();
          var dataTransfer = e2.dataTransfer;
          dataTransfer.effectAllowed = editor.getReadOnly() ? "copy" : "copyMove";
          editor.container.appendChild(dragImage);
          dataTransfer.setDragImage && dataTransfer.setDragImage(dragImage, 0, 0);
          setTimeout(function() {
            editor.container.removeChild(dragImage);
          });
          dataTransfer.clearData();
          dataTransfer.setData("Text", editor.session.getTextRange());
          isInternal = true;
          this.setState("drag");
        };
        this.onDragEnd = function(e2) {
          mouseTarget.draggable = false;
          isInternal = false;
          this.setState(null);
          if (!editor.getReadOnly()) {
            var dropEffect = e2.dataTransfer.dropEffect;
            if (!dragOperation && dropEffect == "move")
              editor.session.remove(editor.getSelectionRange());
            editor.$resetCursorStyle();
          }
          this.editor.unsetStyle("ace_dragging");
          this.editor.renderer.setCursorStyle("");
        };
        this.onDragEnter = function(e2) {
          if (editor.getReadOnly() || !canAccept(e2.dataTransfer))
            return;
          x2 = e2.clientX;
          y3 = e2.clientY;
          if (!dragSelectionMarker)
            addDragMarker();
          counter++;
          e2.dataTransfer.dropEffect = dragOperation = getDropEffect(e2);
          return event.preventDefault(e2);
        };
        this.onDragOver = function(e2) {
          if (editor.getReadOnly() || !canAccept(e2.dataTransfer))
            return;
          x2 = e2.clientX;
          y3 = e2.clientY;
          if (!dragSelectionMarker) {
            addDragMarker();
            counter++;
          }
          if (onMouseMoveTimer !== null)
            onMouseMoveTimer = null;
          e2.dataTransfer.dropEffect = dragOperation = getDropEffect(e2);
          return event.preventDefault(e2);
        };
        this.onDragLeave = function(e2) {
          counter--;
          if (counter <= 0 && dragSelectionMarker) {
            clearDragMarker();
            dragOperation = null;
            return event.preventDefault(e2);
          }
        };
        this.onDrop = function(e2) {
          if (!dragCursor)
            return;
          var dataTransfer = e2.dataTransfer;
          if (isInternal) {
            switch (dragOperation) {
              case "move":
                if (range.contains(dragCursor.row, dragCursor.column)) {
                  range = {
                    start: dragCursor,
                    end: dragCursor
                  };
                } else {
                  range = editor.moveText(range, dragCursor);
                }
                break;
              case "copy":
                range = editor.moveText(range, dragCursor, true);
                break;
            }
          } else {
            var dropData = dataTransfer.getData("Text");
            range = {
              start: dragCursor,
              end: editor.session.insert(dragCursor, dropData)
            };
            editor.focus();
            dragOperation = null;
          }
          clearDragMarker();
          return event.preventDefault(e2);
        };
        event.addListener(mouseTarget, "dragstart", this.onDragStart.bind(mouseHandler), editor);
        event.addListener(mouseTarget, "dragend", this.onDragEnd.bind(mouseHandler), editor);
        event.addListener(mouseTarget, "dragenter", this.onDragEnter.bind(mouseHandler), editor);
        event.addListener(mouseTarget, "dragover", this.onDragOver.bind(mouseHandler), editor);
        event.addListener(mouseTarget, "dragleave", this.onDragLeave.bind(mouseHandler), editor);
        event.addListener(mouseTarget, "drop", this.onDrop.bind(mouseHandler), editor);
        function scrollCursorIntoView(cursor, prevCursor) {
          var now = Date.now();
          var vMovement = !prevCursor || cursor.row != prevCursor.row;
          var hMovement = !prevCursor || cursor.column != prevCursor.column;
          if (!cursorMovedTime || vMovement || hMovement) {
            editor.moveCursorToPosition(cursor);
            cursorMovedTime = now;
            cursorPointOnCaretMoved = { x: x2, y: y3 };
          } else {
            var distance = calcDistance(cursorPointOnCaretMoved.x, cursorPointOnCaretMoved.y, x2, y3);
            if (distance > SCROLL_CURSOR_HYSTERESIS) {
              cursorMovedTime = null;
            } else if (now - cursorMovedTime >= SCROLL_CURSOR_DELAY) {
              editor.renderer.scrollCursorIntoView();
              cursorMovedTime = null;
            }
          }
        }
        function autoScroll(cursor, prevCursor) {
          var now = Date.now();
          var lineHeight = editor.renderer.layerConfig.lineHeight;
          var characterWidth = editor.renderer.layerConfig.characterWidth;
          var editorRect = editor.renderer.scroller.getBoundingClientRect();
          var offsets = {
            x: {
              left: x2 - editorRect.left,
              right: editorRect.right - x2
            },
            y: {
              top: y3 - editorRect.top,
              bottom: editorRect.bottom - y3
            }
          };
          var nearestXOffset = Math.min(offsets.x.left, offsets.x.right);
          var nearestYOffset = Math.min(offsets.y.top, offsets.y.bottom);
          var scrollCursor = { row: cursor.row, column: cursor.column };
          if (nearestXOffset / characterWidth <= 2) {
            scrollCursor.column += offsets.x.left < offsets.x.right ? -3 : 2;
          }
          if (nearestYOffset / lineHeight <= 1) {
            scrollCursor.row += offsets.y.top < offsets.y.bottom ? -1 : 1;
          }
          var vScroll = cursor.row != scrollCursor.row;
          var hScroll = cursor.column != scrollCursor.column;
          var vMovement = !prevCursor || cursor.row != prevCursor.row;
          if (vScroll || hScroll && !vMovement) {
            if (!autoScrollStartTime)
              autoScrollStartTime = now;
            else if (now - autoScrollStartTime >= AUTOSCROLL_DELAY)
              editor.renderer.scrollCursorIntoView(scrollCursor);
          } else {
            autoScrollStartTime = null;
          }
        }
        function onDragInterval() {
          var prevCursor = dragCursor;
          dragCursor = editor.renderer.screenToTextCoordinates(x2, y3);
          scrollCursorIntoView(dragCursor, prevCursor);
          autoScroll(dragCursor, prevCursor);
        }
        function addDragMarker() {
          range = editor.selection.toOrientedRange();
          dragSelectionMarker = editor.session.addMarker(range, "ace_selection", editor.getSelectionStyle());
          editor.clearSelection();
          if (editor.isFocused())
            editor.renderer.$cursorLayer.setBlinking(false);
          clearInterval(timerId);
          onDragInterval();
          timerId = setInterval(onDragInterval, 20);
          counter = 0;
          event.addListener(document, "mousemove", onMouseMove);
        }
        function clearDragMarker() {
          clearInterval(timerId);
          editor.session.removeMarker(dragSelectionMarker);
          dragSelectionMarker = null;
          editor.selection.fromOrientedRange(range);
          if (editor.isFocused() && !isInternal)
            editor.$resetCursorStyle();
          range = null;
          dragCursor = null;
          counter = 0;
          autoScrollStartTime = null;
          cursorMovedTime = null;
          event.removeListener(document, "mousemove", onMouseMove);
        }
        var onMouseMoveTimer = null;
        function onMouseMove() {
          if (onMouseMoveTimer == null) {
            onMouseMoveTimer = setTimeout(function() {
              if (onMouseMoveTimer != null && dragSelectionMarker)
                clearDragMarker();
            }, 20);
          }
        }
        function canAccept(dataTransfer) {
          var types = dataTransfer.types;
          return !types || Array.prototype.some.call(types, function(type) {
            return type == "text/plain" || type == "Text";
          });
        }
        function getDropEffect(e2) {
          var copyAllowed = ["copy", "copymove", "all", "uninitialized"];
          var moveAllowed = ["move", "copymove", "linkmove", "all", "uninitialized"];
          var copyModifierState = useragent.isMac ? e2.altKey : e2.ctrlKey;
          var effectAllowed = "uninitialized";
          try {
            effectAllowed = e2.dataTransfer.effectAllowed.toLowerCase();
          } catch (e3) {
          }
          var dropEffect = "none";
          if (copyModifierState && copyAllowed.indexOf(effectAllowed) >= 0)
            dropEffect = "copy";
          else if (moveAllowed.indexOf(effectAllowed) >= 0)
            dropEffect = "move";
          else if (copyAllowed.indexOf(effectAllowed) >= 0)
            dropEffect = "copy";
          return dropEffect;
        }
      }
      (function() {
        this.dragWait = function() {
          var interval = Date.now() - this.mousedownEvent.time;
          if (interval > this.editor.getDragDelay())
            this.startDrag();
        };
        this.dragWaitEnd = function() {
          var target = this.editor.container;
          target.draggable = false;
          this.startSelect(this.mousedownEvent.getDocumentPosition());
          this.selectEnd();
        };
        this.dragReadyEnd = function(e2) {
          this.editor.$resetCursorStyle();
          this.editor.unsetStyle("ace_dragging");
          this.editor.renderer.setCursorStyle("");
          this.dragWaitEnd();
        };
        this.startDrag = function() {
          this.cancelDrag = false;
          var editor = this.editor;
          var target = editor.container;
          target.draggable = true;
          editor.renderer.$cursorLayer.setBlinking(false);
          editor.setStyle("ace_dragging");
          var cursorStyle = useragent.isWin ? "default" : "move";
          editor.renderer.setCursorStyle(cursorStyle);
          this.setState("dragReady");
        };
        this.onMouseDrag = function(e2) {
          var target = this.editor.container;
          if (useragent.isIE && this.state == "dragReady") {
            var distance = calcDistance(this.mousedownEvent.x, this.mousedownEvent.y, this.x, this.y);
            if (distance > 3)
              target.dragDrop();
          }
          if (this.state === "dragWait") {
            var distance = calcDistance(this.mousedownEvent.x, this.mousedownEvent.y, this.x, this.y);
            if (distance > 0) {
              target.draggable = false;
              this.startSelect(this.mousedownEvent.getDocumentPosition());
            }
          }
        };
        this.onMouseDown = function(e2) {
          if (!this.$dragEnabled)
            return;
          this.mousedownEvent = e2;
          var editor = this.editor;
          var inSelection = e2.inSelection();
          var button2 = e2.getButton();
          var clickCount = e2.domEvent.detail || 1;
          if (clickCount === 1 && button2 === 0 && inSelection) {
            if (e2.editor.inMultiSelectMode && (e2.getAccelKey() || e2.getShiftKey()))
              return;
            this.mousedownEvent.time = Date.now();
            var eventTarget = e2.domEvent.target || e2.domEvent.srcElement;
            if ("unselectable" in eventTarget)
              eventTarget.unselectable = "on";
            if (editor.getDragDelay()) {
              if (useragent.isWebKit) {
                this.cancelDrag = true;
                var mouseTarget = editor.container;
                mouseTarget.draggable = true;
              }
              this.setState("dragWait");
            } else {
              this.startDrag();
            }
            this.captureMouse(e2, this.onMouseDrag.bind(this));
            e2.defaultPrevented = true;
          }
        };
      }).call(DragdropHandler.prototype);
      function calcDistance(ax, ay, bx, by) {
        return Math.sqrt(Math.pow(bx - ax, 2) + Math.pow(by - ay, 2));
      }
      exports3.DragdropHandler = DragdropHandler;
    });
    ace.define("ace/mouse/touch_handler", ["require", "exports", "module", "ace/mouse/mouse_event", "ace/lib/event", "ace/lib/dom"], function(require2, exports3, module3) {
      var MouseEvent2 = require2("./mouse_event").MouseEvent;
      var event = require2("../lib/event");
      var dom = require2("../lib/dom");
      exports3.addTouchListeners = function(el, editor) {
        var mode = "scroll";
        var startX;
        var startY;
        var touchStartT;
        var lastT;
        var longTouchTimer;
        var animationTimer;
        var animationSteps = 0;
        var pos;
        var clickCount = 0;
        var vX = 0;
        var vY = 0;
        var pressed;
        var contextMenu;
        function createContextMenu() {
          var clipboard = window.navigator && window.navigator.clipboard;
          var isOpen = false;
          var updateMenu = function() {
            var selected = editor.getCopyText();
            var hasUndo = editor.session.getUndoManager().hasUndo();
            contextMenu.replaceChild(dom.buildDom(isOpen ? [
              "span",
              !selected && canExecuteCommand("selectall") && ["span", { class: "ace_mobile-button", action: "selectall" }, "Select All"],
              selected && canExecuteCommand("copy") && ["span", { class: "ace_mobile-button", action: "copy" }, "Copy"],
              selected && canExecuteCommand("cut") && ["span", { class: "ace_mobile-button", action: "cut" }, "Cut"],
              clipboard && canExecuteCommand("paste") && ["span", { class: "ace_mobile-button", action: "paste" }, "Paste"],
              hasUndo && canExecuteCommand("undo") && ["span", { class: "ace_mobile-button", action: "undo" }, "Undo"],
              canExecuteCommand("find") && ["span", { class: "ace_mobile-button", action: "find" }, "Find"],
              canExecuteCommand("openCommandPalette") && ["span", { class: "ace_mobile-button", action: "openCommandPalette" }, "Palette"]
            ] : ["span"]), contextMenu.firstChild);
          };
          var canExecuteCommand = function(cmd) {
            return editor.commands.canExecute(cmd, editor);
          };
          var handleClick = function(e2) {
            var action = e2.target.getAttribute("action");
            if (action == "more" || !isOpen) {
              isOpen = !isOpen;
              return updateMenu();
            }
            if (action == "paste") {
              clipboard.readText().then(function(text) {
                editor.execCommand(action, text);
              });
            } else if (action) {
              if (action == "cut" || action == "copy") {
                if (clipboard)
                  clipboard.writeText(editor.getCopyText());
                else
                  document.execCommand("copy");
              }
              editor.execCommand(action);
            }
            contextMenu.firstChild.style.display = "none";
            isOpen = false;
            if (action != "openCommandPalette")
              editor.focus();
          };
          contextMenu = dom.buildDom([
            "div",
            {
              class: "ace_mobile-menu",
              ontouchstart: function(e2) {
                mode = "menu";
                e2.stopPropagation();
                e2.preventDefault();
                editor.textInput.focus();
              },
              ontouchend: function(e2) {
                e2.stopPropagation();
                e2.preventDefault();
                handleClick(e2);
              },
              onclick: handleClick
            },
            ["span"],
            ["span", { class: "ace_mobile-button", action: "more" }, "..."]
          ], editor.container);
        }
        function showContextMenu() {
          if (!editor.getOption("enableMobileMenu")) {
            if (contextMenu) {
              hideContextMenu();
            }
            return;
          }
          if (!contextMenu)
            createContextMenu();
          var cursor = editor.selection.cursor;
          var pagePos = editor.renderer.textToScreenCoordinates(cursor.row, cursor.column);
          var leftOffset = editor.renderer.textToScreenCoordinates(0, 0).pageX;
          var scrollLeft = editor.renderer.scrollLeft;
          var rect = editor.container.getBoundingClientRect();
          contextMenu.style.top = pagePos.pageY - rect.top - 3 + "px";
          if (pagePos.pageX - rect.left < rect.width - 70) {
            contextMenu.style.left = "";
            contextMenu.style.right = "10px";
          } else {
            contextMenu.style.right = "";
            contextMenu.style.left = leftOffset + scrollLeft - rect.left + "px";
          }
          contextMenu.style.display = "";
          contextMenu.firstChild.style.display = "none";
          editor.on("input", hideContextMenu);
        }
        function hideContextMenu(e2) {
          if (contextMenu)
            contextMenu.style.display = "none";
          editor.off("input", hideContextMenu);
        }
        function handleLongTap() {
          longTouchTimer = null;
          clearTimeout(longTouchTimer);
          var range = editor.selection.getRange();
          var inSelection = range.contains(pos.row, pos.column);
          if (range.isEmpty() || !inSelection) {
            editor.selection.moveToPosition(pos);
            editor.selection.selectWord();
          }
          mode = "wait";
          showContextMenu();
        }
        function switchToSelectionMode() {
          longTouchTimer = null;
          clearTimeout(longTouchTimer);
          editor.selection.moveToPosition(pos);
          var range = clickCount >= 2 ? editor.selection.getLineRange(pos.row) : editor.session.getBracketRange(pos);
          if (range && !range.isEmpty()) {
            editor.selection.setRange(range);
          } else {
            editor.selection.selectWord();
          }
          mode = "wait";
        }
        event.addListener(el, "contextmenu", function(e2) {
          if (!pressed)
            return;
          var textarea = editor.textInput.getElement();
          textarea.focus();
        }, editor);
        event.addListener(el, "touchstart", function(e2) {
          var touches = e2.touches;
          if (longTouchTimer || touches.length > 1) {
            clearTimeout(longTouchTimer);
            longTouchTimer = null;
            touchStartT = -1;
            mode = "zoom";
            return;
          }
          pressed = editor.$mouseHandler.isMousePressed = true;
          var h3 = editor.renderer.layerConfig.lineHeight;
          var w2 = editor.renderer.layerConfig.lineHeight;
          var t2 = e2.timeStamp;
          lastT = t2;
          var touchObj = touches[0];
          var x2 = touchObj.clientX;
          var y3 = touchObj.clientY;
          if (Math.abs(startX - x2) + Math.abs(startY - y3) > h3)
            touchStartT = -1;
          startX = e2.clientX = x2;
          startY = e2.clientY = y3;
          vX = vY = 0;
          var ev = new MouseEvent2(e2, editor);
          pos = ev.getDocumentPosition();
          if (t2 - touchStartT < 500 && touches.length == 1 && !animationSteps) {
            clickCount++;
            e2.preventDefault();
            e2.button = 0;
            switchToSelectionMode();
          } else {
            clickCount = 0;
            var cursor = editor.selection.cursor;
            var anchor = editor.selection.isEmpty() ? cursor : editor.selection.anchor;
            var cursorPos = editor.renderer.$cursorLayer.getPixelPosition(cursor, true);
            var anchorPos = editor.renderer.$cursorLayer.getPixelPosition(anchor, true);
            var rect = editor.renderer.scroller.getBoundingClientRect();
            var offsetTop = editor.renderer.layerConfig.offset;
            var offsetLeft = editor.renderer.scrollLeft;
            var weightedDistance = function(x3, y4) {
              x3 = x3 / w2;
              y4 = y4 / h3 - 0.75;
              return x3 * x3 + y4 * y4;
            };
            if (e2.clientX < rect.left) {
              mode = "zoom";
              return;
            }
            var diff1 = weightedDistance(e2.clientX - rect.left - cursorPos.left + offsetLeft, e2.clientY - rect.top - cursorPos.top + offsetTop);
            var diff2 = weightedDistance(e2.clientX - rect.left - anchorPos.left + offsetLeft, e2.clientY - rect.top - anchorPos.top + offsetTop);
            if (diff1 < 3.5 && diff2 < 3.5)
              mode = diff1 > diff2 ? "cursor" : "anchor";
            if (diff2 < 3.5)
              mode = "anchor";
            else if (diff1 < 3.5)
              mode = "cursor";
            else
              mode = "scroll";
            longTouchTimer = setTimeout(handleLongTap, 450);
          }
          touchStartT = t2;
        }, editor);
        event.addListener(el, "touchend", function(e2) {
          pressed = editor.$mouseHandler.isMousePressed = false;
          if (animationTimer)
            clearInterval(animationTimer);
          if (mode == "zoom") {
            mode = "";
            animationSteps = 0;
          } else if (longTouchTimer) {
            editor.selection.moveToPosition(pos);
            animationSteps = 0;
            showContextMenu();
          } else if (mode == "scroll") {
            animate();
            hideContextMenu();
          } else {
            showContextMenu();
          }
          clearTimeout(longTouchTimer);
          longTouchTimer = null;
        }, editor);
        event.addListener(el, "touchmove", function(e2) {
          if (longTouchTimer) {
            clearTimeout(longTouchTimer);
            longTouchTimer = null;
          }
          var touches = e2.touches;
          if (touches.length > 1 || mode == "zoom")
            return;
          var touchObj = touches[0];
          var wheelX = startX - touchObj.clientX;
          var wheelY = startY - touchObj.clientY;
          if (mode == "wait") {
            if (wheelX * wheelX + wheelY * wheelY > 4)
              mode = "cursor";
            else
              return e2.preventDefault();
          }
          startX = touchObj.clientX;
          startY = touchObj.clientY;
          e2.clientX = touchObj.clientX;
          e2.clientY = touchObj.clientY;
          var t2 = e2.timeStamp;
          var dt = t2 - lastT;
          lastT = t2;
          if (mode == "scroll") {
            var mouseEvent = new MouseEvent2(e2, editor);
            mouseEvent.speed = 1;
            mouseEvent.wheelX = wheelX;
            mouseEvent.wheelY = wheelY;
            if (10 * Math.abs(wheelX) < Math.abs(wheelY))
              wheelX = 0;
            if (10 * Math.abs(wheelY) < Math.abs(wheelX))
              wheelY = 0;
            if (dt != 0) {
              vX = wheelX / dt;
              vY = wheelY / dt;
            }
            editor._emit("mousewheel", mouseEvent);
            if (!mouseEvent.propagationStopped) {
              vX = vY = 0;
            }
          } else {
            var ev = new MouseEvent2(e2, editor);
            var pos2 = ev.getDocumentPosition();
            if (mode == "cursor")
              editor.selection.moveCursorToPosition(pos2);
            else if (mode == "anchor")
              editor.selection.setSelectionAnchor(pos2.row, pos2.column);
            editor.renderer.scrollCursorIntoView(pos2);
            e2.preventDefault();
          }
        }, editor);
        function animate() {
          animationSteps += 60;
          animationTimer = setInterval(function() {
            if (animationSteps-- <= 0) {
              clearInterval(animationTimer);
              animationTimer = null;
            }
            if (Math.abs(vX) < 0.01)
              vX = 0;
            if (Math.abs(vY) < 0.01)
              vY = 0;
            if (animationSteps < 20)
              vX = 0.9 * vX;
            if (animationSteps < 20)
              vY = 0.9 * vY;
            var oldScrollTop = editor.session.getScrollTop();
            editor.renderer.scrollBy(10 * vX, 10 * vY);
            if (oldScrollTop == editor.session.getScrollTop())
              animationSteps = 0;
          }, 10);
        }
      };
    });
    ace.define("ace/mouse/mouse_handler", ["require", "exports", "module", "ace/lib/event", "ace/lib/useragent", "ace/mouse/default_handlers", "ace/mouse/default_gutter_handler", "ace/mouse/mouse_event", "ace/mouse/dragdrop_handler", "ace/mouse/touch_handler", "ace/config"], function(require2, exports3, module3) {
      var event = require2("../lib/event");
      var useragent = require2("../lib/useragent");
      var DefaultHandlers = require2("./default_handlers").DefaultHandlers;
      var DefaultGutterHandler = require2("./default_gutter_handler").GutterHandler;
      var MouseEvent2 = require2("./mouse_event").MouseEvent;
      var DragdropHandler = require2("./dragdrop_handler").DragdropHandler;
      var addTouchListeners = require2("./touch_handler").addTouchListeners;
      var config = require2("../config");
      var MouseHandler = (
        /** @class */
        (function() {
          function MouseHandler2(editor) {
            this.$dragDelay;
            this.$dragEnabled;
            this.$mouseMoved;
            this.mouseEvent;
            this.$focusTimeout;
            var _self = this;
            this.editor = editor;
            new DefaultHandlers(this);
            new DefaultGutterHandler(this);
            new DragdropHandler(this);
            var focusEditor = function(e2) {
              var windowBlurred = !document.hasFocus || !document.hasFocus() || !editor.isFocused() && document.activeElement == (editor.textInput && editor.textInput.getElement());
              if (windowBlurred)
                window.focus();
              editor.focus();
              setTimeout(function() {
                if (!editor.isFocused())
                  editor.focus();
              });
            };
            var mouseTarget = editor.renderer.getMouseEventTarget();
            event.addListener(mouseTarget, "click", this.onMouseEvent.bind(this, "click"), editor);
            event.addListener(mouseTarget, "mousemove", this.onMouseMove.bind(this, "mousemove"), editor);
            event.addMultiMouseDownListener([
              mouseTarget,
              editor.renderer.scrollBarV && editor.renderer.scrollBarV.inner,
              editor.renderer.scrollBarH && editor.renderer.scrollBarH.inner,
              editor.textInput && editor.textInput.getElement()
            ].filter(Boolean), [400, 300, 250], this, "onMouseEvent", editor);
            event.addMouseWheelListener(editor.container, this.onMouseWheel.bind(this, "mousewheel"), editor);
            addTouchListeners(editor.container, editor);
            var gutterEl = editor.renderer.$gutter;
            event.addListener(gutterEl, "mousedown", this.onMouseEvent.bind(this, "guttermousedown"), editor);
            event.addListener(gutterEl, "click", this.onMouseEvent.bind(this, "gutterclick"), editor);
            event.addListener(gutterEl, "dblclick", this.onMouseEvent.bind(this, "gutterdblclick"), editor);
            event.addListener(gutterEl, "mousemove", this.onMouseEvent.bind(this, "guttermousemove"), editor);
            event.addListener(mouseTarget, "mousedown", focusEditor, editor);
            event.addListener(gutterEl, "mousedown", focusEditor, editor);
            if (useragent.isIE && editor.renderer.scrollBarV) {
              event.addListener(editor.renderer.scrollBarV.element, "mousedown", focusEditor, editor);
              event.addListener(editor.renderer.scrollBarH.element, "mousedown", focusEditor, editor);
            }
            editor.on(
              "mousemove",
              function(e2) {
                if (_self.state || _self.$dragDelay || !_self.$dragEnabled)
                  return;
                var character = editor.renderer.screenToTextCoordinates(e2.x, e2.y);
                var range = editor.session.selection.getRange();
                var renderer = editor.renderer;
                if (!range.isEmpty() && range.insideStart(character.row, character.column)) {
                  renderer.setCursorStyle("default");
                } else {
                  renderer.setCursorStyle("");
                }
              },
              //@ts-expect-error TODO: seems mistyping - should be boolean
              editor
            );
          }
          MouseHandler2.prototype.onMouseEvent = function(name, e2) {
            if (!this.editor.session)
              return;
            this.editor._emit(name, new MouseEvent2(e2, this.editor));
          };
          MouseHandler2.prototype.onMouseMove = function(name, e2) {
            var listeners = this.editor._eventRegistry && this.editor._eventRegistry.mousemove;
            if (!listeners || !listeners.length)
              return;
            this.editor._emit(name, new MouseEvent2(e2, this.editor));
          };
          MouseHandler2.prototype.onMouseWheel = function(name, e2) {
            var mouseEvent = new MouseEvent2(e2, this.editor);
            mouseEvent.speed = this.$scrollSpeed * 2;
            mouseEvent.wheelX = e2.wheelX;
            mouseEvent.wheelY = e2.wheelY;
            this.editor._emit(name, mouseEvent);
          };
          MouseHandler2.prototype.setState = function(state) {
            this.state = state;
          };
          MouseHandler2.prototype.captureMouse = function(ev, mouseMoveHandler) {
            this.x = ev.x;
            this.y = ev.y;
            this.isMousePressed = true;
            var editor = this.editor;
            var renderer = this.editor.renderer;
            renderer.$isMousePressed = true;
            var self2 = this;
            var onMouseMove = function(e2) {
              if (!e2)
                return;
              if (useragent.isWebKit && !e2.which && self2.releaseMouse)
                return self2.releaseMouse();
              self2.x = e2.clientX;
              self2.y = e2.clientY;
              mouseMoveHandler && mouseMoveHandler(e2);
              self2.mouseEvent = new MouseEvent2(e2, self2.editor);
              self2.$mouseMoved = true;
            };
            var onCaptureEnd = function(e2) {
              editor.off("beforeEndOperation", onOperationEnd);
              clearInterval(timerId);
              if (editor.session)
                onCaptureInterval();
              self2[self2.state + "End"] && self2[self2.state + "End"](e2);
              self2.state = "";
              self2.isMousePressed = renderer.$isMousePressed = false;
              if (renderer.$keepTextAreaAtCursor)
                renderer.$moveTextAreaToCursor();
              self2.$onCaptureMouseMove = self2.releaseMouse = null;
              e2 && self2.onMouseEvent("mouseup", e2);
              editor.endOperation();
            };
            var onCaptureInterval = function() {
              self2[self2.state] && self2[self2.state]();
              self2.$mouseMoved = false;
            };
            if (useragent.isOldIE && ev.domEvent.type == "dblclick") {
              return setTimeout(function() {
                onCaptureEnd(ev);
              });
            }
            var onOperationEnd = function(e2) {
              if (!self2.releaseMouse)
                return;
              if (editor.curOp.command.name && editor.curOp.selectionChanged) {
                self2[self2.state + "End"] && self2[self2.state + "End"]();
                self2.state = "";
                self2.releaseMouse();
              }
            };
            editor.on("beforeEndOperation", onOperationEnd);
            editor.startOperation({ command: { name: "mouse" } });
            self2.$onCaptureMouseMove = onMouseMove;
            self2.releaseMouse = event.capture(this.editor.container, onMouseMove, onCaptureEnd);
            var timerId = setInterval(onCaptureInterval, 20);
          };
          MouseHandler2.prototype.cancelContextMenu = function() {
            var stop = (function(e2) {
              if (e2 && e2.domEvent && e2.domEvent.type != "contextmenu")
                return;
              this.editor.off("nativecontextmenu", stop);
              if (e2 && e2.domEvent)
                event.stopEvent(e2.domEvent);
            }).bind(this);
            setTimeout(stop, 10);
            this.editor.on("nativecontextmenu", stop);
          };
          MouseHandler2.prototype.destroy = function() {
            if (this.releaseMouse)
              this.releaseMouse();
          };
          return MouseHandler2;
        })()
      );
      MouseHandler.prototype.releaseMouse = null;
      config.defineOptions(MouseHandler.prototype, "mouseHandler", {
        scrollSpeed: { initialValue: 2 },
        dragDelay: { initialValue: useragent.isMac ? 150 : 0 },
        dragEnabled: { initialValue: true },
        focusTimeout: { initialValue: 0 },
        tooltipFollowsMouse: { initialValue: true }
      });
      exports3.MouseHandler = MouseHandler;
    });
    ace.define("ace/mouse/fold_handler", ["require", "exports", "module", "ace/lib/dom"], function(require2, exports3, module3) {
      var dom = require2("../lib/dom");
      var FoldHandler = (
        /** @class */
        /* @__PURE__ */ (function() {
          function FoldHandler2(editor) {
            editor.on("click", function(e2) {
              var position = e2.getDocumentPosition();
              var session = editor.session;
              var fold = session.getFoldAt(position.row, position.column, 1);
              if (fold) {
                if (e2.getAccelKey())
                  session.removeFold(fold);
                else
                  session.expandFold(fold);
                e2.stop();
              }
              var target = e2.domEvent && e2.domEvent.target;
              if (target && dom.hasCssClass(target, "ace_inline_button")) {
                if (dom.hasCssClass(target, "ace_toggle_wrap")) {
                  session.setOption("wrap", !session.getUseWrapMode());
                  editor.renderer.scrollCursorIntoView();
                }
              }
            });
            editor.on("gutterclick", function(e2) {
              var gutterRegion = editor.renderer.$gutterLayer.getRegion(e2);
              if (gutterRegion == "foldWidgets") {
                var row = e2.getDocumentPosition().row;
                var session = editor.session;
                if (session.foldWidgets && session.foldWidgets[row])
                  editor.session.onFoldWidgetClick(row, e2);
                if (!editor.isFocused())
                  editor.focus();
                e2.stop();
              }
            });
            editor.on("gutterdblclick", function(e2) {
              var gutterRegion = editor.renderer.$gutterLayer.getRegion(e2);
              if (gutterRegion == "foldWidgets") {
                var row = e2.getDocumentPosition().row;
                var session = editor.session;
                var data = session.getParentFoldRangeData(row, true);
                var range = data.range || data.firstRange;
                if (range) {
                  row = range.start.row;
                  var fold = session.getFoldAt(row, session.getLine(row).length, 1);
                  if (fold) {
                    session.removeFold(fold);
                  } else {
                    session.addFold("...", range);
                    editor.renderer.scrollCursorIntoView({ row: range.start.row, column: 0 });
                  }
                }
                e2.stop();
              }
            });
          }
          return FoldHandler2;
        })()
      );
      exports3.FoldHandler = FoldHandler;
    });
    ace.define("ace/keyboard/keybinding", ["require", "exports", "module", "ace/lib/keys", "ace/lib/event"], function(require2, exports3, module3) {
      var keyUtil = require2("../lib/keys");
      var event = require2("../lib/event");
      var KeyBinding = (
        /** @class */
        (function() {
          function KeyBinding2(editor) {
            this.$editor = editor;
            this.$data = { editor };
            this.$handlers = [];
            this.setDefaultHandler(editor.commands);
          }
          KeyBinding2.prototype.setDefaultHandler = function(kb) {
            this.removeKeyboardHandler(this.$defaultHandler);
            this.$defaultHandler = kb;
            this.addKeyboardHandler(kb, 0);
          };
          KeyBinding2.prototype.setKeyboardHandler = function(kb) {
            var h3 = this.$handlers;
            if (h3[h3.length - 1] == kb)
              return;
            while (h3[h3.length - 1] && h3[h3.length - 1] != this.$defaultHandler)
              this.removeKeyboardHandler(h3[h3.length - 1]);
            this.addKeyboardHandler(kb, 1);
          };
          KeyBinding2.prototype.addKeyboardHandler = function(kb, pos) {
            if (!kb)
              return;
            if (typeof kb == "function" && !kb.handleKeyboard)
              kb.handleKeyboard = kb;
            var i2 = this.$handlers.indexOf(kb);
            if (i2 != -1)
              this.$handlers.splice(i2, 1);
            if (pos == void 0)
              this.$handlers.push(kb);
            else
              this.$handlers.splice(pos, 0, kb);
            if (i2 == -1 && kb.attach)
              kb.attach(this.$editor);
          };
          KeyBinding2.prototype.removeKeyboardHandler = function(kb) {
            var i2 = this.$handlers.indexOf(kb);
            if (i2 == -1)
              return false;
            this.$handlers.splice(i2, 1);
            kb.detach && kb.detach(this.$editor);
            return true;
          };
          KeyBinding2.prototype.getKeyboardHandler = function() {
            return this.$handlers[this.$handlers.length - 1];
          };
          KeyBinding2.prototype.getStatusText = function() {
            var data = this.$data;
            var editor = data.editor;
            return this.$handlers.map(function(h3) {
              return h3.getStatusText && h3.getStatusText(editor, data) || "";
            }).filter(Boolean).join(" ");
          };
          KeyBinding2.prototype.$callKeyboardHandlers = function(hashId, keyString, keyCode, e2) {
            var toExecute;
            var success = false;
            var commands = this.$editor.commands;
            for (var i2 = this.$handlers.length; i2--; ) {
              toExecute = this.$handlers[i2].handleKeyboard(
                this.$data,
                hashId,
                keyString,
                keyCode,
                e2
              );
              if (!toExecute || !toExecute.command)
                continue;
              if (toExecute.command == "null") {
                success = true;
              } else {
                success = commands.exec(toExecute.command, this.$editor, toExecute.args, e2);
              }
              if (success && e2 && hashId != -1 && toExecute["passEvent"] != true && toExecute.command["passEvent"] != true) {
                event.stopEvent(e2);
              }
              if (success)
                break;
            }
            if (!success && hashId == -1) {
              toExecute = { command: "insertstring" };
              success = commands.exec("insertstring", this.$editor, keyString);
            }
            if (success && this.$editor._signal)
              this.$editor._signal("keyboardActivity", toExecute);
            return success;
          };
          KeyBinding2.prototype.onCommandKey = function(e2, hashId, keyCode) {
            var keyString = keyUtil.keyCodeToString(keyCode);
            return this.$callKeyboardHandlers(hashId, keyString, keyCode, e2);
          };
          KeyBinding2.prototype.onTextInput = function(text) {
            return this.$callKeyboardHandlers(-1, text);
          };
          return KeyBinding2;
        })()
      );
      exports3.KeyBinding = KeyBinding;
    });
    ace.define("ace/lib/bidiutil", ["require", "exports", "module"], function(require2, exports3, module3) {
      var dir = 0, hiLevel = 0;
      var lastArabic = false, hasUBAT_B = false, hasUBAT_S = false;
      var impTab_LTR = [
        [0, 3, 0, 1, 0, 0, 0],
        [0, 3, 0, 1, 2, 2, 0],
        [0, 3, 0, 17, 2, 0, 1],
        [0, 3, 5, 5, 4, 1, 0],
        [0, 3, 21, 21, 4, 0, 1],
        [0, 3, 5, 5, 4, 2, 0]
      ];
      var impTab_RTL = [
        [2, 0, 1, 1, 0, 1, 0],
        [2, 0, 1, 1, 0, 2, 0],
        [2, 0, 2, 1, 3, 2, 0],
        [2, 0, 2, 33, 3, 1, 1]
      ];
      var LTR = 0, RTL = 1;
      var L2 = 0;
      var R2 = 1;
      var EN = 2;
      var AN = 3;
      var ON = 4;
      var B2 = 5;
      var S3 = 6;
      var AL = 7;
      var WS = 8;
      var CS = 9;
      var ES = 10;
      var ET = 11;
      var NSM = 12;
      var LRE = 13;
      var RLE = 14;
      var PDF = 15;
      var LRO = 16;
      var RLO = 17;
      var BN = 18;
      var UnicodeTBL00 = [
        BN,
        BN,
        BN,
        BN,
        BN,
        BN,
        BN,
        BN,
        BN,
        S3,
        B2,
        S3,
        WS,
        B2,
        BN,
        BN,
        BN,
        BN,
        BN,
        BN,
        BN,
        BN,
        BN,
        BN,
        BN,
        BN,
        BN,
        BN,
        B2,
        B2,
        B2,
        S3,
        WS,
        ON,
        ON,
        ET,
        ET,
        ET,
        ON,
        ON,
        ON,
        ON,
        ON,
        ES,
        CS,
        ES,
        CS,
        CS,
        EN,
        EN,
        EN,
        EN,
        EN,
        EN,
        EN,
        EN,
        EN,
        EN,
        CS,
        ON,
        ON,
        ON,
        ON,
        ON,
        ON,
        L2,
        L2,
        L2,
        L2,
        L2,
        L2,
        L2,
        L2,
        L2,
        L2,
        L2,
        L2,
        L2,
        L2,
        L2,
        L2,
        L2,
        L2,
        L2,
        L2,
        L2,
        L2,
        L2,
        L2,
        L2,
        L2,
        ON,
        ON,
        ON,
        ON,
        ON,
        ON,
        L2,
        L2,
        L2,
        L2,
        L2,
        L2,
        L2,
        L2,
        L2,
        L2,
        L2,
        L2,
        L2,
        L2,
        L2,
        L2,
        L2,
        L2,
        L2,
        L2,
        L2,
        L2,
        L2,
        L2,
        L2,
        L2,
        ON,
        ON,
        ON,
        ON,
        BN,
        BN,
        BN,
        BN,
        BN,
        BN,
        B2,
        BN,
        BN,
        BN,
        BN,
        BN,
        BN,
        BN,
        BN,
        BN,
        BN,
        BN,
        BN,
        BN,
        BN,
        BN,
        BN,
        BN,
        BN,
        BN,
        BN,
        BN,
        BN,
        BN,
        BN,
        BN,
        BN,
        CS,
        ON,
        ET,
        ET,
        ET,
        ET,
        ON,
        ON,
        ON,
        ON,
        L2,
        ON,
        ON,
        BN,
        ON,
        ON,
        ET,
        ET,
        EN,
        EN,
        ON,
        L2,
        ON,
        ON,
        ON,
        EN,
        L2,
        ON,
        ON,
        ON,
        ON,
        ON
      ];
      var UnicodeTBL20 = [
        WS,
        WS,
        WS,
        WS,
        WS,
        WS,
        WS,
        WS,
        WS,
        WS,
        WS,
        BN,
        BN,
        BN,
        L2,
        R2,
        ON,
        ON,
        ON,
        ON,
        ON,
        ON,
        ON,
        ON,
        ON,
        ON,
        ON,
        ON,
        ON,
        ON,
        ON,
        ON,
        ON,
        ON,
        ON,
        ON,
        ON,
        ON,
        ON,
        ON,
        WS,
        B2,
        LRE,
        RLE,
        PDF,
        LRO,
        RLO,
        CS,
        ET,
        ET,
        ET,
        ET,
        ET,
        ON,
        ON,
        ON,
        ON,
        ON,
        ON,
        ON,
        ON,
        ON,
        ON,
        ON,
        ON,
        ON,
        ON,
        ON,
        CS,
        ON,
        ON,
        ON,
        ON,
        ON,
        ON,
        ON,
        ON,
        ON,
        ON,
        ON,
        ON,
        ON,
        ON,
        ON,
        ON,
        ON,
        ON,
        ON,
        ON,
        ON,
        ON,
        ON,
        ON,
        ON,
        ON,
        WS
      ];
      function _computeLevels(chars, levels, len, charTypes) {
        var impTab = dir ? impTab_RTL : impTab_LTR, prevState = null, newClass = null, newLevel = null, newState = 0, action = null, cond = null, condPos = -1, i2 = null, ix = null, classes = [];
        if (!charTypes) {
          for (i2 = 0, charTypes = []; i2 < len; i2++) {
            charTypes[i2] = _getCharacterType(chars[i2]);
          }
        }
        hiLevel = dir;
        lastArabic = false;
        hasUBAT_B = false;
        hasUBAT_S = false;
        for (ix = 0; ix < len; ix++) {
          prevState = newState;
          classes[ix] = newClass = _getCharClass(chars, charTypes, classes, ix);
          newState = impTab[prevState][newClass];
          action = newState & 240;
          newState &= 15;
          levels[ix] = newLevel = impTab[newState][5];
          if (action > 0) {
            if (action == 16) {
              for (i2 = condPos; i2 < ix; i2++) {
                levels[i2] = 1;
              }
              condPos = -1;
            } else {
              condPos = -1;
            }
          }
          cond = impTab[newState][6];
          if (cond) {
            if (condPos == -1) {
              condPos = ix;
            }
          } else {
            if (condPos > -1) {
              for (i2 = condPos; i2 < ix; i2++) {
                levels[i2] = newLevel;
              }
              condPos = -1;
            }
          }
          if (charTypes[ix] == B2) {
            levels[ix] = 0;
          }
          hiLevel |= newLevel;
        }
        if (hasUBAT_S) {
          for (i2 = 0; i2 < len; i2++) {
            if (charTypes[i2] == S3) {
              levels[i2] = dir;
              for (var j = i2 - 1; j >= 0; j--) {
                if (charTypes[j] == WS) {
                  levels[j] = dir;
                } else {
                  break;
                }
              }
            }
          }
        }
      }
      function _invertLevel(lev, levels, _array) {
        if (hiLevel < lev) {
          return;
        }
        if (lev == 1 && dir == RTL && !hasUBAT_B) {
          _array.reverse();
          return;
        }
        var len = _array.length, start = 0, end, lo, hi, tmp;
        while (start < len) {
          if (levels[start] >= lev) {
            end = start + 1;
            while (end < len && levels[end] >= lev) {
              end++;
            }
            for (lo = start, hi = end - 1; lo < hi; lo++, hi--) {
              tmp = _array[lo];
              _array[lo] = _array[hi];
              _array[hi] = tmp;
            }
            start = end;
          }
          start++;
        }
      }
      function _getCharClass(chars, types, classes, ix) {
        var cType = types[ix], wType, nType, len, i2;
        switch (cType) {
          case L2:
          case R2:
            lastArabic = false;
          case ON:
          case AN:
            return cType;
          case EN:
            return lastArabic ? AN : EN;
          case AL:
            lastArabic = true;
            return R2;
          case WS:
            return ON;
          case CS:
            if (ix < 1 || ix + 1 >= types.length || (wType = classes[ix - 1]) != EN && wType != AN || (nType = types[ix + 1]) != EN && nType != AN) {
              return ON;
            }
            if (lastArabic) {
              nType = AN;
            }
            return nType == wType ? nType : ON;
          case ES:
            wType = ix > 0 ? classes[ix - 1] : B2;
            if (wType == EN && ix + 1 < types.length && types[ix + 1] == EN) {
              return EN;
            }
            return ON;
          case ET:
            if (ix > 0 && classes[ix - 1] == EN) {
              return EN;
            }
            if (lastArabic) {
              return ON;
            }
            i2 = ix + 1;
            len = types.length;
            while (i2 < len && types[i2] == ET) {
              i2++;
            }
            if (i2 < len && types[i2] == EN) {
              return EN;
            }
            return ON;
          case NSM:
            len = types.length;
            i2 = ix + 1;
            while (i2 < len && types[i2] == NSM) {
              i2++;
            }
            if (i2 < len) {
              var c2 = chars[ix], rtlCandidate = c2 >= 1425 && c2 <= 2303 || c2 == 64286;
              wType = types[i2];
              if (rtlCandidate && (wType == R2 || wType == AL)) {
                return R2;
              }
            }
            if (ix < 1 || (wType = types[ix - 1]) == B2) {
              return ON;
            }
            return classes[ix - 1];
          case B2:
            lastArabic = false;
            hasUBAT_B = true;
            return dir;
          case S3:
            hasUBAT_S = true;
            return ON;
          case LRE:
          case RLE:
          case LRO:
          case RLO:
          case PDF:
            lastArabic = false;
          case BN:
            return ON;
        }
      }
      function _getCharacterType(ch) {
        var uc = ch.charCodeAt(0), hi = uc >> 8;
        if (hi == 0) {
          return uc > 191 ? L2 : UnicodeTBL00[uc];
        } else if (hi == 5) {
          return /[\u0591-\u05f4]/.test(ch) ? R2 : L2;
        } else if (hi == 6) {
          if (/[\u0610-\u061a\u064b-\u065f\u06d6-\u06e4\u06e7-\u06ed]/.test(ch))
            return NSM;
          else if (/[\u0660-\u0669\u066b-\u066c]/.test(ch))
            return AN;
          else if (uc == 1642)
            return ET;
          else if (/[\u06f0-\u06f9]/.test(ch))
            return EN;
          else
            return AL;
        } else if (hi == 32 && uc <= 8287) {
          return UnicodeTBL20[uc & 255];
        } else if (hi == 254) {
          return uc >= 65136 ? AL : ON;
        }
        return ON;
      }
      exports3.L = L2;
      exports3.R = R2;
      exports3.EN = EN;
      exports3.ON_R = 3;
      exports3.AN = 4;
      exports3.R_H = 5;
      exports3.B = 6;
      exports3.RLE = 7;
      exports3.DOT = "";
      exports3.doBidiReorder = function(text, textCharTypes, isRtl) {
        if (text.length < 2)
          return {};
        var chars = text.split(""), logicalFromVisual = new Array(chars.length), bidiLevels = new Array(chars.length), levels = [];
        dir = isRtl ? RTL : LTR;
        _computeLevels(chars, levels, chars.length, textCharTypes);
        for (var i2 = 0; i2 < logicalFromVisual.length; logicalFromVisual[i2] = i2, i2++)
          ;
        _invertLevel(2, levels, logicalFromVisual);
        _invertLevel(1, levels, logicalFromVisual);
        for (var i2 = 0; i2 < logicalFromVisual.length - 1; i2++) {
          if (textCharTypes[i2] === AN) {
            levels[i2] = exports3.AN;
          } else if (levels[i2] === R2 && (textCharTypes[i2] > AL && textCharTypes[i2] < LRE || textCharTypes[i2] === ON || textCharTypes[i2] === BN)) {
            levels[i2] = exports3.ON_R;
          } else if (i2 > 0 && chars[i2 - 1] === "" && /\u0622|\u0623|\u0625|\u0627/.test(chars[i2])) {
            levels[i2 - 1] = levels[i2] = exports3.R_H;
            i2++;
          }
        }
        if (chars[chars.length - 1] === exports3.DOT)
          levels[chars.length - 1] = exports3.B;
        if (chars[0] === "")
          levels[0] = exports3.RLE;
        for (var i2 = 0; i2 < logicalFromVisual.length; i2++) {
          bidiLevels[i2] = levels[logicalFromVisual[i2]];
        }
        return { "logicalFromVisual": logicalFromVisual, "bidiLevels": bidiLevels };
      };
      exports3.hasBidiCharacters = function(text, textCharTypes) {
        var ret = false;
        for (var i2 = 0; i2 < text.length; i2++) {
          textCharTypes[i2] = _getCharacterType(text.charAt(i2));
          if (!ret && (textCharTypes[i2] == R2 || textCharTypes[i2] == AL || textCharTypes[i2] == AN))
            ret = true;
        }
        return ret;
      };
      exports3.getVisualFromLogicalIdx = function(logIdx, rowMap) {
        for (var i2 = 0; i2 < rowMap.logicalFromVisual.length; i2++) {
          if (rowMap.logicalFromVisual[i2] == logIdx)
            return i2;
        }
        return 0;
      };
    });
    ace.define("ace/bidihandler", ["require", "exports", "module", "ace/lib/bidiutil", "ace/lib/lang"], function(require2, exports3, module3) {
      var bidiUtil = require2("./lib/bidiutil");
      var lang = require2("./lib/lang");
      var bidiRE = /[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac\u202B]/;
      var BidiHandler = (
        /** @class */
        (function() {
          function BidiHandler2(session) {
            this.session = session;
            this.bidiMap = {};
            this.currentRow = null;
            this.bidiUtil = bidiUtil;
            this.charWidths = [];
            this.EOL = "";
            this.showInvisibles = true;
            this.isRtlDir = false;
            this.$isRtl = false;
            this.line = "";
            this.wrapIndent = 0;
            this.EOF = "";
            this.RLE = "";
            this.contentWidth = 0;
            this.fontMetrics = null;
            this.rtlLineOffset = 0;
            this.wrapOffset = 0;
            this.isMoveLeftOperation = false;
            this.seenBidi = bidiRE.test(session.getValue());
          }
          BidiHandler2.prototype.isBidiRow = function(screenRow, docRow, splitIndex) {
            if (!this.seenBidi)
              return false;
            if (screenRow !== this.currentRow) {
              this.currentRow = screenRow;
              this.updateRowLine(docRow, splitIndex);
              this.updateBidiMap();
            }
            return this.bidiMap.bidiLevels;
          };
          BidiHandler2.prototype.onChange = function(delta) {
            if (!this.seenBidi) {
              if (delta.action == "insert" && bidiRE.test(delta.lines.join("\n"))) {
                this.seenBidi = true;
                this.currentRow = null;
              }
            } else {
              this.currentRow = null;
            }
          };
          BidiHandler2.prototype.getDocumentRow = function() {
            var docRow = 0;
            var rowCache = this.session.$screenRowCache;
            if (rowCache.length) {
              var index = this.session.$getRowCacheIndex(rowCache, this.currentRow);
              if (index >= 0)
                docRow = this.session.$docRowCache[index];
            }
            return docRow;
          };
          BidiHandler2.prototype.getSplitIndex = function() {
            var splitIndex = 0;
            var rowCache = this.session.$screenRowCache;
            if (rowCache.length) {
              var currentIndex, prevIndex = this.session.$getRowCacheIndex(rowCache, this.currentRow);
              while (this.currentRow - splitIndex > 0) {
                currentIndex = this.session.$getRowCacheIndex(rowCache, this.currentRow - splitIndex - 1);
                if (currentIndex !== prevIndex)
                  break;
                prevIndex = currentIndex;
                splitIndex++;
              }
            } else {
              splitIndex = this.currentRow;
            }
            return splitIndex;
          };
          BidiHandler2.prototype.updateRowLine = function(docRow, splitIndex) {
            if (docRow === void 0)
              docRow = this.getDocumentRow();
            var isLastRow = docRow === this.session.getLength() - 1, endOfLine = isLastRow ? this.EOF : this.EOL;
            this.wrapIndent = 0;
            this.line = this.session.getLine(docRow);
            this.isRtlDir = this.$isRtl || this.line.charAt(0) === this.RLE;
            if (this.session.$useWrapMode) {
              var splits = this.session.$wrapData[docRow];
              if (splits) {
                if (splitIndex === void 0)
                  splitIndex = this.getSplitIndex();
                if (splitIndex > 0 && splits.length) {
                  this.wrapIndent = splits.indent;
                  this.wrapOffset = this.wrapIndent * this.charWidths[bidiUtil.L];
                  this.line = splitIndex < splits.length ? this.line.substring(splits[splitIndex - 1], splits[splitIndex]) : this.line.substring(splits[splits.length - 1]);
                } else {
                  this.line = this.line.substring(0, splits[splitIndex]);
                }
                if (splitIndex == splits.length) {
                  this.line += this.showInvisibles ? endOfLine : bidiUtil.DOT;
                }
              }
            } else {
              this.line += this.showInvisibles ? endOfLine : bidiUtil.DOT;
            }
            var session = this.session, shift = 0, size;
            this.line = this.line.replace(/\t|[\u1100-\u2029, \u202F-\uFFE6]/g, function(ch, i2) {
              if (ch === "	" || session.isFullWidth(ch.charCodeAt(0))) {
                size = ch === "	" ? session.getScreenTabSize(i2 + shift) : 2;
                shift += size - 1;
                return lang.stringRepeat(bidiUtil.DOT, size);
              }
              return ch;
            });
            if (this.isRtlDir) {
              this.fontMetrics.$main.textContent = this.line.charAt(this.line.length - 1) == bidiUtil.DOT ? this.line.substr(0, this.line.length - 1) : this.line;
              this.rtlLineOffset = this.contentWidth - this.fontMetrics.$main.getBoundingClientRect().width;
            }
          };
          BidiHandler2.prototype.updateBidiMap = function() {
            var textCharTypes = [];
            if (bidiUtil.hasBidiCharacters(this.line, textCharTypes) || this.isRtlDir) {
              this.bidiMap = bidiUtil.doBidiReorder(this.line, textCharTypes, this.isRtlDir);
            } else {
              this.bidiMap = {};
            }
          };
          BidiHandler2.prototype.markAsDirty = function() {
            this.currentRow = null;
          };
          BidiHandler2.prototype.updateCharacterWidths = function(fontMetrics) {
            if (this.characterWidth === fontMetrics.$characterSize.width)
              return;
            this.fontMetrics = fontMetrics;
            var characterWidth = this.characterWidth = fontMetrics.$characterSize.width;
            var bidiCharWidth = fontMetrics.$measureCharWidth("");
            this.charWidths[bidiUtil.L] = this.charWidths[bidiUtil.EN] = this.charWidths[bidiUtil.ON_R] = characterWidth;
            this.charWidths[bidiUtil.R] = this.charWidths[bidiUtil.AN] = bidiCharWidth;
            this.charWidths[bidiUtil.R_H] = bidiCharWidth * 0.45;
            this.charWidths[bidiUtil.B] = this.charWidths[bidiUtil.RLE] = 0;
            this.currentRow = null;
          };
          BidiHandler2.prototype.setShowInvisibles = function(showInvisibles) {
            this.showInvisibles = showInvisibles;
            this.currentRow = null;
          };
          BidiHandler2.prototype.setEolChar = function(eolChar) {
            this.EOL = eolChar;
          };
          BidiHandler2.prototype.setContentWidth = function(width) {
            this.contentWidth = width;
          };
          BidiHandler2.prototype.isRtlLine = function(row) {
            if (this.$isRtl)
              return true;
            if (row != void 0)
              return this.session.getLine(row).charAt(0) == this.RLE;
            else
              return this.isRtlDir;
          };
          BidiHandler2.prototype.setRtlDirection = function(editor, isRtlDir) {
            var cursor = editor.getCursorPosition();
            for (var row = editor.selection.getSelectionAnchor().row; row <= cursor.row; row++) {
              if (!isRtlDir && editor.session.getLine(row).charAt(0) === editor.session.$bidiHandler.RLE)
                editor.session.doc.removeInLine(row, 0, 1);
              else if (isRtlDir && editor.session.getLine(row).charAt(0) !== editor.session.$bidiHandler.RLE)
                editor.session.doc.insert({ column: 0, row }, editor.session.$bidiHandler.RLE);
            }
          };
          BidiHandler2.prototype.getPosLeft = function(col) {
            col -= this.wrapIndent;
            var leftBoundary = this.line.charAt(0) === this.RLE ? 1 : 0;
            var logicalIdx = col > leftBoundary ? this.session.getOverwrite() ? col : col - 1 : leftBoundary;
            var visualIdx = bidiUtil.getVisualFromLogicalIdx(logicalIdx, this.bidiMap), levels = this.bidiMap.bidiLevels, left = 0;
            if (!this.session.getOverwrite() && col <= leftBoundary && levels[visualIdx] % 2 !== 0)
              visualIdx++;
            for (var i2 = 0; i2 < visualIdx; i2++) {
              left += this.charWidths[levels[i2]];
            }
            if (!this.session.getOverwrite() && col > leftBoundary && levels[visualIdx] % 2 === 0)
              left += this.charWidths[levels[visualIdx]];
            if (this.wrapIndent)
              left += this.isRtlDir ? -1 * this.wrapOffset : this.wrapOffset;
            if (this.isRtlDir)
              left += this.rtlLineOffset;
            return left;
          };
          BidiHandler2.prototype.getSelections = function(startCol, endCol) {
            var map = this.bidiMap, levels = map.bidiLevels, level, selections = [], offset = 0, selColMin = Math.min(startCol, endCol) - this.wrapIndent, selColMax = Math.max(startCol, endCol) - this.wrapIndent, isSelected = false, isSelectedPrev = false, selectionStart = 0;
            if (this.wrapIndent)
              offset += this.isRtlDir ? -1 * this.wrapOffset : this.wrapOffset;
            for (var logIdx, visIdx = 0; visIdx < levels.length; visIdx++) {
              logIdx = map.logicalFromVisual[visIdx];
              level = levels[visIdx];
              isSelected = logIdx >= selColMin && logIdx < selColMax;
              if (isSelected && !isSelectedPrev) {
                selectionStart = offset;
              } else if (!isSelected && isSelectedPrev) {
                selections.push({ left: selectionStart, width: offset - selectionStart });
              }
              offset += this.charWidths[level];
              isSelectedPrev = isSelected;
            }
            if (isSelected && visIdx === levels.length) {
              selections.push({ left: selectionStart, width: offset - selectionStart });
            }
            if (this.isRtlDir) {
              for (var i2 = 0; i2 < selections.length; i2++) {
                selections[i2].left += this.rtlLineOffset;
              }
            }
            return selections;
          };
          BidiHandler2.prototype.offsetToCol = function(posX) {
            if (this.isRtlDir)
              posX -= this.rtlLineOffset;
            var logicalIdx = 0, posX = Math.max(posX, 0), offset = 0, visualIdx = 0, levels = this.bidiMap.bidiLevels, charWidth = this.charWidths[levels[visualIdx]];
            if (this.wrapIndent)
              posX -= this.isRtlDir ? -1 * this.wrapOffset : this.wrapOffset;
            while (posX > offset + charWidth / 2) {
              offset += charWidth;
              if (visualIdx === levels.length - 1) {
                charWidth = 0;
                break;
              }
              charWidth = this.charWidths[levels[++visualIdx]];
            }
            if (visualIdx > 0 && levels[visualIdx - 1] % 2 !== 0 && levels[visualIdx] % 2 === 0) {
              if (posX < offset)
                visualIdx--;
              logicalIdx = this.bidiMap.logicalFromVisual[visualIdx];
            } else if (visualIdx > 0 && levels[visualIdx - 1] % 2 === 0 && levels[visualIdx] % 2 !== 0) {
              logicalIdx = 1 + (posX > offset ? this.bidiMap.logicalFromVisual[visualIdx] : this.bidiMap.logicalFromVisual[visualIdx - 1]);
            } else if (this.isRtlDir && visualIdx === levels.length - 1 && charWidth === 0 && levels[visualIdx - 1] % 2 === 0 || !this.isRtlDir && visualIdx === 0 && levels[visualIdx] % 2 !== 0) {
              logicalIdx = 1 + this.bidiMap.logicalFromVisual[visualIdx];
            } else {
              if (visualIdx > 0 && levels[visualIdx - 1] % 2 !== 0 && charWidth !== 0)
                visualIdx--;
              logicalIdx = this.bidiMap.logicalFromVisual[visualIdx];
            }
            if (logicalIdx === 0 && this.isRtlDir)
              logicalIdx++;
            return logicalIdx + this.wrapIndent;
          };
          return BidiHandler2;
        })()
      );
      exports3.BidiHandler = BidiHandler;
    });
    ace.define("ace/selection", ["require", "exports", "module", "ace/lib/oop", "ace/lib/lang", "ace/lib/event_emitter", "ace/range"], function(require2, exports3, module3) {
      var oop = require2("./lib/oop");
      var lang = require2("./lib/lang");
      var EventEmitter = require2("./lib/event_emitter").EventEmitter;
      var Range = require2("./range").Range;
      var Selection = (
        /** @class */
        (function() {
          function Selection2(session) {
            this.session = session;
            this.doc = session.getDocument();
            this.clearSelection();
            this.cursor = this.lead = this.doc.createAnchor(0, 0);
            this.anchor = this.doc.createAnchor(0, 0);
            this.$silent = false;
            var self2 = this;
            this.cursor.on("change", function(e2) {
              self2.$cursorChanged = true;
              if (!self2.$silent)
                self2._emit("changeCursor");
              if (!self2.$isEmpty && !self2.$silent)
                self2._emit("changeSelection");
              if (!self2.$keepDesiredColumnOnChange && e2.old.column != e2.value.column)
                self2.$desiredColumn = null;
            });
            this.anchor.on("change", function() {
              self2.$anchorChanged = true;
              if (!self2.$isEmpty && !self2.$silent)
                self2._emit("changeSelection");
            });
          }
          Selection2.prototype.isEmpty = function() {
            return this.$isEmpty || this.anchor.row == this.lead.row && this.anchor.column == this.lead.column;
          };
          Selection2.prototype.isMultiLine = function() {
            return !this.$isEmpty && this.anchor.row != this.cursor.row;
          };
          Selection2.prototype.getCursor = function() {
            return this.lead.getPosition();
          };
          Selection2.prototype.setAnchor = function(row, column) {
            this.$isEmpty = false;
            this.anchor.setPosition(row, column);
          };
          Selection2.prototype.getAnchor = function() {
            if (this.$isEmpty)
              return this.getSelectionLead();
            return this.anchor.getPosition();
          };
          Selection2.prototype.getSelectionLead = function() {
            return this.lead.getPosition();
          };
          Selection2.prototype.isBackwards = function() {
            var anchor = this.anchor;
            var lead = this.lead;
            return anchor.row > lead.row || anchor.row == lead.row && anchor.column > lead.column;
          };
          Selection2.prototype.getRange = function() {
            var anchor = this.anchor;
            var lead = this.lead;
            if (this.$isEmpty)
              return Range.fromPoints(lead, lead);
            return this.isBackwards() ? Range.fromPoints(lead, anchor) : Range.fromPoints(anchor, lead);
          };
          Selection2.prototype.clearSelection = function() {
            if (!this.$isEmpty) {
              this.$isEmpty = true;
              this._emit("changeSelection");
            }
          };
          Selection2.prototype.selectAll = function() {
            this.$setSelection(0, 0, Number.MAX_VALUE, Number.MAX_VALUE);
          };
          Selection2.prototype.setRange = function(range, reverse) {
            var start = reverse ? range.end : range.start;
            var end = reverse ? range.start : range.end;
            this.$setSelection(start.row, start.column, end.row, end.column);
          };
          Selection2.prototype.$setSelection = function(anchorRow, anchorColumn, cursorRow, cursorColumn) {
            if (this.$silent)
              return;
            var wasEmpty = this.$isEmpty;
            var wasMultiselect = this.inMultiSelectMode;
            this.$silent = true;
            this.$cursorChanged = this.$anchorChanged = false;
            this.anchor.setPosition(anchorRow, anchorColumn);
            this.cursor.setPosition(cursorRow, cursorColumn);
            this.$isEmpty = !Range.comparePoints(this.anchor, this.cursor);
            this.$silent = false;
            if (this.$cursorChanged)
              this._emit("changeCursor");
            if (this.$cursorChanged || this.$anchorChanged || wasEmpty != this.$isEmpty || wasMultiselect)
              this._emit("changeSelection");
          };
          Selection2.prototype.$moveSelection = function(mover) {
            var lead = this.lead;
            if (this.$isEmpty)
              this.setSelectionAnchor(lead.row, lead.column);
            mover.call(this);
          };
          Selection2.prototype.selectTo = function(row, column) {
            this.$moveSelection(function() {
              this.moveCursorTo(row, column);
            });
          };
          Selection2.prototype.selectToPosition = function(pos) {
            this.$moveSelection(function() {
              this.moveCursorToPosition(pos);
            });
          };
          Selection2.prototype.moveTo = function(row, column) {
            this.clearSelection();
            this.moveCursorTo(row, column);
          };
          Selection2.prototype.moveToPosition = function(pos) {
            this.clearSelection();
            this.moveCursorToPosition(pos);
          };
          Selection2.prototype.selectUp = function() {
            this.$moveSelection(this.moveCursorUp);
          };
          Selection2.prototype.selectDown = function() {
            this.$moveSelection(this.moveCursorDown);
          };
          Selection2.prototype.selectRight = function() {
            this.$moveSelection(this.moveCursorRight);
          };
          Selection2.prototype.selectLeft = function() {
            this.$moveSelection(this.moveCursorLeft);
          };
          Selection2.prototype.selectLineStart = function() {
            this.$moveSelection(this.moveCursorLineStart);
          };
          Selection2.prototype.selectLineEnd = function() {
            this.$moveSelection(this.moveCursorLineEnd);
          };
          Selection2.prototype.selectFileEnd = function() {
            this.$moveSelection(this.moveCursorFileEnd);
          };
          Selection2.prototype.selectFileStart = function() {
            this.$moveSelection(this.moveCursorFileStart);
          };
          Selection2.prototype.selectWordRight = function() {
            this.$moveSelection(this.moveCursorWordRight);
          };
          Selection2.prototype.selectWordLeft = function() {
            this.$moveSelection(this.moveCursorWordLeft);
          };
          Selection2.prototype.getWordRange = function(row, column) {
            if (typeof column == "undefined") {
              var cursor = row || this.lead;
              row = cursor.row;
              column = cursor.column;
            }
            return this.session.getWordRange(row, column);
          };
          Selection2.prototype.selectWord = function() {
            this.setSelectionRange(this.getWordRange());
          };
          Selection2.prototype.selectAWord = function() {
            var cursor = this.getCursor();
            var range = this.session.getAWordRange(cursor.row, cursor.column);
            this.setSelectionRange(range);
          };
          Selection2.prototype.getLineRange = function(row, excludeLastChar) {
            var rowStart = typeof row == "number" ? row : this.lead.row;
            var rowEnd;
            var foldLine = this.session.getFoldLine(rowStart);
            if (foldLine) {
              rowStart = foldLine.start.row;
              rowEnd = foldLine.end.row;
            } else {
              rowEnd = rowStart;
            }
            if (excludeLastChar === true)
              return new Range(rowStart, 0, rowEnd, this.session.getLine(rowEnd).length);
            else
              return new Range(rowStart, 0, rowEnd + 1, 0);
          };
          Selection2.prototype.selectLine = function() {
            this.setSelectionRange(this.getLineRange());
          };
          Selection2.prototype.moveCursorUp = function() {
            this.moveCursorBy(-1, 0);
          };
          Selection2.prototype.moveCursorDown = function() {
            this.moveCursorBy(1, 0);
          };
          Selection2.prototype.wouldMoveIntoSoftTab = function(cursor, tabSize, direction) {
            var start = cursor.column;
            var end = cursor.column + tabSize;
            if (direction < 0) {
              start = cursor.column - tabSize;
              end = cursor.column;
            }
            return this.session.isTabStop(cursor) && this.doc.getLine(cursor.row).slice(start, end).split(" ").length - 1 == tabSize;
          };
          Selection2.prototype.moveCursorLeft = function() {
            var cursor = this.lead.getPosition(), fold;
            if (fold = this.session.getFoldAt(cursor.row, cursor.column, -1)) {
              this.moveCursorTo(fold.start.row, fold.start.column);
            } else if (cursor.column === 0) {
              if (cursor.row > 0) {
                this.moveCursorTo(cursor.row - 1, this.doc.getLine(cursor.row - 1).length);
              }
            } else {
              var tabSize = this.session.getTabSize();
              if (this.wouldMoveIntoSoftTab(cursor, tabSize, -1) && !this.session.getNavigateWithinSoftTabs()) {
                this.moveCursorBy(0, -tabSize);
              } else {
                this.moveCursorBy(0, -1);
              }
            }
          };
          Selection2.prototype.moveCursorRight = function() {
            var cursor = this.lead.getPosition(), fold;
            if (fold = this.session.getFoldAt(cursor.row, cursor.column, 1)) {
              this.moveCursorTo(fold.end.row, fold.end.column);
            } else if (this.lead.column == this.doc.getLine(this.lead.row).length) {
              if (this.lead.row < this.doc.getLength() - 1) {
                this.moveCursorTo(this.lead.row + 1, 0);
              }
            } else {
              var tabSize = this.session.getTabSize();
              var cursor = this.lead;
              if (this.wouldMoveIntoSoftTab(cursor, tabSize, 1) && !this.session.getNavigateWithinSoftTabs()) {
                this.moveCursorBy(0, tabSize);
              } else {
                this.moveCursorBy(0, 1);
              }
            }
          };
          Selection2.prototype.moveCursorLineStart = function() {
            var row = this.lead.row;
            var column = this.lead.column;
            var screenRow = this.session.documentToScreenRow(row, column);
            var firstColumnPosition = this.session.screenToDocumentPosition(screenRow, 0);
            var beforeCursor = this.session.getDisplayLine(row, null, firstColumnPosition.row, firstColumnPosition.column);
            var leadingSpace = beforeCursor.match(/^\s*/);
            if (leadingSpace[0].length != column && !this.session.$useEmacsStyleLineStart)
              firstColumnPosition.column += leadingSpace[0].length;
            this.moveCursorToPosition(firstColumnPosition);
          };
          Selection2.prototype.moveCursorLineEnd = function() {
            var lead = this.lead;
            var lineEnd = this.session.getDocumentLastRowColumnPosition(lead.row, lead.column);
            if (this.lead.column == lineEnd.column) {
              var line = this.session.getLine(lineEnd.row);
              if (lineEnd.column == line.length) {
                var textEnd = line.search(/\s+$/);
                if (textEnd > 0)
                  lineEnd.column = textEnd;
              }
            }
            this.moveCursorTo(lineEnd.row, lineEnd.column);
          };
          Selection2.prototype.moveCursorFileEnd = function() {
            var row = this.doc.getLength() - 1;
            var column = this.doc.getLine(row).length;
            this.moveCursorTo(row, column);
          };
          Selection2.prototype.moveCursorFileStart = function() {
            this.moveCursorTo(0, 0);
          };
          Selection2.prototype.moveCursorLongWordRight = function() {
            var row = this.lead.row;
            var column = this.lead.column;
            var line = this.doc.getLine(row);
            var rightOfCursor = line.substring(column);
            this.session.nonTokenRe.lastIndex = 0;
            this.session.tokenRe.lastIndex = 0;
            var fold = this.session.getFoldAt(row, column, 1);
            if (fold) {
              this.moveCursorTo(fold.end.row, fold.end.column);
              return;
            }
            if (this.session.nonTokenRe.exec(rightOfCursor)) {
              column += this.session.nonTokenRe.lastIndex;
              this.session.nonTokenRe.lastIndex = 0;
              rightOfCursor = line.substring(column);
            }
            if (column >= line.length) {
              this.moveCursorTo(row, line.length);
              this.moveCursorRight();
              if (row < this.doc.getLength() - 1)
                this.moveCursorWordRight();
              return;
            }
            if (this.session.tokenRe.exec(rightOfCursor)) {
              column += this.session.tokenRe.lastIndex;
              this.session.tokenRe.lastIndex = 0;
            }
            this.moveCursorTo(row, column);
          };
          Selection2.prototype.moveCursorLongWordLeft = function() {
            var row = this.lead.row;
            var column = this.lead.column;
            var fold;
            if (fold = this.session.getFoldAt(row, column, -1)) {
              this.moveCursorTo(fold.start.row, fold.start.column);
              return;
            }
            var str = this.session.getFoldStringAt(row, column, -1);
            if (str == null) {
              str = this.doc.getLine(row).substring(0, column);
            }
            var leftOfCursor = lang.stringReverse(str);
            this.session.nonTokenRe.lastIndex = 0;
            this.session.tokenRe.lastIndex = 0;
            if (this.session.nonTokenRe.exec(leftOfCursor)) {
              column -= this.session.nonTokenRe.lastIndex;
              leftOfCursor = leftOfCursor.slice(this.session.nonTokenRe.lastIndex);
              this.session.nonTokenRe.lastIndex = 0;
            }
            if (column <= 0) {
              this.moveCursorTo(row, 0);
              this.moveCursorLeft();
              if (row > 0)
                this.moveCursorWordLeft();
              return;
            }
            if (this.session.tokenRe.exec(leftOfCursor)) {
              column -= this.session.tokenRe.lastIndex;
              this.session.tokenRe.lastIndex = 0;
            }
            this.moveCursorTo(row, column);
          };
          Selection2.prototype.$shortWordEndIndex = function(rightOfCursor) {
            var index = 0, ch;
            var whitespaceRe = /\s/;
            var tokenRe = this.session.tokenRe;
            tokenRe.lastIndex = 0;
            if (this.session.tokenRe.exec(rightOfCursor)) {
              index = this.session.tokenRe.lastIndex;
            } else {
              while ((ch = rightOfCursor[index]) && whitespaceRe.test(ch))
                index++;
              if (index < 1) {
                tokenRe.lastIndex = 0;
                while ((ch = rightOfCursor[index]) && !tokenRe.test(ch)) {
                  tokenRe.lastIndex = 0;
                  index++;
                  if (whitespaceRe.test(ch)) {
                    if (index > 2) {
                      index--;
                      break;
                    } else {
                      while ((ch = rightOfCursor[index]) && whitespaceRe.test(ch))
                        index++;
                      if (index > 2)
                        break;
                    }
                  }
                }
              }
            }
            tokenRe.lastIndex = 0;
            return index;
          };
          Selection2.prototype.moveCursorShortWordRight = function() {
            var row = this.lead.row;
            var column = this.lead.column;
            var line = this.doc.getLine(row);
            var rightOfCursor = line.substring(column);
            var fold = this.session.getFoldAt(row, column, 1);
            if (fold)
              return this.moveCursorTo(fold.end.row, fold.end.column);
            if (column == line.length) {
              var l = this.doc.getLength();
              do {
                row++;
                rightOfCursor = this.doc.getLine(row);
              } while (row < l && /^\s*$/.test(rightOfCursor));
              if (!/^\s+/.test(rightOfCursor))
                rightOfCursor = "";
              column = 0;
            }
            var index = this.$shortWordEndIndex(rightOfCursor);
            this.moveCursorTo(row, column + index);
          };
          Selection2.prototype.moveCursorShortWordLeft = function() {
            var row = this.lead.row;
            var column = this.lead.column;
            var fold;
            if (fold = this.session.getFoldAt(row, column, -1))
              return this.moveCursorTo(fold.start.row, fold.start.column);
            var line = this.session.getLine(row).substring(0, column);
            if (column === 0) {
              do {
                row--;
                line = this.doc.getLine(row);
              } while (row > 0 && /^\s*$/.test(line));
              column = line.length;
              if (!/\s+$/.test(line))
                line = "";
            }
            var leftOfCursor = lang.stringReverse(line);
            var index = this.$shortWordEndIndex(leftOfCursor);
            return this.moveCursorTo(row, column - index);
          };
          Selection2.prototype.moveCursorWordRight = function() {
            if (this.session.$selectLongWords)
              this.moveCursorLongWordRight();
            else
              this.moveCursorShortWordRight();
          };
          Selection2.prototype.moveCursorWordLeft = function() {
            if (this.session.$selectLongWords)
              this.moveCursorLongWordLeft();
            else
              this.moveCursorShortWordLeft();
          };
          Selection2.prototype.moveCursorBy = function(rows, chars) {
            var screenPos = this.session.documentToScreenPosition(this.lead.row, this.lead.column);
            var offsetX;
            if (chars === 0) {
              if (rows !== 0) {
                if (this.session.$bidiHandler.isBidiRow(screenPos.row, this.lead.row)) {
                  offsetX = this.session.$bidiHandler.getPosLeft(screenPos.column);
                  screenPos.column = Math.round(offsetX / this.session.$bidiHandler.charWidths[0]);
                } else {
                  offsetX = screenPos.column * this.session.$bidiHandler.charWidths[0];
                }
              }
              if (this.$desiredColumn)
                screenPos.column = this.$desiredColumn;
              else
                this.$desiredColumn = screenPos.column;
            }
            if (rows != 0 && this.session.lineWidgets && this.session.lineWidgets[this.lead.row]) {
              var widget = this.session.lineWidgets[this.lead.row];
              if (rows < 0)
                rows -= widget.rowsAbove || 0;
              else if (rows > 0)
                rows += widget.rowCount - (widget.rowsAbove || 0);
            }
            var docPos = this.session.screenToDocumentPosition(screenPos.row + rows, screenPos.column, offsetX);
            if (rows !== 0 && chars === 0 && docPos.row === this.lead.row && docPos.column === this.lead.column) ;
            this.moveCursorTo(docPos.row, docPos.column + chars, chars === 0);
          };
          Selection2.prototype.moveCursorToPosition = function(position) {
            this.moveCursorTo(position.row, position.column);
          };
          Selection2.prototype.moveCursorTo = function(row, column, keepDesiredColumn) {
            var fold = this.session.getFoldAt(row, column, 1);
            if (fold) {
              row = fold.start.row;
              column = fold.start.column;
            }
            this.$keepDesiredColumnOnChange = true;
            var line = this.session.getLine(row);
            if (/[\uDC00-\uDFFF]/.test(line.charAt(column)) && line.charAt(column - 1)) {
              if (this.lead.row == row && this.lead.column == column + 1)
                column = column - 1;
              else
                column = column + 1;
            }
            this.lead.setPosition(row, column);
            this.$keepDesiredColumnOnChange = false;
            if (!keepDesiredColumn)
              this.$desiredColumn = null;
          };
          Selection2.prototype.moveCursorToScreen = function(row, column, keepDesiredColumn) {
            var pos = this.session.screenToDocumentPosition(row, column);
            this.moveCursorTo(pos.row, pos.column, keepDesiredColumn);
          };
          Selection2.prototype.detach = function() {
            this.lead.detach();
            this.anchor.detach();
          };
          Selection2.prototype.fromOrientedRange = function(range) {
            this.setSelectionRange(range, range.cursor == range.start);
            this.$desiredColumn = range.desiredColumn || this.$desiredColumn;
          };
          Selection2.prototype.toOrientedRange = function(range) {
            var r = this.getRange();
            if (range) {
              range.start.column = r.start.column;
              range.start.row = r.start.row;
              range.end.column = r.end.column;
              range.end.row = r.end.row;
            } else {
              range = r;
            }
            range.cursor = this.isBackwards() ? range.start : range.end;
            range.desiredColumn = this.$desiredColumn;
            return range;
          };
          Selection2.prototype.getRangeOfMovements = function(func) {
            var start = this.getCursor();
            try {
              func(this);
              var end = this.getCursor();
              return Range.fromPoints(start, end);
            } catch (e2) {
              return Range.fromPoints(start, start);
            } finally {
              this.moveCursorToPosition(start);
            }
          };
          Selection2.prototype.toJSON = function() {
            if (this.rangeCount) {
              var data = this.ranges.map(function(r) {
                var r1 = r.clone();
                r1.isBackwards = r.cursor == r.start;
                return r1;
              });
            } else {
              var data = this.getRange();
              data.isBackwards = this.isBackwards();
            }
            return data;
          };
          Selection2.prototype.fromJSON = function(data) {
            if (data.start == void 0) {
              if (this.rangeList && data.length > 1) {
                this.toSingleRange(data[0]);
                for (var i2 = data.length; i2--; ) {
                  var r = Range.fromPoints(data[i2].start, data[i2].end);
                  if (data[i2].isBackwards)
                    r.cursor = r.start;
                  this.addRange(r, true);
                }
                return;
              } else {
                data = data[0];
              }
            }
            if (this.rangeList)
              this.toSingleRange(data);
            this.setSelectionRange(data, data.isBackwards);
          };
          Selection2.prototype.isEqual = function(data) {
            if ((data.length || this.rangeCount) && data.length != this.rangeCount)
              return false;
            if (!data.length || !this.ranges)
              return this.getRange().isEqual(data);
            for (var i2 = this.ranges.length; i2--; ) {
              if (!this.ranges[i2].isEqual(data[i2]))
                return false;
            }
            return true;
          };
          return Selection2;
        })()
      );
      Selection.prototype.setSelectionAnchor = Selection.prototype.setAnchor;
      Selection.prototype.getSelectionAnchor = Selection.prototype.getAnchor;
      Selection.prototype.setSelectionRange = Selection.prototype.setRange;
      oop.implement(Selection.prototype, EventEmitter);
      exports3.Selection = Selection;
    });
    ace.define("ace/tokenizer", ["require", "exports", "module", "ace/lib/report_error"], function(require2, exports3, module3) {
      var reportError = require2("./lib/report_error").reportError;
      var MAX_TOKEN_COUNT = 2e3;
      var Tokenizer = (
        /** @class */
        (function() {
          function Tokenizer2(rules) {
            this.splitRegex;
            this.states = rules;
            this.regExps = {};
            this.matchMappings = {};
            for (var key in this.states) {
              var state = this.states[key];
              var ruleRegExps = [];
              var matchTotal = 0;
              var mapping = this.matchMappings[key] = { defaultToken: "text" };
              var flag = "g";
              var splitterRurles = [];
              for (var i2 = 0; i2 < state.length; i2++) {
                var rule = state[i2];
                if (rule.defaultToken)
                  mapping.defaultToken = rule.defaultToken;
                if (rule.caseInsensitive && flag.indexOf("i") === -1)
                  flag += "i";
                if (rule.unicode && flag.indexOf("u") === -1)
                  flag += "u";
                if (rule.regex == null)
                  continue;
                if (rule.regex instanceof RegExp)
                  rule.regex = rule.regex.toString().slice(1, -1);
                var adjustedregex = rule.regex;
                var matchcount = new RegExp("(?:(" + adjustedregex + ")|(.))").exec("a").length - 2;
                if (Array.isArray(rule.token)) {
                  if (rule.token.length == 1 || matchcount == 1) {
                    rule.token = rule.token[0];
                  } else if (matchcount - 1 != rule.token.length) {
                    this.reportError("number of classes and regexp groups doesn't match", {
                      rule,
                      groupCount: matchcount - 1
                    });
                    rule.token = rule.token[0];
                  } else {
                    rule.tokenArray = rule.token;
                    rule.token = null;
                    rule.onMatch = this.$arrayTokens;
                  }
                } else if (typeof rule.token == "function" && !rule.onMatch) {
                  if (matchcount > 1)
                    rule.onMatch = this.$applyToken;
                  else
                    rule.onMatch = rule.token;
                }
                if (matchcount > 1) {
                  if (/\\\d/.test(rule.regex)) {
                    adjustedregex = rule.regex.replace(/\\([0-9]+)/g, function(match2, digit) {
                      return "\\" + (parseInt(digit, 10) + matchTotal + 1);
                    });
                  } else {
                    matchcount = 1;
                    adjustedregex = this.removeCapturingGroups(rule.regex);
                  }
                  if (!rule.splitRegex && typeof rule.token != "string")
                    splitterRurles.push(rule);
                }
                mapping[matchTotal] = i2;
                matchTotal += matchcount;
                ruleRegExps.push(adjustedregex);
                if (!rule.onMatch)
                  rule.onMatch = null;
              }
              if (!ruleRegExps.length) {
                mapping[0] = 0;
                ruleRegExps.push("$");
              }
              splitterRurles.forEach(function(rule2) {
                rule2.splitRegex = this.createSplitterRegexp(rule2.regex, flag);
              }, this);
              this.regExps[key] = new RegExp("(" + ruleRegExps.join(")|(") + ")|($)", flag);
            }
          }
          Tokenizer2.prototype.$setMaxTokenCount = function(m3) {
            MAX_TOKEN_COUNT = m3 | 0;
          };
          Tokenizer2.prototype.$applyToken = function(str) {
            var values = this.splitRegex.exec(str).slice(1);
            var types = this.token.apply(this, values);
            if (typeof types === "string")
              return [{ type: types, value: str }];
            var tokens = [];
            for (var i2 = 0, l = types.length; i2 < l; i2++) {
              if (values[i2])
                tokens[tokens.length] = {
                  type: types[i2],
                  value: values[i2]
                };
            }
            return tokens;
          };
          Tokenizer2.prototype.$arrayTokens = function(str) {
            if (!str)
              return [];
            var values = this.splitRegex.exec(str);
            if (!values)
              return "text";
            var tokens = [];
            var types = this.tokenArray;
            for (var i2 = 0, l = types.length; i2 < l; i2++) {
              if (values[i2 + 1])
                tokens[tokens.length] = {
                  type: types[i2],
                  value: values[i2 + 1]
                };
            }
            return tokens;
          };
          Tokenizer2.prototype.removeCapturingGroups = function(src) {
            var r = src.replace(/\\.|\[(?:\\.|[^\\\]])*|\(\?[:=!<]|(\()/g, function(x2, y3) {
              return y3 ? "(?:" : x2;
            });
            return r;
          };
          Tokenizer2.prototype.createSplitterRegexp = function(src, flag) {
            if (src.indexOf("(?=") != -1) {
              var stack = 0;
              var inChClass = false;
              var lastCapture = {};
              src.replace(/(\\.)|(\((?:\?[=!])?)|(\))|([\[\]])/g, function(m3, esc, parenOpen, parenClose, square, index) {
                if (inChClass) {
                  inChClass = square != "]";
                } else if (square) {
                  inChClass = true;
                } else if (parenClose) {
                  if (stack == lastCapture.stack) {
                    lastCapture.end = index + 1;
                    lastCapture.stack = -1;
                  }
                  stack--;
                } else if (parenOpen) {
                  stack++;
                  if (parenOpen.length != 1) {
                    lastCapture.stack = stack;
                    lastCapture.start = index;
                  }
                }
                return m3;
              });
              if (lastCapture.end != null && /^\)*$/.test(src.substr(lastCapture.end)))
                src = src.substring(0, lastCapture.start) + src.substr(lastCapture.end);
            }
            if (src.charAt(0) != "^")
              src = "^" + src;
            if (src.charAt(src.length - 1) != "$")
              src += "$";
            return new RegExp(src, (flag || "").replace("g", ""));
          };
          Tokenizer2.prototype.getLineTokens = function(line, startState) {
            if (startState && typeof startState != "string") {
              var stack = startState.slice(0);
              startState = stack[0];
              if (startState === "#tmp") {
                stack.shift();
                startState = stack.shift();
              }
            } else
              var stack = [];
            var currentState = (
              /**@type{string}*/
              startState || "start"
            );
            var state = this.states[currentState];
            if (!state) {
              currentState = "start";
              state = this.states[currentState];
            }
            var mapping = this.matchMappings[currentState];
            var re2 = this.regExps[currentState];
            re2.lastIndex = 0;
            var match2, tokens = [];
            var lastIndex = 0;
            var matchAttempts = 0;
            var token = { type: null, value: "" };
            while (match2 = re2.exec(line)) {
              var type = mapping.defaultToken;
              var rule = null;
              var value = match2[0];
              var index = re2.lastIndex;
              if (index - value.length > lastIndex) {
                var skipped = line.substring(lastIndex, index - value.length);
                if (token.type == type) {
                  token.value += skipped;
                } else {
                  if (token.type)
                    tokens.push(token);
                  token = { type, value: skipped };
                }
              }
              for (var i2 = 0; i2 < match2.length - 2; i2++) {
                if (match2[i2 + 1] === void 0)
                  continue;
                rule = state[mapping[i2]];
                if (rule.onMatch)
                  type = rule.onMatch(value, currentState, stack, line);
                else
                  type = rule.token;
                if (rule.next) {
                  if (typeof rule.next == "string") {
                    currentState = rule.next;
                  } else {
                    currentState = rule.next(currentState, stack);
                  }
                  state = this.states[currentState];
                  if (!state) {
                    this.reportError("state doesn't exist", currentState);
                    currentState = "start";
                    state = this.states[currentState];
                  }
                  mapping = this.matchMappings[currentState];
                  lastIndex = index;
                  re2 = this.regExps[currentState];
                  re2.lastIndex = index;
                }
                if (rule.consumeLineEnd)
                  lastIndex = index;
                break;
              }
              if (value) {
                if (typeof type === "string") {
                  if ((!rule || rule.merge !== false) && token.type === type) {
                    token.value += value;
                  } else {
                    if (token.type)
                      tokens.push(token);
                    token = { type, value };
                  }
                } else if (type) {
                  if (token.type)
                    tokens.push(token);
                  token = { type: null, value: "" };
                  for (var i2 = 0; i2 < type.length; i2++)
                    tokens.push(type[i2]);
                }
              }
              if (lastIndex == line.length)
                break;
              lastIndex = index;
              if (matchAttempts++ > MAX_TOKEN_COUNT) {
                if (matchAttempts > 2 * line.length) {
                  this.reportError("infinite loop with in ace tokenizer", {
                    startState,
                    line
                  });
                }
                while (lastIndex < line.length) {
                  if (token.type)
                    tokens.push(token);
                  token = {
                    value: line.substring(lastIndex, lastIndex += 500),
                    type: "overflow"
                  };
                }
                currentState = "start";
                stack = [];
                break;
              }
            }
            if (token.type)
              tokens.push(token);
            if (stack.length > 1) {
              if (stack[0] !== currentState)
                stack.unshift("#tmp", currentState);
            }
            return {
              tokens,
              state: stack.length ? stack : currentState
            };
          };
          return Tokenizer2;
        })()
      );
      Tokenizer.prototype.reportError = reportError;
      exports3.Tokenizer = Tokenizer;
    });
    ace.define("ace/mode/text_highlight_rules", ["require", "exports", "module", "ace/lib/deep_copy"], function(require2, exports3, module3) {
      var deepCopy = require2("../lib/deep_copy").deepCopy;
      var TextHighlightRules;
      TextHighlightRules = function() {
        this.$rules = {
          "start": [{
            token: "empty_line",
            regex: "^$"
          }, {
            defaultToken: "text"
          }]
        };
      };
      (function() {
        this.addRules = function(rules, prefix) {
          if (!prefix) {
            for (var key in rules)
              this.$rules[key] = rules[key];
            return;
          }
          for (var key in rules) {
            var state = rules[key];
            for (var i2 = 0; i2 < state.length; i2++) {
              var rule = state[i2];
              if (rule.next || rule.onMatch) {
                if (typeof rule.next == "string") {
                  if (rule.next.indexOf(prefix) !== 0)
                    rule.next = prefix + rule.next;
                }
                if (rule.nextState && rule.nextState.indexOf(prefix) !== 0)
                  rule.nextState = prefix + rule.nextState;
              }
            }
            this.$rules[prefix + key] = state;
          }
        };
        this.getRules = function() {
          return this.$rules;
        };
        this.embedRules = function(HighlightRules, prefix, escapeRules, states, append) {
          var embedRules = typeof HighlightRules == "function" ? new HighlightRules().getRules() : HighlightRules;
          if (states) {
            for (var i2 = 0; i2 < states.length; i2++)
              states[i2] = prefix + states[i2];
          } else {
            states = [];
            for (var key in embedRules)
              states.push(prefix + key);
          }
          this.addRules(embedRules, prefix);
          if (escapeRules) {
            var addRules = Array.prototype[append ? "push" : "unshift"];
            for (var i2 = 0; i2 < states.length; i2++)
              addRules.apply(this.$rules[states[i2]], deepCopy(escapeRules));
          }
          if (!this.$embeds)
            this.$embeds = [];
          this.$embeds.push(prefix);
        };
        this.getEmbeds = function() {
          return this.$embeds;
        };
        var pushState = function(currentState, stack) {
          if (currentState != "start" || stack.length)
            stack.unshift(this.nextState, currentState);
          return this.nextState;
        };
        var popState = function(currentState, stack) {
          stack.shift();
          return stack.shift() || "start";
        };
        this.normalizeRules = function() {
          var id = 0;
          var rules = this.$rules;
          function processState(key) {
            var state = rules[key];
            state["processed"] = true;
            for (var i2 = 0; i2 < state.length; i2++) {
              var rule = state[i2];
              var toInsert = null;
              if (Array.isArray(rule)) {
                toInsert = rule;
                rule = {};
              }
              if (!rule.regex && rule.start) {
                rule.regex = rule.start;
                if (!rule.next)
                  rule.next = [];
                rule.next.push({
                  defaultToken: rule.token
                }, {
                  token: rule.token + ".end",
                  regex: rule.end || rule.start,
                  next: "pop"
                });
                rule.token = rule.token + ".start";
                rule.push = true;
              }
              var next = rule.next || rule.push;
              if (next && Array.isArray(next)) {
                var stateName = rule.stateName;
                if (!stateName) {
                  stateName = rule.token;
                  if (typeof stateName != "string")
                    stateName = stateName[0] || "";
                  if (rules[stateName])
                    stateName += id++;
                }
                rules[stateName] = next;
                rule.next = stateName;
                processState(stateName);
              } else if (next == "pop") {
                rule.next = popState;
              }
              if (rule.push) {
                rule.nextState = rule.next || rule.push;
                rule.next = pushState;
                delete rule.push;
              }
              if (rule.rules) {
                for (var r in rule.rules) {
                  if (rules[r]) {
                    if (rules[r].push)
                      rules[r].push.apply(rules[r], rule.rules[r]);
                  } else {
                    rules[r] = rule.rules[r];
                  }
                }
              }
              var includeName = typeof rule == "string" ? rule : rule.include;
              if (includeName) {
                if (includeName === "$self")
                  includeName = "start";
                if (Array.isArray(includeName))
                  toInsert = includeName.map(function(x2) {
                    return rules[x2];
                  });
                else
                  toInsert = rules[includeName];
              }
              if (toInsert) {
                var args = [i2, 1].concat(toInsert);
                if (rule.noEscape)
                  args = args.filter(function(x2) {
                    return !x2.next;
                  });
                state.splice.apply(state, args);
                i2--;
              }
              if (rule.keywordMap) {
                rule.token = this.createKeywordMapper(rule.keywordMap, rule.defaultToken || "text", rule.caseInsensitive);
                delete rule.defaultToken;
              }
            }
          }
          Object.keys(rules).forEach(processState, this);
        };
        this.createKeywordMapper = function(map, defaultToken, ignoreCase, splitChar) {
          var keywords = /* @__PURE__ */ Object.create(null);
          this.$keywordList = [];
          Object.keys(map).forEach(function(className) {
            var a3 = map[className];
            var list = a3.split(splitChar || "|");
            for (var i2 = list.length; i2--; ) {
              var word = list[i2];
              this.$keywordList.push(word);
              if (ignoreCase)
                word = word.toLowerCase();
              keywords[word] = className;
            }
          }, this);
          map = null;
          return ignoreCase ? function(value) {
            return keywords[value.toLowerCase()] || defaultToken;
          } : function(value) {
            return keywords[value] || defaultToken;
          };
        };
        this.getKeywords = function() {
          return this.$keywords;
        };
      }).call(TextHighlightRules.prototype);
      exports3.TextHighlightRules = TextHighlightRules;
    });
    ace.define("ace/mode/behaviour", ["require", "exports", "module"], function(require2, exports3, module3) {
      var Behaviour;
      Behaviour = function() {
        this.$behaviours = {};
      };
      (function() {
        this.add = function(name, action, callback) {
          switch (void 0) {
            case this.$behaviours:
              this.$behaviours = {};
            case this.$behaviours[name]:
              this.$behaviours[name] = {};
          }
          this.$behaviours[name][action] = callback;
        };
        this.addBehaviours = function(behaviours) {
          for (var key in behaviours) {
            for (var action in behaviours[key]) {
              this.add(key, action, behaviours[key][action]);
            }
          }
        };
        this.remove = function(name) {
          if (this.$behaviours && this.$behaviours[name]) {
            delete this.$behaviours[name];
          }
        };
        this.inherit = function(mode, filter2) {
          if (typeof mode === "function") {
            var behaviours = new mode().getBehaviours(filter2);
          } else {
            var behaviours = mode.getBehaviours(filter2);
          }
          this.addBehaviours(behaviours);
        };
        this.getBehaviours = function(filter2) {
          if (!filter2) {
            return this.$behaviours;
          } else {
            var ret = {};
            for (var i2 = 0; i2 < filter2.length; i2++) {
              if (this.$behaviours[filter2[i2]]) {
                ret[filter2[i2]] = this.$behaviours[filter2[i2]];
              }
            }
            return ret;
          }
        };
      }).call(Behaviour.prototype);
      exports3.Behaviour = Behaviour;
    });
    ace.define("ace/token_iterator", ["require", "exports", "module", "ace/range"], function(require2, exports3, module3) {
      var Range = require2("./range").Range;
      var TokenIterator = (
        /** @class */
        (function() {
          function TokenIterator2(session, initialRow, initialColumn) {
            this.$session = session;
            this.$row = initialRow;
            this.$rowTokens = session.getTokens(initialRow);
            var token = session.getTokenAt(initialRow, initialColumn);
            this.$tokenIndex = token ? token.index : -1;
          }
          TokenIterator2.prototype.stepBackward = function() {
            this.$tokenIndex -= 1;
            while (this.$tokenIndex < 0) {
              this.$row -= 1;
              if (this.$row < 0) {
                this.$row = 0;
                return null;
              }
              this.$rowTokens = this.$session.getTokens(this.$row);
              this.$tokenIndex = this.$rowTokens.length - 1;
            }
            return this.$rowTokens[this.$tokenIndex];
          };
          TokenIterator2.prototype.stepForward = function() {
            this.$tokenIndex += 1;
            var rowCount;
            while (this.$tokenIndex >= this.$rowTokens.length) {
              this.$row += 1;
              if (!rowCount)
                rowCount = this.$session.getLength();
              if (this.$row >= rowCount) {
                this.$row = rowCount - 1;
                return null;
              }
              this.$rowTokens = this.$session.getTokens(this.$row);
              this.$tokenIndex = 0;
            }
            return this.$rowTokens[this.$tokenIndex];
          };
          TokenIterator2.prototype.getCurrentToken = function() {
            return this.$rowTokens[this.$tokenIndex];
          };
          TokenIterator2.prototype.getCurrentTokenRow = function() {
            return this.$row;
          };
          TokenIterator2.prototype.getCurrentTokenColumn = function() {
            var rowTokens = this.$rowTokens;
            var tokenIndex = this.$tokenIndex;
            var column = rowTokens[tokenIndex].start;
            if (column !== void 0)
              return column;
            column = 0;
            while (tokenIndex > 0) {
              tokenIndex -= 1;
              column += rowTokens[tokenIndex].value.length;
            }
            return column;
          };
          TokenIterator2.prototype.getCurrentTokenPosition = function() {
            return { row: this.$row, column: this.getCurrentTokenColumn() };
          };
          TokenIterator2.prototype.getCurrentTokenRange = function() {
            var token = this.$rowTokens[this.$tokenIndex];
            var column = this.getCurrentTokenColumn();
            return new Range(this.$row, column, this.$row, column + token.value.length);
          };
          return TokenIterator2;
        })()
      );
      exports3.TokenIterator = TokenIterator;
    });
    ace.define("ace/mode/behaviour/cstyle", ["require", "exports", "module", "ace/lib/oop", "ace/mode/behaviour", "ace/token_iterator", "ace/lib/lang"], function(require2, exports3, module3) {
      var oop = require2("../../lib/oop");
      var Behaviour = require2("../behaviour").Behaviour;
      var TokenIterator = require2("../../token_iterator").TokenIterator;
      var lang = require2("../../lib/lang");
      var SAFE_INSERT_IN_TOKENS = ["text", "paren.rparen", "rparen", "paren", "punctuation.operator"];
      var SAFE_INSERT_BEFORE_TOKENS = ["text", "paren.rparen", "rparen", "paren", "punctuation.operator", "comment"];
      var context;
      var contextCache = {};
      var defaultQuotes = { '"': '"', "'": "'" };
      var initContext = function(editor) {
        var id = -1;
        if (editor.multiSelect) {
          id = editor.selection.index;
          if (contextCache.rangeCount != editor.multiSelect.rangeCount)
            contextCache = { rangeCount: editor.multiSelect.rangeCount };
        }
        if (contextCache[id])
          return context = contextCache[id];
        context = contextCache[id] = {
          autoInsertedBrackets: 0,
          autoInsertedRow: -1,
          autoInsertedLineEnd: "",
          maybeInsertedBrackets: 0,
          maybeInsertedRow: -1,
          maybeInsertedLineStart: "",
          maybeInsertedLineEnd: ""
        };
      };
      var getWrapped = function(selection, selected, opening, closing2) {
        var rowDiff = selection.end.row - selection.start.row;
        return {
          text: opening + selected + closing2,
          selection: [
            0,
            selection.start.column + 1,
            rowDiff,
            selection.end.column + (rowDiff ? 0 : 1)
          ]
        };
      };
      var CstyleBehaviour;
      CstyleBehaviour = function(options) {
        options = options || {};
        this.add("braces", "insertion", function(state, action, editor, session, text) {
          var cursor = editor.getCursorPosition();
          var line = session.doc.getLine(cursor.row);
          if (text == "{") {
            initContext(editor);
            var selection = editor.getSelectionRange();
            var selected = session.doc.getTextRange(selection);
            var token = session.getTokenAt(cursor.row, cursor.column);
            if (selected !== "" && selected !== "{" && editor.getWrapBehavioursEnabled()) {
              return getWrapped(selection, selected, "{", "}");
            } else if (token && /(?:string)\.quasi|\.xml/.test(token.type)) {
              var excludeTokens = [
                /tag\-(?:open|name)/,
                /attribute\-name/
              ];
              if (excludeTokens.some(function(el) {
                return el.test(token.type);
              }) || /(string)\.quasi/.test(token.type) && token.value[cursor.column - token.start - 1] !== "$")
                return;
              CstyleBehaviour.recordAutoInsert(editor, session, "}");
              return {
                text: "{}",
                selection: [1, 1]
              };
            } else if (CstyleBehaviour.isSaneInsertion(editor, session)) {
              if (/[\]\}\)]/.test(line[cursor.column]) || editor.inMultiSelectMode || options.braces) {
                CstyleBehaviour.recordAutoInsert(editor, session, "}");
                return {
                  text: "{}",
                  selection: [1, 1]
                };
              } else {
                CstyleBehaviour.recordMaybeInsert(editor, session, "{");
                return {
                  text: "{",
                  selection: [1, 1]
                };
              }
            }
          } else if (text == "}") {
            initContext(editor);
            var rightChar = line.substring(cursor.column, cursor.column + 1);
            if (rightChar == "}") {
              var matching = session.$findOpeningBracket("}", { column: cursor.column + 1, row: cursor.row });
              if (matching !== null && CstyleBehaviour.isAutoInsertedClosing(cursor, line, text)) {
                CstyleBehaviour.popAutoInsertedClosing();
                return {
                  text: "",
                  selection: [1, 1]
                };
              }
            }
          } else if (text == "\n" || text == "\r\n") {
            initContext(editor);
            var closing2 = "";
            if (CstyleBehaviour.isMaybeInsertedClosing(cursor, line)) {
              closing2 = lang.stringRepeat("}", context.maybeInsertedBrackets);
              CstyleBehaviour.clearMaybeInsertedClosing();
            }
            var rightChar = line.substring(cursor.column, cursor.column + 1);
            if (rightChar === "}") {
              var openBracePos = session.findMatchingBracket({ row: cursor.row, column: cursor.column + 1 }, "}");
              if (!openBracePos)
                return null;
              var next_indent = this.$getIndent(session.getLine(openBracePos.row));
            } else if (closing2) {
              var next_indent = this.$getIndent(line);
            } else {
              CstyleBehaviour.clearMaybeInsertedClosing();
              return;
            }
            var indent = next_indent + session.getTabString();
            return {
              text: "\n" + indent + "\n" + next_indent + closing2,
              selection: [1, indent.length, 1, indent.length]
            };
          } else {
            CstyleBehaviour.clearMaybeInsertedClosing();
          }
        });
        this.add("braces", "deletion", function(state, action, editor, session, range) {
          var selected = session.doc.getTextRange(range);
          if (!range.isMultiLine() && selected == "{") {
            initContext(editor);
            var line = session.doc.getLine(range.start.row);
            var rightChar = line.substring(range.end.column, range.end.column + 1);
            if (rightChar == "}") {
              range.end.column++;
              return range;
            } else {
              context.maybeInsertedBrackets--;
            }
          }
        });
        this.add("parens", "insertion", function(state, action, editor, session, text) {
          if (text == "(") {
            initContext(editor);
            var selection = editor.getSelectionRange();
            var selected = session.doc.getTextRange(selection);
            if (selected !== "" && editor.getWrapBehavioursEnabled()) {
              return getWrapped(selection, selected, "(", ")");
            } else if (CstyleBehaviour.isSaneInsertion(editor, session)) {
              CstyleBehaviour.recordAutoInsert(editor, session, ")");
              return {
                text: "()",
                selection: [1, 1]
              };
            }
          } else if (text == ")") {
            initContext(editor);
            var cursor = editor.getCursorPosition();
            var line = session.doc.getLine(cursor.row);
            var rightChar = line.substring(cursor.column, cursor.column + 1);
            if (rightChar == ")") {
              var matching = session.$findOpeningBracket(")", { column: cursor.column + 1, row: cursor.row });
              if (matching !== null && CstyleBehaviour.isAutoInsertedClosing(cursor, line, text)) {
                CstyleBehaviour.popAutoInsertedClosing();
                return {
                  text: "",
                  selection: [1, 1]
                };
              }
            }
          }
        });
        this.add("parens", "deletion", function(state, action, editor, session, range) {
          var selected = session.doc.getTextRange(range);
          if (!range.isMultiLine() && selected == "(") {
            initContext(editor);
            var line = session.doc.getLine(range.start.row);
            var rightChar = line.substring(range.start.column + 1, range.start.column + 2);
            if (rightChar == ")") {
              range.end.column++;
              return range;
            }
          }
        });
        this.add("brackets", "insertion", function(state, action, editor, session, text) {
          if (text == "[") {
            initContext(editor);
            var selection = editor.getSelectionRange();
            var selected = session.doc.getTextRange(selection);
            if (selected !== "" && editor.getWrapBehavioursEnabled()) {
              return getWrapped(selection, selected, "[", "]");
            } else if (CstyleBehaviour.isSaneInsertion(editor, session)) {
              CstyleBehaviour.recordAutoInsert(editor, session, "]");
              return {
                text: "[]",
                selection: [1, 1]
              };
            }
          } else if (text == "]") {
            initContext(editor);
            var cursor = editor.getCursorPosition();
            var line = session.doc.getLine(cursor.row);
            var rightChar = line.substring(cursor.column, cursor.column + 1);
            if (rightChar == "]") {
              var matching = session.$findOpeningBracket("]", { column: cursor.column + 1, row: cursor.row });
              if (matching !== null && CstyleBehaviour.isAutoInsertedClosing(cursor, line, text)) {
                CstyleBehaviour.popAutoInsertedClosing();
                return {
                  text: "",
                  selection: [1, 1]
                };
              }
            }
          }
        });
        this.add("brackets", "deletion", function(state, action, editor, session, range) {
          var selected = session.doc.getTextRange(range);
          if (!range.isMultiLine() && selected == "[") {
            initContext(editor);
            var line = session.doc.getLine(range.start.row);
            var rightChar = line.substring(range.start.column + 1, range.start.column + 2);
            if (rightChar == "]") {
              range.end.column++;
              return range;
            }
          }
        });
        this.add("string_dquotes", "insertion", function(state, action, editor, session, text) {
          var quotes = session.$mode.$quotes || defaultQuotes;
          if (text.length == 1 && quotes[text]) {
            if (this.lineCommentStart && this.lineCommentStart.indexOf(text) != -1)
              return;
            initContext(editor);
            var quote = text;
            var selection = editor.getSelectionRange();
            var selected = session.doc.getTextRange(selection);
            if (selected !== "" && (selected.length != 1 || !quotes[selected]) && editor.getWrapBehavioursEnabled()) {
              return getWrapped(selection, selected, quote, quote);
            } else if (!selected) {
              var cursor = editor.getCursorPosition();
              var line = session.doc.getLine(cursor.row);
              var leftChar = line.substring(cursor.column - 1, cursor.column);
              var rightChar = line.substring(cursor.column, cursor.column + 1);
              var token = session.getTokenAt(cursor.row, cursor.column);
              var rightToken = session.getTokenAt(cursor.row, cursor.column + 1);
              if (leftChar == "\\" && token && /escape/.test(token.type))
                return null;
              var stringBefore = token && /string|escape/.test(token.type);
              var stringAfter = !rightToken || /string|escape/.test(rightToken.type);
              var pair;
              if (rightChar == quote) {
                pair = stringBefore !== stringAfter;
                if (pair && /string\.end/.test(rightToken.type))
                  pair = false;
              } else {
                if (stringBefore && !stringAfter)
                  return null;
                if (stringBefore && stringAfter)
                  return null;
                var wordRe = session.$mode.tokenRe;
                wordRe.lastIndex = 0;
                var isWordBefore = wordRe.test(leftChar);
                wordRe.lastIndex = 0;
                var isWordAfter = wordRe.test(rightChar);
                var pairQuotesAfter = session.$mode.$pairQuotesAfter;
                var shouldPairQuotes = pairQuotesAfter && pairQuotesAfter[quote] && pairQuotesAfter[quote].test(leftChar);
                if (!shouldPairQuotes && isWordBefore || isWordAfter)
                  return null;
                if (rightChar && !/[\s;,.})\]\\]/.test(rightChar))
                  return null;
                var charBefore = line[cursor.column - 2];
                if (leftChar == quote && (charBefore == quote || wordRe.test(charBefore)))
                  return null;
                pair = true;
              }
              return {
                text: pair ? quote + quote : "",
                selection: [1, 1]
              };
            }
          }
        });
        this.add("string_dquotes", "deletion", function(state, action, editor, session, range) {
          var quotes = session.$mode.$quotes || defaultQuotes;
          var selected = session.doc.getTextRange(range);
          if (!range.isMultiLine() && quotes.hasOwnProperty(selected)) {
            initContext(editor);
            var line = session.doc.getLine(range.start.row);
            var rightChar = line.substring(range.start.column + 1, range.start.column + 2);
            if (rightChar == selected) {
              range.end.column++;
              return range;
            }
          }
        });
        if (options.closeDocComment !== false) {
          this.add("doc comment end", "insertion", function(state, action, editor, session, text) {
            if (state === "doc-start" && (text === "\n" || text === "\r\n") && editor.selection.isEmpty()) {
              var cursor = editor.getCursorPosition();
              if (cursor.column === 0) {
                return;
              }
              var line = session.doc.getLine(cursor.row);
              var nextLine = session.doc.getLine(cursor.row + 1);
              var tokens = session.getTokens(cursor.row);
              var index = 0;
              for (var i2 = 0; i2 < tokens.length; i2++) {
                index += tokens[i2].value.length;
                var currentToken = tokens[i2];
                if (index >= cursor.column) {
                  if (index === cursor.column) {
                    if (!/\.doc/.test(currentToken.type)) {
                      return;
                    }
                    if (/\*\//.test(currentToken.value)) {
                      var nextToken = tokens[i2 + 1];
                      if (!nextToken || !/\.doc/.test(nextToken.type)) {
                        return;
                      }
                    }
                  }
                  var cursorPosInToken = cursor.column - (index - currentToken.value.length);
                  var closeDocPos = currentToken.value.indexOf("*/");
                  var openDocPos = currentToken.value.indexOf("/**", closeDocPos > -1 ? closeDocPos + 2 : 0);
                  if (openDocPos !== -1 && cursorPosInToken > openDocPos && cursorPosInToken < openDocPos + 3) {
                    return;
                  }
                  if (closeDocPos !== -1 && openDocPos !== -1 && cursorPosInToken >= closeDocPos && cursorPosInToken <= openDocPos || !/\.doc/.test(currentToken.type)) {
                    return;
                  }
                  break;
                }
              }
              var indent = this.$getIndent(line);
              if (/\s*\*/.test(nextLine)) {
                if (/^\s*\*/.test(line)) {
                  return {
                    text: text + indent + "* ",
                    selection: [1, 2 + indent.length, 1, 2 + indent.length]
                  };
                } else {
                  return {
                    text: text + indent + " * ",
                    selection: [1, 3 + indent.length, 1, 3 + indent.length]
                  };
                }
              }
              if (/\/\*\*/.test(line.substring(0, cursor.column))) {
                return {
                  text: text + indent + " * " + text + " " + indent + "*/",
                  selection: [1, 4 + indent.length, 1, 4 + indent.length]
                };
              }
            }
          });
        }
      };
      CstyleBehaviour.isSaneInsertion = function(editor, session) {
        var cursor = editor.getCursorPosition();
        var iterator = new TokenIterator(session, cursor.row, cursor.column);
        if (!this.$matchTokenType(iterator.getCurrentToken() || "text", SAFE_INSERT_IN_TOKENS)) {
          if (/[)}\]]/.test(editor.session.getLine(cursor.row)[cursor.column]))
            return true;
          var iterator2 = new TokenIterator(session, cursor.row, cursor.column + 1);
          if (!this.$matchTokenType(iterator2.getCurrentToken() || "text", SAFE_INSERT_IN_TOKENS))
            return false;
        }
        iterator.stepForward();
        return iterator.getCurrentTokenRow() !== cursor.row || this.$matchTokenType(iterator.getCurrentToken() || "text", SAFE_INSERT_BEFORE_TOKENS);
      };
      CstyleBehaviour["$matchTokenType"] = function(token, types) {
        return types.indexOf(token.type || token) > -1;
      };
      CstyleBehaviour["recordAutoInsert"] = function(editor, session, bracket) {
        var cursor = editor.getCursorPosition();
        var line = session.doc.getLine(cursor.row);
        if (!this["isAutoInsertedClosing"](cursor, line, context.autoInsertedLineEnd[0]))
          context.autoInsertedBrackets = 0;
        context.autoInsertedRow = cursor.row;
        context.autoInsertedLineEnd = bracket + line.substr(cursor.column);
        context.autoInsertedBrackets++;
      };
      CstyleBehaviour["recordMaybeInsert"] = function(editor, session, bracket) {
        var cursor = editor.getCursorPosition();
        var line = session.doc.getLine(cursor.row);
        if (!this["isMaybeInsertedClosing"](cursor, line))
          context.maybeInsertedBrackets = 0;
        context.maybeInsertedRow = cursor.row;
        context.maybeInsertedLineStart = line.substr(0, cursor.column) + bracket;
        context.maybeInsertedLineEnd = line.substr(cursor.column);
        context.maybeInsertedBrackets++;
      };
      CstyleBehaviour["isAutoInsertedClosing"] = function(cursor, line, bracket) {
        return context.autoInsertedBrackets > 0 && cursor.row === context.autoInsertedRow && bracket === context.autoInsertedLineEnd[0] && line.substr(cursor.column) === context.autoInsertedLineEnd;
      };
      CstyleBehaviour["isMaybeInsertedClosing"] = function(cursor, line) {
        return context.maybeInsertedBrackets > 0 && cursor.row === context.maybeInsertedRow && line.substr(cursor.column) === context.maybeInsertedLineEnd && line.substr(0, cursor.column) == context.maybeInsertedLineStart;
      };
      CstyleBehaviour["popAutoInsertedClosing"] = function() {
        context.autoInsertedLineEnd = context.autoInsertedLineEnd.substr(1);
        context.autoInsertedBrackets--;
      };
      CstyleBehaviour["clearMaybeInsertedClosing"] = function() {
        if (context) {
          context.maybeInsertedBrackets = 0;
          context.maybeInsertedRow = -1;
        }
      };
      oop.inherits(CstyleBehaviour, Behaviour);
      exports3.CstyleBehaviour = CstyleBehaviour;
    });
    ace.define("ace/unicode", ["require", "exports", "module"], function(require2, exports3, module3) {
      var wordChars = [48, 9, 8, 25, 5, 0, 2, 25, 48, 0, 11, 0, 5, 0, 6, 22, 2, 30, 2, 457, 5, 11, 15, 4, 8, 0, 2, 0, 18, 116, 2, 1, 3, 3, 9, 0, 2, 2, 2, 0, 2, 19, 2, 82, 2, 138, 2, 4, 3, 155, 12, 37, 3, 0, 8, 38, 10, 44, 2, 0, 2, 1, 2, 1, 2, 0, 9, 26, 6, 2, 30, 10, 7, 61, 2, 9, 5, 101, 2, 7, 3, 9, 2, 18, 3, 0, 17, 58, 3, 100, 15, 53, 5, 0, 6, 45, 211, 57, 3, 18, 2, 5, 3, 11, 3, 9, 2, 1, 7, 6, 2, 2, 2, 7, 3, 1, 3, 21, 2, 6, 2, 0, 4, 3, 3, 8, 3, 1, 3, 3, 9, 0, 5, 1, 2, 4, 3, 11, 16, 2, 2, 5, 5, 1, 3, 21, 2, 6, 2, 1, 2, 1, 2, 1, 3, 0, 2, 4, 5, 1, 3, 2, 4, 0, 8, 3, 2, 0, 8, 15, 12, 2, 2, 8, 2, 2, 2, 21, 2, 6, 2, 1, 2, 4, 3, 9, 2, 2, 2, 2, 3, 0, 16, 3, 3, 9, 18, 2, 2, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 3, 8, 3, 1, 3, 2, 9, 1, 5, 1, 2, 4, 3, 9, 2, 0, 17, 1, 2, 5, 4, 2, 2, 3, 4, 1, 2, 0, 2, 1, 4, 1, 4, 2, 4, 11, 5, 4, 4, 2, 2, 3, 3, 0, 7, 0, 15, 9, 18, 2, 2, 7, 2, 2, 2, 22, 2, 9, 2, 4, 4, 7, 2, 2, 2, 3, 8, 1, 2, 1, 7, 3, 3, 9, 19, 1, 2, 7, 2, 2, 2, 22, 2, 9, 2, 4, 3, 8, 2, 2, 2, 3, 8, 1, 8, 0, 2, 3, 3, 9, 19, 1, 2, 7, 2, 2, 2, 22, 2, 15, 4, 7, 2, 2, 2, 3, 10, 0, 9, 3, 3, 9, 11, 5, 3, 1, 2, 17, 4, 23, 2, 8, 2, 0, 3, 6, 4, 0, 5, 5, 2, 0, 2, 7, 19, 1, 14, 57, 6, 14, 2, 9, 40, 1, 2, 0, 3, 1, 2, 0, 3, 0, 7, 3, 2, 6, 2, 2, 2, 0, 2, 0, 3, 1, 2, 12, 2, 2, 3, 4, 2, 0, 2, 5, 3, 9, 3, 1, 35, 0, 24, 1, 7, 9, 12, 0, 2, 0, 2, 0, 5, 9, 2, 35, 5, 19, 2, 5, 5, 7, 2, 35, 10, 0, 58, 73, 7, 77, 3, 37, 11, 42, 2, 0, 4, 328, 2, 3, 3, 6, 2, 0, 2, 3, 3, 40, 2, 3, 3, 32, 2, 3, 3, 6, 2, 0, 2, 3, 3, 14, 2, 56, 2, 3, 3, 66, 5, 0, 33, 15, 17, 84, 13, 619, 3, 16, 2, 25, 6, 74, 22, 12, 2, 6, 12, 20, 12, 19, 13, 12, 2, 2, 2, 1, 13, 51, 3, 29, 4, 0, 5, 1, 3, 9, 34, 2, 3, 9, 7, 87, 9, 42, 6, 69, 11, 28, 4, 11, 5, 11, 11, 39, 3, 4, 12, 43, 5, 25, 7, 10, 38, 27, 5, 62, 2, 28, 3, 10, 7, 9, 14, 0, 89, 75, 5, 9, 18, 8, 13, 42, 4, 11, 71, 55, 9, 9, 4, 48, 83, 2, 2, 30, 14, 230, 23, 280, 3, 5, 3, 37, 3, 5, 3, 7, 2, 0, 2, 0, 2, 0, 2, 30, 3, 52, 2, 6, 2, 0, 4, 2, 2, 6, 4, 3, 3, 5, 5, 12, 6, 2, 2, 6, 67, 1, 20, 0, 29, 0, 14, 0, 17, 4, 60, 12, 5, 0, 4, 11, 18, 0, 5, 0, 3, 9, 2, 0, 4, 4, 7, 0, 2, 0, 2, 0, 2, 3, 2, 10, 3, 3, 6, 4, 5, 0, 53, 1, 2684, 46, 2, 46, 2, 132, 7, 6, 15, 37, 11, 53, 10, 0, 17, 22, 10, 6, 2, 6, 2, 6, 2, 6, 2, 6, 2, 6, 2, 6, 2, 6, 2, 31, 48, 0, 470, 1, 36, 5, 2, 4, 6, 1, 5, 85, 3, 1, 3, 2, 2, 89, 2, 3, 6, 40, 4, 93, 18, 23, 57, 15, 513, 6581, 75, 20939, 53, 1164, 68, 45, 3, 268, 4, 27, 21, 31, 3, 13, 13, 1, 2, 24, 9, 69, 11, 1, 38, 8, 3, 102, 3, 1, 111, 44, 25, 51, 13, 68, 12, 9, 7, 23, 4, 0, 5, 45, 3, 35, 13, 28, 4, 64, 15, 10, 39, 54, 10, 13, 3, 9, 7, 22, 4, 1, 5, 66, 25, 2, 227, 42, 2, 1, 3, 9, 7, 11171, 13, 22, 5, 48, 8453, 301, 3, 61, 3, 105, 39, 6, 13, 4, 6, 11, 2, 12, 2, 4, 2, 0, 2, 1, 2, 1, 2, 107, 34, 362, 19, 63, 3, 53, 41, 11, 5, 15, 17, 6, 13, 1, 25, 2, 33, 4, 2, 134, 20, 9, 8, 25, 5, 0, 2, 25, 12, 88, 4, 5, 3, 5, 3, 5, 3, 2];
      var code = 0;
      var str = [];
      for (var i2 = 0; i2 < wordChars.length; i2 += 2) {
        str.push(code += wordChars[i2]);
        if (wordChars[i2 + 1])
          str.push(45, code += wordChars[i2 + 1]);
      }
      exports3.wordChars = String.fromCharCode.apply(null, str);
    });
    ace.define("ace/mode/text", ["require", "exports", "module", "ace/config", "ace/tokenizer", "ace/mode/text_highlight_rules", "ace/mode/behaviour/cstyle", "ace/unicode", "ace/lib/lang", "ace/token_iterator", "ace/range"], function(require2, exports3, module3) {
      var config = require2("../config");
      var Tokenizer = require2("../tokenizer").Tokenizer;
      var TextHighlightRules = require2("./text_highlight_rules").TextHighlightRules;
      var CstyleBehaviour = require2("./behaviour/cstyle").CstyleBehaviour;
      var unicode = require2("../unicode");
      var lang = require2("../lib/lang");
      var TokenIterator = require2("../token_iterator").TokenIterator;
      var Range = require2("../range").Range;
      var Mode;
      Mode = function() {
        this.HighlightRules = TextHighlightRules;
      };
      (function() {
        this.$defaultBehaviour = new CstyleBehaviour();
        this.tokenRe = new RegExp("^[" + unicode.wordChars + "\\$_]+", "g");
        this.nonTokenRe = new RegExp("^(?:[^" + unicode.wordChars + "\\$_]|\\s])+", "g");
        this.getTokenizer = function() {
          if (!this.$tokenizer) {
            this.$highlightRules = this.$highlightRules || new this.HighlightRules(this.$highlightRuleConfig);
            this.$tokenizer = new Tokenizer(this.$highlightRules.getRules());
          }
          return this.$tokenizer;
        };
        this.lineCommentStart = "";
        this.blockComment = "";
        this.toggleCommentLines = function(state, session, startRow, endRow) {
          var doc = session.doc;
          var ignoreBlankLines = true;
          var shouldRemove = true;
          var minIndent = Infinity;
          var tabSize = session.getTabSize();
          var insertAtTabStop = false;
          if (!this.lineCommentStart) {
            if (!this.blockComment)
              return false;
            var lineCommentStart = this.blockComment.start;
            var lineCommentEnd = this.blockComment.end;
            var regexpStart = new RegExp("^(\\s*)(?:" + lang.escapeRegExp(lineCommentStart) + ")");
            var regexpEnd = new RegExp("(?:" + lang.escapeRegExp(lineCommentEnd) + ")\\s*$");
            var comment = function(line, i2) {
              if (testRemove(line, i2))
                return;
              if (!ignoreBlankLines || /\S/.test(line)) {
                doc.insertInLine({ row: i2, column: line.length }, lineCommentEnd);
                doc.insertInLine({ row: i2, column: minIndent }, lineCommentStart);
              }
            };
            var uncomment = function(line, i2) {
              var m3;
              if (m3 = line.match(regexpEnd))
                doc.removeInLine(i2, line.length - m3[0].length, line.length);
              if (m3 = line.match(regexpStart))
                doc.removeInLine(i2, m3[1].length, m3[0].length);
            };
            var testRemove = function(line, row) {
              if (regexpStart.test(line))
                return true;
              var tokens = session.getTokens(row);
              for (var i2 = 0; i2 < tokens.length; i2++) {
                if (tokens[i2].type === "comment")
                  return true;
              }
            };
          } else {
            if (Array.isArray(this.lineCommentStart)) {
              var regexpStart = this.lineCommentStart.map(lang.escapeRegExp).join("|");
              var lineCommentStart = this.lineCommentStart[0];
            } else {
              var regexpStart = lang.escapeRegExp(this.lineCommentStart);
              var lineCommentStart = this.lineCommentStart;
            }
            regexpStart = new RegExp("^(\\s*)(?:" + regexpStart + ") ?");
            insertAtTabStop = session.getUseSoftTabs();
            var uncomment = function(line, i2) {
              var m3 = line.match(regexpStart);
              if (!m3)
                return;
              var start = m3[1].length, end = m3[0].length;
              if (!shouldInsertSpace(line, start, end) && m3[0][end - 1] == " ")
                end--;
              doc.removeInLine(i2, start, end);
            };
            var commentWithSpace = lineCommentStart + " ";
            var comment = function(line, i2) {
              if (!ignoreBlankLines || /\S/.test(line)) {
                if (shouldInsertSpace(line, minIndent, minIndent))
                  doc.insertInLine({ row: i2, column: minIndent }, commentWithSpace);
                else
                  doc.insertInLine({ row: i2, column: minIndent }, lineCommentStart);
              }
            };
            var testRemove = function(line, i2) {
              return regexpStart.test(line);
            };
            var shouldInsertSpace = function(line, before, after) {
              var spaces = 0;
              while (before-- && line.charAt(before) == " ")
                spaces++;
              if (spaces % tabSize != 0)
                return false;
              var spaces = 0;
              while (line.charAt(after++) == " ")
                spaces++;
              if (tabSize > 2)
                return spaces % tabSize != tabSize - 1;
              else
                return spaces % tabSize == 0;
            };
          }
          function iter(fun) {
            for (var i2 = startRow; i2 <= endRow; i2++)
              fun(doc.getLine(i2), i2);
          }
          var minEmptyLength = Infinity;
          iter(function(line, i2) {
            var indent = line.search(/\S/);
            if (indent !== -1) {
              if (indent < minIndent)
                minIndent = indent;
              if (shouldRemove && !testRemove(line, i2))
                shouldRemove = false;
            } else if (minEmptyLength > line.length) {
              minEmptyLength = line.length;
            }
          });
          if (minIndent == Infinity) {
            minIndent = minEmptyLength;
            ignoreBlankLines = false;
            shouldRemove = false;
          }
          if (insertAtTabStop && minIndent % tabSize != 0)
            minIndent = Math.floor(minIndent / tabSize) * tabSize;
          iter(shouldRemove ? uncomment : comment);
        };
        this.toggleBlockComment = function(state, session, range, cursor) {
          var comment = this.blockComment;
          if (!comment)
            return;
          if (!comment.start && comment[0])
            comment = comment[0];
          var iterator = new TokenIterator(session, cursor.row, cursor.column);
          var token = iterator.getCurrentToken();
          session.selection;
          var initialRange = session.selection.toOrientedRange();
          var startRow, colDiff;
          if (token && /comment/.test(token.type)) {
            var startRange, endRange;
            while (token && /comment/.test(token.type)) {
              var i2 = token.value.indexOf(comment.start);
              if (i2 != -1) {
                var row = iterator.getCurrentTokenRow();
                var column = iterator.getCurrentTokenColumn() + i2;
                startRange = new Range(row, column, row, column + comment.start.length);
                break;
              }
              token = iterator.stepBackward();
            }
            var iterator = new TokenIterator(session, cursor.row, cursor.column);
            var token = iterator.getCurrentToken();
            while (token && /comment/.test(token.type)) {
              var i2 = token.value.indexOf(comment.end);
              if (i2 != -1) {
                var row = iterator.getCurrentTokenRow();
                var column = iterator.getCurrentTokenColumn() + i2;
                endRange = new Range(row, column, row, column + comment.end.length);
                break;
              }
              token = iterator.stepForward();
            }
            if (endRange)
              session.remove(endRange);
            if (startRange) {
              session.remove(startRange);
              startRow = startRange.start.row;
              colDiff = -comment.start.length;
            }
          } else {
            colDiff = comment.start.length;
            startRow = range.start.row;
            session.insert(range.end, comment.end);
            session.insert(range.start, comment.start);
          }
          if (initialRange.start.row == startRow)
            initialRange.start.column += colDiff;
          if (initialRange.end.row == startRow)
            initialRange.end.column += colDiff;
          session.selection.fromOrientedRange(initialRange);
        };
        this.getNextLineIndent = function(state, line, tab) {
          return this.$getIndent(line);
        };
        this.checkOutdent = function(state, line, input) {
          return false;
        };
        this.autoOutdent = function(state, doc, row) {
        };
        this.$getIndent = function(line) {
          return line.match(/^\s*/)[0];
        };
        this.createWorker = function(session) {
          return null;
        };
        this.createModeDelegates = function(mapping) {
          this.$embeds = [];
          this.$modes = {};
          for (var i2 in mapping) {
            if (mapping[i2]) {
              var Mode2 = mapping[i2];
              var id = Mode2.prototype.$id;
              var mode = config.$modes[id];
              if (!mode)
                config.$modes[id] = mode = new Mode2();
              if (!config.$modes[i2])
                config.$modes[i2] = mode;
              this.$embeds.push(i2);
              this.$modes[i2] = mode;
            }
          }
          var delegations = [
            "toggleBlockComment",
            "toggleCommentLines",
            "getNextLineIndent",
            "checkOutdent",
            "autoOutdent",
            "transformAction",
            "getCompletions"
          ];
          var _loop_1 = function(i3) {
            (function(scope) {
              var functionName = delegations[i3];
              var defaultHandler = scope[functionName];
              scope[delegations[i3]] = function() {
                return this.$delegator(functionName, arguments, defaultHandler);
              };
            })(this_1);
          };
          var this_1 = this;
          for (var i2 = 0; i2 < delegations.length; i2++) {
            _loop_1(i2);
          }
        };
        this.$delegator = function(method, args, defaultHandler) {
          var state = args[0] || "start";
          if (typeof state != "string") {
            if (Array.isArray(state[2])) {
              var language = state[2][state[2].length - 1];
              var mode = this.$modes[language];
              if (mode)
                return mode[method].apply(mode, [state[1]].concat([].slice.call(args, 1)));
            }
            state = state[0] || "start";
          }
          for (var i2 = 0; i2 < this.$embeds.length; i2++) {
            if (!this.$modes[this.$embeds[i2]])
              continue;
            var split2 = state.split(this.$embeds[i2]);
            if (!split2[0] && split2[1]) {
              args[0] = split2[1];
              var mode = this.$modes[this.$embeds[i2]];
              return mode[method].apply(mode, args);
            }
          }
          var ret = defaultHandler.apply(this, args);
          return defaultHandler ? ret : void 0;
        };
        this.transformAction = function(state, action, editor, session, param) {
          if (this.$behaviour) {
            var behaviours = this.$behaviour.getBehaviours();
            for (var key in behaviours) {
              if (behaviours[key][action]) {
                var ret = behaviours[key][action].apply(this, arguments);
                if (ret) {
                  return ret;
                }
              }
            }
          }
        };
        this.getKeywords = function(append) {
          if (!this.completionKeywords) {
            var rules = this.$tokenizer["rules"];
            var completionKeywords = [];
            for (var rule in rules) {
              var ruleItr = rules[rule];
              for (var r = 0, l = ruleItr.length; r < l; r++) {
                if (typeof ruleItr[r].token === "string") {
                  if (/keyword|support|storage/.test(ruleItr[r].token))
                    completionKeywords.push(ruleItr[r].regex);
                } else if (typeof ruleItr[r].token === "object") {
                  for (var a3 = 0, aLength = ruleItr[r].token.length; a3 < aLength; a3++) {
                    if (/keyword|support|storage/.test(ruleItr[r].token[a3])) {
                      var rule = ruleItr[r].regex.match(/\(.+?\)/g)[a3];
                      completionKeywords.push(rule.substr(1, rule.length - 2));
                    }
                  }
                }
              }
            }
            this.completionKeywords = completionKeywords;
          }
          if (!append)
            return this.$keywordList;
          return completionKeywords.concat(this.$keywordList || []);
        };
        this.$createKeywordList = function() {
          if (!this.$highlightRules)
            this.getTokenizer();
          return this.$keywordList = this.$highlightRules.$keywordList || [];
        };
        this.getCompletions = function(state, session, pos, prefix) {
          var keywords = this.$keywordList || this.$createKeywordList();
          return keywords.map(function(word) {
            return {
              name: word,
              value: word,
              score: 0,
              meta: "keyword"
            };
          });
        };
        this.$id = "ace/mode/text";
      }).call(Mode.prototype);
      exports3.Mode = Mode;
    });
    ace.define("ace/line_widgets", ["require", "exports", "module", "ace/lib/dom"], function(require2, exports3, module3) {
      var dom = require2("./lib/dom");
      var LineWidgets = (
        /** @class */
        (function() {
          function LineWidgets2(session) {
            this.session = session;
            this.session.widgetManager = this;
            this.session.getRowLength = this.getRowLength;
            this.session.$getWidgetScreenLength = this.$getWidgetScreenLength;
            this.updateOnChange = this.updateOnChange.bind(this);
            this.renderWidgets = this.renderWidgets.bind(this);
            this.measureWidgets = this.measureWidgets.bind(this);
            this.session._changedWidgets = [];
            this.$onChangeEditor = this.$onChangeEditor.bind(this);
            this.session.on("change", this.updateOnChange);
            this.session.on("changeFold", this.updateOnFold);
            this.session.on("changeEditor", this.$onChangeEditor);
          }
          LineWidgets2.prototype.getRowLength = function(row) {
            var h3;
            if (this.lineWidgets)
              h3 = this.lineWidgets[row] && this.lineWidgets[row].rowCount || 0;
            else
              h3 = 0;
            if (!this["$useWrapMode"] || !this["$wrapData"][row]) {
              return 1 + h3;
            } else {
              return this["$wrapData"][row].length + 1 + h3;
            }
          };
          LineWidgets2.prototype.$getWidgetScreenLength = function() {
            var screenRows = 0;
            this.lineWidgets.forEach(function(w2) {
              if (w2 && w2.rowCount && !w2.hidden)
                screenRows += w2.rowCount;
            });
            return screenRows;
          };
          LineWidgets2.prototype.$onChangeEditor = function(e2) {
            this.attach(e2.editor);
          };
          LineWidgets2.prototype.attach = function(editor) {
            if (editor && editor.widgetManager && editor.widgetManager != this)
              editor.widgetManager.detach();
            if (this.editor == editor)
              return;
            this.detach();
            this.editor = editor;
            if (editor) {
              editor.widgetManager = this;
              editor.renderer.on("beforeRender", this.measureWidgets);
              editor.renderer.on("afterRender", this.renderWidgets);
            }
          };
          LineWidgets2.prototype.detach = function(e2) {
            var editor = this.editor;
            if (!editor)
              return;
            this.editor = null;
            editor.widgetManager = null;
            editor.renderer.off("beforeRender", this.measureWidgets);
            editor.renderer.off("afterRender", this.renderWidgets);
            var lineWidgets = this.session.lineWidgets;
            lineWidgets && lineWidgets.forEach(function(w2) {
              if (w2 && w2.el && w2.el.parentNode) {
                w2._inDocument = false;
                w2.el.parentNode.removeChild(w2.el);
              }
            });
          };
          LineWidgets2.prototype.updateOnFold = function(e2, session) {
            var lineWidgets = session.lineWidgets;
            if (!lineWidgets || !e2.action)
              return;
            var fold = e2.data;
            var start = fold.start.row;
            var end = fold.end.row;
            var hide = e2.action == "add";
            for (var i2 = start + 1; i2 < end; i2++) {
              if (lineWidgets[i2])
                lineWidgets[i2].hidden = hide;
            }
            if (lineWidgets[end]) {
              if (hide) {
                if (!lineWidgets[start])
                  lineWidgets[start] = lineWidgets[end];
                else
                  lineWidgets[end].hidden = hide;
              } else {
                if (lineWidgets[start] == lineWidgets[end])
                  lineWidgets[start] = void 0;
                lineWidgets[end].hidden = hide;
              }
            }
          };
          LineWidgets2.prototype.updateOnChange = function(delta) {
            var lineWidgets = this.session.lineWidgets;
            if (!lineWidgets)
              return;
            var startRow = delta.start.row;
            var len = delta.end.row - startRow;
            if (len === 0) ;
            else if (delta.action == "remove") {
              var removed = lineWidgets.splice(startRow + 1, len);
              if (!lineWidgets[startRow] && removed[removed.length - 1]) {
                lineWidgets[startRow] = removed.pop();
              }
              removed.forEach(function(w2) {
                w2 && this.removeLineWidget(w2);
              }, this);
              this.$updateRows();
            } else {
              var args = new Array(len);
              if (lineWidgets[startRow] && lineWidgets[startRow].column != null) {
                if (delta.start.column > lineWidgets[startRow].column)
                  startRow++;
              }
              args.unshift(startRow, 0);
              lineWidgets.splice.apply(lineWidgets, args);
              this.$updateRows();
            }
          };
          LineWidgets2.prototype.$updateRows = function() {
            var lineWidgets = this.session.lineWidgets;
            if (!lineWidgets)
              return;
            var noWidgets = true;
            lineWidgets.forEach(function(w2, i2) {
              if (w2) {
                noWidgets = false;
                w2.row = i2;
                while (w2.$oldWidget) {
                  w2.$oldWidget.row = i2;
                  w2 = w2.$oldWidget;
                }
              }
            });
            if (noWidgets)
              this.session.lineWidgets = null;
          };
          LineWidgets2.prototype.$registerLineWidget = function(w2) {
            if (!this.session.lineWidgets)
              this.session.lineWidgets = new Array(this.session.getLength());
            var old = this.session.lineWidgets[w2.row];
            if (old) {
              w2.$oldWidget = old;
              if (old.el && old.el.parentNode) {
                old.el.parentNode.removeChild(old.el);
                old._inDocument = false;
              }
            }
            this.session.lineWidgets[w2.row] = w2;
            return w2;
          };
          LineWidgets2.prototype.addLineWidget = function(w2) {
            this.$registerLineWidget(w2);
            w2.session = this.session;
            if (!this.editor)
              return w2;
            var renderer = this.editor.renderer;
            if (w2.html && !w2.el) {
              w2.el = dom.createElement("div");
              w2.el.innerHTML = w2.html;
            }
            if (w2.text && !w2.el) {
              w2.el = dom.createElement("div");
              w2.el.textContent = w2.text;
            }
            if (w2.el) {
              dom.addCssClass(w2.el, "ace_lineWidgetContainer");
              if (w2.className) {
                dom.addCssClass(w2.el, w2.className);
              }
              w2.el.style.position = "absolute";
              w2.el.style.zIndex = "5";
              renderer.container.appendChild(w2.el);
              w2._inDocument = true;
              if (!w2.coverGutter) {
                w2.el.style.zIndex = "3";
              }
              if (w2.pixelHeight == null) {
                w2.pixelHeight = w2.el.offsetHeight;
              }
            }
            if (w2.rowCount == null) {
              w2.rowCount = w2.pixelHeight / renderer.layerConfig.lineHeight;
            }
            var fold = this.session.getFoldAt(w2.row, 0);
            w2.$fold = fold;
            if (fold) {
              var lineWidgets = this.session.lineWidgets;
              if (w2.row == fold.end.row && !lineWidgets[fold.start.row])
                lineWidgets[fold.start.row] = w2;
              else
                w2.hidden = true;
            }
            this.session._emit("changeFold", { data: { start: { row: w2.row } } });
            this.$updateRows();
            this.renderWidgets(null, renderer);
            this.onWidgetChanged(w2);
            return w2;
          };
          LineWidgets2.prototype.removeLineWidget = function(w2) {
            w2._inDocument = false;
            w2.session = null;
            if (w2.el && w2.el.parentNode)
              w2.el.parentNode.removeChild(w2.el);
            if (w2.editor && w2.editor.destroy)
              try {
                w2.editor.destroy();
              } catch (e2) {
              }
            if (this.session.lineWidgets) {
              var w1 = this.session.lineWidgets[w2.row];
              if (w1 == w2) {
                this.session.lineWidgets[w2.row] = w2.$oldWidget;
                if (w2.$oldWidget)
                  this.onWidgetChanged(w2.$oldWidget);
              } else {
                while (w1) {
                  if (w1.$oldWidget == w2) {
                    w1.$oldWidget = w2.$oldWidget;
                    break;
                  }
                  w1 = w1.$oldWidget;
                }
              }
            }
            this.session._emit("changeFold", { data: { start: { row: w2.row } } });
            this.$updateRows();
          };
          LineWidgets2.prototype.getWidgetsAtRow = function(row) {
            var lineWidgets = this.session.lineWidgets;
            var w2 = lineWidgets && lineWidgets[row];
            var list = [];
            while (w2) {
              list.push(w2);
              w2 = w2.$oldWidget;
            }
            return list;
          };
          LineWidgets2.prototype.onWidgetChanged = function(w2) {
            this.session._changedWidgets.push(w2);
            this.editor && this.editor.renderer.updateFull();
          };
          LineWidgets2.prototype.measureWidgets = function(e2, renderer) {
            var changedWidgets = this.session._changedWidgets;
            var config = renderer.layerConfig;
            if (!changedWidgets || !changedWidgets.length)
              return;
            var min = Infinity;
            for (var i2 = 0; i2 < changedWidgets.length; i2++) {
              var w2 = changedWidgets[i2];
              if (!w2 || !w2.el)
                continue;
              if (w2.session != this.session)
                continue;
              if (!w2._inDocument) {
                if (this.session.lineWidgets[w2.row] != w2)
                  continue;
                w2._inDocument = true;
                renderer.container.appendChild(w2.el);
              }
              w2.h = w2.el.offsetHeight;
              if (!w2.fixedWidth) {
                w2.w = w2.el.offsetWidth;
                w2.screenWidth = Math.ceil(w2.w / config.characterWidth);
              }
              var rowCount = w2.h / config.lineHeight;
              if (w2.coverLine) {
                rowCount -= this.session.getRowLineCount(w2.row);
                if (rowCount < 0)
                  rowCount = 0;
              }
              if (w2.rowCount != rowCount) {
                w2.rowCount = rowCount;
                if (w2.row < min)
                  min = w2.row;
              }
            }
            if (min != Infinity) {
              this.session._emit("changeFold", { data: { start: { row: min } } });
              this.session.lineWidgetWidth = null;
            }
            this.session._changedWidgets = [];
          };
          LineWidgets2.prototype.renderWidgets = function(e2, renderer) {
            var config = renderer.layerConfig;
            var lineWidgets = this.session.lineWidgets;
            if (!lineWidgets)
              return;
            var first = Math.min(this.firstRow, config.firstRow);
            var last = Math.max(this.lastRow, config.lastRow, lineWidgets.length);
            while (first > 0 && !lineWidgets[first])
              first--;
            this.firstRow = config.firstRow;
            this.lastRow = config.lastRow;
            renderer.$cursorLayer.config = config;
            for (var i2 = first; i2 <= last; i2++) {
              var w2 = lineWidgets[i2];
              if (!w2 || !w2.el)
                continue;
              if (w2.hidden) {
                w2.el.style.top = -100 - (w2.pixelHeight || 0) + "px";
                continue;
              }
              if (!w2._inDocument) {
                w2._inDocument = true;
                renderer.container.appendChild(w2.el);
              }
              var top = renderer.$cursorLayer.getPixelPosition({ row: i2, column: 0 }, true).top;
              if (!w2.coverLine)
                top += config.lineHeight * this.session.getRowLineCount(w2.row);
              w2.el.style.top = top - config.offset + "px";
              var left = w2.coverGutter ? 0 : renderer.gutterWidth;
              if (!w2.fixedWidth)
                left -= renderer.scrollLeft;
              w2.el.style.left = left + "px";
              if (w2.fullWidth && w2.screenWidth) {
                w2.el.style.minWidth = config.width + 2 * config.padding + "px";
              }
              if (w2.fixedWidth) {
                w2.el.style.right = renderer.scrollBar.getWidth() + "px";
              } else {
                w2.el.style.right = "";
              }
            }
          };
          return LineWidgets2;
        })()
      );
      exports3.LineWidgets = LineWidgets;
    });
    ace.define("ace/apply_delta", ["require", "exports", "module"], function(require2, exports3, module3) {
      exports3.applyDelta = function(docLines, delta, doNotValidate) {
        var row = delta.start.row;
        var startColumn = delta.start.column;
        var line = docLines[row] || "";
        switch (delta.action) {
          case "insert":
            var lines = delta.lines;
            if (lines.length === 1) {
              docLines[row] = line.substring(0, startColumn) + delta.lines[0] + line.substring(startColumn);
            } else {
              var args = [row, 1].concat(delta.lines);
              docLines.splice.apply(docLines, args);
              docLines[row] = line.substring(0, startColumn) + docLines[row];
              docLines[row + delta.lines.length - 1] += line.substring(startColumn);
            }
            break;
          case "remove":
            var endColumn = delta.end.column;
            var endRow = delta.end.row;
            if (row === endRow) {
              docLines[row] = line.substring(0, startColumn) + line.substring(endColumn);
            } else {
              docLines.splice(row, endRow - row + 1, line.substring(0, startColumn) + docLines[endRow].substring(endColumn));
            }
            break;
        }
      };
    });
    ace.define("ace/anchor", ["require", "exports", "module", "ace/lib/oop", "ace/lib/event_emitter"], function(require2, exports3, module3) {
      var oop = require2("./lib/oop");
      var EventEmitter = require2("./lib/event_emitter").EventEmitter;
      var Anchor = (
        /** @class */
        (function() {
          function Anchor2(doc, row, column) {
            this.$onChange = this.onChange.bind(this);
            this.attach(doc);
            if (typeof row != "number")
              this.setPosition(row.row, row.column);
            else
              this.setPosition(row, column);
          }
          Anchor2.prototype.getPosition = function() {
            return this.$clipPositionToDocument(this.row, this.column);
          };
          Anchor2.prototype.getDocument = function() {
            return this.document;
          };
          Anchor2.prototype.onChange = function(delta) {
            if (delta.start.row == delta.end.row && delta.start.row != this.row)
              return;
            if (delta.start.row > this.row)
              return;
            var point = $getTransformedPoint(delta, { row: this.row, column: this.column }, this.$insertRight);
            this.setPosition(point.row, point.column, true);
          };
          Anchor2.prototype.setPosition = function(row, column, noClip) {
            var pos;
            if (noClip) {
              pos = {
                row,
                column
              };
            } else {
              pos = this.$clipPositionToDocument(row, column);
            }
            if (this.row == pos.row && this.column == pos.column)
              return;
            var old = {
              row: this.row,
              column: this.column
            };
            this.row = pos.row;
            this.column = pos.column;
            this._signal("change", {
              old,
              value: pos
            });
          };
          Anchor2.prototype.detach = function() {
            this.document.off("change", this.$onChange);
          };
          Anchor2.prototype.attach = function(doc) {
            this.document = doc || this.document;
            this.document.on("change", this.$onChange);
          };
          Anchor2.prototype.$clipPositionToDocument = function(row, column) {
            var pos = {};
            if (row >= this.document.getLength()) {
              pos.row = Math.max(0, this.document.getLength() - 1);
              pos.column = this.document.getLine(pos.row).length;
            } else if (row < 0) {
              pos.row = 0;
              pos.column = 0;
            } else {
              pos.row = row;
              pos.column = Math.min(this.document.getLine(pos.row).length, Math.max(0, column));
            }
            if (column < 0)
              pos.column = 0;
            return pos;
          };
          return Anchor2;
        })()
      );
      Anchor.prototype.$insertRight = false;
      oop.implement(Anchor.prototype, EventEmitter);
      function $pointsInOrder(point1, point2, equalPointsInOrder) {
        var bColIsAfter = equalPointsInOrder ? point1.column <= point2.column : point1.column < point2.column;
        return point1.row < point2.row || point1.row == point2.row && bColIsAfter;
      }
      function $getTransformedPoint(delta, point, moveIfEqual) {
        var deltaIsInsert = delta.action == "insert";
        var deltaRowShift = (deltaIsInsert ? 1 : -1) * (delta.end.row - delta.start.row);
        var deltaColShift = (deltaIsInsert ? 1 : -1) * (delta.end.column - delta.start.column);
        var deltaStart = delta.start;
        var deltaEnd = deltaIsInsert ? deltaStart : delta.end;
        if ($pointsInOrder(point, deltaStart, moveIfEqual)) {
          return {
            row: point.row,
            column: point.column
          };
        }
        if ($pointsInOrder(deltaEnd, point, !moveIfEqual)) {
          return {
            row: point.row + deltaRowShift,
            column: point.column + (point.row == deltaEnd.row ? deltaColShift : 0)
          };
        }
        return {
          row: deltaStart.row,
          column: deltaStart.column
        };
      }
      exports3.Anchor = Anchor;
    });
    ace.define("ace/document", ["require", "exports", "module", "ace/lib/oop", "ace/apply_delta", "ace/lib/event_emitter", "ace/range", "ace/anchor"], function(require2, exports3, module3) {
      var oop = require2("./lib/oop");
      var applyDelta = require2("./apply_delta").applyDelta;
      var EventEmitter = require2("./lib/event_emitter").EventEmitter;
      var Range = require2("./range").Range;
      var Anchor = require2("./anchor").Anchor;
      var Document2 = (
        /** @class */
        (function() {
          function Document3(textOrLines) {
            this.$lines = [""];
            if (textOrLines.length === 0) {
              this.$lines = [""];
            } else if (Array.isArray(textOrLines)) {
              this.insertMergedLines({ row: 0, column: 0 }, textOrLines);
            } else {
              this.insert({ row: 0, column: 0 }, textOrLines);
            }
          }
          Document3.prototype.setValue = function(text) {
            var len = this.getLength() - 1;
            this.remove(new Range(0, 0, len, this.getLine(len).length));
            this.insert({ row: 0, column: 0 }, text || "");
          };
          Document3.prototype.getValue = function() {
            return this.getAllLines().join(this.getNewLineCharacter());
          };
          Document3.prototype.createAnchor = function(row, column) {
            return new Anchor(this, row, column);
          };
          Document3.prototype.$detectNewLine = function(text) {
            var match2 = text.match(/^.*?(\r\n|\r|\n)/m);
            this.$autoNewLine = match2 ? match2[1] : "\n";
            this._signal("changeNewLineMode");
          };
          Document3.prototype.getNewLineCharacter = function() {
            switch (this.$newLineMode) {
              case "windows":
                return "\r\n";
              case "unix":
                return "\n";
              default:
                return this.$autoNewLine || "\n";
            }
          };
          Document3.prototype.setNewLineMode = function(newLineMode) {
            if (this.$newLineMode === newLineMode)
              return;
            this.$newLineMode = newLineMode;
            this._signal("changeNewLineMode");
          };
          Document3.prototype.getNewLineMode = function() {
            return this.$newLineMode;
          };
          Document3.prototype.isNewLine = function(text) {
            return text == "\r\n" || text == "\r" || text == "\n";
          };
          Document3.prototype.getLine = function(row) {
            return this.$lines[row] || "";
          };
          Document3.prototype.getLines = function(firstRow, lastRow) {
            return this.$lines.slice(firstRow, lastRow + 1);
          };
          Document3.prototype.getAllLines = function() {
            return this.getLines(0, this.getLength());
          };
          Document3.prototype.getLength = function() {
            return this.$lines.length;
          };
          Document3.prototype.getTextRange = function(range) {
            return this.getLinesForRange(range).join(this.getNewLineCharacter());
          };
          Document3.prototype.getLinesForRange = function(range) {
            var lines;
            if (range.start.row === range.end.row) {
              lines = [this.getLine(range.start.row).substring(range.start.column, range.end.column)];
            } else {
              lines = this.getLines(range.start.row, range.end.row);
              lines[0] = (lines[0] || "").substring(range.start.column);
              var l = lines.length - 1;
              if (range.end.row - range.start.row == l)
                lines[l] = lines[l].substring(0, range.end.column);
            }
            return lines;
          };
          Document3.prototype.insertLines = function(row, lines) {
            console.warn("Use of document.insertLines is deprecated. Use the insertFullLines method instead.");
            return this.insertFullLines(row, lines);
          };
          Document3.prototype.removeLines = function(firstRow, lastRow) {
            console.warn("Use of document.removeLines is deprecated. Use the removeFullLines method instead.");
            return this.removeFullLines(firstRow, lastRow);
          };
          Document3.prototype.insertNewLine = function(position) {
            console.warn("Use of document.insertNewLine is deprecated. Use insertMergedLines(position, ['', '']) instead.");
            return this.insertMergedLines(position, ["", ""]);
          };
          Document3.prototype.insert = function(position, text) {
            if (this.getLength() <= 1)
              this.$detectNewLine(text);
            return this.insertMergedLines(position, this.$split(text));
          };
          Document3.prototype.insertInLine = function(position, text) {
            var start = this.clippedPos(position.row, position.column);
            var end = this.pos(position.row, position.column + text.length);
            this.applyDelta({
              start,
              end,
              action: "insert",
              lines: [text]
            }, true);
            return this.clonePos(end);
          };
          Document3.prototype.clippedPos = function(row, column) {
            var length = this.getLength();
            if (row === void 0) {
              row = length;
            } else if (row < 0) {
              row = 0;
            } else if (row >= length) {
              row = length - 1;
              column = void 0;
            }
            var line = this.getLine(row);
            if (column == void 0)
              column = line.length;
            column = Math.min(Math.max(column, 0), line.length);
            return { row, column };
          };
          Document3.prototype.clonePos = function(pos) {
            return { row: pos.row, column: pos.column };
          };
          Document3.prototype.pos = function(row, column) {
            return { row, column };
          };
          Document3.prototype.$clipPosition = function(position) {
            var length = this.getLength();
            if (position.row >= length) {
              position.row = Math.max(0, length - 1);
              position.column = this.getLine(length - 1).length;
            } else {
              position.row = Math.max(0, position.row);
              position.column = Math.min(Math.max(position.column, 0), this.getLine(position.row).length);
            }
            return position;
          };
          Document3.prototype.insertFullLines = function(row, lines) {
            row = Math.min(Math.max(row, 0), this.getLength());
            var column = 0;
            if (row < this.getLength()) {
              lines = lines.concat([""]);
              column = 0;
            } else {
              lines = [""].concat(lines);
              row--;
              column = this.$lines[row].length;
            }
            this.insertMergedLines({ row, column }, lines);
          };
          Document3.prototype.insertMergedLines = function(position, lines) {
            var start = this.clippedPos(position.row, position.column);
            var end = {
              row: start.row + lines.length - 1,
              column: (lines.length == 1 ? start.column : 0) + lines[lines.length - 1].length
            };
            this.applyDelta({
              start,
              end,
              action: "insert",
              lines
            });
            return this.clonePos(end);
          };
          Document3.prototype.remove = function(range) {
            var start = this.clippedPos(range.start.row, range.start.column);
            var end = this.clippedPos(range.end.row, range.end.column);
            this.applyDelta({
              start,
              end,
              action: "remove",
              lines: this.getLinesForRange({ start, end })
            });
            return this.clonePos(start);
          };
          Document3.prototype.removeInLine = function(row, startColumn, endColumn) {
            var start = this.clippedPos(row, startColumn);
            var end = this.clippedPos(row, endColumn);
            this.applyDelta({
              start,
              end,
              action: "remove",
              lines: this.getLinesForRange({ start, end })
            }, true);
            return this.clonePos(start);
          };
          Document3.prototype.removeFullLines = function(firstRow, lastRow) {
            firstRow = Math.min(Math.max(0, firstRow), this.getLength() - 1);
            lastRow = Math.min(Math.max(0, lastRow), this.getLength() - 1);
            var deleteFirstNewLine = lastRow == this.getLength() - 1 && firstRow > 0;
            var deleteLastNewLine = lastRow < this.getLength() - 1;
            var startRow = deleteFirstNewLine ? firstRow - 1 : firstRow;
            var startCol = deleteFirstNewLine ? this.getLine(startRow).length : 0;
            var endRow = deleteLastNewLine ? lastRow + 1 : lastRow;
            var endCol = deleteLastNewLine ? 0 : this.getLine(endRow).length;
            var range = new Range(startRow, startCol, endRow, endCol);
            var deletedLines = this.$lines.slice(firstRow, lastRow + 1);
            this.applyDelta({
              start: range.start,
              end: range.end,
              action: "remove",
              lines: this.getLinesForRange(range)
            });
            return deletedLines;
          };
          Document3.prototype.removeNewLine = function(row) {
            if (row < this.getLength() - 1 && row >= 0) {
              this.applyDelta({
                start: this.pos(row, this.getLine(row).length),
                end: this.pos(row + 1, 0),
                action: "remove",
                lines: ["", ""]
              });
            }
          };
          Document3.prototype.replace = function(range, text) {
            if (!(range instanceof Range))
              range = Range.fromPoints(range.start, range.end);
            if (text.length === 0 && range.isEmpty())
              return range.start;
            if (text == this.getTextRange(range))
              return range.end;
            this.remove(range);
            var end;
            if (text) {
              end = this.insert(range.start, text);
            } else {
              end = range.start;
            }
            return end;
          };
          Document3.prototype.applyDeltas = function(deltas) {
            for (var i2 = 0; i2 < deltas.length; i2++) {
              this.applyDelta(deltas[i2]);
            }
          };
          Document3.prototype.revertDeltas = function(deltas) {
            for (var i2 = deltas.length - 1; i2 >= 0; i2--) {
              this.revertDelta(deltas[i2]);
            }
          };
          Document3.prototype.applyDelta = function(delta, doNotValidate) {
            var isInsert = delta.action == "insert";
            if (isInsert ? delta.lines.length <= 1 && !delta.lines[0] : !Range.comparePoints(delta.start, delta.end)) {
              return;
            }
            if (isInsert && delta.lines.length > 2e4) {
              this.$splitAndapplyLargeDelta(delta, 2e4);
            } else {
              applyDelta(this.$lines, delta, doNotValidate);
              this._signal("change", delta);
            }
          };
          Document3.prototype.$safeApplyDelta = function(delta) {
            var docLength = this.$lines.length;
            if (delta.action == "remove" && delta.start.row < docLength && delta.end.row < docLength || delta.action == "insert" && delta.start.row <= docLength) {
              this.applyDelta(delta);
            }
          };
          Document3.prototype.$splitAndapplyLargeDelta = function(delta, MAX) {
            var lines = delta.lines;
            var l = lines.length - MAX + 1;
            var row = delta.start.row;
            var column = delta.start.column;
            for (var from = 0, to = 0; from < l; from = to) {
              to += MAX - 1;
              var chunk = lines.slice(from, to);
              chunk.push("");
              this.applyDelta({
                start: this.pos(row + from, column),
                end: this.pos(row + to, column = 0),
                action: delta.action,
                lines: chunk
              }, true);
            }
            delta.lines = lines.slice(from);
            delta.start.row = row + from;
            delta.start.column = column;
            this.applyDelta(delta, true);
          };
          Document3.prototype.revertDelta = function(delta) {
            this.$safeApplyDelta({
              start: this.clonePos(delta.start),
              end: this.clonePos(delta.end),
              action: delta.action == "insert" ? "remove" : "insert",
              lines: delta.lines.slice()
            });
          };
          Document3.prototype.indexToPosition = function(index, startRow) {
            var lines = this.$lines || this.getAllLines();
            var newlineLength = this.getNewLineCharacter().length;
            for (var i2 = startRow || 0, l = lines.length; i2 < l; i2++) {
              index -= lines[i2].length + newlineLength;
              if (index < 0)
                return { row: i2, column: index + lines[i2].length + newlineLength };
            }
            return { row: l - 1, column: index + lines[l - 1].length + newlineLength };
          };
          Document3.prototype.positionToIndex = function(pos, startRow) {
            var lines = this.$lines || this.getAllLines();
            var newlineLength = this.getNewLineCharacter().length;
            var index = 0;
            var row = Math.min(pos.row, lines.length);
            for (var i2 = startRow || 0; i2 < row; ++i2)
              index += lines[i2].length + newlineLength;
            return index + pos.column;
          };
          Document3.prototype.$split = function(text) {
            return text.split(/\r\n|\r|\n/);
          };
          return Document3;
        })()
      );
      Document2.prototype.$autoNewLine = "";
      Document2.prototype.$newLineMode = "auto";
      oop.implement(Document2.prototype, EventEmitter);
      exports3.Document = Document2;
    });
    ace.define("ace/background_tokenizer", ["require", "exports", "module", "ace/lib/oop", "ace/lib/event_emitter"], function(require2, exports3, module3) {
      var oop = require2("./lib/oop");
      var EventEmitter = require2("./lib/event_emitter").EventEmitter;
      var BackgroundTokenizer = (
        /** @class */
        (function() {
          function BackgroundTokenizer2(tokenizer, session) {
            this.running = false;
            this.lines = [];
            this.states = [];
            this.currentLine = 0;
            this.tokenizer = tokenizer;
            var self2 = this;
            this.$worker = function() {
              if (!self2.running) {
                return;
              }
              var workerStart = /* @__PURE__ */ new Date();
              var currentLine = self2.currentLine;
              var endLine = -1;
              var doc = self2.doc;
              var startLine = currentLine;
              while (self2.lines[currentLine])
                currentLine++;
              var len = doc.getLength();
              var processedLines = 0;
              self2.running = false;
              while (currentLine < len) {
                self2.$tokenizeRow(currentLine);
                endLine = currentLine;
                do {
                  currentLine++;
                } while (self2.lines[currentLine]);
                processedLines++;
                if (processedLines % 5 === 0 && /* @__PURE__ */ new Date() - workerStart > 20) {
                  self2.running = setTimeout(self2.$worker, 20);
                  break;
                }
              }
              self2.currentLine = currentLine;
              if (endLine == -1)
                endLine = currentLine;
              if (startLine <= endLine)
                self2.fireUpdateEvent(startLine, endLine);
            };
          }
          BackgroundTokenizer2.prototype.setTokenizer = function(tokenizer) {
            this.tokenizer = tokenizer;
            this.lines = [];
            this.states = [];
            this.start(0);
          };
          BackgroundTokenizer2.prototype.setDocument = function(doc) {
            this.doc = doc;
            this.lines = [];
            this.states = [];
            this.stop();
          };
          BackgroundTokenizer2.prototype.fireUpdateEvent = function(firstRow, lastRow) {
            var data = {
              first: firstRow,
              last: lastRow
            };
            this._signal("update", { data });
          };
          BackgroundTokenizer2.prototype.start = function(startRow) {
            this.currentLine = Math.min(startRow || 0, this.currentLine, this.doc.getLength());
            this.lines.splice(this.currentLine, this.lines.length);
            this.states.splice(this.currentLine, this.states.length);
            this.stop();
            this.running = setTimeout(this.$worker, 700);
          };
          BackgroundTokenizer2.prototype.scheduleStart = function() {
            if (!this.running)
              this.running = setTimeout(this.$worker, 700);
          };
          BackgroundTokenizer2.prototype.$updateOnChange = function(delta) {
            var startRow = delta.start.row;
            var len = delta.end.row - startRow;
            if (len === 0) {
              this.lines[startRow] = null;
            } else if (delta.action == "remove") {
              this.lines.splice(startRow, len + 1, null);
              this.states.splice(startRow, len + 1, null);
            } else {
              var args = Array(len + 1);
              args.unshift(startRow, 1);
              this.lines.splice.apply(this.lines, args);
              this.states.splice.apply(this.states, args);
            }
            this.currentLine = Math.min(startRow, this.currentLine, this.doc.getLength());
            this.stop();
          };
          BackgroundTokenizer2.prototype.stop = function() {
            if (this.running)
              clearTimeout(this.running);
            this.running = false;
          };
          BackgroundTokenizer2.prototype.getTokens = function(row) {
            return this.lines[row] || this.$tokenizeRow(row);
          };
          BackgroundTokenizer2.prototype.getState = function(row) {
            if (this.currentLine == row)
              this.$tokenizeRow(row);
            return this.states[row] || "start";
          };
          BackgroundTokenizer2.prototype.$tokenizeRow = function(row) {
            var line = this.doc.getLine(row);
            var state = this.states[row - 1];
            var data = this.tokenizer.getLineTokens(line, state, row);
            if (this.states[row] + "" !== data.state + "") {
              this.states[row] = data.state;
              this.lines[row + 1] = null;
              if (this.currentLine > row + 1)
                this.currentLine = row + 1;
            } else if (this.currentLine == row) {
              this.currentLine = row + 1;
            }
            return this.lines[row] = data.tokens;
          };
          BackgroundTokenizer2.prototype.cleanup = function() {
            this.running = false;
            this.lines = [];
            this.states = [];
            this.currentLine = 0;
            this.removeAllListeners();
          };
          return BackgroundTokenizer2;
        })()
      );
      oop.implement(BackgroundTokenizer.prototype, EventEmitter);
      exports3.BackgroundTokenizer = BackgroundTokenizer;
    });
    ace.define("ace/search_highlight", ["require", "exports", "module", "ace/lib/lang", "ace/range"], function(require2, exports3, module3) {
      var lang = require2("./lib/lang");
      var Range = require2("./range").Range;
      var SearchHighlight = (
        /** @class */
        (function() {
          function SearchHighlight2(regExp, clazz, type) {
            if (type === void 0) {
              type = "text";
            }
            this.setRegexp(regExp);
            this.clazz = clazz;
            this.type = type;
            this.docLen = 0;
          }
          SearchHighlight2.prototype.setRegexp = function(regExp) {
            if (this.regExp + "" == regExp + "")
              return;
            this.regExp = regExp;
            this.cache = [];
          };
          SearchHighlight2.prototype.update = function(html3, markerLayer, session, config) {
            if (!this.regExp)
              return;
            var start = config.firstRow;
            var end = config.lastRow;
            var renderedMarkerRanges = {};
            var _search = session.$editor.$search;
            var mtSearch = _search.$isMultilineSearch(session.$editor.getLastSearchOptions());
            for (var i2 = start; i2 <= end; i2++) {
              var ranges = this.cache[i2];
              if (ranges == null || session.getValue().length != this.docLen) {
                if (mtSearch) {
                  ranges = [];
                  var match2 = _search.$multiLineForward(session, this.regExp, i2, end);
                  if (match2) {
                    var end_row = match2.endRow <= end ? match2.endRow - 1 : end;
                    if (end_row > i2)
                      i2 = end_row;
                    ranges.push(new Range(match2.startRow, match2.startCol, match2.endRow, match2.endCol));
                  }
                  if (ranges.length > this.MAX_RANGES)
                    ranges = ranges.slice(0, this.MAX_RANGES);
                } else {
                  ranges = lang.getMatchOffsets(session.getLine(i2), this.regExp);
                  if (ranges.length > this.MAX_RANGES)
                    ranges = ranges.slice(0, this.MAX_RANGES);
                  ranges = ranges.map(function(match3) {
                    return new Range(i2, match3.offset, i2, match3.offset + match3.length);
                  });
                }
                this.cache[i2] = ranges.length ? ranges : "";
              }
              if (ranges.length === 0)
                continue;
              for (var j = ranges.length; j--; ) {
                var rangeToAddMarkerTo = ranges[j].toScreenRange(session);
                var rangeAsString = rangeToAddMarkerTo.toString();
                if (renderedMarkerRanges[rangeAsString])
                  continue;
                renderedMarkerRanges[rangeAsString] = true;
                markerLayer.drawSingleLineMarker(html3, rangeToAddMarkerTo, this.clazz, config);
              }
            }
            this.docLen = session.getValue().length;
          };
          return SearchHighlight2;
        })()
      );
      SearchHighlight.prototype.MAX_RANGES = 500;
      exports3.SearchHighlight = SearchHighlight;
    });
    ace.define("ace/undomanager", ["require", "exports", "module", "ace/range"], function(require2, exports3, module3) {
      var UndoManager = (
        /** @class */
        (function() {
          function UndoManager2() {
            this.$keepRedoStack;
            this.$maxRev = 0;
            this.$fromUndo = false;
            this.$undoDepth = Infinity;
            this.reset();
          }
          UndoManager2.prototype.addSession = function(session) {
            this.$session = session;
          };
          UndoManager2.prototype.add = function(delta, allowMerge, session) {
            if (this.$fromUndo)
              return;
            if (delta == this.$lastDelta)
              return;
            if (!this.$keepRedoStack)
              this.$redoStack.length = 0;
            if (allowMerge === false || !this.lastDeltas) {
              this.lastDeltas = [];
              var undoStackLength = this.$undoStack.length;
              if (undoStackLength > this.$undoDepth - 1) {
                this.$undoStack.splice(0, undoStackLength - this.$undoDepth + 1);
              }
              this.$undoStack.push(this.lastDeltas);
              delta.id = this.$rev = ++this.$maxRev;
            }
            if (delta.action == "remove" || delta.action == "insert")
              this.$lastDelta = delta;
            this.lastDeltas.push(delta);
          };
          UndoManager2.prototype.addSelection = function(selection, rev) {
            this.selections.push({
              value: selection,
              rev: rev || this.$rev
            });
          };
          UndoManager2.prototype.startNewGroup = function() {
            this.lastDeltas = null;
            return this.$rev;
          };
          UndoManager2.prototype.markIgnored = function(from, to) {
            if (to == null)
              to = this.$rev + 1;
            var stack = this.$undoStack;
            for (var i2 = stack.length; i2--; ) {
              var delta = stack[i2][0];
              if (delta.id <= from)
                break;
              if (delta.id < to)
                delta.ignore = true;
            }
            this.lastDeltas = null;
          };
          UndoManager2.prototype.getSelection = function(rev, after) {
            var stack = this.selections;
            for (var i2 = stack.length; i2--; ) {
              var selection = stack[i2];
              if (selection.rev < rev) {
                if (after)
                  selection = stack[i2 + 1];
                return selection;
              }
            }
          };
          UndoManager2.prototype.getRevision = function() {
            return this.$rev;
          };
          UndoManager2.prototype.getDeltas = function(from, to) {
            if (to == null)
              to = this.$rev + 1;
            var stack = this.$undoStack;
            var end = null, start = 0;
            for (var i2 = stack.length; i2--; ) {
              var delta = stack[i2][0];
              if (delta.id < to && !end)
                end = i2 + 1;
              if (delta.id <= from) {
                start = i2 + 1;
                break;
              }
            }
            return stack.slice(start, end);
          };
          UndoManager2.prototype.getChangedRanges = function(from, to) {
            if (to == null)
              to = this.$rev + 1;
          };
          UndoManager2.prototype.getChangedLines = function(from, to) {
            if (to == null)
              to = this.$rev + 1;
          };
          UndoManager2.prototype.undo = function(session, dontSelect) {
            this.lastDeltas = null;
            var stack = this.$undoStack;
            if (!rearrangeUndoStack(stack, stack.length))
              return;
            if (!session)
              session = this.$session;
            if (this.$redoStackBaseRev !== this.$rev && this.$redoStack.length)
              this.$redoStack = [];
            this.$fromUndo = true;
            var deltaSet = stack.pop();
            var undoSelectionRange = null;
            if (deltaSet) {
              undoSelectionRange = session.undoChanges(deltaSet, dontSelect);
              this.$redoStack.push(deltaSet);
              this.$syncRev();
            }
            this.$fromUndo = false;
            return undoSelectionRange;
          };
          UndoManager2.prototype.redo = function(session, dontSelect) {
            this.lastDeltas = null;
            if (!session)
              session = this.$session;
            this.$fromUndo = true;
            if (this.$redoStackBaseRev != this.$rev) {
              var diff = this.getDeltas(this.$redoStackBaseRev, this.$rev + 1);
              rebaseRedoStack(this.$redoStack, diff);
              this.$redoStackBaseRev = this.$rev;
              this.$redoStack.forEach(function(x2) {
                x2[0].id = ++this.$maxRev;
              }, this);
            }
            var deltaSet = this.$redoStack.pop();
            var redoSelectionRange = null;
            if (deltaSet) {
              redoSelectionRange = session.redoChanges(deltaSet, dontSelect);
              this.$undoStack.push(deltaSet);
              this.$syncRev();
            }
            this.$fromUndo = false;
            return redoSelectionRange;
          };
          UndoManager2.prototype.$syncRev = function() {
            var stack = this.$undoStack;
            var nextDelta = stack[stack.length - 1];
            var id = nextDelta && nextDelta[0].id || 0;
            this.$redoStackBaseRev = id;
            this.$rev = id;
          };
          UndoManager2.prototype.reset = function() {
            this.lastDeltas = null;
            this.$lastDelta = null;
            this.$undoStack = [];
            this.$redoStack = [];
            this.$rev = 0;
            this.mark = 0;
            this.$redoStackBaseRev = this.$rev;
            this.selections = [];
          };
          UndoManager2.prototype.canUndo = function() {
            return this.$undoStack.length > 0;
          };
          UndoManager2.prototype.canRedo = function() {
            return this.$redoStack.length > 0;
          };
          UndoManager2.prototype.bookmark = function(rev) {
            if (rev == void 0)
              rev = this.$rev;
            this.mark = rev;
          };
          UndoManager2.prototype.isAtBookmark = function() {
            return this.$rev === this.mark;
          };
          UndoManager2.prototype.toJSON = function() {
            return {
              $redoStack: this.$redoStack,
              $undoStack: this.$undoStack
            };
          };
          UndoManager2.prototype.fromJSON = function(json) {
            this.reset();
            this.$undoStack = json.$undoStack;
            this.$redoStack = json.$redoStack;
          };
          UndoManager2.prototype.$prettyPrint = function(delta) {
            if (delta)
              return stringifyDelta(delta);
            return stringifyDelta(this.$undoStack) + "\n---\n" + stringifyDelta(this.$redoStack);
          };
          return UndoManager2;
        })()
      );
      UndoManager.prototype.hasUndo = UndoManager.prototype.canUndo;
      UndoManager.prototype.hasRedo = UndoManager.prototype.canRedo;
      UndoManager.prototype.isClean = UndoManager.prototype.isAtBookmark;
      UndoManager.prototype.markClean = UndoManager.prototype.bookmark;
      function rearrangeUndoStack(stack, pos) {
        for (var i2 = pos; i2--; ) {
          var deltaSet = stack[i2];
          if (deltaSet && !deltaSet[0].ignore) {
            while (i2 < pos - 1) {
              var swapped = swapGroups(stack[i2], stack[i2 + 1]);
              stack[i2] = swapped[0];
              stack[i2 + 1] = swapped[1];
              i2++;
            }
            return true;
          }
        }
      }
      var Range = require2("./range").Range;
      var cmp = Range.comparePoints;
      Range.comparePoints;
      function clonePos(pos) {
        return { row: pos.row, column: pos.column };
      }
      function cloneDelta(d3) {
        return {
          start: clonePos(d3.start),
          end: clonePos(d3.end),
          action: d3.action,
          lines: d3.lines.slice()
        };
      }
      function stringifyDelta(d3) {
        d3 = d3 || this;
        if (Array.isArray(d3)) {
          return d3.map(stringifyDelta).join("\n");
        }
        var type = "";
        if (d3.action) {
          type = d3.action == "insert" ? "+" : "-";
          type += "[" + d3.lines + "]";
        } else if (d3.value) {
          if (Array.isArray(d3.value)) {
            type = d3.value.map(stringifyRange).join("\n");
          } else {
            type = stringifyRange(d3.value);
          }
        }
        if (d3.start) {
          type += stringifyRange(d3);
        }
        if (d3.id || d3.rev) {
          type += "	(" + (d3.id || d3.rev) + ")";
        }
        return type;
      }
      function stringifyRange(r) {
        return r.start.row + ":" + r.start.column + "=>" + r.end.row + ":" + r.end.column;
      }
      function swap(d1, d22) {
        var i1 = d1.action == "insert";
        var i2 = d22.action == "insert";
        if (i1 && i2) {
          if (cmp(d22.start, d1.end) >= 0) {
            shift(d22, d1, -1);
          } else if (cmp(d22.start, d1.start) <= 0) {
            shift(d1, d22, 1);
          } else {
            return null;
          }
        } else if (i1 && !i2) {
          if (cmp(d22.start, d1.end) >= 0) {
            shift(d22, d1, -1);
          } else if (cmp(d22.end, d1.start) <= 0) {
            shift(d1, d22, -1);
          } else {
            return null;
          }
        } else if (!i1 && i2) {
          if (cmp(d22.start, d1.start) >= 0) {
            shift(d22, d1, 1);
          } else if (cmp(d22.start, d1.start) <= 0) {
            shift(d1, d22, 1);
          } else {
            return null;
          }
        } else if (!i1 && !i2) {
          if (cmp(d22.start, d1.start) >= 0) {
            shift(d22, d1, 1);
          } else if (cmp(d22.end, d1.start) <= 0) {
            shift(d1, d22, -1);
          } else {
            return null;
          }
        }
        return [d22, d1];
      }
      function swapGroups(ds1, ds2) {
        for (var i2 = ds1.length; i2--; ) {
          for (var j = 0; j < ds2.length; j++) {
            if (!swap(ds1[i2], ds2[j])) {
              while (i2 < ds1.length) {
                while (j--) {
                  swap(ds2[j], ds1[i2]);
                }
                j = ds2.length;
                i2++;
              }
              return [ds1, ds2];
            }
          }
        }
        ds1.selectionBefore = ds2.selectionBefore = ds1.selectionAfter = ds2.selectionAfter = null;
        return [ds2, ds1];
      }
      function xform(d1, c1) {
        var i1 = d1.action == "insert";
        var i2 = c1.action == "insert";
        if (i1 && i2) {
          if (cmp(d1.start, c1.start) < 0) {
            shift(c1, d1, 1);
          } else {
            shift(d1, c1, 1);
          }
        } else if (i1 && !i2) {
          if (cmp(d1.start, c1.end) >= 0) {
            shift(d1, c1, -1);
          } else if (cmp(d1.start, c1.start) <= 0) {
            shift(c1, d1, 1);
          } else {
            shift(d1, Range.fromPoints(c1.start, d1.start), -1);
            shift(c1, d1, 1);
          }
        } else if (!i1 && i2) {
          if (cmp(c1.start, d1.end) >= 0) {
            shift(c1, d1, -1);
          } else if (cmp(c1.start, d1.start) <= 0) {
            shift(d1, c1, 1);
          } else {
            shift(c1, Range.fromPoints(d1.start, c1.start), -1);
            shift(d1, c1, 1);
          }
        } else if (!i1 && !i2) {
          if (cmp(c1.start, d1.end) >= 0) {
            shift(c1, d1, -1);
          } else if (cmp(c1.end, d1.start) <= 0) {
            shift(d1, c1, -1);
          } else {
            var before, after;
            if (cmp(d1.start, c1.start) < 0) {
              before = d1;
              d1 = splitDelta(d1, c1.start);
            }
            if (cmp(d1.end, c1.end) > 0) {
              after = splitDelta(d1, c1.end);
            }
            shiftPos(c1.end, d1.start, d1.end, -1);
            if (after && !before) {
              d1.lines = after.lines;
              d1.start = after.start;
              d1.end = after.end;
              after = d1;
            }
            return [c1, before, after].filter(Boolean);
          }
        }
        return [c1, d1];
      }
      function shift(d1, d22, dir) {
        shiftPos(d1.start, d22.start, d22.end, dir);
        shiftPos(d1.end, d22.start, d22.end, dir);
      }
      function shiftPos(pos, start, end, dir) {
        if (pos.row == (dir == 1 ? start : end).row) {
          pos.column += dir * (end.column - start.column);
        }
        pos.row += dir * (end.row - start.row);
      }
      function splitDelta(c2, pos) {
        var lines = c2.lines;
        var end = c2.end;
        c2.end = clonePos(pos);
        var rowsBefore = c2.end.row - c2.start.row;
        var otherLines = lines.splice(rowsBefore, lines.length);
        var col = rowsBefore ? pos.column : pos.column - c2.start.column;
        lines.push(otherLines[0].substring(0, col));
        otherLines[0] = otherLines[0].substr(col);
        var rest = {
          start: clonePos(pos),
          end,
          lines: otherLines,
          action: c2.action
        };
        return rest;
      }
      function moveDeltasByOne(redoStack, d3) {
        d3 = cloneDelta(d3);
        for (var j = redoStack.length; j--; ) {
          var deltaSet = redoStack[j];
          for (var i2 = 0; i2 < deltaSet.length; i2++) {
            var x2 = deltaSet[i2];
            var xformed = xform(x2, d3);
            d3 = xformed[0];
            if (xformed.length != 2) {
              if (xformed[2]) {
                deltaSet.splice(i2 + 1, 1, xformed[1], xformed[2]);
                i2++;
              } else if (!xformed[1]) {
                deltaSet.splice(i2, 1);
                i2--;
              }
            }
          }
          if (!deltaSet.length) {
            redoStack.splice(j, 1);
          }
        }
        return redoStack;
      }
      function rebaseRedoStack(redoStack, deltaSets) {
        for (var i2 = 0; i2 < deltaSets.length; i2++) {
          var deltas = deltaSets[i2];
          for (var j = 0; j < deltas.length; j++) {
            moveDeltasByOne(redoStack, deltas[j]);
          }
        }
      }
      exports3.UndoManager = UndoManager;
    });
    ace.define("ace/edit_session/fold_line", ["require", "exports", "module", "ace/range"], function(require2, exports3, module3) {
      var Range = require2("../range").Range;
      var FoldLine = (
        /** @class */
        (function() {
          function FoldLine2(foldData, folds) {
            this.foldData = foldData;
            if (Array.isArray(folds)) {
              this.folds = folds;
            } else {
              folds = this.folds = [folds];
            }
            var last = folds[folds.length - 1];
            this.range = new Range(folds[0].start.row, folds[0].start.column, last.end.row, last.end.column);
            this.start = this.range.start;
            this.end = this.range.end;
            this.folds.forEach(function(fold) {
              fold.setFoldLine(this);
            }, this);
          }
          FoldLine2.prototype.shiftRow = function(shift) {
            this.start.row += shift;
            this.end.row += shift;
            this.folds.forEach(function(fold) {
              fold.start.row += shift;
              fold.end.row += shift;
            });
          };
          FoldLine2.prototype.addFold = function(fold) {
            if (fold.sameRow) {
              if (fold.start.row < this.startRow || fold.endRow > this.endRow) {
                throw new Error("Can't add a fold to this FoldLine as it has no connection");
              }
              this.folds.push(fold);
              this.folds.sort(function(a3, b2) {
                return -a3.range.compareEnd(b2.start.row, b2.start.column);
              });
              if (this.range.compareEnd(fold.start.row, fold.start.column) > 0) {
                this.end.row = fold.end.row;
                this.end.column = fold.end.column;
              } else if (this.range.compareStart(fold.end.row, fold.end.column) < 0) {
                this.start.row = fold.start.row;
                this.start.column = fold.start.column;
              }
            } else if (fold.start.row == this.end.row) {
              this.folds.push(fold);
              this.end.row = fold.end.row;
              this.end.column = fold.end.column;
            } else if (fold.end.row == this.start.row) {
              this.folds.unshift(fold);
              this.start.row = fold.start.row;
              this.start.column = fold.start.column;
            } else {
              throw new Error("Trying to add fold to FoldRow that doesn't have a matching row");
            }
            fold.foldLine = this;
          };
          FoldLine2.prototype.containsRow = function(row) {
            return row >= this.start.row && row <= this.end.row;
          };
          FoldLine2.prototype.walk = function(callback, endRow, endColumn) {
            var lastEnd = 0, folds = this.folds, fold, cmp, stop, isNewRow = true;
            if (endRow == null) {
              endRow = this.end.row;
              endColumn = this.end.column;
            }
            for (var i2 = 0; i2 < folds.length; i2++) {
              fold = folds[i2];
              cmp = fold.range.compareStart(endRow, endColumn);
              if (cmp == -1) {
                callback(null, endRow, endColumn, lastEnd, isNewRow);
                return;
              }
              stop = callback(null, fold.start.row, fold.start.column, lastEnd, isNewRow);
              stop = !stop && callback(fold.placeholder, fold.start.row, fold.start.column, lastEnd);
              if (stop || cmp === 0) {
                return;
              }
              isNewRow = !fold.sameRow;
              lastEnd = fold.end.column;
            }
            callback(null, endRow, endColumn, lastEnd, isNewRow);
          };
          FoldLine2.prototype.getNextFoldTo = function(row, column) {
            var fold, cmp;
            for (var i2 = 0; i2 < this.folds.length; i2++) {
              fold = this.folds[i2];
              cmp = fold.range.compareEnd(row, column);
              if (cmp == -1) {
                return {
                  fold,
                  kind: "after"
                };
              } else if (cmp === 0) {
                return {
                  fold,
                  kind: "inside"
                };
              }
            }
            return null;
          };
          FoldLine2.prototype.addRemoveChars = function(row, column, len) {
            var ret = this.getNextFoldTo(row, column), fold, folds;
            if (ret) {
              fold = ret.fold;
              if (ret.kind == "inside" && fold.start.column != column && fold.start.row != row) {
                window.console && window.console.log(row, column, fold);
              } else if (fold.start.row == row) {
                folds = this.folds;
                var i2 = folds.indexOf(fold);
                if (i2 === 0) {
                  this.start.column += len;
                }
                for (i2; i2 < folds.length; i2++) {
                  fold = folds[i2];
                  fold.start.column += len;
                  if (!fold.sameRow) {
                    return;
                  }
                  fold.end.column += len;
                }
                this.end.column += len;
              }
            }
          };
          FoldLine2.prototype.split = function(row, column) {
            var pos = this.getNextFoldTo(row, column);
            if (!pos || pos.kind == "inside")
              return null;
            var fold = pos.fold;
            var folds = this.folds;
            var foldData = this.foldData;
            var i2 = folds.indexOf(fold);
            var foldBefore = folds[i2 - 1];
            this.end.row = foldBefore.end.row;
            this.end.column = foldBefore.end.column;
            folds = folds.splice(i2, folds.length - i2);
            var newFoldLine = new FoldLine2(foldData, folds);
            foldData.splice(foldData.indexOf(this) + 1, 0, newFoldLine);
            return newFoldLine;
          };
          FoldLine2.prototype.merge = function(foldLineNext) {
            var folds = foldLineNext.folds;
            for (var i2 = 0; i2 < folds.length; i2++) {
              this.addFold(folds[i2]);
            }
            var foldData = this.foldData;
            foldData.splice(foldData.indexOf(foldLineNext), 1);
          };
          FoldLine2.prototype.toString = function() {
            var ret = [this.range.toString() + ": ["];
            this.folds.forEach(function(fold) {
              ret.push("  " + fold.toString());
            });
            ret.push("]");
            return ret.join("\n");
          };
          FoldLine2.prototype.idxToPosition = function(idx) {
            var lastFoldEndColumn = 0;
            for (var i2 = 0; i2 < this.folds.length; i2++) {
              var fold = this.folds[i2];
              idx -= fold.start.column - lastFoldEndColumn;
              if (idx < 0) {
                return {
                  row: fold.start.row,
                  column: fold.start.column + idx
                };
              }
              idx -= fold.placeholder.length;
              if (idx < 0) {
                return fold.start;
              }
              lastFoldEndColumn = fold.end.column;
            }
            return {
              row: this.end.row,
              column: this.end.column + idx
            };
          };
          return FoldLine2;
        })()
      );
      exports3.FoldLine = FoldLine;
    });
    ace.define("ace/range_list", ["require", "exports", "module", "ace/range"], function(require2, exports3, module3) {
      var Range = require2("./range").Range;
      var comparePoints = Range.comparePoints;
      var RangeList = (
        /** @class */
        (function() {
          function RangeList2() {
            this.ranges = [];
            this.$bias = 1;
          }
          RangeList2.prototype.pointIndex = function(pos, excludeEdges, startIndex) {
            var list = this.ranges;
            for (var i2 = startIndex || 0; i2 < list.length; i2++) {
              var range = list[i2];
              var cmpEnd = comparePoints(pos, range.end);
              if (cmpEnd > 0)
                continue;
              var cmpStart = comparePoints(pos, range.start);
              if (cmpEnd === 0)
                return excludeEdges && cmpStart !== 0 ? -i2 - 2 : i2;
              if (cmpStart > 0 || cmpStart === 0 && !excludeEdges)
                return i2;
              return -i2 - 1;
            }
            return -i2 - 1;
          };
          RangeList2.prototype.add = function(range) {
            var excludeEdges = !range.isEmpty();
            var startIndex = this.pointIndex(range.start, excludeEdges);
            if (startIndex < 0)
              startIndex = -startIndex - 1;
            var endIndex = this.pointIndex(range.end, excludeEdges, startIndex);
            if (endIndex < 0)
              endIndex = -endIndex - 1;
            else
              endIndex++;
            return this.ranges.splice(startIndex, endIndex - startIndex, range);
          };
          RangeList2.prototype.addList = function(list) {
            var removed = [];
            for (var i2 = list.length; i2--; ) {
              removed.push.apply(removed, this.add(list[i2]));
            }
            return removed;
          };
          RangeList2.prototype.substractPoint = function(pos) {
            var i2 = this.pointIndex(pos);
            if (i2 >= 0)
              return this.ranges.splice(i2, 1);
          };
          RangeList2.prototype.merge = function() {
            var removed = [];
            var list = this.ranges;
            list = list.sort(function(a3, b2) {
              return comparePoints(a3.start, b2.start);
            });
            var next = list[0], range;
            for (var i2 = 1; i2 < list.length; i2++) {
              range = next;
              next = list[i2];
              var cmp = comparePoints(range.end, next.start);
              if (cmp < 0)
                continue;
              if (cmp == 0 && !range.isEmpty() && !next.isEmpty())
                continue;
              if (comparePoints(range.end, next.end) < 0) {
                range.end.row = next.end.row;
                range.end.column = next.end.column;
              }
              list.splice(i2, 1);
              removed.push(next);
              next = range;
              i2--;
            }
            this.ranges = list;
            return removed;
          };
          RangeList2.prototype.contains = function(row, column) {
            return this.pointIndex({ row, column }) >= 0;
          };
          RangeList2.prototype.containsPoint = function(pos) {
            return this.pointIndex(pos) >= 0;
          };
          RangeList2.prototype.rangeAtPoint = function(pos) {
            var i2 = this.pointIndex(pos);
            if (i2 >= 0)
              return this.ranges[i2];
          };
          RangeList2.prototype.clipRows = function(startRow, endRow) {
            var list = this.ranges;
            if (list[0].start.row > endRow || list[list.length - 1].start.row < startRow)
              return [];
            var startIndex = this.pointIndex({ row: startRow, column: 0 });
            if (startIndex < 0)
              startIndex = -startIndex - 1;
            var endIndex = this.pointIndex({ row: endRow, column: 0 }, startIndex);
            if (endIndex < 0)
              endIndex = -endIndex - 1;
            var clipped = [];
            for (var i2 = startIndex; i2 < endIndex; i2++) {
              clipped.push(list[i2]);
            }
            return clipped;
          };
          RangeList2.prototype.removeAll = function() {
            return this.ranges.splice(0, this.ranges.length);
          };
          RangeList2.prototype.attach = function(session) {
            if (this.session)
              this.detach();
            this.session = session;
            this.onChange = this.$onChange.bind(this);
            this.session.on("change", this.onChange);
          };
          RangeList2.prototype.detach = function() {
            if (!this.session)
              return;
            this.session.removeListener("change", this.onChange);
            this.session = null;
          };
          RangeList2.prototype.$onChange = function(delta) {
            var start = delta.start;
            var end = delta.end;
            var startRow = start.row;
            var endRow = end.row;
            var ranges = this.ranges;
            for (var i2 = 0, n = ranges.length; i2 < n; i2++) {
              var r = ranges[i2];
              if (r.end.row >= startRow)
                break;
            }
            if (delta.action == "insert") {
              var lineDif = endRow - startRow;
              var colDiff = -start.column + end.column;
              for (; i2 < n; i2++) {
                var r = ranges[i2];
                if (r.start.row > startRow)
                  break;
                if (r.start.row == startRow && r.start.column >= start.column) {
                  if (r.start.column == start.column && this.$bias <= 0) ;
                  else {
                    r.start.column += colDiff;
                    r.start.row += lineDif;
                  }
                }
                if (r.end.row == startRow && r.end.column >= start.column) {
                  if (r.end.column == start.column && this.$bias < 0) {
                    continue;
                  }
                  if (r.end.column == start.column && colDiff > 0 && i2 < n - 1) {
                    if (r.end.column > r.start.column && r.end.column == ranges[i2 + 1].start.column)
                      r.end.column -= colDiff;
                  }
                  r.end.column += colDiff;
                  r.end.row += lineDif;
                }
              }
            } else {
              var lineDif = startRow - endRow;
              var colDiff = start.column - end.column;
              for (; i2 < n; i2++) {
                var r = ranges[i2];
                if (r.start.row > endRow)
                  break;
                if (r.end.row < endRow && (startRow < r.end.row || startRow == r.end.row && start.column < r.end.column)) {
                  r.end.row = startRow;
                  r.end.column = start.column;
                } else if (r.end.row == endRow) {
                  if (r.end.column <= end.column) {
                    if (lineDif || r.end.column > start.column) {
                      r.end.column = start.column;
                      r.end.row = start.row;
                    }
                  } else {
                    r.end.column += colDiff;
                    r.end.row += lineDif;
                  }
                } else if (r.end.row > endRow) {
                  r.end.row += lineDif;
                }
                if (r.start.row < endRow && (startRow < r.start.row || startRow == r.start.row && start.column < r.start.column)) {
                  r.start.row = startRow;
                  r.start.column = start.column;
                } else if (r.start.row == endRow) {
                  if (r.start.column <= end.column) {
                    if (lineDif || r.start.column > start.column) {
                      r.start.column = start.column;
                      r.start.row = start.row;
                    }
                  } else {
                    r.start.column += colDiff;
                    r.start.row += lineDif;
                  }
                } else if (r.start.row > endRow) {
                  r.start.row += lineDif;
                }
              }
            }
            if (lineDif != 0 && i2 < n) {
              for (; i2 < n; i2++) {
                var r = ranges[i2];
                r.start.row += lineDif;
                r.end.row += lineDif;
              }
            }
          };
          return RangeList2;
        })()
      );
      RangeList.prototype.comparePoints = comparePoints;
      exports3.RangeList = RangeList;
    });
    ace.define("ace/edit_session/fold", ["require", "exports", "module", "ace/range_list"], function(require2, exports3, module3) {
      var __extends = this && this.__extends || /* @__PURE__ */ (function() {
        var extendStatics = function(d3, b2) {
          extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d4, b3) {
            d4.__proto__ = b3;
          } || function(d4, b3) {
            for (var p in b3) if (Object.prototype.hasOwnProperty.call(b3, p)) d4[p] = b3[p];
          };
          return extendStatics(d3, b2);
        };
        return function(d3, b2) {
          if (typeof b2 !== "function" && b2 !== null)
            throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
          extendStatics(d3, b2);
          function __() {
            this.constructor = d3;
          }
          d3.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
        };
      })();
      var RangeList = require2("../range_list").RangeList;
      var Fold = (
        /** @class */
        (function(_super) {
          __extends(Fold2, _super);
          function Fold2(range, placeholder) {
            var _this = _super.call(this) || this;
            _this.foldLine = null;
            _this.placeholder = placeholder;
            _this.range = range;
            _this.start = range.start;
            _this.end = range.end;
            _this.sameRow = range.start.row == range.end.row;
            _this.subFolds = _this.ranges = [];
            return _this;
          }
          Fold2.prototype.toString = function() {
            return '"' + this.placeholder + '" ' + this.range.toString();
          };
          Fold2.prototype.setFoldLine = function(foldLine) {
            this.foldLine = foldLine;
            this.subFolds.forEach(function(fold) {
              fold.setFoldLine(foldLine);
            });
          };
          Fold2.prototype.clone = function() {
            var range = this.range.clone();
            var fold = new Fold2(range, this.placeholder);
            this.subFolds.forEach(function(subFold) {
              fold.subFolds.push(subFold.clone());
            });
            fold.collapseChildren = this.collapseChildren;
            return fold;
          };
          Fold2.prototype.addSubFold = function(fold) {
            if (this.range.isEqual(fold))
              return;
            consumeRange(fold, this.start);
            var row = fold.start.row, column = fold.start.column;
            for (var i2 = 0, cmp = -1; i2 < this.subFolds.length; i2++) {
              cmp = this.subFolds[i2].range.compare(row, column);
              if (cmp != 1)
                break;
            }
            var afterStart = this.subFolds[i2];
            var firstConsumed = 0;
            if (cmp == 0) {
              if (afterStart.range.containsRange(fold))
                return afterStart.addSubFold(fold);
              else
                firstConsumed = 1;
            }
            var row = fold.range.end.row, column = fold.range.end.column;
            for (var j = i2, cmp = -1; j < this.subFolds.length; j++) {
              cmp = this.subFolds[j].range.compare(row, column);
              if (cmp != 1)
                break;
            }
            if (cmp == 0)
              j++;
            var consumedFolds = this.subFolds.splice(i2, j - i2, fold);
            var last = cmp == 0 ? consumedFolds.length - 1 : consumedFolds.length;
            for (var k2 = firstConsumed; k2 < last; k2++) {
              fold.addSubFold(consumedFolds[k2]);
            }
            fold.setFoldLine(this.foldLine);
            return fold;
          };
          Fold2.prototype.restoreRange = function(range) {
            return restoreRange(range, this.start);
          };
          return Fold2;
        })(RangeList)
      );
      function consumePoint(point, anchor) {
        point.row -= anchor.row;
        if (point.row == 0)
          point.column -= anchor.column;
      }
      function consumeRange(range, anchor) {
        consumePoint(range.start, anchor);
        consumePoint(range.end, anchor);
      }
      function restorePoint(point, anchor) {
        if (point.row == 0)
          point.column += anchor.column;
        point.row += anchor.row;
      }
      function restoreRange(range, anchor) {
        restorePoint(range.start, anchor);
        restorePoint(range.end, anchor);
      }
      exports3.Fold = Fold;
    });
    ace.define("ace/edit_session/folding", ["require", "exports", "module", "ace/range", "ace/edit_session/fold_line", "ace/edit_session/fold", "ace/token_iterator", "ace/mouse/mouse_event"], function(require2, exports3, module3) {
      var Range = require2("../range").Range;
      var FoldLine = require2("./fold_line").FoldLine;
      var Fold = require2("./fold").Fold;
      var TokenIterator = require2("../token_iterator").TokenIterator;
      var MouseEvent2 = require2("../mouse/mouse_event").MouseEvent;
      function Folding() {
        this.getFoldAt = function(row, column, side) {
          var foldLine = this.getFoldLine(row);
          if (!foldLine)
            return null;
          var folds = foldLine.folds;
          for (var i2 = 0; i2 < folds.length; i2++) {
            var range = folds[i2].range;
            if (range.contains(row, column)) {
              if (side == 1 && range.isEnd(row, column) && !range.isEmpty()) {
                continue;
              } else if (side == -1 && range.isStart(row, column) && !range.isEmpty()) {
                continue;
              }
              return folds[i2];
            }
          }
        };
        this.getFoldsInRange = function(range) {
          var start = range.start;
          var end = range.end;
          var foldLines = this.$foldData;
          var foundFolds = [];
          start.column += 1;
          end.column -= 1;
          for (var i2 = 0; i2 < foldLines.length; i2++) {
            var cmp = foldLines[i2].range.compareRange(range);
            if (cmp == 2) {
              continue;
            } else if (cmp == -2) {
              break;
            }
            var folds = foldLines[i2].folds;
            for (var j = 0; j < folds.length; j++) {
              var fold = folds[j];
              cmp = fold.range.compareRange(range);
              if (cmp == -2) {
                break;
              } else if (cmp == 2) {
                continue;
              } else if (cmp == 42) {
                break;
              }
              foundFolds.push(fold);
            }
          }
          start.column -= 1;
          end.column += 1;
          return foundFolds;
        };
        this.getFoldsInRangeList = function(ranges) {
          if (Array.isArray(ranges)) {
            var folds = [];
            ranges.forEach(function(range) {
              folds = folds.concat(this.getFoldsInRange(range));
            }, this);
          } else {
            var folds = this.getFoldsInRange(ranges);
          }
          return folds;
        };
        this.getAllFolds = function() {
          var folds = [];
          var foldLines = this.$foldData;
          for (var i2 = 0; i2 < foldLines.length; i2++)
            for (var j = 0; j < foldLines[i2].folds.length; j++)
              folds.push(foldLines[i2].folds[j]);
          return folds;
        };
        this.getFoldStringAt = function(row, column, trim, foldLine) {
          foldLine = foldLine || this.getFoldLine(row);
          if (!foldLine)
            return null;
          var lastFold = {
            end: { column: 0 }
          };
          var str, fold;
          for (var i2 = 0; i2 < foldLine.folds.length; i2++) {
            fold = foldLine.folds[i2];
            var cmp = fold.range.compareEnd(row, column);
            if (cmp == -1) {
              str = this.getLine(fold.start.row).substring(lastFold.end.column, fold.start.column);
              break;
            } else if (cmp === 0) {
              return null;
            }
            lastFold = fold;
          }
          if (!str)
            str = this.getLine(fold.start.row).substring(lastFold.end.column);
          if (trim == -1)
            return str.substring(0, column - lastFold.end.column);
          else if (trim == 1)
            return str.substring(column - lastFold.end.column);
          else
            return str;
        };
        this.getFoldLine = function(docRow, startFoldLine) {
          var foldData = this.$foldData;
          var i2 = 0;
          if (startFoldLine)
            i2 = foldData.indexOf(startFoldLine);
          if (i2 == -1)
            i2 = 0;
          for (i2; i2 < foldData.length; i2++) {
            var foldLine = foldData[i2];
            if (foldLine.start.row <= docRow && foldLine.end.row >= docRow) {
              return foldLine;
            } else if (foldLine.end.row > docRow) {
              return null;
            }
          }
          return null;
        };
        this.getNextFoldLine = function(docRow, startFoldLine) {
          var foldData = this.$foldData;
          var i2 = 0;
          if (startFoldLine)
            i2 = foldData.indexOf(startFoldLine);
          if (i2 == -1)
            i2 = 0;
          for (i2; i2 < foldData.length; i2++) {
            var foldLine = foldData[i2];
            if (foldLine.end.row >= docRow) {
              return foldLine;
            }
          }
          return null;
        };
        this.getFoldedRowCount = function(first, last) {
          var foldData = this.$foldData, rowCount = last - first + 1;
          for (var i2 = 0; i2 < foldData.length; i2++) {
            var foldLine = foldData[i2], end = foldLine.end.row, start = foldLine.start.row;
            if (end >= last) {
              if (start < last) {
                if (start >= first)
                  rowCount -= last - start;
                else
                  rowCount = 0;
              }
              break;
            } else if (end >= first) {
              if (start >= first)
                rowCount -= end - start;
              else
                rowCount -= end - first + 1;
            }
          }
          return rowCount;
        };
        this.$addFoldLine = function(foldLine) {
          this.$foldData.push(foldLine);
          this.$foldData.sort(function(a3, b2) {
            return a3.start.row - b2.start.row;
          });
          return foldLine;
        };
        this.addFold = function(placeholder, range) {
          var foldData = this.$foldData;
          var added = false;
          var fold;
          if (placeholder instanceof Fold)
            fold = placeholder;
          else {
            fold = new Fold(range, placeholder);
            fold.collapseChildren = range.collapseChildren;
          }
          this.$clipRangeToDocument(fold.range);
          var startRow = fold.start.row;
          var startColumn = fold.start.column;
          var endRow = fold.end.row;
          var endColumn = fold.end.column;
          var startFold = this.getFoldAt(startRow, startColumn, 1);
          var endFold = this.getFoldAt(endRow, endColumn, -1);
          if (startFold && endFold == startFold)
            return startFold.addSubFold(fold);
          if (startFold && !startFold.range.isStart(startRow, startColumn))
            this.removeFold(startFold);
          if (endFold && !endFold.range.isEnd(endRow, endColumn))
            this.removeFold(endFold);
          var folds = this.getFoldsInRange(fold.range);
          if (folds.length > 0) {
            this.removeFolds(folds);
            if (!fold.collapseChildren) {
              folds.forEach(function(subFold) {
                fold.addSubFold(subFold);
              });
            }
          }
          for (var i2 = 0; i2 < foldData.length; i2++) {
            var foldLine = foldData[i2];
            if (endRow == foldLine.start.row) {
              foldLine.addFold(fold);
              added = true;
              break;
            } else if (startRow == foldLine.end.row) {
              foldLine.addFold(fold);
              added = true;
              if (!fold.sameRow) {
                var foldLineNext = foldData[i2 + 1];
                if (foldLineNext && foldLineNext.start.row == endRow) {
                  foldLine.merge(foldLineNext);
                  break;
                }
              }
              break;
            } else if (endRow <= foldLine.start.row) {
              break;
            }
          }
          if (!added)
            foldLine = this.$addFoldLine(new FoldLine(this.$foldData, fold));
          if (this.$useWrapMode)
            this.$updateWrapData(foldLine.start.row, foldLine.start.row);
          else
            this.$updateRowLengthCache(foldLine.start.row, foldLine.start.row);
          this.$modified = true;
          this._signal("changeFold", { data: fold, action: "add" });
          return fold;
        };
        this.addFolds = function(folds) {
          folds.forEach(function(fold) {
            this.addFold(fold);
          }, this);
        };
        this.removeFold = function(fold) {
          var foldLine = fold.foldLine;
          var startRow = foldLine.start.row;
          var endRow = foldLine.end.row;
          var foldLines = this.$foldData;
          var folds = foldLine.folds;
          if (folds.length == 1) {
            foldLines.splice(foldLines.indexOf(foldLine), 1);
          } else if (foldLine.range.isEnd(fold.end.row, fold.end.column)) {
            folds.pop();
            foldLine.end.row = folds[folds.length - 1].end.row;
            foldLine.end.column = folds[folds.length - 1].end.column;
          } else if (foldLine.range.isStart(fold.start.row, fold.start.column)) {
            folds.shift();
            foldLine.start.row = folds[0].start.row;
            foldLine.start.column = folds[0].start.column;
          } else if (fold.sameRow) {
            folds.splice(folds.indexOf(fold), 1);
          } else {
            var newFoldLine = foldLine.split(fold.start.row, fold.start.column);
            folds = newFoldLine.folds;
            folds.shift();
            newFoldLine.start.row = folds[0].start.row;
            newFoldLine.start.column = folds[0].start.column;
          }
          if (!this.$updating) {
            if (this.$useWrapMode)
              this.$updateWrapData(startRow, endRow);
            else
              this.$updateRowLengthCache(startRow, endRow);
          }
          this.$modified = true;
          this._signal("changeFold", { data: fold, action: "remove" });
        };
        this.removeFolds = function(folds) {
          var cloneFolds = [];
          for (var i2 = 0; i2 < folds.length; i2++) {
            cloneFolds.push(folds[i2]);
          }
          cloneFolds.forEach(function(fold) {
            this.removeFold(fold);
          }, this);
          this.$modified = true;
        };
        this.expandFold = function(fold) {
          this.removeFold(fold);
          fold.subFolds.forEach(function(subFold) {
            fold.restoreRange(subFold);
            this.addFold(subFold);
          }, this);
          if (fold.collapseChildren > 0) {
            this.foldAll(fold.start.row + 1, fold.end.row, fold.collapseChildren - 1);
          }
          fold.subFolds = [];
        };
        this.expandFolds = function(folds) {
          folds.forEach(function(fold) {
            this.expandFold(fold);
          }, this);
        };
        this.unfold = function(location2, expandInner) {
          var range, folds;
          if (location2 == null) {
            range = new Range(0, 0, this.getLength(), 0);
            if (expandInner == null)
              expandInner = true;
          } else if (typeof location2 == "number") {
            range = new Range(location2, 0, location2, this.getLine(location2).length);
          } else if ("row" in location2) {
            range = Range.fromPoints(location2, location2);
          } else if (Array.isArray(location2)) {
            folds = [];
            location2.forEach(function(range2) {
              folds = folds.concat(this.unfold(range2));
            }, this);
            return folds;
          } else {
            range = location2;
          }
          folds = this.getFoldsInRangeList(range);
          var outermostFolds = folds;
          while (folds.length == 1 && Range.comparePoints(folds[0].start, range.start) < 0 && Range.comparePoints(folds[0].end, range.end) > 0) {
            this.expandFolds(folds);
            folds = this.getFoldsInRangeList(range);
          }
          if (expandInner != false) {
            this.removeFolds(folds);
          } else {
            this.expandFolds(folds);
          }
          if (outermostFolds.length)
            return outermostFolds;
        };
        this.isRowFolded = function(docRow, startFoldRow) {
          return !!this.getFoldLine(docRow, startFoldRow);
        };
        this.getRowFoldEnd = function(docRow, startFoldRow) {
          var foldLine = this.getFoldLine(docRow, startFoldRow);
          return foldLine ? foldLine.end.row : docRow;
        };
        this.getRowFoldStart = function(docRow, startFoldRow) {
          var foldLine = this.getFoldLine(docRow, startFoldRow);
          return foldLine ? foldLine.start.row : docRow;
        };
        this.getFoldDisplayLine = function(foldLine, endRow, endColumn, startRow, startColumn) {
          if (startRow == null)
            startRow = foldLine.start.row;
          if (startColumn == null)
            startColumn = 0;
          if (endRow == null)
            endRow = foldLine.end.row;
          if (endColumn == null)
            endColumn = this.getLine(endRow).length;
          var doc = this.doc;
          var textLine = "";
          foldLine.walk(function(placeholder, row, column, lastColumn) {
            if (row < startRow)
              return;
            if (row == startRow) {
              if (column < startColumn)
                return;
              lastColumn = Math.max(startColumn, lastColumn);
            }
            if (placeholder != null) {
              textLine += placeholder;
            } else {
              textLine += doc.getLine(row).substring(lastColumn, column);
            }
          }, endRow, endColumn);
          return textLine;
        };
        this.getDisplayLine = function(row, endColumn, startRow, startColumn) {
          var foldLine = this.getFoldLine(row);
          if (!foldLine) {
            var line;
            line = this.doc.getLine(row);
            return line.substring(startColumn || 0, endColumn || line.length);
          } else {
            return this.getFoldDisplayLine(foldLine, row, endColumn, startRow, startColumn);
          }
        };
        this.$cloneFoldData = function() {
          var fd = [];
          fd = this.$foldData.map(function(foldLine) {
            var folds = foldLine.folds.map(function(fold) {
              return fold.clone();
            });
            return new FoldLine(fd, folds);
          });
          return fd;
        };
        this.toggleFold = function(tryToUnfold) {
          var selection = this.selection;
          var range = selection.getRange();
          var fold;
          var bracketPos;
          if (range.isEmpty()) {
            var cursor = range.start;
            fold = this.getFoldAt(cursor.row, cursor.column);
            if (fold) {
              this.expandFold(fold);
              return;
            } else if (bracketPos = this.findMatchingBracket(cursor)) {
              if (range.comparePoint(bracketPos) == 1) {
                range.end = bracketPos;
              } else {
                range.start = bracketPos;
                range.start.column++;
                range.end.column--;
              }
            } else if (bracketPos = this.findMatchingBracket({ row: cursor.row, column: cursor.column + 1 })) {
              if (range.comparePoint(bracketPos) == 1)
                range.end = bracketPos;
              else
                range.start = bracketPos;
              range.start.column++;
            } else {
              range = this.getCommentFoldRange(cursor.row, cursor.column) || range;
            }
          } else {
            var folds = this.getFoldsInRange(range);
            if (tryToUnfold && folds.length) {
              this.expandFolds(folds);
              return;
            } else if (folds.length == 1) {
              fold = folds[0];
            }
          }
          if (!fold)
            fold = this.getFoldAt(range.start.row, range.start.column);
          if (fold && fold.range.toString() == range.toString()) {
            this.expandFold(fold);
            return;
          }
          var placeholder = "...";
          if (!range.isMultiLine()) {
            placeholder = this.getTextRange(range);
            if (placeholder.length < 4)
              return;
            placeholder = placeholder.trim().substring(0, 2) + "..";
          }
          this.addFold(placeholder, range);
        };
        this.getCommentFoldRange = function(row, column, dir) {
          var iterator = new TokenIterator(this, row, column);
          var token = iterator.getCurrentToken();
          var type = token && token.type;
          if (token && /^comment|string/.test(type)) {
            type = type.match(/comment|string/)[0];
            if (type == "comment")
              type += "|doc-start|\\.doc";
            var re2 = new RegExp(type);
            var range = new Range();
            if (dir != 1) {
              do {
                token = iterator.stepBackward();
              } while (token && re2.test(token.type));
              token = iterator.stepForward();
            }
            range.start.row = iterator.getCurrentTokenRow();
            range.start.column = iterator.getCurrentTokenColumn() + token.value.length;
            iterator = new TokenIterator(this, row, column);
            var initState = this.getState(iterator.$row);
            if (dir != -1) {
              var lastRow = -1;
              do {
                token = iterator.stepForward();
                if (lastRow == -1) {
                  var state = this.getState(iterator.$row);
                  if (initState.toString() !== state.toString())
                    lastRow = iterator.$row;
                } else if (iterator.$row > lastRow) {
                  break;
                }
              } while (token && re2.test(token.type));
              token = iterator.stepBackward();
            } else
              token = iterator.getCurrentToken();
            range.end.row = iterator.getCurrentTokenRow();
            range.end.column = iterator.getCurrentTokenColumn();
            return range;
          }
        };
        this.foldAll = function(startRow, endRow, depth, test) {
          if (depth == void 0)
            depth = 1e5;
          var foldWidgets = this.foldWidgets;
          if (!foldWidgets)
            return;
          endRow = endRow || this.getLength();
          startRow = startRow || 0;
          for (var row = startRow; row < endRow; row++) {
            if (foldWidgets[row] == null)
              foldWidgets[row] = this.getFoldWidget(row);
            if (foldWidgets[row] != "start")
              continue;
            if (test && !test(row))
              continue;
            var range = this.getFoldWidgetRange(row);
            if (range && range.isMultiLine() && range.end.row <= endRow && range.start.row >= startRow) {
              row = range.end.row;
              range.collapseChildren = depth;
              this.addFold("...", range);
            }
          }
        };
        this.foldToLevel = function(level) {
          this.foldAll();
          while (level-- > 0)
            this.unfold(null, false);
        };
        this.foldAllComments = function() {
          var session = this;
          this.foldAll(null, null, null, function(row) {
            var tokens = session.getTokens(row);
            for (var i2 = 0; i2 < tokens.length; i2++) {
              var token = tokens[i2];
              if (token.type == "text" && /^\s+$/.test(token.value))
                continue;
              if (/comment/.test(token.type))
                return true;
              return false;
            }
          });
        };
        this.$foldStyles = {
          "manual": 1,
          "markbegin": 1,
          "markbeginend": 1
        };
        this.$foldStyle = "markbegin";
        this.setFoldStyle = function(style) {
          if (!this.$foldStyles[style])
            throw new Error("invalid fold style: " + style + "[" + Object.keys(this.$foldStyles).join(", ") + "]");
          if (this.$foldStyle == style)
            return;
          this.$foldStyle = style;
          if (style == "manual")
            this.unfold();
          var mode = this.$foldMode;
          this.$setFolding(null);
          this.$setFolding(mode);
        };
        this.$setFolding = function(foldMode) {
          if (this.$foldMode == foldMode)
            return;
          this.$foldMode = foldMode;
          this.off("change", this.$updateFoldWidgets);
          this.off("tokenizerUpdate", this.$tokenizerUpdateFoldWidgets);
          this._signal("changeAnnotation");
          if (!foldMode || this.$foldStyle == "manual") {
            this.foldWidgets = null;
            return;
          }
          this.foldWidgets = [];
          this.getFoldWidget = foldMode.getFoldWidget.bind(foldMode, this, this.$foldStyle);
          this.getFoldWidgetRange = foldMode.getFoldWidgetRange.bind(foldMode, this, this.$foldStyle);
          this.$updateFoldWidgets = this.updateFoldWidgets.bind(this);
          this.$tokenizerUpdateFoldWidgets = this.tokenizerUpdateFoldWidgets.bind(this);
          this.on("change", this.$updateFoldWidgets);
          this.on("tokenizerUpdate", this.$tokenizerUpdateFoldWidgets);
        };
        this.getParentFoldRangeData = function(row, ignoreCurrent) {
          var fw = this.foldWidgets;
          if (!fw || ignoreCurrent && fw[row])
            return {};
          var i2 = row - 1, firstRange;
          while (i2 >= 0) {
            var c2 = fw[i2];
            if (c2 == null)
              c2 = fw[i2] = this.getFoldWidget(i2);
            if (c2 == "start") {
              var range = this.getFoldWidgetRange(i2);
              if (!firstRange)
                firstRange = range;
              if (range && range.end.row >= row)
                break;
            }
            i2--;
          }
          return {
            range: i2 !== -1 && range,
            firstRange
          };
        };
        this.onFoldWidgetClick = function(row, e2) {
          if (e2 instanceof MouseEvent2)
            e2 = e2.domEvent;
          var options = {
            children: e2.shiftKey,
            all: e2.ctrlKey || e2.metaKey,
            siblings: e2.altKey
          };
          var range = this.$toggleFoldWidget(row, options);
          if (!range) {
            var el = e2.target || e2.srcElement;
            if (el && /ace_fold-widget/.test(el.className))
              el.className += " ace_invalid";
          }
        };
        this.$toggleFoldWidget = function(row, options) {
          if (!this.getFoldWidget)
            return;
          var type = this.getFoldWidget(row);
          var line = this.getLine(row);
          var dir = type === "end" ? -1 : 1;
          var fold = this.getFoldAt(row, dir === -1 ? 0 : line.length, dir);
          if (fold) {
            if (options.children || options.all)
              this.removeFold(fold);
            else
              this.expandFold(fold);
            return fold;
          }
          var range = this.getFoldWidgetRange(row, true);
          if (range && !range.isMultiLine()) {
            fold = this.getFoldAt(range.start.row, range.start.column, 1);
            if (fold && range.isEqual(fold.range)) {
              this.removeFold(fold);
              return fold;
            }
          }
          if (options.siblings) {
            var data = this.getParentFoldRangeData(row);
            if (data.range) {
              var startRow = data.range.start.row + 1;
              var endRow = data.range.end.row;
            }
            this.foldAll(startRow, endRow, options.all ? 1e4 : 0);
          } else if (options.children) {
            endRow = range ? range.end.row : this.getLength();
            this.foldAll(row + 1, endRow, options.all ? 1e4 : 0);
          } else if (range) {
            if (options.all)
              range.collapseChildren = 1e4;
            this.addFold("...", range);
          }
          return range;
        };
        this.toggleFoldWidget = function(toggleParent) {
          var row = this.selection.getCursor().row;
          row = this.getRowFoldStart(row);
          var range = this.$toggleFoldWidget(row, {});
          if (range)
            return;
          var data = this.getParentFoldRangeData(row, true);
          range = data.range || data.firstRange;
          if (range) {
            row = range.start.row;
            var fold = this.getFoldAt(row, this.getLine(row).length, 1);
            if (fold) {
              this.removeFold(fold);
            } else {
              this.addFold("...", range);
            }
          }
        };
        this.updateFoldWidgets = function(delta) {
          var firstRow = delta.start.row;
          var len = delta.end.row - firstRow;
          if (len === 0) {
            this.foldWidgets[firstRow] = null;
          } else if (delta.action == "remove") {
            this.foldWidgets.splice(firstRow, len + 1, null);
          } else {
            var args = Array(len + 1);
            args.unshift(firstRow, 1);
            this.foldWidgets.splice.apply(this.foldWidgets, args);
          }
        };
        this.tokenizerUpdateFoldWidgets = function(e2) {
          var rows = e2.data;
          if (rows.first != rows.last) {
            if (this.foldWidgets.length > rows.first)
              this.foldWidgets.splice(rows.first, this.foldWidgets.length);
          }
        };
      }
      exports3.Folding = Folding;
    });
    ace.define("ace/edit_session/bracket_match", ["require", "exports", "module", "ace/token_iterator", "ace/range"], function(require2, exports3, module3) {
      var TokenIterator = require2("../token_iterator").TokenIterator;
      var Range = require2("../range").Range;
      function BracketMatch() {
        this.findMatchingBracket = function(position, chr) {
          if (position.column == 0)
            return null;
          var charBeforeCursor = chr || this.getLine(position.row).charAt(position.column - 1);
          if (charBeforeCursor == "")
            return null;
          var match2 = charBeforeCursor.match(/([\(\[\{])|([\)\]\}])/);
          if (!match2)
            return null;
          if (match2[1])
            return this.$findClosingBracket(match2[1], position);
          else
            return this.$findOpeningBracket(match2[2], position);
        };
        this.getBracketRange = function(pos) {
          var line = this.getLine(pos.row);
          var before = true, range;
          var chr = line.charAt(pos.column - 1);
          var match2 = chr && chr.match(/([\(\[\{])|([\)\]\}])/);
          if (!match2) {
            chr = line.charAt(pos.column);
            pos = { row: pos.row, column: pos.column + 1 };
            match2 = chr && chr.match(/([\(\[\{])|([\)\]\}])/);
            before = false;
          }
          if (!match2)
            return null;
          if (match2[1]) {
            var bracketPos = this.$findClosingBracket(match2[1], pos);
            if (!bracketPos)
              return null;
            range = Range.fromPoints(pos, bracketPos);
            if (!before) {
              range.end.column++;
              range.start.column--;
            }
            range.cursor = range.end;
          } else {
            var bracketPos = this.$findOpeningBracket(match2[2], pos);
            if (!bracketPos)
              return null;
            range = Range.fromPoints(bracketPos, pos);
            if (!before) {
              range.start.column++;
              range.end.column--;
            }
            range.cursor = range.start;
          }
          return range;
        };
        this.getMatchingBracketRanges = function(pos, isBackwards) {
          var line = this.getLine(pos.row);
          var bracketsRegExp = /([\(\[\{])|([\)\]\}])/;
          var chr = !isBackwards && line.charAt(pos.column - 1);
          var match2 = chr && chr.match(bracketsRegExp);
          if (!match2) {
            chr = (isBackwards === void 0 || isBackwards) && line.charAt(pos.column);
            pos = {
              row: pos.row,
              column: pos.column + 1
            };
            match2 = chr && chr.match(bracketsRegExp);
          }
          if (!match2)
            return null;
          var startRange = new Range(pos.row, pos.column - 1, pos.row, pos.column);
          var bracketPos = match2[1] ? this.$findClosingBracket(match2[1], pos) : this.$findOpeningBracket(match2[2], pos);
          if (!bracketPos)
            return [startRange];
          var endRange = new Range(bracketPos.row, bracketPos.column, bracketPos.row, bracketPos.column + 1);
          return [startRange, endRange];
        };
        this.$brackets = {
          ")": "(",
          "(": ")",
          "]": "[",
          "[": "]",
          "{": "}",
          "}": "{",
          "<": ">",
          ">": "<"
        };
        this.$findOpeningBracket = function(bracket, position, typeRe) {
          var openBracket = this.$brackets[bracket];
          var depth = 1;
          var iterator = new TokenIterator(this, position.row, position.column);
          var token = iterator.getCurrentToken();
          if (!token)
            token = iterator.stepForward();
          if (!token)
            return;
          if (!typeRe) {
            typeRe = new RegExp("(\\.?" + token.type.replace(".", "\\.").replace("rparen", ".paren").replace(/\b(?:end)\b/, "(?:start|begin|end)").replace(/-close\b/, "-(close|open)") + ")+");
          }
          var valueIndex = position.column - iterator.getCurrentTokenColumn() - 2;
          var value = token.value;
          while (true) {
            while (valueIndex >= 0) {
              var chr = value.charAt(valueIndex);
              if (chr == openBracket) {
                depth -= 1;
                if (depth == 0) {
                  return {
                    row: iterator.getCurrentTokenRow(),
                    column: valueIndex + iterator.getCurrentTokenColumn()
                  };
                }
              } else if (chr == bracket) {
                depth += 1;
              }
              valueIndex -= 1;
            }
            do {
              token = iterator.stepBackward();
            } while (token && !typeRe.test(token.type));
            if (token == null)
              break;
            value = token.value;
            valueIndex = value.length - 1;
          }
          return null;
        };
        this.$findClosingBracket = function(bracket, position, typeRe) {
          var closingBracket = this.$brackets[bracket];
          var depth = 1;
          var iterator = new TokenIterator(this, position.row, position.column);
          var token = iterator.getCurrentToken();
          if (!token)
            token = iterator.stepForward();
          if (!token)
            return;
          if (!typeRe) {
            typeRe = new RegExp("(\\.?" + token.type.replace(".", "\\.").replace("lparen", ".paren").replace(/\b(?:start|begin)\b/, "(?:start|begin|end)").replace(/-open\b/, "-(close|open)") + ")+");
          }
          var valueIndex = position.column - iterator.getCurrentTokenColumn();
          while (true) {
            var value = token.value;
            var valueLength = value.length;
            while (valueIndex < valueLength) {
              var chr = value.charAt(valueIndex);
              if (chr == closingBracket) {
                depth -= 1;
                if (depth == 0) {
                  return {
                    row: iterator.getCurrentTokenRow(),
                    column: valueIndex + iterator.getCurrentTokenColumn()
                  };
                }
              } else if (chr == bracket) {
                depth += 1;
              }
              valueIndex += 1;
            }
            do {
              token = iterator.stepForward();
            } while (token && !typeRe.test(token.type));
            if (token == null)
              break;
            valueIndex = 0;
          }
          return null;
        };
        this.getMatchingTags = function(pos) {
          var iterator = new TokenIterator(this, pos.row, pos.column);
          var token = this.$findTagName(iterator);
          if (!token)
            return;
          var prevToken = iterator.stepBackward();
          if (prevToken.value === "<") {
            return this.$findClosingTag(iterator, token);
          } else {
            return this.$findOpeningTag(iterator, token);
          }
        };
        this.$findTagName = function(iterator) {
          var token = iterator.getCurrentToken();
          var found = false;
          var backward = false;
          if (token && token.type.indexOf("tag-name") === -1) {
            do {
              if (backward)
                token = iterator.stepBackward();
              else
                token = iterator.stepForward();
              if (token) {
                if (token.value === "/>") {
                  backward = true;
                } else if (token.type.indexOf("tag-name") !== -1) {
                  found = true;
                }
              }
            } while (token && !found);
          }
          return token;
        };
        this.$findClosingTag = function(iterator, token) {
          var prevToken;
          var currentTag = token.value;
          var tag = token.value;
          var depth = 0;
          var openTagStart = new Range(iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn(), iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn() + 1);
          token = iterator.stepForward();
          var openTagName = new Range(iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn(), iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn() + token.value.length);
          var foundOpenTagEnd = false;
          do {
            prevToken = token;
            if (prevToken.type.indexOf("tag-close") !== -1 && !foundOpenTagEnd) {
              var openTagEnd = new Range(iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn(), iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn() + 1);
              foundOpenTagEnd = true;
            }
            token = iterator.stepForward();
            if (token) {
              if (token.value === ">" && !foundOpenTagEnd) {
                var openTagEnd = new Range(iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn(), iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn() + 1);
                foundOpenTagEnd = true;
              }
              if (token.type.indexOf("tag-name") !== -1) {
                currentTag = token.value;
                if (tag === currentTag) {
                  if (prevToken.value === "<") {
                    depth++;
                  } else if (prevToken.value === "</") {
                    depth--;
                    if (depth < 0) {
                      iterator.stepBackward();
                      var closeTagStart = new Range(iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn(), iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn() + 2);
                      token = iterator.stepForward();
                      var closeTagName = new Range(iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn(), iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn() + token.value.length);
                      if (token.type.indexOf("tag-close") === -1) {
                        token = iterator.stepForward();
                      }
                      if (token && token.value === ">") {
                        var closeTagEnd = new Range(iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn(), iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn() + 1);
                      } else {
                        return;
                      }
                    }
                  }
                }
              } else if (tag === currentTag && token.value === "/>") {
                depth--;
                if (depth < 0) {
                  var closeTagStart = new Range(iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn(), iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn() + 2);
                  var closeTagName = closeTagStart;
                  var closeTagEnd = closeTagName;
                  var openTagEnd = new Range(openTagName.end.row, openTagName.end.column, openTagName.end.row, openTagName.end.column + 1);
                }
              }
            }
          } while (token && depth >= 0);
          if (openTagStart && openTagEnd && closeTagStart && closeTagEnd && openTagName && closeTagName) {
            return {
              openTag: new Range(openTagStart.start.row, openTagStart.start.column, openTagEnd.end.row, openTagEnd.end.column),
              closeTag: new Range(closeTagStart.start.row, closeTagStart.start.column, closeTagEnd.end.row, closeTagEnd.end.column),
              openTagName,
              closeTagName
            };
          }
        };
        this.$findOpeningTag = function(iterator, token) {
          var prevToken = iterator.getCurrentToken();
          var tag = token.value;
          var depth = 0;
          var startRow = iterator.getCurrentTokenRow();
          var startColumn = iterator.getCurrentTokenColumn();
          var endColumn = startColumn + 2;
          var closeTagStart = new Range(startRow, startColumn, startRow, endColumn);
          iterator.stepForward();
          var closeTagName = new Range(iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn(), iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn() + token.value.length);
          if (token.type.indexOf("tag-close") === -1) {
            token = iterator.stepForward();
          }
          if (!token || token.value !== ">")
            return;
          var closeTagEnd = new Range(iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn(), iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn() + 1);
          iterator.stepBackward();
          iterator.stepBackward();
          do {
            token = prevToken;
            startRow = iterator.getCurrentTokenRow();
            startColumn = iterator.getCurrentTokenColumn();
            endColumn = startColumn + token.value.length;
            prevToken = iterator.stepBackward();
            if (token) {
              if (token.type.indexOf("tag-name") !== -1) {
                if (tag === token.value) {
                  if (prevToken.value === "<") {
                    depth++;
                    if (depth > 0) {
                      var openTagName = new Range(startRow, startColumn, startRow, endColumn);
                      var openTagStart = new Range(iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn(), iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn() + 1);
                      do {
                        token = iterator.stepForward();
                      } while (token && token.value !== ">");
                      var openTagEnd = new Range(iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn(), iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn() + 1);
                    }
                  } else if (prevToken.value === "</") {
                    depth--;
                  }
                }
              } else if (token.value === "/>") {
                var stepCount = 0;
                var tmpToken = prevToken;
                while (tmpToken) {
                  if (tmpToken.type.indexOf("tag-name") !== -1 && tmpToken.value === tag) {
                    depth--;
                    break;
                  } else if (tmpToken.value === "<") {
                    break;
                  }
                  tmpToken = iterator.stepBackward();
                  stepCount++;
                }
                for (var i2 = 0; i2 < stepCount; i2++) {
                  iterator.stepForward();
                }
              }
            }
          } while (prevToken && depth <= 0);
          if (openTagStart && openTagEnd && closeTagStart && closeTagEnd && openTagName && closeTagName) {
            return {
              openTag: new Range(openTagStart.start.row, openTagStart.start.column, openTagEnd.end.row, openTagEnd.end.column),
              closeTag: new Range(closeTagStart.start.row, closeTagStart.start.column, closeTagEnd.end.row, closeTagEnd.end.column),
              openTagName,
              closeTagName
            };
          }
        };
      }
      exports3.BracketMatch = BracketMatch;
    });
    ace.define("ace/edit_session", ["require", "exports", "module", "ace/lib/oop", "ace/lib/lang", "ace/bidihandler", "ace/config", "ace/lib/event_emitter", "ace/selection", "ace/mode/text", "ace/range", "ace/line_widgets", "ace/document", "ace/background_tokenizer", "ace/search_highlight", "ace/undomanager", "ace/edit_session/folding", "ace/edit_session/bracket_match"], function(require2, exports3, module3) {
      var oop = require2("./lib/oop");
      var lang = require2("./lib/lang");
      var BidiHandler = require2("./bidihandler").BidiHandler;
      var config = require2("./config");
      var EventEmitter = require2("./lib/event_emitter").EventEmitter;
      var Selection = require2("./selection").Selection;
      var TextMode = require2("./mode/text").Mode;
      var Range = require2("./range").Range;
      var LineWidgets = require2("./line_widgets").LineWidgets;
      var Document2 = require2("./document").Document;
      var BackgroundTokenizer = require2("./background_tokenizer").BackgroundTokenizer;
      var SearchHighlight = require2("./search_highlight").SearchHighlight;
      var UndoManager = require2("./undomanager").UndoManager;
      var EditSession = (
        /** @class */
        (function() {
          function EditSession2(text, mode) {
            this.doc;
            this.$breakpoints = [];
            this.$decorations = [];
            this.$frontMarkers = {};
            this.$backMarkers = {};
            this.$markerId = 1;
            this.$undoSelect = true;
            this.$editor = null;
            this.prevOp = {};
            this.$foldData = [];
            this.id = "session" + ++EditSession2.$uid;
            this.$foldData.toString = function() {
              return this.join("\n");
            };
            this.bgTokenizer = new BackgroundTokenizer(new TextMode().getTokenizer(), this);
            var _self = this;
            this.bgTokenizer.on("update", function(e2) {
              _self._signal("tokenizerUpdate", e2);
            });
            this.on("changeFold", this.onChangeFold.bind(this));
            this.$onChange = this.onChange.bind(this);
            if (typeof text != "object" || !text.getLine)
              text = new Document2(
                /**@type{string}*/
                text
              );
            this.setDocument(text);
            this.selection = new Selection(this);
            this.$onSelectionChange = this.onSelectionChange.bind(this);
            this.selection.on("changeSelection", this.$onSelectionChange);
            this.selection.on("changeCursor", this.$onSelectionChange);
            this.$bidiHandler = new BidiHandler(this);
            config.resetOptions(this);
            this.setMode(mode);
            config._signal("session", this);
            this.destroyed = false;
            this.$initOperationListeners();
          }
          EditSession2.prototype.$initOperationListeners = function() {
            var _this = this;
            this.curOp = null;
            this.on("change", function() {
              if (!_this.curOp) {
                _this.startOperation();
                _this.curOp.selectionBefore = _this.$lastSel;
              }
              _this.curOp.docChanged = true;
            }, true);
            this.on("changeSelection", function() {
              if (!_this.curOp) {
                _this.startOperation();
                _this.curOp.selectionBefore = _this.$lastSel;
              }
              _this.curOp.selectionChanged = true;
            }, true);
            this.$operationResetTimer = lang.delayedCall(this.endOperation.bind(this, true));
          };
          EditSession2.prototype.startOperation = function(commandEvent) {
            if (this.curOp) {
              if (!commandEvent || this.curOp.command) {
                return;
              }
              this.prevOp = this.curOp;
            }
            if (!commandEvent) {
              commandEvent = {};
            }
            this.$operationResetTimer.schedule();
            this.curOp = {
              command: commandEvent.command || {},
              args: commandEvent.args
            };
            this.curOp.selectionBefore = this.selection.toJSON();
            this._signal("startOperation", commandEvent);
          };
          EditSession2.prototype.endOperation = function(e2) {
            if (this.curOp) {
              if (e2 && e2.returnValue === false) {
                this.curOp = null;
                this._signal("endOperation", e2);
                return;
              }
              if (e2 == true && this.curOp.command && this.curOp.command.name == "mouse") {
                return;
              }
              var currentSelection = this.selection.toJSON();
              this.curOp.selectionAfter = currentSelection;
              this.$lastSel = this.selection.toJSON();
              this.getUndoManager().addSelection(currentSelection);
              this._signal("beforeEndOperation");
              this.prevOp = this.curOp;
              this.curOp = null;
              this._signal("endOperation", e2);
            }
          };
          EditSession2.prototype.setDocument = function(doc) {
            if (this.doc)
              this.doc.off("change", this.$onChange);
            this.doc = doc;
            doc.on("change", this.$onChange, true);
            this.bgTokenizer.setDocument(this.getDocument());
            this.resetCaches();
          };
          EditSession2.prototype.getDocument = function() {
            return this.doc;
          };
          Object.defineProperty(EditSession2.prototype, "widgetManager", {
            get: function() {
              var widgetManager = new LineWidgets(this);
              this.widgetManager = widgetManager;
              if (this.$editor)
                widgetManager.attach(this.$editor);
              return widgetManager;
            },
            set: function(value) {
              Object.defineProperty(this, "widgetManager", {
                writable: true,
                enumerable: true,
                configurable: true,
                value
              });
            },
            enumerable: false,
            configurable: true
          });
          EditSession2.prototype.$resetRowCache = function(docRow) {
            if (!docRow) {
              this.$docRowCache = [];
              this.$screenRowCache = [];
              return;
            }
            var l = this.$docRowCache.length;
            var i2 = this.$getRowCacheIndex(this.$docRowCache, docRow) + 1;
            if (l > i2) {
              this.$docRowCache.splice(i2, l);
              this.$screenRowCache.splice(i2, l);
            }
          };
          EditSession2.prototype.$getRowCacheIndex = function(cacheArray, val) {
            var low = 0;
            var hi = cacheArray.length - 1;
            while (low <= hi) {
              var mid = low + hi >> 1;
              var c2 = cacheArray[mid];
              if (val > c2)
                low = mid + 1;
              else if (val < c2)
                hi = mid - 1;
              else
                return mid;
            }
            return low - 1;
          };
          EditSession2.prototype.resetCaches = function() {
            this.$modified = true;
            this.$wrapData = [];
            this.$rowLengthCache = [];
            this.$resetRowCache(0);
            if (!this.destroyed)
              this.bgTokenizer.start(0);
          };
          EditSession2.prototype.onChangeFold = function(e2) {
            var fold = e2.data;
            this.$resetRowCache(fold.start.row);
          };
          EditSession2.prototype.onChange = function(delta) {
            this.$modified = true;
            this.$bidiHandler.onChange(delta);
            this.$resetRowCache(delta.start.row);
            var removedFolds = this.$updateInternalDataOnChange(delta);
            if (!this.$fromUndo && this.$undoManager) {
              if (removedFolds && removedFolds.length) {
                this.$undoManager.add({
                  action: "removeFolds",
                  folds: removedFolds
                }, this.mergeUndoDeltas);
                this.mergeUndoDeltas = true;
              }
              this.$undoManager.add(delta, this.mergeUndoDeltas);
              this.mergeUndoDeltas = true;
              this.$informUndoManager.schedule();
            }
            this.bgTokenizer.$updateOnChange(delta);
            this._signal("change", delta);
          };
          EditSession2.prototype.onSelectionChange = function() {
            this._signal("changeSelection");
          };
          EditSession2.prototype.setValue = function(text) {
            this.doc.setValue(text);
            this.selection.moveTo(0, 0);
            this.$resetRowCache(0);
            this.setUndoManager(this.$undoManager);
            this.getUndoManager().reset();
          };
          EditSession2.fromJSON = function(session) {
            if (typeof session == "string")
              session = JSON.parse(session);
            var undoManager = new UndoManager();
            undoManager.$undoStack = session.history.undo;
            undoManager.$redoStack = session.history.redo;
            undoManager.mark = session.history.mark;
            undoManager.$rev = session.history.rev;
            var editSession = new EditSession2(session.value);
            session.folds.forEach(function(fold) {
              editSession.addFold("...", Range.fromPoints(fold.start, fold.end));
            });
            editSession.setAnnotations(session.annotations);
            editSession.setBreakpoints(session.breakpoints);
            editSession.setMode(session.mode);
            editSession.setScrollLeft(session.scrollLeft);
            editSession.setScrollTop(session.scrollTop);
            editSession.setUndoManager(undoManager);
            editSession.selection.fromJSON(session.selection);
            return editSession;
          };
          EditSession2.prototype.toJSON = function() {
            return {
              annotations: this.$annotations,
              breakpoints: this.$breakpoints,
              folds: this.getAllFolds().map(function(fold) {
                return fold.range;
              }),
              history: this.getUndoManager(),
              mode: this.$mode.$id,
              scrollLeft: this.$scrollLeft,
              scrollTop: this.$scrollTop,
              selection: this.selection.toJSON(),
              value: this.doc.getValue()
            };
          };
          EditSession2.prototype.toString = function() {
            return this.doc.getValue();
          };
          EditSession2.prototype.getSelection = function() {
            return this.selection;
          };
          EditSession2.prototype.getState = function(row) {
            return this.bgTokenizer.getState(row);
          };
          EditSession2.prototype.getTokens = function(row) {
            return this.bgTokenizer.getTokens(row);
          };
          EditSession2.prototype.getTokenAt = function(row, column) {
            var tokens = this.bgTokenizer.getTokens(row);
            var token, c2 = 0;
            if (column == null) {
              var i2 = tokens.length - 1;
              c2 = this.getLine(row).length;
            } else {
              for (var i2 = 0; i2 < tokens.length; i2++) {
                c2 += tokens[i2].value.length;
                if (c2 >= column)
                  break;
              }
            }
            token = tokens[i2];
            if (!token)
              return null;
            token.index = i2;
            token.start = c2 - token.value.length;
            return token;
          };
          EditSession2.prototype.setUndoManager = function(undoManager) {
            this.$undoManager = undoManager;
            if (this.$informUndoManager)
              this.$informUndoManager.cancel();
            if (undoManager) {
              var self2 = this;
              undoManager.addSession(this);
              this.$syncInformUndoManager = function() {
                self2.$informUndoManager.cancel();
                self2.mergeUndoDeltas = false;
              };
              this.$informUndoManager = lang.delayedCall(this.$syncInformUndoManager);
            } else {
              this.$syncInformUndoManager = function() {
              };
            }
          };
          EditSession2.prototype.markUndoGroup = function() {
            if (this.$syncInformUndoManager)
              this.$syncInformUndoManager();
          };
          EditSession2.prototype.getUndoManager = function() {
            return this.$undoManager || this.$defaultUndoManager;
          };
          EditSession2.prototype.getTabString = function() {
            if (this.getUseSoftTabs()) {
              return lang.stringRepeat(" ", this.getTabSize());
            } else {
              return "	";
            }
          };
          EditSession2.prototype.setUseSoftTabs = function(val) {
            this.setOption("useSoftTabs", val);
          };
          EditSession2.prototype.getUseSoftTabs = function() {
            return this.$useSoftTabs && !this.$mode.$indentWithTabs;
          };
          EditSession2.prototype.setTabSize = function(tabSize) {
            this.setOption("tabSize", tabSize);
          };
          EditSession2.prototype.getTabSize = function() {
            return this.$tabSize;
          };
          EditSession2.prototype.isTabStop = function(position) {
            return this.$useSoftTabs && position.column % this.$tabSize === 0;
          };
          EditSession2.prototype.setNavigateWithinSoftTabs = function(navigateWithinSoftTabs) {
            this.setOption("navigateWithinSoftTabs", navigateWithinSoftTabs);
          };
          EditSession2.prototype.getNavigateWithinSoftTabs = function() {
            return this.$navigateWithinSoftTabs;
          };
          EditSession2.prototype.setOverwrite = function(overwrite) {
            this.setOption("overwrite", overwrite);
          };
          EditSession2.prototype.getOverwrite = function() {
            return this.$overwrite;
          };
          EditSession2.prototype.toggleOverwrite = function() {
            this.setOverwrite(!this.$overwrite);
          };
          EditSession2.prototype.addGutterDecoration = function(row, className) {
            if (!this.$decorations[row])
              this.$decorations[row] = "";
            this.$decorations[row] += " " + className;
            this._signal("changeBreakpoint", {});
          };
          EditSession2.prototype.removeGutterDecoration = function(row, className) {
            this.$decorations[row] = (this.$decorations[row] || "").replace(" " + className, "");
            this._signal("changeBreakpoint", {});
          };
          EditSession2.prototype.getBreakpoints = function() {
            return this.$breakpoints;
          };
          EditSession2.prototype.setBreakpoints = function(rows) {
            this.$breakpoints = [];
            for (var i2 = 0; i2 < rows.length; i2++) {
              this.$breakpoints[rows[i2]] = "ace_breakpoint";
            }
            this._signal("changeBreakpoint", {});
          };
          EditSession2.prototype.clearBreakpoints = function() {
            this.$breakpoints = [];
            this._signal("changeBreakpoint", {});
          };
          EditSession2.prototype.setBreakpoint = function(row, className) {
            if (className === void 0)
              className = "ace_breakpoint";
            if (className)
              this.$breakpoints[row] = className;
            else
              delete this.$breakpoints[row];
            this._signal("changeBreakpoint", {});
          };
          EditSession2.prototype.clearBreakpoint = function(row) {
            delete this.$breakpoints[row];
            this._signal("changeBreakpoint", {});
          };
          EditSession2.prototype.addMarker = function(range, clazz, type, inFront) {
            var id = this.$markerId++;
            var marker = {
              range,
              type: type || "line",
              renderer: typeof type == "function" ? type : null,
              clazz,
              inFront: !!inFront,
              id
            };
            if (inFront) {
              this.$frontMarkers[id] = marker;
              this._signal("changeFrontMarker");
            } else {
              this.$backMarkers[id] = marker;
              this._signal("changeBackMarker");
            }
            return id;
          };
          EditSession2.prototype.addDynamicMarker = function(marker, inFront) {
            if (!marker.update)
              return;
            var id = this.$markerId++;
            marker.id = id;
            marker.inFront = !!inFront;
            if (inFront) {
              this.$frontMarkers[id] = marker;
              this._signal("changeFrontMarker");
            } else {
              this.$backMarkers[id] = marker;
              this._signal("changeBackMarker");
            }
            return marker;
          };
          EditSession2.prototype.removeMarker = function(markerId) {
            var marker = this.$frontMarkers[markerId] || this.$backMarkers[markerId];
            if (!marker)
              return;
            var markers = marker.inFront ? this.$frontMarkers : this.$backMarkers;
            delete markers[markerId];
            this._signal(marker.inFront ? "changeFrontMarker" : "changeBackMarker");
          };
          EditSession2.prototype.getMarkers = function(inFront) {
            return inFront ? this.$frontMarkers : this.$backMarkers;
          };
          EditSession2.prototype.highlight = function(re2) {
            if (!this.$searchHighlight) {
              var highlight = new SearchHighlight(null, "ace_selected-word", "text");
              this.$searchHighlight = this.addDynamicMarker(highlight);
            }
            this.$searchHighlight.setRegexp(re2);
          };
          EditSession2.prototype.highlightLines = function(startRow, endRow, clazz, inFront) {
            if (typeof endRow != "number") {
              clazz = endRow;
              endRow = startRow;
            }
            if (!clazz)
              clazz = "ace_step";
            var range = new Range(startRow, 0, endRow, Infinity);
            range.id = this.addMarker(range, clazz, "fullLine", inFront);
            return range;
          };
          EditSession2.prototype.setAnnotations = function(annotations) {
            this.$annotations = annotations;
            this._signal("changeAnnotation", {});
          };
          EditSession2.prototype.getAnnotations = function() {
            return this.$annotations || [];
          };
          EditSession2.prototype.clearAnnotations = function() {
            this.setAnnotations([]);
          };
          EditSession2.prototype.$detectNewLine = function(text) {
            var match2 = text.match(/^.*?(\r?\n)/m);
            if (match2) {
              this.$autoNewLine = match2[1];
            } else {
              this.$autoNewLine = "\n";
            }
          };
          EditSession2.prototype.getWordRange = function(row, column) {
            var line = this.getLine(row);
            var inToken = false;
            if (column > 0)
              inToken = !!line.charAt(column - 1).match(this.tokenRe);
            if (!inToken)
              inToken = !!line.charAt(column).match(this.tokenRe);
            if (inToken)
              var re2 = this.tokenRe;
            else if (/^\s+$/.test(line.slice(column - 1, column + 1)))
              var re2 = /\s/;
            else
              var re2 = this.nonTokenRe;
            var start = column;
            if (start > 0) {
              do {
                start--;
              } while (start >= 0 && line.charAt(start).match(re2));
              start++;
            }
            var end = column;
            while (end < line.length && line.charAt(end).match(re2)) {
              end++;
            }
            return new Range(row, start, row, end);
          };
          EditSession2.prototype.getAWordRange = function(row, column) {
            var wordRange = this.getWordRange(row, column);
            var line = this.getLine(wordRange.end.row);
            while (line.charAt(wordRange.end.column).match(/[ \t]/)) {
              wordRange.end.column += 1;
            }
            return wordRange;
          };
          EditSession2.prototype.setNewLineMode = function(newLineMode) {
            this.doc.setNewLineMode(newLineMode);
          };
          EditSession2.prototype.getNewLineMode = function() {
            return this.doc.getNewLineMode();
          };
          EditSession2.prototype.setUseWorker = function(useWorker) {
            this.setOption("useWorker", useWorker);
          };
          EditSession2.prototype.getUseWorker = function() {
            return this.$useWorker;
          };
          EditSession2.prototype.onReloadTokenizer = function(e2) {
            var rows = e2.data;
            this.bgTokenizer.start(rows.first);
            this._signal("tokenizerUpdate", e2);
          };
          EditSession2.prototype.setMode = function(mode, cb) {
            if (mode && typeof mode === "object") {
              if (mode.getTokenizer)
                return this.$onChangeMode(mode);
              var options = mode;
              var path = options.path;
            } else {
              path = /**@type{string}*/
              mode || "ace/mode/text";
            }
            if (!this.$modes["ace/mode/text"])
              this.$modes["ace/mode/text"] = new TextMode();
            if (this.$modes[path] && !options) {
              this.$onChangeMode(this.$modes[path]);
              cb && cb();
              return;
            }
            this.$modeId = path;
            config.loadModule(["mode", path], (function(m3) {
              if (this.destroyed) {
                return;
              }
              if (this.$modeId !== path)
                return cb && cb();
              if (this.$modes[path] && !options) {
                this.$onChangeMode(this.$modes[path]);
              } else if (m3 && m3.Mode) {
                m3 = new m3.Mode(options);
                if (!options) {
                  this.$modes[path] = m3;
                  m3.$id = path;
                }
                this.$onChangeMode(m3);
              }
              cb && cb();
            }).bind(this));
            if (!this.$mode)
              this.$onChangeMode(this.$modes["ace/mode/text"], true);
          };
          EditSession2.prototype.$onChangeMode = function(mode, $isPlaceholder) {
            if (!$isPlaceholder)
              this.$modeId = mode.$id;
            if (this.$mode === mode)
              return;
            var oldMode = this.$mode;
            this.$mode = mode;
            this.$stopWorker();
            if (this.$useWorker)
              this.$startWorker();
            var tokenizer = mode.getTokenizer();
            if (tokenizer.on !== void 0) {
              var onReloadTokenizer = this.onReloadTokenizer.bind(this);
              tokenizer.on("update", onReloadTokenizer);
            }
            this.bgTokenizer.setTokenizer(tokenizer);
            this.bgTokenizer.setDocument(this.getDocument());
            this.tokenRe = mode.tokenRe;
            this.nonTokenRe = mode.nonTokenRe;
            if (!$isPlaceholder) {
              if (mode.attachToSession)
                mode.attachToSession(this);
              this.$options.wrapMethod.set.call(this, this.$wrapMethod);
              this.$setFolding(mode.foldingRules);
              this.bgTokenizer.start(0);
              this._emit("changeMode", { oldMode, mode });
            }
          };
          EditSession2.prototype.$stopWorker = function() {
            if (this.$worker) {
              this.$worker.terminate();
              this.$worker = null;
            }
          };
          EditSession2.prototype.$startWorker = function() {
            try {
              this.$worker = this.$mode.createWorker(this);
            } catch (e2) {
              config.warn("Could not load worker", e2);
              this.$worker = null;
            }
          };
          EditSession2.prototype.getMode = function() {
            return this.$mode;
          };
          EditSession2.prototype.setScrollTop = function(scrollTop) {
            if (this.$scrollTop === scrollTop || isNaN(scrollTop))
              return;
            this.$scrollTop = scrollTop;
            this._signal("changeScrollTop", scrollTop);
          };
          EditSession2.prototype.getScrollTop = function() {
            return this.$scrollTop;
          };
          EditSession2.prototype.setScrollLeft = function(scrollLeft) {
            if (this.$scrollLeft === scrollLeft || isNaN(scrollLeft))
              return;
            this.$scrollLeft = scrollLeft;
            this._signal("changeScrollLeft", scrollLeft);
          };
          EditSession2.prototype.getScrollLeft = function() {
            return this.$scrollLeft;
          };
          EditSession2.prototype.getScreenWidth = function() {
            this.$computeWidth();
            if (this.lineWidgets)
              return Math.max(this.getLineWidgetMaxWidth(), this.screenWidth);
            return this.screenWidth;
          };
          EditSession2.prototype.getLineWidgetMaxWidth = function() {
            if (this.lineWidgetsWidth != null)
              return this.lineWidgetsWidth;
            var width = 0;
            this.lineWidgets.forEach(function(w2) {
              if (w2 && w2.screenWidth > width)
                width = w2.screenWidth;
            });
            return this.lineWidgetWidth = width;
          };
          EditSession2.prototype.$computeWidth = function(force) {
            if (this.$modified || force) {
              this.$modified = false;
              if (this.$useWrapMode)
                return this.screenWidth = this.$wrapLimit;
              var lines = this.doc.getAllLines();
              var cache = this.$rowLengthCache;
              var longestScreenLine = 0;
              var foldIndex = 0;
              var foldLine = this.$foldData[foldIndex];
              var foldStart = foldLine ? foldLine.start.row : Infinity;
              var len = lines.length;
              for (var i2 = 0; i2 < len; i2++) {
                if (i2 > foldStart) {
                  i2 = foldLine.end.row + 1;
                  if (i2 >= len)
                    break;
                  foldLine = this.$foldData[foldIndex++];
                  foldStart = foldLine ? foldLine.start.row : Infinity;
                }
                if (cache[i2] == null)
                  cache[i2] = this.$getStringScreenWidth(lines[i2])[0];
                if (cache[i2] > longestScreenLine)
                  longestScreenLine = cache[i2];
              }
              this.screenWidth = longestScreenLine;
            }
          };
          EditSession2.prototype.getLine = function(row) {
            return this.doc.getLine(row);
          };
          EditSession2.prototype.getLines = function(firstRow, lastRow) {
            return this.doc.getLines(firstRow, lastRow);
          };
          EditSession2.prototype.getLength = function() {
            return this.doc.getLength();
          };
          EditSession2.prototype.getTextRange = function(range) {
            return this.doc.getTextRange(range || this.selection.getRange());
          };
          EditSession2.prototype.insert = function(position, text) {
            return this.doc.insert(position, text);
          };
          EditSession2.prototype.remove = function(range) {
            return this.doc.remove(range);
          };
          EditSession2.prototype.removeFullLines = function(firstRow, lastRow) {
            return this.doc.removeFullLines(firstRow, lastRow);
          };
          EditSession2.prototype.undoChanges = function(deltas, dontSelect) {
            if (!deltas.length)
              return;
            this.$fromUndo = true;
            for (var i2 = deltas.length - 1; i2 != -1; i2--) {
              var delta = deltas[i2];
              if (delta.action == "insert" || delta.action == "remove") {
                this.doc.revertDelta(delta);
              } else if (delta.folds) {
                this.addFolds(delta.folds);
              }
            }
            if (!dontSelect && this.$undoSelect) {
              if (deltas.selectionBefore)
                this.selection.fromJSON(deltas.selectionBefore);
              else
                this.selection.setRange(this.$getUndoSelection(deltas, true));
            }
            this.$fromUndo = false;
          };
          EditSession2.prototype.redoChanges = function(deltas, dontSelect) {
            if (!deltas.length)
              return;
            this.$fromUndo = true;
            for (var i2 = 0; i2 < deltas.length; i2++) {
              var delta = deltas[i2];
              if (delta.action == "insert" || delta.action == "remove") {
                this.doc.$safeApplyDelta(delta);
              }
            }
            if (!dontSelect && this.$undoSelect) {
              if (deltas.selectionAfter)
                this.selection.fromJSON(deltas.selectionAfter);
              else
                this.selection.setRange(this.$getUndoSelection(deltas, false));
            }
            this.$fromUndo = false;
          };
          EditSession2.prototype.setUndoSelect = function(enable) {
            this.$undoSelect = enable;
          };
          EditSession2.prototype.$getUndoSelection = function(deltas, isUndo) {
            function isInsert(delta2) {
              return isUndo ? delta2.action !== "insert" : delta2.action === "insert";
            }
            var range, point;
            for (var i2 = 0; i2 < deltas.length; i2++) {
              var delta = deltas[i2];
              if (!delta.start)
                continue;
              if (!range) {
                if (isInsert(delta)) {
                  range = Range.fromPoints(delta.start, delta.end);
                } else {
                  range = Range.fromPoints(delta.start, delta.start);
                }
                continue;
              }
              if (isInsert(delta)) {
                point = delta.start;
                if (range.compare(point.row, point.column) == -1) {
                  range.setStart(point);
                }
                point = delta.end;
                if (range.compare(point.row, point.column) == 1) {
                  range.setEnd(point);
                }
              } else {
                point = delta.start;
                if (range.compare(point.row, point.column) == -1) {
                  range = Range.fromPoints(delta.start, delta.start);
                }
              }
            }
            return range;
          };
          EditSession2.prototype.replace = function(range, text) {
            return this.doc.replace(range, text);
          };
          EditSession2.prototype.moveText = function(fromRange, toPosition, copy) {
            var text = this.getTextRange(fromRange);
            var folds = this.getFoldsInRange(fromRange);
            var toRange = Range.fromPoints(toPosition, toPosition);
            if (!copy) {
              this.remove(fromRange);
              var rowDiff = fromRange.start.row - fromRange.end.row;
              var collDiff = rowDiff ? -fromRange.end.column : fromRange.start.column - fromRange.end.column;
              if (collDiff) {
                if (toRange.start.row == fromRange.end.row && toRange.start.column > fromRange.end.column)
                  toRange.start.column += collDiff;
                if (toRange.end.row == fromRange.end.row && toRange.end.column > fromRange.end.column)
                  toRange.end.column += collDiff;
              }
              if (rowDiff && toRange.start.row >= fromRange.end.row) {
                toRange.start.row += rowDiff;
                toRange.end.row += rowDiff;
              }
            }
            toRange.end = this.insert(toRange.start, text);
            if (folds.length) {
              var oldStart = fromRange.start;
              var newStart = toRange.start;
              var rowDiff = newStart.row - oldStart.row;
              var collDiff = newStart.column - oldStart.column;
              this.addFolds(folds.map(function(x2) {
                x2 = x2.clone();
                if (x2.start.row == oldStart.row)
                  x2.start.column += collDiff;
                if (x2.end.row == oldStart.row)
                  x2.end.column += collDiff;
                x2.start.row += rowDiff;
                x2.end.row += rowDiff;
                return x2;
              }));
            }
            return toRange;
          };
          EditSession2.prototype.indentRows = function(startRow, endRow, indentString) {
            indentString = indentString.replace(/\t/g, this.getTabString());
            for (var row = startRow; row <= endRow; row++)
              this.doc.insertInLine({ row, column: 0 }, indentString);
          };
          EditSession2.prototype.outdentRows = function(range) {
            var rowRange = range.collapseRows();
            var deleteRange = new Range(0, 0, 0, 0);
            var size = this.getTabSize();
            for (var i2 = rowRange.start.row; i2 <= rowRange.end.row; ++i2) {
              var line = this.getLine(i2);
              deleteRange.start.row = i2;
              deleteRange.end.row = i2;
              for (var j = 0; j < size; ++j)
                if (line.charAt(j) != " ")
                  break;
              if (j < size && line.charAt(j) == "	") {
                deleteRange.start.column = j;
                deleteRange.end.column = j + 1;
              } else {
                deleteRange.start.column = 0;
                deleteRange.end.column = j;
              }
              this.remove(deleteRange);
            }
          };
          EditSession2.prototype.$moveLines = function(firstRow, lastRow, dir) {
            firstRow = this.getRowFoldStart(firstRow);
            lastRow = this.getRowFoldEnd(lastRow);
            if (dir < 0) {
              var row = this.getRowFoldStart(firstRow + dir);
              if (row < 0)
                return 0;
              var diff = row - firstRow;
            } else if (dir > 0) {
              var row = this.getRowFoldEnd(lastRow + dir);
              if (row > this.doc.getLength() - 1)
                return 0;
              var diff = row - lastRow;
            } else {
              firstRow = this.$clipRowToDocument(firstRow);
              lastRow = this.$clipRowToDocument(lastRow);
              var diff = lastRow - firstRow + 1;
            }
            var range = new Range(firstRow, 0, lastRow, Number.MAX_VALUE);
            var folds = this.getFoldsInRange(range).map(function(x2) {
              x2 = x2.clone();
              x2.start.row += diff;
              x2.end.row += diff;
              return x2;
            });
            var lines = dir == 0 ? this.doc.getLines(firstRow, lastRow) : this.doc.removeFullLines(firstRow, lastRow);
            this.doc.insertFullLines(firstRow + diff, lines);
            folds.length && this.addFolds(folds);
            return diff;
          };
          EditSession2.prototype.moveLinesUp = function(firstRow, lastRow) {
            return this.$moveLines(firstRow, lastRow, -1);
          };
          EditSession2.prototype.moveLinesDown = function(firstRow, lastRow) {
            return this.$moveLines(firstRow, lastRow, 1);
          };
          EditSession2.prototype.duplicateLines = function(firstRow, lastRow) {
            return this.$moveLines(firstRow, lastRow, 0);
          };
          EditSession2.prototype.$clipRowToDocument = function(row) {
            return Math.max(0, Math.min(row, this.doc.getLength() - 1));
          };
          EditSession2.prototype.$clipColumnToRow = function(row, column) {
            if (column < 0)
              return 0;
            return Math.min(this.doc.getLine(row).length, column);
          };
          EditSession2.prototype.$clipPositionToDocument = function(row, column) {
            column = Math.max(0, column);
            if (row < 0) {
              row = 0;
              column = 0;
            } else {
              var len = this.doc.getLength();
              if (row >= len) {
                row = len - 1;
                column = this.doc.getLine(len - 1).length;
              } else {
                column = Math.min(this.doc.getLine(row).length, column);
              }
            }
            return {
              row,
              column
            };
          };
          EditSession2.prototype.$clipRangeToDocument = function(range) {
            if (range.start.row < 0) {
              range.start.row = 0;
              range.start.column = 0;
            } else {
              range.start.column = this.$clipColumnToRow(range.start.row, range.start.column);
            }
            var len = this.doc.getLength() - 1;
            if (range.end.row > len) {
              range.end.row = len;
              range.end.column = this.doc.getLine(len).length;
            } else {
              range.end.column = this.$clipColumnToRow(range.end.row, range.end.column);
            }
            return range;
          };
          EditSession2.prototype.setUseWrapMode = function(useWrapMode) {
            if (useWrapMode != this.$useWrapMode) {
              this.$useWrapMode = useWrapMode;
              this.$modified = true;
              this.$resetRowCache(0);
              if (useWrapMode) {
                var len = this.getLength();
                this.$wrapData = Array(len);
                this.$updateWrapData(0, len - 1);
              }
              this._signal("changeWrapMode");
            }
          };
          EditSession2.prototype.getUseWrapMode = function() {
            return this.$useWrapMode;
          };
          EditSession2.prototype.setWrapLimitRange = function(min, max) {
            if (this.$wrapLimitRange.min !== min || this.$wrapLimitRange.max !== max) {
              this.$wrapLimitRange = { min, max };
              this.$modified = true;
              this.$bidiHandler.markAsDirty();
              if (this.$useWrapMode)
                this._signal("changeWrapMode");
            }
          };
          EditSession2.prototype.adjustWrapLimit = function(desiredLimit, $printMargin) {
            var limits = this.$wrapLimitRange;
            if (limits.max < 0)
              limits = { min: $printMargin, max: $printMargin };
            var wrapLimit = this.$constrainWrapLimit(desiredLimit, limits.min, limits.max);
            if (wrapLimit != this.$wrapLimit && wrapLimit > 1) {
              this.$wrapLimit = wrapLimit;
              this.$modified = true;
              if (this.$useWrapMode) {
                this.$updateWrapData(0, this.getLength() - 1);
                this.$resetRowCache(0);
                this._signal("changeWrapLimit");
              }
              return true;
            }
            return false;
          };
          EditSession2.prototype.$constrainWrapLimit = function(wrapLimit, min, max) {
            if (min)
              wrapLimit = Math.max(min, wrapLimit);
            if (max)
              wrapLimit = Math.min(max, wrapLimit);
            return wrapLimit;
          };
          EditSession2.prototype.getWrapLimit = function() {
            return this.$wrapLimit;
          };
          EditSession2.prototype.setWrapLimit = function(limit) {
            this.setWrapLimitRange(limit, limit);
          };
          EditSession2.prototype.getWrapLimitRange = function() {
            return {
              min: this.$wrapLimitRange.min,
              max: this.$wrapLimitRange.max
            };
          };
          EditSession2.prototype.$updateInternalDataOnChange = function(delta) {
            var useWrapMode = this.$useWrapMode;
            var action = delta.action;
            var start = delta.start;
            var end = delta.end;
            var firstRow = start.row;
            var lastRow = end.row;
            var len = lastRow - firstRow;
            var removedFolds = null;
            this.$updating = true;
            if (len != 0) {
              if (action === "remove") {
                this[useWrapMode ? "$wrapData" : "$rowLengthCache"].splice(firstRow, len);
                var foldLines = this.$foldData;
                removedFolds = this.getFoldsInRange(delta);
                this.removeFolds(removedFolds);
                var foldLine = this.getFoldLine(end.row);
                var idx = 0;
                if (foldLine) {
                  foldLine.addRemoveChars(end.row, end.column, start.column - end.column);
                  foldLine.shiftRow(-len);
                  var foldLineBefore = this.getFoldLine(firstRow);
                  if (foldLineBefore && foldLineBefore !== foldLine) {
                    foldLineBefore.merge(foldLine);
                    foldLine = foldLineBefore;
                  }
                  idx = foldLines.indexOf(foldLine) + 1;
                }
                for (idx; idx < foldLines.length; idx++) {
                  var foldLine = foldLines[idx];
                  if (foldLine.start.row >= end.row) {
                    foldLine.shiftRow(-len);
                  }
                }
                lastRow = firstRow;
              } else {
                var args = Array(len);
                args.unshift(firstRow, 0);
                var arr = useWrapMode ? this.$wrapData : this.$rowLengthCache;
                arr.splice.apply(arr, args);
                var foldLines = this.$foldData;
                var foldLine = this.getFoldLine(firstRow);
                var idx = 0;
                if (foldLine) {
                  var cmp = foldLine.range.compareInside(start.row, start.column);
                  if (cmp == 0) {
                    foldLine = foldLine.split(start.row, start.column);
                    if (foldLine) {
                      foldLine.shiftRow(len);
                      foldLine.addRemoveChars(lastRow, 0, end.column - start.column);
                    }
                  } else if (cmp == -1) {
                    foldLine.addRemoveChars(firstRow, 0, end.column - start.column);
                    foldLine.shiftRow(len);
                  }
                  idx = foldLines.indexOf(foldLine) + 1;
                }
                for (idx; idx < foldLines.length; idx++) {
                  var foldLine = foldLines[idx];
                  if (foldLine.start.row >= firstRow) {
                    foldLine.shiftRow(len);
                  }
                }
              }
            } else {
              len = Math.abs(delta.start.column - delta.end.column);
              if (action === "remove") {
                removedFolds = this.getFoldsInRange(delta);
                this.removeFolds(removedFolds);
                len = -len;
              }
              var foldLine = this.getFoldLine(firstRow);
              if (foldLine) {
                foldLine.addRemoveChars(firstRow, start.column, len);
              }
            }
            if (useWrapMode && this.$wrapData.length != this.doc.getLength()) {
              console.error("doc.getLength() and $wrapData.length have to be the same!");
            }
            this.$updating = false;
            if (useWrapMode)
              this.$updateWrapData(firstRow, lastRow);
            else
              this.$updateRowLengthCache(firstRow, lastRow);
            return removedFolds;
          };
          EditSession2.prototype.$updateRowLengthCache = function(firstRow, lastRow) {
            this.$rowLengthCache[firstRow] = null;
            this.$rowLengthCache[lastRow] = null;
          };
          EditSession2.prototype.$updateWrapData = function(firstRow, lastRow) {
            var lines = this.doc.getAllLines();
            var tabSize = this.getTabSize();
            var wrapData = this.$wrapData;
            var wrapLimit = this.$wrapLimit;
            var tokens;
            var foldLine;
            var row = firstRow;
            lastRow = Math.min(lastRow, lines.length - 1);
            while (row <= lastRow) {
              foldLine = this.getFoldLine(row, foldLine);
              if (!foldLine) {
                tokens = this.$getDisplayTokens(lines[row]);
                wrapData[row] = this.$computeWrapSplits(tokens, wrapLimit, tabSize);
                row++;
              } else {
                tokens = [];
                foldLine.walk((function(placeholder, row2, column, lastColumn) {
                  var walkTokens;
                  if (placeholder != null) {
                    walkTokens = this.$getDisplayTokens(placeholder, tokens.length);
                    walkTokens[0] = PLACEHOLDER_START;
                    for (var i2 = 1; i2 < walkTokens.length; i2++) {
                      walkTokens[i2] = PLACEHOLDER_BODY;
                    }
                  } else {
                    walkTokens = this.$getDisplayTokens(lines[row2].substring(lastColumn, column), tokens.length);
                  }
                  tokens = tokens.concat(walkTokens);
                }).bind(this), foldLine.end.row, lines[foldLine.end.row].length + 1);
                wrapData[foldLine.start.row] = this.$computeWrapSplits(tokens, wrapLimit, tabSize);
                row = foldLine.end.row + 1;
              }
            }
          };
          EditSession2.prototype.$computeWrapSplits = function(tokens, wrapLimit, tabSize) {
            if (tokens.length == 0) {
              return [];
            }
            var splits = [];
            var displayLength = tokens.length;
            var lastSplit = 0, lastDocSplit = 0;
            var isCode = this.$wrapAsCode;
            var indentedSoftWrap = this.$indentedSoftWrap;
            var maxIndent = wrapLimit <= Math.max(2 * tabSize, 8) || indentedSoftWrap === false ? 0 : Math.floor(wrapLimit / 2);
            function getWrapIndent() {
              var indentation = 0;
              if (maxIndent === 0)
                return indentation;
              if (indentedSoftWrap) {
                for (var i2 = 0; i2 < tokens.length; i2++) {
                  var token = tokens[i2];
                  if (token == SPACE)
                    indentation += 1;
                  else if (token == TAB)
                    indentation += tabSize;
                  else if (token == TAB_SPACE)
                    continue;
                  else
                    break;
                }
              }
              if (isCode && indentedSoftWrap !== false)
                indentation += tabSize;
              return Math.min(indentation, maxIndent);
            }
            function addSplit(screenPos) {
              var len = screenPos - lastSplit;
              for (var i2 = lastSplit; i2 < screenPos; i2++) {
                var ch = tokens[i2];
                if (ch === 12 || ch === 2)
                  len -= 1;
              }
              if (!splits.length) {
                indent = getWrapIndent();
                splits.indent = indent;
              }
              lastDocSplit += len;
              splits.push(lastDocSplit);
              lastSplit = screenPos;
            }
            var indent = 0;
            while (displayLength - lastSplit > wrapLimit - indent) {
              var split2 = lastSplit + wrapLimit - indent;
              if (tokens[split2 - 1] >= SPACE && tokens[split2] >= SPACE) {
                addSplit(split2);
                continue;
              }
              if (tokens[split2] == PLACEHOLDER_START || tokens[split2] == PLACEHOLDER_BODY) {
                for (split2; split2 != lastSplit - 1; split2--) {
                  if (tokens[split2] == PLACEHOLDER_START) {
                    break;
                  }
                }
                if (split2 > lastSplit) {
                  addSplit(split2);
                  continue;
                }
                split2 = lastSplit + wrapLimit;
                for (split2; split2 < tokens.length; split2++) {
                  if (tokens[split2] != PLACEHOLDER_BODY) {
                    break;
                  }
                }
                if (split2 == tokens.length) {
                  break;
                }
                addSplit(split2);
                continue;
              }
              var minSplit = Math.max(split2 - (wrapLimit - (wrapLimit >> 2)), lastSplit - 1);
              while (split2 > minSplit && tokens[split2] < PLACEHOLDER_START) {
                split2--;
              }
              if (isCode) {
                while (split2 > minSplit && tokens[split2] < PLACEHOLDER_START) {
                  split2--;
                }
                while (split2 > minSplit && tokens[split2] == PUNCTUATION) {
                  split2--;
                }
              } else {
                while (split2 > minSplit && tokens[split2] < SPACE) {
                  split2--;
                }
              }
              if (split2 > minSplit) {
                addSplit(++split2);
                continue;
              }
              split2 = lastSplit + wrapLimit;
              if (tokens[split2] == CHAR_EXT)
                split2--;
              addSplit(split2 - indent);
            }
            return splits;
          };
          EditSession2.prototype.$getDisplayTokens = function(str, offset) {
            var arr = [];
            var tabSize;
            offset = offset || 0;
            for (var i2 = 0; i2 < str.length; i2++) {
              var c2 = str.charCodeAt(i2);
              if (c2 == 9) {
                tabSize = this.getScreenTabSize(arr.length + offset);
                arr.push(TAB);
                for (var n = 1; n < tabSize; n++) {
                  arr.push(TAB_SPACE);
                }
              } else if (c2 == 32) {
                arr.push(SPACE);
              } else if (c2 > 39 && c2 < 48 || c2 > 57 && c2 < 64) {
                arr.push(PUNCTUATION);
              } else if (c2 >= 4352 && isFullWidth(c2)) {
                arr.push(CHAR, CHAR_EXT);
              } else {
                arr.push(CHAR);
              }
            }
            return arr;
          };
          EditSession2.prototype.$getStringScreenWidth = function(str, maxScreenColumn, screenColumn) {
            if (maxScreenColumn == 0)
              return [0, 0];
            if (maxScreenColumn == null)
              maxScreenColumn = Infinity;
            screenColumn = screenColumn || 0;
            var c2, column;
            for (column = 0; column < str.length; column++) {
              c2 = str.charCodeAt(column);
              if (c2 == 9) {
                screenColumn += this.getScreenTabSize(screenColumn);
              } else if (c2 >= 4352 && isFullWidth(c2)) {
                screenColumn += 2;
              } else {
                screenColumn += 1;
              }
              if (screenColumn > maxScreenColumn) {
                break;
              }
            }
            return [screenColumn, column];
          };
          EditSession2.prototype.getRowLength = function(row) {
            var h3 = 1;
            if (this.lineWidgets)
              h3 += this.lineWidgets[row] && this.lineWidgets[row].rowCount || 0;
            if (!this.$useWrapMode || !this.$wrapData[row])
              return h3;
            else
              return this.$wrapData[row].length + h3;
          };
          EditSession2.prototype.getRowLineCount = function(row) {
            if (!this.$useWrapMode || !this.$wrapData[row]) {
              return 1;
            } else {
              return this.$wrapData[row].length + 1;
            }
          };
          EditSession2.prototype.getRowWrapIndent = function(screenRow) {
            if (this.$useWrapMode) {
              var pos = this.screenToDocumentPosition(screenRow, Number.MAX_VALUE);
              var splits = this.$wrapData[pos.row];
              return splits.length && splits[0] < pos.column ? splits.indent : 0;
            } else {
              return 0;
            }
          };
          EditSession2.prototype.getScreenLastRowColumn = function(screenRow) {
            var pos = this.screenToDocumentPosition(screenRow, Number.MAX_VALUE);
            return this.documentToScreenColumn(pos.row, pos.column);
          };
          EditSession2.prototype.getDocumentLastRowColumn = function(docRow, docColumn) {
            var screenRow = this.documentToScreenRow(docRow, docColumn);
            return this.getScreenLastRowColumn(screenRow);
          };
          EditSession2.prototype.getDocumentLastRowColumnPosition = function(docRow, docColumn) {
            var screenRow = this.documentToScreenRow(docRow, docColumn);
            return this.screenToDocumentPosition(screenRow, Number.MAX_VALUE / 10);
          };
          EditSession2.prototype.getRowSplitData = function(row) {
            if (!this.$useWrapMode) {
              return void 0;
            } else {
              return this.$wrapData[row];
            }
          };
          EditSession2.prototype.getScreenTabSize = function(screenColumn) {
            return this.$tabSize - (screenColumn % this.$tabSize | 0);
          };
          EditSession2.prototype.screenToDocumentRow = function(screenRow, screenColumn) {
            return this.screenToDocumentPosition(screenRow, screenColumn).row;
          };
          EditSession2.prototype.screenToDocumentColumn = function(screenRow, screenColumn) {
            return this.screenToDocumentPosition(screenRow, screenColumn).column;
          };
          EditSession2.prototype.screenToDocumentPosition = function(screenRow, screenColumn, offsetX) {
            if (screenRow < 0)
              return { row: 0, column: 0 };
            var line;
            var docRow = 0;
            var docColumn = 0;
            var column;
            var row = 0;
            var rowLength = 0;
            var rowCache = this.$screenRowCache;
            var i2 = this.$getRowCacheIndex(rowCache, screenRow);
            var l = rowCache.length;
            if (l && i2 >= 0) {
              var row = rowCache[i2];
              var docRow = this.$docRowCache[i2];
              var doCache = screenRow > rowCache[l - 1];
            } else {
              var doCache = !l;
            }
            var maxRow = this.getLength() - 1;
            var foldLine = this.getNextFoldLine(docRow);
            var foldStart = foldLine ? foldLine.start.row : Infinity;
            while (row <= screenRow) {
              rowLength = this.getRowLength(docRow);
              if (row + rowLength > screenRow || docRow >= maxRow) {
                break;
              } else {
                row += rowLength;
                docRow++;
                if (docRow > foldStart) {
                  docRow = foldLine.end.row + 1;
                  foldLine = this.getNextFoldLine(docRow, foldLine);
                  foldStart = foldLine ? foldLine.start.row : Infinity;
                }
              }
              if (doCache) {
                this.$docRowCache.push(docRow);
                this.$screenRowCache.push(row);
              }
            }
            if (foldLine && foldLine.start.row <= docRow) {
              line = this.getFoldDisplayLine(foldLine);
              docRow = foldLine.start.row;
            } else if (row + rowLength <= screenRow || docRow > maxRow) {
              return {
                row: maxRow,
                column: this.getLine(maxRow).length
              };
            } else {
              line = this.getLine(docRow);
              foldLine = null;
            }
            var wrapIndent = 0, splitIndex = Math.floor(screenRow - row);
            if (this.$useWrapMode) {
              var splits = this.$wrapData[docRow];
              if (splits) {
                column = splits[splitIndex];
                if (splitIndex > 0 && splits.length) {
                  wrapIndent = splits.indent;
                  docColumn = splits[splitIndex - 1] || splits[splits.length - 1];
                  line = line.substring(docColumn);
                }
              }
            }
            if (offsetX !== void 0 && this.$bidiHandler.isBidiRow(row + splitIndex, docRow, splitIndex))
              screenColumn = this.$bidiHandler.offsetToCol(offsetX);
            docColumn += this.$getStringScreenWidth(line, screenColumn - wrapIndent)[1];
            if (this.$useWrapMode && docColumn >= column)
              docColumn = column - 1;
            if (foldLine)
              return foldLine.idxToPosition(docColumn);
            return { row: docRow, column: docColumn };
          };
          EditSession2.prototype.documentToScreenPosition = function(docRow, docColumn) {
            if (typeof docColumn === "undefined")
              var pos = this.$clipPositionToDocument(
                /**@type{Point}*/
                docRow.row,
                /**@type{Point}*/
                docRow.column
              );
            else
              pos = this.$clipPositionToDocument(
                /**@type{number}*/
                docRow,
                docColumn
              );
            docRow = pos.row;
            docColumn = pos.column;
            var screenRow = 0;
            var foldStartRow = null;
            var fold = null;
            fold = this.getFoldAt(docRow, docColumn, 1);
            if (fold) {
              docRow = fold.start.row;
              docColumn = fold.start.column;
            }
            var rowEnd, row = 0;
            var rowCache = this.$docRowCache;
            var i2 = this.$getRowCacheIndex(rowCache, docRow);
            var l = rowCache.length;
            if (l && i2 >= 0) {
              var row = rowCache[i2];
              var screenRow = this.$screenRowCache[i2];
              var doCache = docRow > rowCache[l - 1];
            } else {
              var doCache = !l;
            }
            var foldLine = this.getNextFoldLine(row);
            var foldStart = foldLine ? foldLine.start.row : Infinity;
            while (row < docRow) {
              if (row >= foldStart) {
                rowEnd = foldLine.end.row + 1;
                if (rowEnd > docRow)
                  break;
                foldLine = this.getNextFoldLine(rowEnd, foldLine);
                foldStart = foldLine ? foldLine.start.row : Infinity;
              } else {
                rowEnd = row + 1;
              }
              screenRow += this.getRowLength(row);
              row = rowEnd;
              if (doCache) {
                this.$docRowCache.push(row);
                this.$screenRowCache.push(screenRow);
              }
            }
            var textLine = "";
            if (foldLine && row >= foldStart) {
              textLine = this.getFoldDisplayLine(foldLine, docRow, docColumn);
              foldStartRow = foldLine.start.row;
            } else {
              textLine = this.getLine(docRow).substring(0, docColumn);
              foldStartRow = docRow;
            }
            var wrapIndent = 0;
            if (this.$useWrapMode) {
              var wrapRow = this.$wrapData[foldStartRow];
              if (wrapRow) {
                var screenRowOffset = 0;
                while (textLine.length >= wrapRow[screenRowOffset]) {
                  screenRow++;
                  screenRowOffset++;
                }
                textLine = textLine.substring(wrapRow[screenRowOffset - 1] || 0, textLine.length);
                wrapIndent = screenRowOffset > 0 ? wrapRow.indent : 0;
              }
            }
            if (this.lineWidgets && this.lineWidgets[row] && this.lineWidgets[row].rowsAbove)
              screenRow += this.lineWidgets[row].rowsAbove;
            return {
              row: screenRow,
              column: wrapIndent + this.$getStringScreenWidth(textLine)[0]
            };
          };
          EditSession2.prototype.documentToScreenColumn = function(row, docColumn) {
            return this.documentToScreenPosition(row, docColumn).column;
          };
          EditSession2.prototype.documentToScreenRow = function(docRow, docColumn) {
            return this.documentToScreenPosition(docRow, docColumn).row;
          };
          EditSession2.prototype.getScreenLength = function() {
            var screenRows = 0;
            var fold = null;
            if (!this.$useWrapMode) {
              screenRows = this.getLength();
              var foldData = this.$foldData;
              for (var i2 = 0; i2 < foldData.length; i2++) {
                fold = foldData[i2];
                screenRows -= fold.end.row - fold.start.row;
              }
            } else {
              var lastRow = this.$wrapData.length;
              var row = 0, i2 = 0;
              var fold = this.$foldData[i2++];
              var foldStart = fold ? fold.start.row : Infinity;
              while (row < lastRow) {
                var splits = this.$wrapData[row];
                screenRows += splits ? splits.length + 1 : 1;
                row++;
                if (row > foldStart) {
                  row = fold.end.row + 1;
                  fold = this.$foldData[i2++];
                  foldStart = fold ? fold.start.row : Infinity;
                }
              }
            }
            if (this.lineWidgets)
              screenRows += this.$getWidgetScreenLength();
            return screenRows;
          };
          EditSession2.prototype.$setFontMetrics = function(fm) {
            if (!this.$enableVarChar)
              return;
            this.$getStringScreenWidth = function(str, maxScreenColumn, screenColumn) {
              if (maxScreenColumn === 0)
                return [0, 0];
              if (!maxScreenColumn)
                maxScreenColumn = Infinity;
              screenColumn = screenColumn || 0;
              var c2, column;
              for (column = 0; column < str.length; column++) {
                c2 = str.charAt(column);
                if (c2 === "	") {
                  screenColumn += this.getScreenTabSize(screenColumn);
                } else {
                  screenColumn += fm.getCharacterWidth(c2);
                }
                if (screenColumn > maxScreenColumn) {
                  break;
                }
              }
              return [screenColumn, column];
            };
          };
          EditSession2.prototype.getPrecedingCharacter = function() {
            var pos = this.selection.getCursor();
            if (pos.column === 0) {
              return pos.row === 0 ? "" : this.doc.getNewLineCharacter();
            }
            var currentLine = this.getLine(pos.row);
            return currentLine[pos.column - 1];
          };
          EditSession2.prototype.destroy = function() {
            if (!this.destroyed) {
              this.bgTokenizer.setDocument(null);
              this.bgTokenizer.cleanup();
              this.destroyed = true;
            }
            this.endOperation();
            this.$stopWorker();
            this.removeAllListeners();
            if (this.doc) {
              this.doc.off("change", this.$onChange);
            }
            if (this.selection) {
              this.selection.off("changeCursor", this.$onSelectionChange);
              this.selection.off("changeSelection", this.$onSelectionChange);
            }
            this.selection.detach();
          };
          return EditSession2;
        })()
      );
      EditSession.$uid = 0;
      EditSession.prototype.$modes = config.$modes;
      EditSession.prototype.getValue = EditSession.prototype.toString;
      EditSession.prototype.$defaultUndoManager = {
        undo: function() {
        },
        redo: function() {
        },
        hasUndo: function() {
        },
        hasRedo: function() {
        },
        reset: function() {
        },
        add: function() {
        },
        addSelection: function() {
        },
        startNewGroup: function() {
        },
        addSession: function() {
        }
      };
      EditSession.prototype.$overwrite = false;
      EditSession.prototype.$mode = null;
      EditSession.prototype.$modeId = null;
      EditSession.prototype.$scrollTop = 0;
      EditSession.prototype.$scrollLeft = 0;
      EditSession.prototype.$wrapLimit = 80;
      EditSession.prototype.$useWrapMode = false;
      EditSession.prototype.$wrapLimitRange = {
        min: null,
        max: null
      };
      EditSession.prototype.lineWidgets = null;
      EditSession.prototype.isFullWidth = isFullWidth;
      oop.implement(EditSession.prototype, EventEmitter);
      var CHAR = 1, CHAR_EXT = 2, PLACEHOLDER_START = 3, PLACEHOLDER_BODY = 4, PUNCTUATION = 9, SPACE = 10, TAB = 11, TAB_SPACE = 12;
      function isFullWidth(c2) {
        if (c2 < 4352)
          return false;
        return c2 >= 4352 && c2 <= 4447 || c2 >= 4515 && c2 <= 4519 || c2 >= 4602 && c2 <= 4607 || c2 >= 9001 && c2 <= 9002 || c2 >= 11904 && c2 <= 11929 || c2 >= 11931 && c2 <= 12019 || c2 >= 12032 && c2 <= 12245 || c2 >= 12272 && c2 <= 12283 || c2 >= 12288 && c2 <= 12350 || c2 >= 12353 && c2 <= 12438 || c2 >= 12441 && c2 <= 12543 || c2 >= 12549 && c2 <= 12589 || c2 >= 12593 && c2 <= 12686 || c2 >= 12688 && c2 <= 12730 || c2 >= 12736 && c2 <= 12771 || c2 >= 12784 && c2 <= 12830 || c2 >= 12832 && c2 <= 12871 || c2 >= 12880 && c2 <= 13054 || c2 >= 13056 && c2 <= 19903 || c2 >= 19968 && c2 <= 42124 || c2 >= 42128 && c2 <= 42182 || c2 >= 43360 && c2 <= 43388 || c2 >= 44032 && c2 <= 55203 || c2 >= 55216 && c2 <= 55238 || c2 >= 55243 && c2 <= 55291 || c2 >= 63744 && c2 <= 64255 || c2 >= 65040 && c2 <= 65049 || c2 >= 65072 && c2 <= 65106 || c2 >= 65108 && c2 <= 65126 || c2 >= 65128 && c2 <= 65131 || c2 >= 65281 && c2 <= 65376 || c2 >= 65504 && c2 <= 65510;
      }
      require2("./edit_session/folding").Folding.call(EditSession.prototype);
      require2("./edit_session/bracket_match").BracketMatch.call(EditSession.prototype);
      config.defineOptions(EditSession.prototype, "session", {
        wrap: {
          set: function(value) {
            if (!value || value == "off")
              value = false;
            else if (value == "free")
              value = true;
            else if (value == "printMargin")
              value = -1;
            else if (typeof value == "string")
              value = parseInt(value, 10) || false;
            if (this.$wrap == value)
              return;
            this.$wrap = value;
            if (!value) {
              this.setUseWrapMode(false);
            } else {
              var col = typeof value == "number" ? value : null;
              this.setWrapLimitRange(col, col);
              this.setUseWrapMode(true);
            }
          },
          get: function() {
            if (this.getUseWrapMode()) {
              if (this.$wrap == -1)
                return "printMargin";
              if (!this.getWrapLimitRange().min)
                return "free";
              return this.$wrap;
            }
            return "off";
          },
          handlesSet: true
        },
        wrapMethod: {
          set: function(val) {
            val = val == "auto" ? this.$mode.type != "text" : val != "text";
            if (val != this.$wrapAsCode) {
              this.$wrapAsCode = val;
              if (this.$useWrapMode) {
                this.$useWrapMode = false;
                this.setUseWrapMode(true);
              }
            }
          },
          initialValue: "auto"
        },
        indentedSoftWrap: {
          set: function() {
            if (this.$useWrapMode) {
              this.$useWrapMode = false;
              this.setUseWrapMode(true);
            }
          },
          initialValue: true
        },
        firstLineNumber: {
          set: function() {
            this._signal("changeBreakpoint");
          },
          initialValue: 1
        },
        useWorker: {
          set: function(useWorker) {
            this.$useWorker = useWorker;
            this.$stopWorker();
            if (useWorker)
              this.$startWorker();
          },
          initialValue: true
        },
        useSoftTabs: { initialValue: true },
        tabSize: {
          set: function(tabSize) {
            tabSize = parseInt(tabSize);
            if (tabSize > 0 && this.$tabSize !== tabSize) {
              this.$modified = true;
              this.$rowLengthCache = [];
              this.$tabSize = tabSize;
              this._signal("changeTabSize");
            }
          },
          initialValue: 4,
          handlesSet: true
        },
        navigateWithinSoftTabs: { initialValue: false },
        foldStyle: {
          set: function(val) {
            this.setFoldStyle(val);
          },
          handlesSet: true
        },
        overwrite: {
          set: function(val) {
            this._signal("changeOverwrite");
          },
          initialValue: false
        },
        newLineMode: {
          set: function(val) {
            this.doc.setNewLineMode(val);
          },
          get: function() {
            return this.doc.getNewLineMode();
          },
          handlesSet: true
        },
        mode: {
          set: function(val) {
            this.setMode(val);
          },
          get: function() {
            return this.$modeId;
          },
          handlesSet: true
        }
      });
      exports3.EditSession = EditSession;
    });
    ace.define("ace/search", ["require", "exports", "module", "ace/lib/lang", "ace/lib/oop", "ace/range"], function(require2, exports3, module3) {
      var lang = require2("./lib/lang");
      var oop = require2("./lib/oop");
      var Range = require2("./range").Range;
      var Search = (
        /** @class */
        (function() {
          function Search2() {
            this.$options = {};
          }
          Search2.prototype.set = function(options) {
            oop.mixin(this.$options, options);
            return this;
          };
          Search2.prototype.getOptions = function() {
            return lang.copyObject(this.$options);
          };
          Search2.prototype.setOptions = function(options) {
            this.$options = options;
          };
          Search2.prototype.find = function(session) {
            var options = this.$options;
            var iterator = this.$matchIterator(session, options);
            if (!iterator)
              return false;
            var firstRange = null;
            iterator.forEach(function(sr, sc, er, ec) {
              firstRange = new Range(sr, sc, er, ec);
              if (sc == ec && options.start && /**@type{Range}*/
              options.start.start && options.skipCurrent != false && firstRange.isEqual(
                /**@type{Range}*/
                options.start
              )) {
                firstRange = null;
                return false;
              }
              return true;
            });
            return firstRange;
          };
          Search2.prototype.findAll = function(session) {
            var options = this.$options;
            if (!options.needle)
              return [];
            this.$assembleRegExp(options);
            var range = options.range;
            var lines = range ? session.getLines(range.start.row, range.end.row) : session.doc.getAllLines();
            var ranges = [];
            var re2 = options.re;
            if (options.$isMultiLine) {
              var len = re2.length;
              var maxRow = lines.length - len;
              var prevRange;
              outer: for (var row = re2.offset || 0; row <= maxRow; row++) {
                for (var j = 0; j < len; j++)
                  if (lines[row + j].search(re2[j]) == -1)
                    continue outer;
                var startLine = lines[row];
                var line = lines[row + len - 1];
                var startIndex = startLine.length - startLine.match(re2[0])[0].length;
                var endIndex = line.match(re2[len - 1])[0].length;
                if (prevRange && prevRange.end.row === row && prevRange.end.column > startIndex) {
                  continue;
                }
                ranges.push(prevRange = new Range(row, startIndex, row + len - 1, endIndex));
                if (len > 2)
                  row = row + len - 2;
              }
            } else {
              for (var matches2, i2 = 0; i2 < lines.length; i2++) {
                if (this.$isMultilineSearch(options)) {
                  var lng = lines.length - 1;
                  matches2 = this.$multiLineForward(session, re2, i2, lng);
                  if (matches2) {
                    var end_row = matches2.endRow <= lng ? matches2.endRow - 1 : lng;
                    if (end_row > i2)
                      i2 = end_row;
                    ranges.push(new Range(matches2.startRow, matches2.startCol, matches2.endRow, matches2.endCol));
                  }
                } else {
                  matches2 = lang.getMatchOffsets(lines[i2], re2);
                  for (var j = 0; j < matches2.length; j++) {
                    var match2 = matches2[j];
                    ranges.push(new Range(i2, match2.offset, i2, match2.offset + match2.length));
                  }
                }
              }
            }
            if (range) {
              var startColumn = range.start.column;
              var endColumn = range.end.column;
              var i2 = 0, j = ranges.length - 1;
              while (i2 < j && ranges[i2].start.column < startColumn && ranges[i2].start.row == 0)
                i2++;
              var endRow = range.end.row - range.start.row;
              while (i2 < j && ranges[j].end.column > endColumn && ranges[j].end.row == endRow)
                j--;
              ranges = ranges.slice(i2, j + 1);
              for (i2 = 0, j = ranges.length; i2 < j; i2++) {
                ranges[i2].start.row += range.start.row;
                ranges[i2].end.row += range.start.row;
              }
            }
            return ranges;
          };
          Search2.prototype.parseReplaceString = function(replaceString) {
            var CharCode = {
              DollarSign: 36,
              Ampersand: 38,
              Digit0: 48,
              Digit1: 49,
              Digit9: 57,
              Backslash: 92,
              n: 110,
              t: 116
            };
            var replacement = "";
            for (var i2 = 0, len = replaceString.length; i2 < len; i2++) {
              var chCode = replaceString.charCodeAt(i2);
              if (chCode === CharCode.Backslash) {
                i2++;
                if (i2 >= len) {
                  replacement += "\\";
                  break;
                }
                var nextChCode = replaceString.charCodeAt(i2);
                switch (nextChCode) {
                  case CharCode.Backslash:
                    replacement += "\\";
                    break;
                  case CharCode.n:
                    replacement += "\n";
                    break;
                  case CharCode.t:
                    replacement += "	";
                    break;
                }
                continue;
              }
              if (chCode === CharCode.DollarSign) {
                i2++;
                if (i2 >= len) {
                  replacement += "$";
                  break;
                }
                var nextChCode_1 = replaceString.charCodeAt(i2);
                if (nextChCode_1 === CharCode.DollarSign) {
                  replacement += "$$";
                  continue;
                }
                if (nextChCode_1 === CharCode.Digit0 || nextChCode_1 === CharCode.Ampersand) {
                  replacement += "$&";
                  continue;
                }
                if (CharCode.Digit1 <= nextChCode_1 && nextChCode_1 <= CharCode.Digit9) {
                  replacement += "$" + replaceString[i2];
                  continue;
                }
              }
              replacement += replaceString[i2];
            }
            return replacement || replaceString;
          };
          Search2.prototype.replace = function(input, replacement) {
            var options = this.$options;
            var re2 = this.$assembleRegExp(options);
            if (options.$isMultiLine)
              return replacement;
            if (!re2)
              return;
            var mtSearch = this.$isMultilineSearch(options);
            if (mtSearch)
              input = input.replace(/\r\n|\r|\n/g, "\n");
            var match2 = re2.exec(input);
            if (!match2 || !mtSearch && match2[0].length != input.length)
              return null;
            replacement = options.regExp ? this.parseReplaceString(replacement) : replacement.replace(/\$/g, "$$$$");
            replacement = input.replace(re2, replacement);
            if (options.preserveCase) {
              replacement = replacement.split("");
              for (var i2 = Math.min(input.length, input.length); i2--; ) {
                var ch = input[i2];
                if (ch && ch.toLowerCase() != ch)
                  replacement[i2] = replacement[i2].toUpperCase();
                else
                  replacement[i2] = replacement[i2].toLowerCase();
              }
              replacement = replacement.join("");
            }
            return replacement;
          };
          Search2.prototype.$assembleRegExp = function(options, $disableFakeMultiline) {
            if (options.needle instanceof RegExp)
              return options.re = options.needle;
            var needle = options.needle;
            if (!options.needle)
              return options.re = false;
            if (!options.regExp)
              needle = lang.escapeRegExp(needle);
            var modifier = options.caseSensitive ? "gm" : "gmi";
            try {
              new RegExp(needle, "u");
              options.$supportsUnicodeFlag = true;
              modifier += "u";
            } catch (e2) {
              options.$supportsUnicodeFlag = false;
            }
            if (options.wholeWord)
              needle = addWordBoundary(needle, options);
            options.$isMultiLine = !$disableFakeMultiline && /[\n\r]/.test(needle);
            if (options.$isMultiLine)
              return options.re = this.$assembleMultilineRegExp(needle, modifier);
            try {
              var re2 = new RegExp(needle, modifier);
            } catch (e2) {
              re2 = false;
            }
            return options.re = re2;
          };
          Search2.prototype.$assembleMultilineRegExp = function(needle, modifier) {
            var parts = needle.replace(/\r\n|\r|\n/g, "$\n^").split("\n");
            var re2 = [];
            for (var i2 = 0; i2 < parts.length; i2++)
              try {
                re2.push(new RegExp(parts[i2], modifier));
              } catch (e2) {
                return false;
              }
            return re2;
          };
          Search2.prototype.$isMultilineSearch = function(options) {
            return options.re && /\\r\\n|\\r|\\n/.test(options.re.source) && options.regExp && !options.$isMultiLine;
          };
          Search2.prototype.$multiLineForward = function(session, re2, start, last) {
            var line, chunk = chunkEnd(session, start);
            for (var row = start; row <= last; ) {
              for (var i2 = 0; i2 < chunk; i2++) {
                if (row > last)
                  break;
                var next = session.getLine(row++);
                line = line == null ? next : line + "\n" + next;
              }
              var match2 = re2.exec(line);
              re2.lastIndex = 0;
              if (match2) {
                var beforeMatch = line.slice(0, match2.index).split("\n");
                var matchedText = match2[0].split("\n");
                var startRow = start + beforeMatch.length - 1;
                var startCol = beforeMatch[beforeMatch.length - 1].length;
                var endRow = startRow + matchedText.length - 1;
                var endCol = matchedText.length == 1 ? startCol + matchedText[0].length : matchedText[matchedText.length - 1].length;
                return {
                  startRow,
                  startCol,
                  endRow,
                  endCol
                };
              }
            }
            return null;
          };
          Search2.prototype.$multiLineBackward = function(session, re2, endIndex, start, first) {
            var line, chunk = chunkEnd(session, start), endMargin = session.getLine(start).length - endIndex;
            for (var row = start; row >= first; ) {
              for (var i2 = 0; i2 < chunk && row >= first; i2++) {
                var next = session.getLine(row--);
                line = line == null ? next : next + "\n" + line;
              }
              var match2 = multiLineBackwardMatch(line, re2, endMargin);
              if (match2) {
                var beforeMatch = line.slice(0, match2.index).split("\n");
                var matchedText = match2[0].split("\n");
                var startRow = row + beforeMatch.length;
                var startCol = beforeMatch[beforeMatch.length - 1].length;
                var endRow = startRow + matchedText.length - 1;
                var endCol = matchedText.length == 1 ? startCol + matchedText[0].length : matchedText[matchedText.length - 1].length;
                return {
                  startRow,
                  startCol,
                  endRow,
                  endCol
                };
              }
            }
            return null;
          };
          Search2.prototype.$matchIterator = function(session, options) {
            var re2 = this.$assembleRegExp(options);
            if (!re2)
              return false;
            var mtSearch = this.$isMultilineSearch(options);
            var mtForward = this.$multiLineForward;
            var mtBackward = this.$multiLineBackward;
            var backwards = options.backwards == true;
            var skipCurrent = options.skipCurrent != false;
            var supportsUnicodeFlag = re2.unicode;
            var range = options.range;
            var start = options.start;
            if (!start)
              start = range ? range[backwards ? "end" : "start"] : session.selection.getRange();
            if (start.start)
              start = start[skipCurrent != backwards ? "end" : "start"];
            var firstRow = range ? range.start.row : 0;
            var lastRow = range ? range.end.row : session.getLength() - 1;
            if (backwards) {
              var forEach = function(callback) {
                var row = start.row;
                if (forEachInLine(row, start.column, callback))
                  return;
                for (row--; row >= firstRow; row--)
                  if (forEachInLine(row, Number.MAX_VALUE, callback))
                    return;
                if (options.wrap == false)
                  return;
                for (row = lastRow, firstRow = start.row; row >= firstRow; row--)
                  if (forEachInLine(row, Number.MAX_VALUE, callback))
                    return;
              };
            } else {
              var forEach = function(callback) {
                var row = start.row;
                if (forEachInLine(row, start.column, callback))
                  return;
                for (row = row + 1; row <= lastRow; row++)
                  if (forEachInLine(row, 0, callback))
                    return;
                if (options.wrap == false)
                  return;
                for (row = firstRow, lastRow = start.row; row <= lastRow; row++)
                  if (forEachInLine(row, 0, callback))
                    return;
              };
            }
            if (options.$isMultiLine) {
              var len = re2.length;
              var forEachInLine = function(row, offset, callback) {
                var startRow = backwards ? row - len + 1 : row;
                if (startRow < 0 || startRow + len > session.getLength())
                  return;
                var line = session.getLine(startRow);
                var startIndex = line.search(re2[0]);
                if (!backwards && startIndex < offset || startIndex === -1)
                  return;
                for (var i2 = 1; i2 < len; i2++) {
                  line = session.getLine(startRow + i2);
                  if (line.search(re2[i2]) == -1)
                    return;
                }
                var endIndex = line.match(re2[len - 1])[0].length;
                if (backwards && endIndex > offset)
                  return;
                if (callback(startRow, startIndex, startRow + len - 1, endIndex))
                  return true;
              };
            } else if (backwards) {
              var forEachInLine = function(row, endIndex, callback) {
                if (mtSearch) {
                  var pos = mtBackward(session, re2, endIndex, row, firstRow);
                  if (!pos)
                    return false;
                  if (callback(pos.startRow, pos.startCol, pos.endRow, pos.endCol))
                    return true;
                } else {
                  var line = session.getLine(row);
                  var matches2 = [];
                  var m3, last = 0;
                  re2.lastIndex = 0;
                  while (m3 = re2.exec(line)) {
                    var length = m3[0].length;
                    last = m3.index;
                    if (!length) {
                      if (last >= line.length)
                        break;
                      re2.lastIndex = last += lang.skipEmptyMatch(line, last, supportsUnicodeFlag);
                    }
                    if (m3.index + length > endIndex)
                      break;
                    matches2.push(m3.index, length);
                  }
                  for (var i2 = matches2.length - 1; i2 >= 0; i2 -= 2) {
                    var column = matches2[i2 - 1];
                    var length = matches2[i2];
                    if (callback(row, column, row, column + length))
                      return true;
                  }
                }
              };
            } else {
              var forEachInLine = function(row, startIndex, callback) {
                re2.lastIndex = startIndex;
                if (mtSearch) {
                  var pos = mtForward(session, re2, row, lastRow);
                  if (pos) {
                    var end_row = pos.endRow <= lastRow ? pos.endRow - 1 : lastRow;
                    if (end_row > row)
                      row = end_row;
                  }
                  if (!pos)
                    return false;
                  if (callback(pos.startRow, pos.startCol, pos.endRow, pos.endCol))
                    return true;
                } else {
                  var line = session.getLine(row);
                  var last;
                  var m3;
                  while (m3 = re2.exec(line)) {
                    var length = m3[0].length;
                    last = m3.index;
                    if (callback(row, last, row, last + length))
                      return true;
                    if (!length) {
                      re2.lastIndex = last += lang.skipEmptyMatch(line, last, supportsUnicodeFlag);
                      if (last >= line.length)
                        return false;
                    }
                  }
                }
              };
            }
            return { forEach };
          };
          return Search2;
        })()
      );
      function addWordBoundary(needle, options) {
        var supportsLookbehind = lang.supportsLookbehind();
        function wordBoundary(c2, firstChar2) {
          if (firstChar2 === void 0) {
            firstChar2 = true;
          }
          var wordRegExp = supportsLookbehind && options.$supportsUnicodeFlag ? new RegExp("[\\p{L}\\p{N}_]", "u") : new RegExp("\\w");
          if (wordRegExp.test(c2) || options.regExp) {
            if (supportsLookbehind && options.$supportsUnicodeFlag) {
              if (firstChar2)
                return "(?<=^|[^\\p{L}\\p{N}_])";
              return "(?=[^\\p{L}\\p{N}_]|$)";
            }
            return "\\b";
          }
          return "";
        }
        var needleArray = Array.from(needle);
        var firstChar = needleArray[0];
        var lastChar = needleArray[needleArray.length - 1];
        return wordBoundary(firstChar) + needle + wordBoundary(lastChar, false);
      }
      function multiLineBackwardMatch(line, re2, endMargin) {
        var match2 = null;
        var from = 0;
        while (from <= line.length) {
          re2.lastIndex = from;
          var newMatch = re2.exec(line);
          if (!newMatch)
            break;
          var end = newMatch.index + newMatch[0].length;
          if (end > line.length - endMargin)
            break;
          if (!match2 || end > match2.index + match2[0].length)
            match2 = newMatch;
          from = newMatch.index + 1;
        }
        return match2;
      }
      function chunkEnd(session, start) {
        var base = 5e3, startPosition = { row: start, column: 0 }, startIndex = session.doc.positionToIndex(startPosition), targetIndex = startIndex + base, targetPosition = session.doc.indexToPosition(targetIndex), targetLine = targetPosition.row;
        return targetLine + 1;
      }
      exports3.Search = Search;
    });
    ace.define("ace/keyboard/hash_handler", ["require", "exports", "module", "ace/lib/keys", "ace/lib/useragent"], function(require2, exports3, module3) {
      var __extends = this && this.__extends || /* @__PURE__ */ (function() {
        var extendStatics = function(d3, b2) {
          extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d4, b3) {
            d4.__proto__ = b3;
          } || function(d4, b3) {
            for (var p in b3) if (Object.prototype.hasOwnProperty.call(b3, p)) d4[p] = b3[p];
          };
          return extendStatics(d3, b2);
        };
        return function(d3, b2) {
          if (typeof b2 !== "function" && b2 !== null)
            throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
          extendStatics(d3, b2);
          function __() {
            this.constructor = d3;
          }
          d3.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
        };
      })();
      var keyUtil = require2("../lib/keys");
      var useragent = require2("../lib/useragent");
      var KEY_MODS = keyUtil.KEY_MODS;
      var MultiHashHandler = (
        /** @class */
        (function() {
          function MultiHashHandler2(config, platform) {
            this.$init(config, platform, false);
          }
          MultiHashHandler2.prototype.$init = function(config, platform, $singleCommand) {
            this.platform = platform || (useragent.isMac ? "mac" : "win");
            this.commands = {};
            this.commandKeyBinding = {};
            this.addCommands(config);
            this.$singleCommand = $singleCommand;
          };
          MultiHashHandler2.prototype.addCommand = function(command) {
            if (this.commands[command.name])
              this.removeCommand(command);
            this.commands[command.name] = command;
            if (command.bindKey)
              this._buildKeyHash(command);
          };
          MultiHashHandler2.prototype.removeCommand = function(command, keepCommand) {
            var name = command && (typeof command === "string" ? command : command.name);
            command = this.commands[name];
            if (!keepCommand)
              delete this.commands[name];
            var ckb = this.commandKeyBinding;
            for (var keyId in ckb) {
              var cmdGroup = ckb[keyId];
              if (cmdGroup == command) {
                delete ckb[keyId];
              } else if (Array.isArray(cmdGroup)) {
                var i2 = cmdGroup.indexOf(command);
                if (i2 != -1) {
                  cmdGroup.splice(i2, 1);
                  if (cmdGroup.length == 1)
                    ckb[keyId] = cmdGroup[0];
                }
              }
            }
          };
          MultiHashHandler2.prototype.bindKey = function(key, command, position) {
            if (typeof key == "object" && key) {
              if (position == void 0)
                position = key.position;
              key = key[this.platform];
            }
            if (!key)
              return;
            if (typeof command == "function")
              return this.addCommand({ exec: command, bindKey: key, name: command.name || /**@type{string}*/
              key });
            key.split("|").forEach(function(keyPart) {
              var chain = "";
              if (keyPart.indexOf(" ") != -1) {
                var parts = keyPart.split(/\s+/);
                keyPart = parts.pop();
                parts.forEach(function(keyPart2) {
                  var binding2 = this.parseKeys(keyPart2);
                  var id2 = KEY_MODS[binding2.hashId] + binding2.key;
                  chain += (chain ? " " : "") + id2;
                  this._addCommandToBinding(chain, "chainKeys");
                }, this);
                chain += " ";
              }
              var binding = this.parseKeys(keyPart);
              var id = KEY_MODS[binding.hashId] + binding.key;
              this._addCommandToBinding(chain + id, command, position);
            }, this);
          };
          MultiHashHandler2.prototype._addCommandToBinding = function(keyId, command, position) {
            var ckb = this.commandKeyBinding, i2;
            if (!command) {
              delete ckb[keyId];
            } else if (!ckb[keyId] || this.$singleCommand) {
              ckb[keyId] = command;
            } else {
              if (!Array.isArray(ckb[keyId])) {
                ckb[keyId] = [ckb[keyId]];
              } else if ((i2 = ckb[keyId].indexOf(command)) != -1) {
                ckb[keyId].splice(i2, 1);
              }
              if (typeof position != "number") {
                position = getPosition(command);
              }
              var commands = ckb[keyId];
              for (i2 = 0; i2 < commands.length; i2++) {
                var other = commands[i2];
                var otherPos = getPosition(other);
                if (otherPos > position)
                  break;
              }
              commands.splice(i2, 0, command);
            }
          };
          MultiHashHandler2.prototype.addCommands = function(commands) {
            commands && Object.keys(commands).forEach(function(name) {
              var command = commands[name];
              if (!command)
                return;
              if (typeof command === "string")
                return this.bindKey(command, name);
              if (typeof command === "function")
                command = { exec: command };
              if (typeof command !== "object")
                return;
              if (!command.name)
                command.name = name;
              this.addCommand(command);
            }, this);
          };
          MultiHashHandler2.prototype.removeCommands = function(commands) {
            Object.keys(commands).forEach(function(name) {
              this.removeCommand(commands[name]);
            }, this);
          };
          MultiHashHandler2.prototype.bindKeys = function(keyList) {
            Object.keys(keyList).forEach(function(key) {
              this.bindKey(key, keyList[key]);
            }, this);
          };
          MultiHashHandler2.prototype._buildKeyHash = function(command) {
            this.bindKey(command.bindKey, command);
          };
          MultiHashHandler2.prototype.parseKeys = function(keys) {
            var parts = keys.toLowerCase().split(/[\-\+]([\-\+])?/).filter(function(x2) {
              return x2;
            });
            var key = parts.pop();
            var keyCode = keyUtil[key];
            if (keyUtil.FUNCTION_KEYS[keyCode])
              key = keyUtil.FUNCTION_KEYS[keyCode].toLowerCase();
            else if (!parts.length)
              return { key, hashId: -1 };
            else if (parts.length == 1 && parts[0] == "shift")
              return { key: key.toUpperCase(), hashId: -1 };
            var hashId = 0;
            for (var i2 = parts.length; i2--; ) {
              var modifier = keyUtil.KEY_MODS[parts[i2]];
              if (modifier == null) {
                if (typeof console != "undefined")
                  console.error("invalid modifier " + parts[i2] + " in " + keys);
                return false;
              }
              hashId |= modifier;
            }
            return { key, hashId };
          };
          MultiHashHandler2.prototype.findKeyCommand = function(hashId, keyString) {
            var key = KEY_MODS[hashId] + keyString;
            return this.commandKeyBinding[key];
          };
          MultiHashHandler2.prototype.handleKeyboard = function(data, hashId, keyString, keyCode) {
            if (keyCode < 0)
              return;
            var key = KEY_MODS[hashId] + keyString;
            var command = this.commandKeyBinding[key];
            if (data.$keyChain) {
              data.$keyChain += " " + key;
              command = this.commandKeyBinding[data.$keyChain] || command;
            }
            if (command) {
              if (command == "chainKeys" || command[command.length - 1] == "chainKeys") {
                data.$keyChain = data.$keyChain || key;
                return { command: "null" };
              }
            }
            if (data.$keyChain) {
              if ((!hashId || hashId == 4) && keyString.length == 1)
                data.$keyChain = data.$keyChain.slice(0, -key.length - 1);
              else if (hashId == -1 || keyCode > 0)
                data.$keyChain = "";
            }
            return { command };
          };
          MultiHashHandler2.prototype.getStatusText = function(editor, data) {
            return data.$keyChain || "";
          };
          return MultiHashHandler2;
        })()
      );
      function getPosition(command) {
        return typeof command == "object" && command.bindKey && command.bindKey.position || (command.isDefault ? -100 : 0);
      }
      var HashHandler = (
        /** @class */
        (function(_super) {
          __extends(HashHandler2, _super);
          function HashHandler2(config, platform) {
            var _this = _super.call(this, config, platform) || this;
            _this.$singleCommand = true;
            return _this;
          }
          return HashHandler2;
        })(MultiHashHandler)
      );
      HashHandler.call = function(thisArg, config, platform) {
        MultiHashHandler.prototype.$init.call(thisArg, config, platform, true);
      };
      MultiHashHandler.call = function(thisArg, config, platform) {
        MultiHashHandler.prototype.$init.call(thisArg, config, platform, false);
      };
      exports3.HashHandler = HashHandler;
      exports3.MultiHashHandler = MultiHashHandler;
    });
    ace.define("ace/commands/command_manager", ["require", "exports", "module", "ace/lib/oop", "ace/keyboard/hash_handler", "ace/lib/event_emitter"], function(require2, exports3, module3) {
      var __extends = this && this.__extends || /* @__PURE__ */ (function() {
        var extendStatics = function(d3, b2) {
          extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d4, b3) {
            d4.__proto__ = b3;
          } || function(d4, b3) {
            for (var p in b3) if (Object.prototype.hasOwnProperty.call(b3, p)) d4[p] = b3[p];
          };
          return extendStatics(d3, b2);
        };
        return function(d3, b2) {
          if (typeof b2 !== "function" && b2 !== null)
            throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
          extendStatics(d3, b2);
          function __() {
            this.constructor = d3;
          }
          d3.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
        };
      })();
      var oop = require2("../lib/oop");
      var MultiHashHandler = require2("../keyboard/hash_handler").MultiHashHandler;
      var EventEmitter = require2("../lib/event_emitter").EventEmitter;
      var CommandManager = (
        /** @class */
        (function(_super) {
          __extends(CommandManager2, _super);
          function CommandManager2(platform, commands) {
            var _this = _super.call(this, commands, platform) || this;
            _this.byName = _this.commands;
            _this.setDefaultHandler("exec", function(e2) {
              if (!e2.args) {
                return e2.command.exec(e2.editor, {}, e2.event, true);
              }
              return e2.command.exec(e2.editor, e2.args, e2.event, false);
            });
            return _this;
          }
          CommandManager2.prototype.exec = function(command, editor, args) {
            if (Array.isArray(command)) {
              for (var i2 = command.length; i2--; ) {
                if (this.exec(command[i2], editor, args))
                  return true;
              }
              return false;
            }
            if (typeof command === "string")
              command = this.commands[command];
            if (!this.canExecute(command, editor)) {
              return false;
            }
            var e2 = { editor, command, args };
            e2.returnValue = this._emit("exec", e2);
            this._signal("afterExec", e2);
            return e2.returnValue === false ? false : true;
          };
          CommandManager2.prototype.canExecute = function(command, editor) {
            if (typeof command === "string")
              command = this.commands[command];
            if (!command)
              return false;
            if (editor && editor.$readOnly && !command.readOnly)
              return false;
            if (this.$checkCommandState != false && command.isAvailable && !command.isAvailable(editor))
              return false;
            return true;
          };
          CommandManager2.prototype.toggleRecording = function(editor) {
            if (this.$inReplay)
              return;
            editor && editor._emit("changeStatus");
            if (this.recording) {
              this.macro.pop();
              this.off("exec", this.$addCommandToMacro);
              if (!this.macro.length)
                this.macro = this.oldMacro;
              return this.recording = false;
            }
            if (!this.$addCommandToMacro) {
              this.$addCommandToMacro = (function(e2) {
                this.macro.push([e2.command, e2.args]);
              }).bind(this);
            }
            this.oldMacro = this.macro;
            this.macro = [];
            this.on("exec", this.$addCommandToMacro);
            return this.recording = true;
          };
          CommandManager2.prototype.replay = function(editor) {
            if (this.$inReplay || !this.macro)
              return;
            if (this.recording)
              return this.toggleRecording(editor);
            try {
              this.$inReplay = true;
              this.macro.forEach(function(x2) {
                if (typeof x2 == "string")
                  this.exec(x2, editor);
                else
                  this.exec(x2[0], editor, x2[1]);
              }, this);
            } finally {
              this.$inReplay = false;
            }
          };
          CommandManager2.prototype.trimMacro = function(m3) {
            return m3.map(function(x2) {
              if (typeof x2[0] != "string")
                x2[0] = x2[0].name;
              if (!x2[1])
                x2 = x2[0];
              return x2;
            });
          };
          return CommandManager2;
        })(MultiHashHandler)
      );
      oop.implement(CommandManager.prototype, EventEmitter);
      exports3.CommandManager = CommandManager;
    });
    ace.define("ace/commands/default_commands", ["require", "exports", "module", "ace/lib/lang", "ace/config", "ace/range"], function(require2, exports3, module3) {
      var lang = require2("../lib/lang");
      var config = require2("../config");
      var Range = require2("../range").Range;
      function bindKey(win, mac) {
        return { win, mac };
      }
      exports3.commands = [
        {
          name: "showSettingsMenu",
          description: "Show settings menu",
          bindKey: bindKey("Ctrl-,", "Command-,"),
          exec: function(editor) {
            config.loadModule("ace/ext/settings_menu", function(module4) {
              module4.init(editor);
              editor.showSettingsMenu();
            });
          },
          readOnly: true
        },
        {
          name: "goToNextError",
          description: "Go to next error",
          bindKey: bindKey("Alt-E", "F4"),
          exec: function(editor) {
            config.loadModule("ace/ext/error_marker", function(module4) {
              module4.showErrorMarker(editor, 1);
            });
          },
          scrollIntoView: "animate",
          readOnly: true
        },
        {
          name: "goToPreviousError",
          description: "Go to previous error",
          bindKey: bindKey("Alt-Shift-E", "Shift-F4"),
          exec: function(editor) {
            config.loadModule("ace/ext/error_marker", function(module4) {
              module4.showErrorMarker(editor, -1);
            });
          },
          scrollIntoView: "animate",
          readOnly: true
        },
        {
          name: "selectall",
          description: "Select all",
          bindKey: bindKey("Ctrl-A", "Command-A"),
          exec: function(editor) {
            editor.selectAll();
          },
          readOnly: true
        },
        {
          name: "centerselection",
          description: "Center selection",
          bindKey: bindKey(null, "Ctrl-L"),
          exec: function(editor) {
            editor.centerSelection();
          },
          readOnly: true
        },
        {
          name: "gotoline",
          description: "Go to line...",
          bindKey: bindKey("Ctrl-L", "Command-L"),
          exec: function(editor, line) {
            if (typeof line === "number" && !isNaN(line))
              editor.gotoLine(line);
            editor.prompt({ $type: "gotoLine" });
          },
          readOnly: true
        },
        {
          name: "fold",
          bindKey: bindKey("Alt-L|Ctrl-F1", "Command-Alt-L|Command-F1"),
          exec: function(editor) {
            editor.session.toggleFold(false);
          },
          multiSelectAction: "forEach",
          scrollIntoView: "center",
          readOnly: true
        },
        {
          name: "unfold",
          bindKey: bindKey("Alt-Shift-L|Ctrl-Shift-F1", "Command-Alt-Shift-L|Command-Shift-F1"),
          exec: function(editor) {
            editor.session.toggleFold(true);
          },
          multiSelectAction: "forEach",
          scrollIntoView: "center",
          readOnly: true
        },
        {
          name: "toggleFoldWidget",
          description: "Toggle fold widget",
          bindKey: bindKey("F2", "F2"),
          exec: function(editor) {
            editor.session.toggleFoldWidget();
          },
          multiSelectAction: "forEach",
          scrollIntoView: "center",
          readOnly: true
        },
        {
          name: "toggleParentFoldWidget",
          description: "Toggle parent fold widget",
          bindKey: bindKey("Alt-F2", "Alt-F2"),
          exec: function(editor) {
            editor.session.toggleFoldWidget(true);
          },
          multiSelectAction: "forEach",
          scrollIntoView: "center",
          readOnly: true
        },
        {
          name: "foldall",
          description: "Fold all",
          bindKey: bindKey(null, "Ctrl-Command-Option-0"),
          exec: function(editor) {
            editor.session.foldAll();
          },
          scrollIntoView: "center",
          readOnly: true
        },
        {
          name: "foldAllComments",
          description: "Fold all comments",
          bindKey: bindKey(null, "Ctrl-Command-Option-0"),
          exec: function(editor) {
            editor.session.foldAllComments();
          },
          scrollIntoView: "center",
          readOnly: true
        },
        {
          name: "foldOther",
          description: "Fold other",
          bindKey: bindKey("Alt-0", "Command-Option-0"),
          exec: function(editor) {
            editor.session.foldAll();
            editor.session.unfold(editor.selection.getAllRanges());
          },
          scrollIntoView: "center",
          readOnly: true
        },
        {
          name: "unfoldall",
          description: "Unfold all",
          bindKey: bindKey("Alt-Shift-0", "Command-Option-Shift-0"),
          exec: function(editor) {
            editor.session.unfold();
          },
          scrollIntoView: "center",
          readOnly: true
        },
        {
          name: "findnext",
          description: "Find next",
          bindKey: bindKey("Ctrl-K", "Command-G"),
          exec: function(editor) {
            editor.findNext();
          },
          multiSelectAction: "forEach",
          scrollIntoView: "center",
          readOnly: true
        },
        {
          name: "findprevious",
          description: "Find previous",
          bindKey: bindKey("Ctrl-Shift-K", "Command-Shift-G"),
          exec: function(editor) {
            editor.findPrevious();
          },
          multiSelectAction: "forEach",
          scrollIntoView: "center",
          readOnly: true
        },
        {
          name: "selectOrFindNext",
          description: "Select or find next",
          bindKey: bindKey("Alt-K", "Ctrl-G"),
          exec: function(editor) {
            if (editor.selection.isEmpty())
              editor.selection.selectWord();
            else
              editor.findNext();
          },
          readOnly: true
        },
        {
          name: "selectOrFindPrevious",
          description: "Select or find previous",
          bindKey: bindKey("Alt-Shift-K", "Ctrl-Shift-G"),
          exec: function(editor) {
            if (editor.selection.isEmpty())
              editor.selection.selectWord();
            else
              editor.findPrevious();
          },
          readOnly: true
        },
        {
          name: "find",
          description: "Find",
          bindKey: bindKey("Ctrl-F", "Command-F"),
          exec: function(editor) {
            config.loadModule("ace/ext/searchbox", function(e2) {
              e2.Search(editor);
            });
          },
          readOnly: true
        },
        {
          name: "overwrite",
          description: "Overwrite",
          bindKey: "Insert",
          exec: function(editor) {
            editor.toggleOverwrite();
          },
          readOnly: true
        },
        {
          name: "selecttostart",
          description: "Select to start",
          bindKey: bindKey("Ctrl-Shift-Home", "Command-Shift-Home|Command-Shift-Up"),
          exec: function(editor) {
            editor.getSelection().selectFileStart();
          },
          multiSelectAction: "forEach",
          readOnly: true,
          scrollIntoView: "animate",
          aceCommandGroup: "fileJump"
        },
        {
          name: "gotostart",
          description: "Go to start",
          bindKey: bindKey("Ctrl-Home", "Command-Home|Command-Up"),
          exec: function(editor) {
            editor.navigateFileStart();
          },
          multiSelectAction: "forEach",
          readOnly: true,
          scrollIntoView: "animate",
          aceCommandGroup: "fileJump"
        },
        {
          name: "selectup",
          description: "Select up",
          bindKey: bindKey("Shift-Up", "Shift-Up|Ctrl-Shift-P"),
          exec: function(editor) {
            editor.getSelection().selectUp();
          },
          multiSelectAction: "forEach",
          scrollIntoView: "cursor",
          readOnly: true
        },
        {
          name: "golineup",
          description: "Go line up",
          bindKey: bindKey("Up", "Up|Ctrl-P"),
          exec: function(editor, args) {
            editor.navigateUp(args.times);
          },
          multiSelectAction: "forEach",
          scrollIntoView: "cursor",
          readOnly: true
        },
        {
          name: "selecttoend",
          description: "Select to end",
          bindKey: bindKey("Ctrl-Shift-End", "Command-Shift-End|Command-Shift-Down"),
          exec: function(editor) {
            editor.getSelection().selectFileEnd();
          },
          multiSelectAction: "forEach",
          readOnly: true,
          scrollIntoView: "animate",
          aceCommandGroup: "fileJump"
        },
        {
          name: "gotoend",
          description: "Go to end",
          bindKey: bindKey("Ctrl-End", "Command-End|Command-Down"),
          exec: function(editor) {
            editor.navigateFileEnd();
          },
          multiSelectAction: "forEach",
          readOnly: true,
          scrollIntoView: "animate",
          aceCommandGroup: "fileJump"
        },
        {
          name: "selectdown",
          description: "Select down",
          bindKey: bindKey("Shift-Down", "Shift-Down|Ctrl-Shift-N"),
          exec: function(editor) {
            editor.getSelection().selectDown();
          },
          multiSelectAction: "forEach",
          scrollIntoView: "cursor",
          readOnly: true
        },
        {
          name: "golinedown",
          description: "Go line down",
          bindKey: bindKey("Down", "Down|Ctrl-N"),
          exec: function(editor, args) {
            editor.navigateDown(args.times);
          },
          multiSelectAction: "forEach",
          scrollIntoView: "cursor",
          readOnly: true
        },
        {
          name: "selectwordleft",
          description: "Select word left",
          bindKey: bindKey("Ctrl-Shift-Left", "Option-Shift-Left"),
          exec: function(editor) {
            editor.getSelection().selectWordLeft();
          },
          multiSelectAction: "forEach",
          scrollIntoView: "cursor",
          readOnly: true
        },
        {
          name: "gotowordleft",
          description: "Go to word left",
          bindKey: bindKey("Ctrl-Left", "Option-Left"),
          exec: function(editor) {
            editor.navigateWordLeft();
          },
          multiSelectAction: "forEach",
          scrollIntoView: "cursor",
          readOnly: true
        },
        {
          name: "selecttolinestart",
          description: "Select to line start",
          bindKey: bindKey("Alt-Shift-Left", "Command-Shift-Left|Ctrl-Shift-A"),
          exec: function(editor) {
            editor.getSelection().selectLineStart();
          },
          multiSelectAction: "forEach",
          scrollIntoView: "cursor",
          readOnly: true
        },
        {
          name: "gotolinestart",
          description: "Go to line start",
          bindKey: bindKey("Alt-Left|Home", "Command-Left|Home|Ctrl-A"),
          exec: function(editor) {
            editor.navigateLineStart();
          },
          multiSelectAction: "forEach",
          scrollIntoView: "cursor",
          readOnly: true
        },
        {
          name: "selectleft",
          description: "Select left",
          bindKey: bindKey("Shift-Left", "Shift-Left|Ctrl-Shift-B"),
          exec: function(editor) {
            editor.getSelection().selectLeft();
          },
          multiSelectAction: "forEach",
          scrollIntoView: "cursor",
          readOnly: true
        },
        {
          name: "gotoleft",
          description: "Go to left",
          bindKey: bindKey("Left", "Left|Ctrl-B"),
          exec: function(editor, args) {
            editor.navigateLeft(args.times);
          },
          multiSelectAction: "forEach",
          scrollIntoView: "cursor",
          readOnly: true
        },
        {
          name: "selectwordright",
          description: "Select word right",
          bindKey: bindKey("Ctrl-Shift-Right", "Option-Shift-Right"),
          exec: function(editor) {
            editor.getSelection().selectWordRight();
          },
          multiSelectAction: "forEach",
          scrollIntoView: "cursor",
          readOnly: true
        },
        {
          name: "gotowordright",
          description: "Go to word right",
          bindKey: bindKey("Ctrl-Right", "Option-Right"),
          exec: function(editor) {
            editor.navigateWordRight();
          },
          multiSelectAction: "forEach",
          scrollIntoView: "cursor",
          readOnly: true
        },
        {
          name: "selecttolineend",
          description: "Select to line end",
          bindKey: bindKey("Alt-Shift-Right", "Command-Shift-Right|Shift-End|Ctrl-Shift-E"),
          exec: function(editor) {
            editor.getSelection().selectLineEnd();
          },
          multiSelectAction: "forEach",
          scrollIntoView: "cursor",
          readOnly: true
        },
        {
          name: "gotolineend",
          description: "Go to line end",
          bindKey: bindKey("Alt-Right|End", "Command-Right|End|Ctrl-E"),
          exec: function(editor) {
            editor.navigateLineEnd();
          },
          multiSelectAction: "forEach",
          scrollIntoView: "cursor",
          readOnly: true
        },
        {
          name: "selectright",
          description: "Select right",
          bindKey: bindKey("Shift-Right", "Shift-Right"),
          exec: function(editor) {
            editor.getSelection().selectRight();
          },
          multiSelectAction: "forEach",
          scrollIntoView: "cursor",
          readOnly: true
        },
        {
          name: "gotoright",
          description: "Go to right",
          bindKey: bindKey("Right", "Right|Ctrl-F"),
          exec: function(editor, args) {
            editor.navigateRight(args.times);
          },
          multiSelectAction: "forEach",
          scrollIntoView: "cursor",
          readOnly: true
        },
        {
          name: "selectpagedown",
          description: "Select page down",
          bindKey: "Shift-PageDown",
          exec: function(editor) {
            editor.selectPageDown();
          },
          readOnly: true
        },
        {
          name: "pagedown",
          description: "Page down",
          bindKey: bindKey(null, "Option-PageDown"),
          exec: function(editor) {
            editor.scrollPageDown();
          },
          readOnly: true
        },
        {
          name: "gotopagedown",
          description: "Go to page down",
          bindKey: bindKey("PageDown", "PageDown|Ctrl-V"),
          exec: function(editor) {
            editor.gotoPageDown();
          },
          readOnly: true
        },
        {
          name: "selectpageup",
          description: "Select page up",
          bindKey: "Shift-PageUp",
          exec: function(editor) {
            editor.selectPageUp();
          },
          readOnly: true
        },
        {
          name: "pageup",
          description: "Page up",
          bindKey: bindKey(null, "Option-PageUp"),
          exec: function(editor) {
            editor.scrollPageUp();
          },
          readOnly: true
        },
        {
          name: "gotopageup",
          description: "Go to page up",
          bindKey: "PageUp",
          exec: function(editor) {
            editor.gotoPageUp();
          },
          readOnly: true
        },
        {
          name: "scrollup",
          description: "Scroll up",
          bindKey: bindKey("Ctrl-Up", null),
          exec: function(e2) {
            e2.renderer.scrollBy(0, -2 * e2.renderer.layerConfig.lineHeight);
          },
          readOnly: true
        },
        {
          name: "scrolldown",
          description: "Scroll down",
          bindKey: bindKey("Ctrl-Down", null),
          exec: function(e2) {
            e2.renderer.scrollBy(0, 2 * e2.renderer.layerConfig.lineHeight);
          },
          readOnly: true
        },
        {
          name: "selectlinestart",
          description: "Select line start",
          bindKey: "Shift-Home",
          exec: function(editor) {
            editor.getSelection().selectLineStart();
          },
          multiSelectAction: "forEach",
          scrollIntoView: "cursor",
          readOnly: true
        },
        {
          name: "selectlineend",
          description: "Select line end",
          bindKey: "Shift-End",
          exec: function(editor) {
            editor.getSelection().selectLineEnd();
          },
          multiSelectAction: "forEach",
          scrollIntoView: "cursor",
          readOnly: true
        },
        {
          name: "togglerecording",
          description: "Toggle recording",
          bindKey: bindKey("Ctrl-Alt-E", "Command-Option-E"),
          exec: function(editor) {
            editor.commands.toggleRecording(editor);
          },
          readOnly: true
        },
        {
          name: "replaymacro",
          description: "Replay macro",
          bindKey: bindKey("Ctrl-Shift-E", "Command-Shift-E"),
          exec: function(editor) {
            editor.commands.replay(editor);
          },
          readOnly: true
        },
        {
          name: "jumptomatching",
          description: "Jump to matching",
          bindKey: bindKey("Ctrl-\\|Ctrl-P", "Command-\\"),
          exec: function(editor) {
            editor.jumpToMatching();
          },
          multiSelectAction: "forEach",
          scrollIntoView: "animate",
          readOnly: true
        },
        {
          name: "selecttomatching",
          description: "Select to matching",
          bindKey: bindKey("Ctrl-Shift-\\|Ctrl-Shift-P", "Command-Shift-\\"),
          exec: function(editor) {
            editor.jumpToMatching(true);
          },
          multiSelectAction: "forEach",
          scrollIntoView: "animate",
          readOnly: true
        },
        {
          name: "expandToMatching",
          description: "Expand to matching",
          bindKey: bindKey("Ctrl-Shift-M", "Ctrl-Shift-M"),
          exec: function(editor) {
            editor.jumpToMatching(true, true);
          },
          multiSelectAction: "forEach",
          scrollIntoView: "animate",
          readOnly: true
        },
        {
          name: "passKeysToBrowser",
          description: "Pass keys to browser",
          bindKey: bindKey(null, null),
          exec: function() {
          },
          passEvent: true,
          readOnly: true
        },
        {
          name: "copy",
          description: "Copy",
          exec: function(editor) {
          },
          readOnly: true
        },
        {
          name: "cut",
          description: "Cut",
          exec: function(editor) {
            var cutLine = editor.$copyWithEmptySelection && editor.selection.isEmpty();
            var range = cutLine ? editor.selection.getLineRange() : editor.selection.getRange();
            editor._emit("cut", range);
            if (!range.isEmpty())
              editor.session.remove(range);
            editor.clearSelection();
          },
          scrollIntoView: "cursor",
          multiSelectAction: "forEach"
        },
        {
          name: "paste",
          description: "Paste",
          exec: function(editor, args) {
            editor.$handlePaste(args);
          },
          scrollIntoView: "cursor"
        },
        {
          name: "removeline",
          description: "Remove line",
          bindKey: bindKey("Ctrl-D", "Command-D"),
          exec: function(editor) {
            editor.removeLines();
          },
          scrollIntoView: "cursor",
          multiSelectAction: "forEachLine"
        },
        {
          name: "duplicateSelection",
          description: "Duplicate selection",
          bindKey: bindKey("Ctrl-Shift-D", "Command-Shift-D"),
          exec: function(editor) {
            editor.duplicateSelection();
          },
          scrollIntoView: "cursor",
          multiSelectAction: "forEach"
        },
        {
          name: "sortlines",
          description: "Sort lines",
          bindKey: bindKey("Ctrl-Alt-S", "Command-Alt-S"),
          exec: function(editor) {
            editor.sortLines();
          },
          scrollIntoView: "selection",
          multiSelectAction: "forEachLine"
        },
        {
          name: "togglecomment",
          description: "Toggle comment",
          bindKey: bindKey("Ctrl-/", "Command-/"),
          exec: function(editor) {
            editor.toggleCommentLines();
          },
          multiSelectAction: "forEachLine",
          scrollIntoView: "selectionPart"
        },
        {
          name: "toggleBlockComment",
          description: "Toggle block comment",
          bindKey: bindKey("Ctrl-Shift-/", "Command-Shift-/"),
          exec: function(editor) {
            editor.toggleBlockComment();
          },
          multiSelectAction: "forEach",
          scrollIntoView: "selectionPart"
        },
        {
          name: "modifyNumberUp",
          description: "Modify number up",
          bindKey: bindKey("Ctrl-Shift-Up", "Alt-Shift-Up"),
          exec: function(editor) {
            editor.modifyNumber(1);
          },
          scrollIntoView: "cursor",
          multiSelectAction: "forEach"
        },
        {
          name: "modifyNumberDown",
          description: "Modify number down",
          bindKey: bindKey("Ctrl-Shift-Down", "Alt-Shift-Down"),
          exec: function(editor) {
            editor.modifyNumber(-1);
          },
          scrollIntoView: "cursor",
          multiSelectAction: "forEach"
        },
        {
          name: "replace",
          description: "Replace",
          bindKey: bindKey("Ctrl-H", "Command-Option-F"),
          exec: function(editor) {
            config.loadModule("ace/ext/searchbox", function(e2) {
              e2.Search(editor, true);
            });
          }
        },
        {
          name: "undo",
          description: "Undo",
          bindKey: bindKey("Ctrl-Z", "Command-Z"),
          exec: function(editor) {
            editor.undo();
          }
        },
        {
          name: "redo",
          description: "Redo",
          bindKey: bindKey("Ctrl-Shift-Z|Ctrl-Y", "Command-Shift-Z|Command-Y"),
          exec: function(editor) {
            editor.redo();
          }
        },
        {
          name: "copylinesup",
          description: "Copy lines up",
          bindKey: bindKey("Alt-Shift-Up", "Command-Option-Up"),
          exec: function(editor) {
            editor.copyLinesUp();
          },
          scrollIntoView: "cursor"
        },
        {
          name: "movelinesup",
          description: "Move lines up",
          bindKey: bindKey("Alt-Up", "Option-Up"),
          exec: function(editor) {
            editor.moveLinesUp();
          },
          scrollIntoView: "cursor"
        },
        {
          name: "copylinesdown",
          description: "Copy lines down",
          bindKey: bindKey("Alt-Shift-Down", "Command-Option-Down"),
          exec: function(editor) {
            editor.copyLinesDown();
          },
          scrollIntoView: "cursor"
        },
        {
          name: "movelinesdown",
          description: "Move lines down",
          bindKey: bindKey("Alt-Down", "Option-Down"),
          exec: function(editor) {
            editor.moveLinesDown();
          },
          scrollIntoView: "cursor"
        },
        {
          name: "del",
          description: "Delete",
          bindKey: bindKey("Delete", "Delete|Ctrl-D|Shift-Delete"),
          exec: function(editor) {
            editor.remove("right");
          },
          multiSelectAction: "forEach",
          scrollIntoView: "cursor"
        },
        {
          name: "backspace",
          description: "Backspace",
          bindKey: bindKey("Shift-Backspace|Backspace", "Ctrl-Backspace|Shift-Backspace|Backspace|Ctrl-H"),
          exec: function(editor) {
            editor.remove("left");
          },
          multiSelectAction: "forEach",
          scrollIntoView: "cursor"
        },
        {
          name: "cut_or_delete",
          description: "Cut or delete",
          bindKey: bindKey("Shift-Delete", null),
          exec: function(editor) {
            if (editor.selection.isEmpty()) {
              editor.remove("left");
            } else {
              return false;
            }
          },
          multiSelectAction: "forEach",
          scrollIntoView: "cursor"
        },
        {
          name: "removetolinestart",
          description: "Remove to line start",
          bindKey: bindKey("Alt-Backspace", "Command-Backspace"),
          exec: function(editor) {
            editor.removeToLineStart();
          },
          multiSelectAction: "forEach",
          scrollIntoView: "cursor"
        },
        {
          name: "removetolineend",
          description: "Remove to line end",
          bindKey: bindKey("Alt-Delete", "Ctrl-K|Command-Delete"),
          exec: function(editor) {
            editor.removeToLineEnd();
          },
          multiSelectAction: "forEach",
          scrollIntoView: "cursor"
        },
        {
          name: "removetolinestarthard",
          description: "Remove to line start hard",
          bindKey: bindKey("Ctrl-Shift-Backspace", null),
          exec: function(editor) {
            var range = editor.selection.getRange();
            range.start.column = 0;
            editor.session.remove(range);
          },
          multiSelectAction: "forEach",
          scrollIntoView: "cursor"
        },
        {
          name: "removetolineendhard",
          description: "Remove to line end hard",
          bindKey: bindKey("Ctrl-Shift-Delete", null),
          exec: function(editor) {
            var range = editor.selection.getRange();
            range.end.column = Number.MAX_VALUE;
            editor.session.remove(range);
          },
          multiSelectAction: "forEach",
          scrollIntoView: "cursor"
        },
        {
          name: "removewordleft",
          description: "Remove word left",
          bindKey: bindKey("Ctrl-Backspace", "Alt-Backspace|Ctrl-Alt-Backspace"),
          exec: function(editor) {
            editor.removeWordLeft();
          },
          multiSelectAction: "forEach",
          scrollIntoView: "cursor"
        },
        {
          name: "removewordright",
          description: "Remove word right",
          bindKey: bindKey("Ctrl-Delete", "Alt-Delete"),
          exec: function(editor) {
            editor.removeWordRight();
          },
          multiSelectAction: "forEach",
          scrollIntoView: "cursor"
        },
        {
          name: "outdent",
          description: "Outdent",
          bindKey: bindKey("Shift-Tab", "Shift-Tab"),
          exec: function(editor) {
            editor.blockOutdent();
          },
          multiSelectAction: "forEach",
          scrollIntoView: "selectionPart"
        },
        {
          name: "indent",
          description: "Indent",
          bindKey: bindKey("Tab", "Tab"),
          exec: function(editor) {
            editor.indent();
          },
          multiSelectAction: "forEach",
          scrollIntoView: "selectionPart"
        },
        {
          name: "blockoutdent",
          description: "Block outdent",
          bindKey: bindKey("Ctrl-[", "Ctrl-["),
          exec: function(editor) {
            editor.blockOutdent();
          },
          multiSelectAction: "forEachLine",
          scrollIntoView: "selectionPart"
        },
        {
          name: "blockindent",
          description: "Block indent",
          bindKey: bindKey("Ctrl-]", "Ctrl-]"),
          exec: function(editor) {
            editor.blockIndent();
          },
          multiSelectAction: "forEachLine",
          scrollIntoView: "selectionPart"
        },
        {
          name: "insertstring",
          description: "Insert string",
          exec: function(editor, str) {
            editor.insert(str);
          },
          multiSelectAction: "forEach",
          scrollIntoView: "cursor"
        },
        {
          name: "inserttext",
          description: "Insert text",
          exec: function(editor, args) {
            editor.insert(lang.stringRepeat(args.text || "", args.times || 1));
          },
          multiSelectAction: "forEach",
          scrollIntoView: "cursor"
        },
        {
          name: "splitline",
          description: "Split line",
          bindKey: bindKey(null, "Ctrl-O"),
          exec: function(editor) {
            editor.splitLine();
          },
          multiSelectAction: "forEach",
          scrollIntoView: "cursor"
        },
        {
          name: "transposeletters",
          description: "Transpose letters",
          bindKey: bindKey("Alt-Shift-X", "Ctrl-T"),
          exec: function(editor) {
            editor.transposeLetters();
          },
          multiSelectAction: function(editor) {
            editor.transposeSelections(1);
          },
          scrollIntoView: "cursor"
        },
        {
          name: "touppercase",
          description: "To uppercase",
          bindKey: bindKey("Ctrl-U", "Ctrl-U"),
          exec: function(editor) {
            editor.toUpperCase();
          },
          multiSelectAction: "forEach",
          scrollIntoView: "cursor"
        },
        {
          name: "tolowercase",
          description: "To lowercase",
          bindKey: bindKey("Ctrl-Shift-U", "Ctrl-Shift-U"),
          exec: function(editor) {
            editor.toLowerCase();
          },
          multiSelectAction: "forEach",
          scrollIntoView: "cursor"
        },
        {
          name: "autoindent",
          description: "Auto Indent",
          bindKey: bindKey(null, null),
          exec: function(editor) {
            editor.autoIndent();
          },
          scrollIntoView: "animate"
        },
        {
          name: "expandtoline",
          description: "Expand to line",
          bindKey: bindKey("Ctrl-Shift-L", "Command-Shift-L"),
          exec: function(editor) {
            var range = editor.selection.getRange();
            range.start.column = range.end.column = 0;
            range.end.row++;
            editor.selection.setRange(range, false);
          },
          multiSelectAction: "forEach",
          scrollIntoView: "cursor",
          readOnly: true
        },
        {
          name: "openlink",
          bindKey: bindKey("Ctrl+F3", "F3"),
          exec: function(editor) {
            editor.openLink();
          }
        },
        {
          name: "joinlines",
          description: "Join lines",
          bindKey: bindKey(null, null),
          exec: function(editor) {
            var isBackwards = editor.selection.isBackwards();
            var selectionStart = isBackwards ? editor.selection.getSelectionLead() : editor.selection.getSelectionAnchor();
            var selectionEnd = isBackwards ? editor.selection.getSelectionAnchor() : editor.selection.getSelectionLead();
            var firstLineEndCol = editor.session.doc.getLine(selectionStart.row).length;
            var selectedText = editor.session.doc.getTextRange(editor.selection.getRange());
            var selectedCount = selectedText.replace(/\n\s*/, " ").length;
            var insertLine = editor.session.doc.getLine(selectionStart.row);
            for (var i3 = selectionStart.row + 1; i3 <= selectionEnd.row + 1; i3++) {
              var curLine = lang.stringTrimLeft(lang.stringTrimRight(editor.session.doc.getLine(i3)));
              if (curLine.length !== 0) {
                curLine = " " + curLine;
              }
              insertLine += curLine;
            }
            if (selectionEnd.row + 1 < editor.session.doc.getLength() - 1) {
              insertLine += editor.session.doc.getNewLineCharacter();
            }
            editor.clearSelection();
            editor.session.doc.replace(new Range(selectionStart.row, 0, selectionEnd.row + 2, 0), insertLine);
            if (selectedCount > 0) {
              editor.selection.moveCursorTo(selectionStart.row, selectionStart.column);
              editor.selection.selectTo(selectionStart.row, selectionStart.column + selectedCount);
            } else {
              firstLineEndCol = editor.session.doc.getLine(selectionStart.row).length > firstLineEndCol ? firstLineEndCol + 1 : firstLineEndCol;
              editor.selection.moveCursorTo(selectionStart.row, firstLineEndCol);
            }
          },
          multiSelectAction: "forEach",
          readOnly: true
        },
        {
          name: "invertSelection",
          description: "Invert selection",
          bindKey: bindKey(null, null),
          exec: function(editor) {
            var endRow = editor.session.doc.getLength() - 1;
            var endCol = editor.session.doc.getLine(endRow).length;
            var ranges = editor.selection.rangeList.ranges;
            var newRanges = [];
            if (ranges.length < 1) {
              ranges = [editor.selection.getRange()];
            }
            for (var i3 = 0; i3 < ranges.length; i3++) {
              if (i3 == ranges.length - 1) {
                if (!(ranges[i3].end.row === endRow && ranges[i3].end.column === endCol)) {
                  newRanges.push(new Range(ranges[i3].end.row, ranges[i3].end.column, endRow, endCol));
                }
              }
              if (i3 === 0) {
                if (!(ranges[i3].start.row === 0 && ranges[i3].start.column === 0)) {
                  newRanges.push(new Range(0, 0, ranges[i3].start.row, ranges[i3].start.column));
                }
              } else {
                newRanges.push(new Range(ranges[i3 - 1].end.row, ranges[i3 - 1].end.column, ranges[i3].start.row, ranges[i3].start.column));
              }
            }
            editor.exitMultiSelectMode();
            editor.clearSelection();
            for (var i3 = 0; i3 < newRanges.length; i3++) {
              editor.selection.addRange(newRanges[i3], false);
            }
          },
          readOnly: true,
          scrollIntoView: "none"
        },
        {
          name: "addLineAfter",
          description: "Add new line after the current line",
          exec: function(editor) {
            editor.selection.clearSelection();
            editor.navigateLineEnd();
            editor.insert("\n");
          },
          multiSelectAction: "forEach",
          scrollIntoView: "cursor"
        },
        {
          name: "addLineBefore",
          description: "Add new line before the current line",
          exec: function(editor) {
            editor.selection.clearSelection();
            var cursor = editor.getCursorPosition();
            editor.selection.moveTo(cursor.row - 1, Number.MAX_VALUE);
            editor.insert("\n");
            if (cursor.row === 0)
              editor.navigateUp();
          },
          multiSelectAction: "forEach",
          scrollIntoView: "cursor"
        },
        {
          name: "openCommandPallete",
          exec: function(editor) {
            console.warn("This is an obsolete command. Please use `openCommandPalette` instead.");
            editor.prompt({ $type: "commands" });
          },
          readOnly: true
        },
        {
          name: "openCommandPalette",
          description: "Open command palette",
          bindKey: bindKey("F1", "F1"),
          exec: function(editor) {
            editor.prompt({ $type: "commands" });
          },
          readOnly: true
        },
        {
          name: "modeSelect",
          description: "Change language mode...",
          bindKey: bindKey(null, null),
          exec: function(editor) {
            editor.prompt({ $type: "modes" });
          },
          readOnly: true
        }
      ];
      for (var i2 = 1; i2 < 9; i2++) {
        exports3.commands.push({
          name: "foldToLevel" + i2,
          description: "Fold To Level " + i2,
          level: i2,
          exec: function(editor) {
            editor.session.foldToLevel(this.level);
          },
          scrollIntoView: "center",
          readOnly: true
        });
      }
    });
    ace.define("ace/keyboard/gutter_handler", ["require", "exports", "module", "ace/lib/keys", "ace/mouse/default_gutter_handler"], function(require2, exports3, module3) {
      var keys = require2("../lib/keys");
      var GutterTooltip = require2("../mouse/default_gutter_handler").GutterTooltip;
      var GutterKeyboardHandler = (
        /** @class */
        (function() {
          function GutterKeyboardHandler2(editor) {
            this.editor = editor;
            this.gutterLayer = editor.renderer.$gutterLayer;
            this.element = editor.renderer.$gutter;
            this.lines = editor.renderer.$gutterLayer.$lines;
            this.activeRowIndex = null;
            this.activeLane = null;
            this.annotationTooltip = new GutterTooltip(this.editor);
          }
          GutterKeyboardHandler2.prototype.addListener = function() {
            this.element.addEventListener("keydown", this.$onGutterKeyDown.bind(this));
            this.element.addEventListener("focusout", this.$blurGutter.bind(this));
            this.editor.on("mousewheel", this.$blurGutter.bind(this));
          };
          GutterKeyboardHandler2.prototype.removeListener = function() {
            this.element.removeEventListener("keydown", this.$onGutterKeyDown.bind(this));
            this.element.removeEventListener("focusout", this.$blurGutter.bind(this));
            this.editor.off("mousewheel", this.$blurGutter.bind(this));
          };
          GutterKeyboardHandler2.prototype.$onGutterKeyDown = function(e2) {
            if (this.annotationTooltip.isOpen) {
              e2.preventDefault();
              if (e2.keyCode === keys["escape"])
                this.annotationTooltip.hideTooltip();
              return;
            }
            if (e2.target === this.element) {
              if (e2.keyCode != keys["enter"]) {
                return;
              }
              e2.preventDefault();
              var row = this.editor.getCursorPosition().row;
              if (!this.editor.isRowVisible(row))
                this.editor.scrollToLine(row, true, true);
              setTimeout(
                (function() {
                  var index = this.$rowToRowIndex(this.gutterLayer.$cursorCell.row);
                  var nearestFoldIndex = this.$findNearestFoldWidget(index);
                  var nearestAnnotationIndex = this.$findNearestAnnotation(index);
                  if (nearestFoldIndex === null && nearestAnnotationIndex === null)
                    return;
                  if (nearestFoldIndex === null && nearestAnnotationIndex !== null) {
                    this.activeRowIndex = nearestAnnotationIndex;
                    this.activeLane = "annotation";
                    this.$focusAnnotation(this.activeRowIndex);
                    return;
                  }
                  if (nearestFoldIndex !== null && nearestAnnotationIndex === null) {
                    this.activeRowIndex = nearestFoldIndex;
                    this.activeLane = "fold";
                    this.$focusFoldWidget(this.activeRowIndex);
                    return;
                  }
                  if (Math.abs(nearestAnnotationIndex - index) < Math.abs(nearestFoldIndex - index)) {
                    this.activeRowIndex = nearestAnnotationIndex;
                    this.activeLane = "annotation";
                    this.$focusAnnotation(this.activeRowIndex);
                    return;
                  } else {
                    this.activeRowIndex = nearestFoldIndex;
                    this.activeLane = "fold";
                    this.$focusFoldWidget(this.activeRowIndex);
                    return;
                  }
                }).bind(this),
                10
              );
              return;
            }
            this.$handleGutterKeyboardInteraction(e2);
            setTimeout((function() {
              this.editor._signal("gutterkeydown", new GutterKeyboardEvent(e2, this));
            }).bind(this), 10);
          };
          GutterKeyboardHandler2.prototype.$handleGutterKeyboardInteraction = function(e2) {
            if (e2.keyCode === keys["tab"]) {
              e2.preventDefault();
              return;
            }
            if (e2.keyCode === keys["escape"]) {
              e2.preventDefault();
              this.$blurGutter();
              this.element.focus();
              this.lane = null;
              return;
            }
            if (e2.keyCode === keys["up"]) {
              e2.preventDefault();
              switch (this.activeLane) {
                case "fold":
                  this.$moveFoldWidgetUp();
                  break;
                case "annotation":
                  this.$moveAnnotationUp();
                  break;
              }
              return;
            }
            if (e2.keyCode === keys["down"]) {
              e2.preventDefault();
              switch (this.activeLane) {
                case "fold":
                  this.$moveFoldWidgetDown();
                  break;
                case "annotation":
                  this.$moveAnnotationDown();
                  break;
              }
              return;
            }
            if (e2.keyCode === keys["left"]) {
              e2.preventDefault();
              this.$switchLane("annotation");
              return;
            }
            if (e2.keyCode === keys["right"]) {
              e2.preventDefault();
              this.$switchLane("fold");
              return;
            }
            if (e2.keyCode === keys["enter"] || e2.keyCode === keys["space"]) {
              e2.preventDefault();
              switch (this.activeLane) {
                case "fold":
                  if (this.gutterLayer.session.foldWidgets[this.$rowIndexToRow(this.activeRowIndex)] === "start") {
                    var rowFoldingWidget = this.$rowIndexToRow(this.activeRowIndex);
                    this.editor.session.onFoldWidgetClick(this.$rowIndexToRow(this.activeRowIndex), e2);
                    setTimeout(
                      (function() {
                        if (this.$rowIndexToRow(this.activeRowIndex) !== rowFoldingWidget) {
                          this.$blurFoldWidget(this.activeRowIndex);
                          this.activeRowIndex = this.$rowToRowIndex(rowFoldingWidget);
                          this.$focusFoldWidget(this.activeRowIndex);
                        }
                      }).bind(this),
                      10
                    );
                    break;
                  } else if (this.gutterLayer.session.foldWidgets[this.$rowIndexToRow(this.activeRowIndex)] === "end") {
                    break;
                  }
                  return;
                case "annotation":
                  var gutterElement = this.lines.cells[this.activeRowIndex].element.childNodes[2];
                  var rect = gutterElement.getBoundingClientRect();
                  var style = this.annotationTooltip.getElement().style;
                  style.left = rect.right + "px";
                  style.top = rect.bottom + "px";
                  this.annotationTooltip.showTooltip(this.$rowIndexToRow(this.activeRowIndex));
                  break;
              }
              return;
            }
          };
          GutterKeyboardHandler2.prototype.$blurGutter = function() {
            if (this.activeRowIndex !== null) {
              switch (this.activeLane) {
                case "fold":
                  this.$blurFoldWidget(this.activeRowIndex);
                  break;
                case "annotation":
                  this.$blurAnnotation(this.activeRowIndex);
                  break;
              }
            }
            if (this.annotationTooltip.isOpen)
              this.annotationTooltip.hideTooltip();
            return;
          };
          GutterKeyboardHandler2.prototype.$isFoldWidgetVisible = function(index) {
            var isRowFullyVisible = this.editor.isRowFullyVisible(this.$rowIndexToRow(index));
            var isIconVisible = this.$getFoldWidget(index).style.display !== "none";
            return isRowFullyVisible && isIconVisible;
          };
          GutterKeyboardHandler2.prototype.$isAnnotationVisible = function(index) {
            var isRowFullyVisible = this.editor.isRowFullyVisible(this.$rowIndexToRow(index));
            var isIconVisible = this.$getAnnotation(index).style.display !== "none";
            return isRowFullyVisible && isIconVisible;
          };
          GutterKeyboardHandler2.prototype.$getFoldWidget = function(index) {
            var cell = this.lines.get(index);
            var element = cell.element;
            return element.childNodes[1];
          };
          GutterKeyboardHandler2.prototype.$getAnnotation = function(index) {
            var cell = this.lines.get(index);
            var element = cell.element;
            return element.childNodes[2];
          };
          GutterKeyboardHandler2.prototype.$findNearestFoldWidget = function(index) {
            if (this.$isFoldWidgetVisible(index))
              return index;
            var i2 = 0;
            while (index - i2 > 0 || index + i2 < this.lines.getLength() - 1) {
              i2++;
              if (index - i2 >= 0 && this.$isFoldWidgetVisible(index - i2))
                return index - i2;
              if (index + i2 <= this.lines.getLength() - 1 && this.$isFoldWidgetVisible(index + i2))
                return index + i2;
            }
            return null;
          };
          GutterKeyboardHandler2.prototype.$findNearestAnnotation = function(index) {
            if (this.$isAnnotationVisible(index))
              return index;
            var i2 = 0;
            while (index - i2 > 0 || index + i2 < this.lines.getLength() - 1) {
              i2++;
              if (index - i2 >= 0 && this.$isAnnotationVisible(index - i2))
                return index - i2;
              if (index + i2 <= this.lines.getLength() - 1 && this.$isAnnotationVisible(index + i2))
                return index + i2;
            }
            return null;
          };
          GutterKeyboardHandler2.prototype.$focusFoldWidget = function(index) {
            if (index == null)
              return;
            var foldWidget = this.$getFoldWidget(index);
            foldWidget.classList.add(this.editor.renderer.keyboardFocusClassName);
            foldWidget.focus();
          };
          GutterKeyboardHandler2.prototype.$focusAnnotation = function(index) {
            if (index == null)
              return;
            var annotation = this.$getAnnotation(index);
            annotation.classList.add(this.editor.renderer.keyboardFocusClassName);
            annotation.focus();
          };
          GutterKeyboardHandler2.prototype.$blurFoldWidget = function(index) {
            var foldWidget = this.$getFoldWidget(index);
            foldWidget.classList.remove(this.editor.renderer.keyboardFocusClassName);
            foldWidget.blur();
          };
          GutterKeyboardHandler2.prototype.$blurAnnotation = function(index) {
            var annotation = this.$getAnnotation(index);
            annotation.classList.remove(this.editor.renderer.keyboardFocusClassName);
            annotation.blur();
          };
          GutterKeyboardHandler2.prototype.$moveFoldWidgetUp = function() {
            var index = this.activeRowIndex;
            while (index > 0) {
              index--;
              if (this.$isFoldWidgetVisible(index)) {
                this.$blurFoldWidget(this.activeRowIndex);
                this.activeRowIndex = index;
                this.$focusFoldWidget(this.activeRowIndex);
                return;
              }
            }
            return;
          };
          GutterKeyboardHandler2.prototype.$moveFoldWidgetDown = function() {
            var index = this.activeRowIndex;
            while (index < this.lines.getLength() - 1) {
              index++;
              if (this.$isFoldWidgetVisible(index)) {
                this.$blurFoldWidget(this.activeRowIndex);
                this.activeRowIndex = index;
                this.$focusFoldWidget(this.activeRowIndex);
                return;
              }
            }
            return;
          };
          GutterKeyboardHandler2.prototype.$moveAnnotationUp = function() {
            var index = this.activeRowIndex;
            while (index > 0) {
              index--;
              if (this.$isAnnotationVisible(index)) {
                this.$blurAnnotation(this.activeRowIndex);
                this.activeRowIndex = index;
                this.$focusAnnotation(this.activeRowIndex);
                return;
              }
            }
            return;
          };
          GutterKeyboardHandler2.prototype.$moveAnnotationDown = function() {
            var index = this.activeRowIndex;
            while (index < this.lines.getLength() - 1) {
              index++;
              if (this.$isAnnotationVisible(index)) {
                this.$blurAnnotation(this.activeRowIndex);
                this.activeRowIndex = index;
                this.$focusAnnotation(this.activeRowIndex);
                return;
              }
            }
            return;
          };
          GutterKeyboardHandler2.prototype.$switchLane = function(desinationLane) {
            switch (desinationLane) {
              case "annotation":
                if (this.activeLane === "annotation") {
                  break;
                }
                var annotationIndex = this.$findNearestAnnotation(this.activeRowIndex);
                if (annotationIndex == null) {
                  break;
                }
                this.activeLane = "annotation";
                this.$blurFoldWidget(this.activeRowIndex);
                this.activeRowIndex = annotationIndex;
                this.$focusAnnotation(this.activeRowIndex);
                break;
              case "fold":
                if (this.activeLane === "fold") {
                  break;
                }
                var foldWidgetIndex = this.$findNearestFoldWidget(this.activeRowIndex);
                if (foldWidgetIndex == null) {
                  break;
                }
                this.activeLane = "fold";
                this.$blurAnnotation(this.activeRowIndex);
                this.activeRowIndex = foldWidgetIndex;
                this.$focusFoldWidget(this.activeRowIndex);
                break;
            }
            return;
          };
          GutterKeyboardHandler2.prototype.$rowIndexToRow = function(index) {
            var cell = this.lines.get(index);
            if (cell)
              return cell.row;
            return null;
          };
          GutterKeyboardHandler2.prototype.$rowToRowIndex = function(row) {
            for (var i2 = 0; i2 < this.lines.getLength(); i2++) {
              var cell = this.lines.get(i2);
              if (cell.row == row)
                return i2;
            }
            return null;
          };
          return GutterKeyboardHandler2;
        })()
      );
      exports3.GutterKeyboardHandler = GutterKeyboardHandler;
      var GutterKeyboardEvent = (
        /** @class */
        (function() {
          function GutterKeyboardEvent2(domEvent, gutterKeyboardHandler) {
            this.gutterKeyboardHandler = gutterKeyboardHandler;
            this.domEvent = domEvent;
          }
          GutterKeyboardEvent2.prototype.getKey = function() {
            return keys.keyCodeToString(this.domEvent.keyCode);
          };
          GutterKeyboardEvent2.prototype.getRow = function() {
            return this.gutterKeyboardHandler.$rowIndexToRow(this.gutterKeyboardHandler.activeRowIndex);
          };
          GutterKeyboardEvent2.prototype.isInAnnotationLane = function() {
            return this.gutterKeyboardHandler.activeLane === "annotation";
          };
          GutterKeyboardEvent2.prototype.isInFoldLane = function() {
            return this.gutterKeyboardHandler.activeLane === "fold";
          };
          return GutterKeyboardEvent2;
        })()
      );
      exports3.GutterKeyboardEvent = GutterKeyboardEvent;
    });
    ace.define("ace/editor", ["require", "exports", "module", "ace/lib/oop", "ace/lib/dom", "ace/lib/lang", "ace/lib/useragent", "ace/keyboard/textinput", "ace/mouse/mouse_handler", "ace/mouse/fold_handler", "ace/keyboard/keybinding", "ace/edit_session", "ace/search", "ace/range", "ace/lib/event_emitter", "ace/commands/command_manager", "ace/commands/default_commands", "ace/config", "ace/token_iterator", "ace/keyboard/gutter_handler", "ace/config", "ace/clipboard", "ace/lib/keys"], function(require2, exports3, module3) {
      var __values = this && this.__values || function(o) {
        var s3 = typeof Symbol === "function" && Symbol.iterator, m3 = s3 && o[s3], i2 = 0;
        if (m3) return m3.call(o);
        if (o && typeof o.length === "number") return {
          next: function() {
            if (o && i2 >= o.length) o = void 0;
            return { value: o && o[i2++], done: !o };
          }
        };
        throw new TypeError(s3 ? "Object is not iterable." : "Symbol.iterator is not defined.");
      };
      var oop = require2("./lib/oop");
      var dom = require2("./lib/dom");
      var lang = require2("./lib/lang");
      var useragent = require2("./lib/useragent");
      var TextInput = require2("./keyboard/textinput").TextInput;
      var MouseHandler = require2("./mouse/mouse_handler").MouseHandler;
      var FoldHandler = require2("./mouse/fold_handler").FoldHandler;
      var KeyBinding = require2("./keyboard/keybinding").KeyBinding;
      var EditSession = require2("./edit_session").EditSession;
      var Search = require2("./search").Search;
      var Range = require2("./range").Range;
      var EventEmitter = require2("./lib/event_emitter").EventEmitter;
      var CommandManager = require2("./commands/command_manager").CommandManager;
      var defaultCommands = require2("./commands/default_commands").commands;
      var config = require2("./config");
      var TokenIterator = require2("./token_iterator").TokenIterator;
      var GutterKeyboardHandler = require2("./keyboard/gutter_handler").GutterKeyboardHandler;
      var nls = require2("./config").nls;
      var clipboard = require2("./clipboard");
      var keys = require2("./lib/keys");
      var Editor = (
        /** @class */
        (function() {
          function Editor2(renderer, session, options) {
            this.session;
            this.$toDestroy = [];
            var container = renderer.getContainerElement();
            this.container = container;
            this.renderer = renderer;
            this.id = "editor" + ++Editor2.$uid;
            this.commands = new CommandManager(useragent.isMac ? "mac" : "win", defaultCommands);
            if (typeof document == "object") {
              this.textInput = new TextInput(renderer.getTextAreaContainer(), this);
              this.renderer.textarea = this.textInput.getElement();
              this.$mouseHandler = new MouseHandler(this);
              new FoldHandler(this);
            }
            this.keyBinding = new KeyBinding(this);
            this.$search = new Search().set({
              wrap: true
            });
            this.$historyTracker = this.$historyTracker.bind(this);
            this.commands.on("exec", this.$historyTracker);
            this.$initOperationListeners();
            this._$emitInputEvent = lang.delayedCall((function() {
              this._signal("input", {});
              if (this.session && !this.session.destroyed)
                this.session.bgTokenizer.scheduleStart();
            }).bind(this));
            this.on("change", function(_, _self) {
              _self._$emitInputEvent.schedule(31);
            });
            this.setSession(session || options && options.session || new EditSession(""));
            config.resetOptions(this);
            if (options)
              this.setOptions(options);
            config._signal("editor", this);
          }
          Editor2.prototype.$initOperationListeners = function() {
            this.commands.on("exec", this.startOperation.bind(this), true);
            this.commands.on("afterExec", this.endOperation.bind(this), true);
          };
          Editor2.prototype.startOperation = function(commandEvent) {
            this.session.startOperation(commandEvent);
          };
          Editor2.prototype.endOperation = function(e2) {
            this.session.endOperation(e2);
          };
          Editor2.prototype.onStartOperation = function(commandEvent) {
            this.curOp = this.session.curOp;
            this.curOp.scrollTop = this.renderer.scrollTop;
            this.prevOp = this.session.prevOp;
            if (!commandEvent) {
              this.previousCommand = null;
            }
          };
          Editor2.prototype.onEndOperation = function(e2) {
            if (this.curOp && this.session) {
              if (e2 && e2.returnValue === false) {
                this.curOp = null;
                return;
              }
              this._signal("beforeEndOperation");
              if (!this.curOp)
                return;
              var command = this.curOp.command;
              var scrollIntoView = command && command.scrollIntoView;
              if (scrollIntoView) {
                switch (scrollIntoView) {
                  case "center-animate":
                    scrollIntoView = "animate";
                  case "center":
                    this.renderer.scrollCursorIntoView(null, 0.5);
                    break;
                  case "animate":
                  case "cursor":
                    this.renderer.scrollCursorIntoView();
                    break;
                  case "selectionPart":
                    var range = this.selection.getRange();
                    var config2 = this.renderer.layerConfig;
                    if (range.start.row >= config2.lastRow || range.end.row <= config2.firstRow) {
                      this.renderer.scrollSelectionIntoView(this.selection.anchor, this.selection.lead);
                    }
                    break;
                }
                if (scrollIntoView == "animate")
                  this.renderer.animateScrolling(this.curOp.scrollTop);
              }
              this.$lastSel = this.session.selection.toJSON();
              this.prevOp = this.curOp;
              this.curOp = null;
            }
          };
          Editor2.prototype.$historyTracker = function(e2) {
            if (!this.$mergeUndoDeltas)
              return;
            var prev = this.prevOp;
            var mergeableCommands = this.$mergeableCommands;
            var shouldMerge = prev.command && e2.command.name == prev.command.name;
            if (e2.command.name == "insertstring") {
              var text = e2.args;
              if (this.mergeNextCommand === void 0)
                this.mergeNextCommand = true;
              shouldMerge = shouldMerge && this.mergeNextCommand && (!/\s/.test(text) || /\s/.test(prev.args));
              this.mergeNextCommand = true;
            } else {
              shouldMerge = shouldMerge && mergeableCommands.indexOf(e2.command.name) !== -1;
            }
            if (this.$mergeUndoDeltas != "always" && Date.now() - this.sequenceStartTime > 2e3) {
              shouldMerge = false;
            }
            if (shouldMerge)
              this.session.mergeUndoDeltas = true;
            else if (mergeableCommands.indexOf(e2.command.name) !== -1)
              this.sequenceStartTime = Date.now();
          };
          Editor2.prototype.setKeyboardHandler = function(keyboardHandler, cb) {
            if (keyboardHandler && typeof keyboardHandler === "string" && keyboardHandler != "ace") {
              this.$keybindingId = keyboardHandler;
              var _self = this;
              config.loadModule(["keybinding", keyboardHandler], function(module4) {
                if (_self.$keybindingId == keyboardHandler)
                  _self.keyBinding.setKeyboardHandler(module4 && module4.handler);
                cb && cb();
              });
            } else {
              this.$keybindingId = null;
              this.keyBinding.setKeyboardHandler(keyboardHandler);
              cb && cb();
            }
          };
          Editor2.prototype.getKeyboardHandler = function() {
            return this.keyBinding.getKeyboardHandler();
          };
          Editor2.prototype.setSession = function(session) {
            if (this.session == session)
              return;
            if (this.curOp)
              this.endOperation();
            this.curOp = {};
            var oldSession = this.session;
            if (oldSession) {
              this.session.off("change", this.$onDocumentChange);
              this.session.off("changeMode", this.$onChangeMode);
              this.session.off("tokenizerUpdate", this.$onTokenizerUpdate);
              this.session.off("changeTabSize", this.$onChangeTabSize);
              this.session.off("changeWrapLimit", this.$onChangeWrapLimit);
              this.session.off("changeWrapMode", this.$onChangeWrapMode);
              this.session.off("changeFold", this.$onChangeFold);
              this.session.off("changeFrontMarker", this.$onChangeFrontMarker);
              this.session.off("changeBackMarker", this.$onChangeBackMarker);
              this.session.off("changeBreakpoint", this.$onChangeBreakpoint);
              this.session.off("changeAnnotation", this.$onChangeAnnotation);
              this.session.off("changeOverwrite", this.$onCursorChange);
              this.session.off("changeScrollTop", this.$onScrollTopChange);
              this.session.off("changeScrollLeft", this.$onScrollLeftChange);
              this.session.off("startOperation", this.$onStartOperation);
              this.session.off("endOperation", this.$onEndOperation);
              var selection = this.session.getSelection();
              selection.off("changeCursor", this.$onCursorChange);
              selection.off("changeSelection", this.$onSelectionChange);
            }
            this.session = session;
            if (session) {
              this.$onDocumentChange = this.onDocumentChange.bind(this);
              session.on("change", this.$onDocumentChange);
              this.renderer.setSession(session);
              this.$onChangeMode = this.onChangeMode.bind(this);
              session.on("changeMode", this.$onChangeMode);
              this.$onTokenizerUpdate = this.onTokenizerUpdate.bind(this);
              session.on("tokenizerUpdate", this.$onTokenizerUpdate);
              this.$onChangeTabSize = this.renderer.onChangeTabSize.bind(this.renderer);
              session.on("changeTabSize", this.$onChangeTabSize);
              this.$onChangeWrapLimit = this.onChangeWrapLimit.bind(this);
              session.on("changeWrapLimit", this.$onChangeWrapLimit);
              this.$onChangeWrapMode = this.onChangeWrapMode.bind(this);
              session.on("changeWrapMode", this.$onChangeWrapMode);
              this.$onChangeFold = this.onChangeFold.bind(this);
              session.on("changeFold", this.$onChangeFold);
              this.$onChangeFrontMarker = this.onChangeFrontMarker.bind(this);
              this.session.on("changeFrontMarker", this.$onChangeFrontMarker);
              this.$onChangeBackMarker = this.onChangeBackMarker.bind(this);
              this.session.on("changeBackMarker", this.$onChangeBackMarker);
              this.$onChangeBreakpoint = this.onChangeBreakpoint.bind(this);
              this.session.on("changeBreakpoint", this.$onChangeBreakpoint);
              this.$onChangeAnnotation = this.onChangeAnnotation.bind(this);
              this.session.on("changeAnnotation", this.$onChangeAnnotation);
              this.$onCursorChange = this.onCursorChange.bind(this);
              this.session.on("changeOverwrite", this.$onCursorChange);
              this.$onScrollTopChange = this.onScrollTopChange.bind(this);
              this.session.on("changeScrollTop", this.$onScrollTopChange);
              this.$onScrollLeftChange = this.onScrollLeftChange.bind(this);
              this.session.on("changeScrollLeft", this.$onScrollLeftChange);
              this.selection = session.getSelection();
              this.selection.on("changeCursor", this.$onCursorChange);
              this.$onSelectionChange = this.onSelectionChange.bind(this);
              this.selection.on("changeSelection", this.$onSelectionChange);
              this.$onStartOperation = this.onStartOperation.bind(this);
              this.session.on("startOperation", this.$onStartOperation);
              this.$onEndOperation = this.onEndOperation.bind(this);
              this.session.on("endOperation", this.$onEndOperation);
              this.onChangeMode();
              this.onCursorChange();
              this.onScrollTopChange();
              this.onScrollLeftChange();
              this.onSelectionChange();
              this.onChangeFrontMarker();
              this.onChangeBackMarker();
              this.onChangeBreakpoint();
              this.onChangeAnnotation();
              this.session.getUseWrapMode() && this.renderer.adjustWrapLimit();
              this.renderer.updateFull();
            } else {
              this.selection = null;
              this.renderer.setSession(session);
            }
            this._signal("changeSession", {
              session,
              oldSession
            });
            this.curOp = null;
            oldSession && oldSession._signal("changeEditor", { oldEditor: this });
            if (oldSession)
              oldSession.$editor = null;
            session && session._signal("changeEditor", { editor: this });
            if (session)
              session.$editor = this;
            if (session && !session.destroyed)
              session.bgTokenizer.scheduleStart();
          };
          Editor2.prototype.getSession = function() {
            return this.session;
          };
          Editor2.prototype.setValue = function(val, cursorPos) {
            this.session.doc.setValue(val);
            if (!cursorPos)
              this.selectAll();
            else if (cursorPos == 1)
              this.navigateFileEnd();
            else if (cursorPos == -1)
              this.navigateFileStart();
            return val;
          };
          Editor2.prototype.getValue = function() {
            return this.session.getValue();
          };
          Editor2.prototype.getSelection = function() {
            return this.selection;
          };
          Editor2.prototype.resize = function(force) {
            this.renderer.onResize(force);
          };
          Editor2.prototype.setTheme = function(theme, cb) {
            this.renderer.setTheme(theme, cb);
          };
          Editor2.prototype.getTheme = function() {
            return this.renderer.getTheme();
          };
          Editor2.prototype.setStyle = function(style) {
            this.renderer.setStyle(style);
          };
          Editor2.prototype.unsetStyle = function(style) {
            this.renderer.unsetStyle(style);
          };
          Editor2.prototype.getFontSize = function() {
            return this.getOption("fontSize") || dom.computedStyle(this.container).fontSize;
          };
          Editor2.prototype.setFontSize = function(size) {
            this.setOption("fontSize", size);
          };
          Editor2.prototype.$highlightBrackets = function() {
            if (this.$highlightPending) {
              return;
            }
            var self2 = this;
            this.$highlightPending = true;
            setTimeout(function() {
              self2.$highlightPending = false;
              var session = self2.session;
              if (!session || session.destroyed)
                return;
              if (session.$bracketHighlight) {
                session.$bracketHighlight.markerIds.forEach(function(id) {
                  session.removeMarker(id);
                });
                session.$bracketHighlight = null;
              }
              var pos = self2.getCursorPosition();
              var handler = self2.getKeyboardHandler();
              var isBackwards = handler && handler.$getDirectionForHighlight && handler.$getDirectionForHighlight(self2);
              var ranges = session.getMatchingBracketRanges(pos, isBackwards);
              if (!ranges) {
                var iterator = new TokenIterator(session, pos.row, pos.column);
                var token = iterator.getCurrentToken();
                if (token && /\b(?:tag-open|tag-name)/.test(token.type)) {
                  var tagNamesRanges = session.getMatchingTags(pos);
                  if (tagNamesRanges) {
                    ranges = [
                      tagNamesRanges.openTagName.isEmpty() ? tagNamesRanges.openTag : tagNamesRanges.openTagName,
                      tagNamesRanges.closeTagName.isEmpty() ? tagNamesRanges.closeTag : tagNamesRanges.closeTagName
                    ];
                  }
                }
              }
              if (!ranges && session.$mode.getMatching)
                ranges = session.$mode.getMatching(self2.session);
              if (!ranges) {
                if (self2.getHighlightIndentGuides())
                  self2.renderer.$textLayer.$highlightIndentGuide();
                return;
              }
              var markerType = "ace_bracket";
              if (!Array.isArray(ranges)) {
                ranges = [ranges];
              } else if (ranges.length == 1) {
                markerType = "ace_error_bracket";
              }
              if (ranges.length == 2) {
                if (Range.comparePoints(ranges[0].end, ranges[1].start) == 0)
                  ranges = [Range.fromPoints(ranges[0].start, ranges[1].end)];
                else if (Range.comparePoints(ranges[0].start, ranges[1].end) == 0)
                  ranges = [Range.fromPoints(ranges[1].start, ranges[0].end)];
              }
              session.$bracketHighlight = {
                ranges,
                markerIds: ranges.map(function(range) {
                  return session.addMarker(range, markerType, "text");
                })
              };
              if (self2.getHighlightIndentGuides())
                self2.renderer.$textLayer.$highlightIndentGuide();
            }, 50);
          };
          Editor2.prototype.focus = function() {
            this.textInput.focus();
          };
          Editor2.prototype.isFocused = function() {
            return this.textInput.isFocused();
          };
          Editor2.prototype.blur = function() {
            this.textInput.blur();
          };
          Editor2.prototype.onFocus = function(e2) {
            if (this.$isFocused)
              return;
            this.$isFocused = true;
            this.renderer.showCursor();
            this.renderer.visualizeFocus();
            this._emit("focus", e2);
          };
          Editor2.prototype.onBlur = function(e2) {
            if (!this.$isFocused)
              return;
            this.$isFocused = false;
            this.renderer.hideCursor();
            this.renderer.visualizeBlur();
            this._emit("blur", e2);
          };
          Editor2.prototype.$cursorChange = function() {
            this.renderer.updateCursor();
            this.$highlightBrackets();
            this.$updateHighlightActiveLine();
          };
          Editor2.prototype.onDocumentChange = function(delta) {
            var wrap2 = this.session.$useWrapMode;
            var lastRow = delta.start.row == delta.end.row ? delta.end.row : Infinity;
            this.renderer.updateLines(delta.start.row, lastRow, wrap2);
            this._signal("change", delta);
            this.$cursorChange();
          };
          Editor2.prototype.onTokenizerUpdate = function(e2) {
            var rows = e2.data;
            this.renderer.updateLines(rows.first, rows.last);
          };
          Editor2.prototype.onScrollTopChange = function() {
            this.renderer.scrollToY(this.session.getScrollTop());
          };
          Editor2.prototype.onScrollLeftChange = function() {
            this.renderer.scrollToX(this.session.getScrollLeft());
          };
          Editor2.prototype.onCursorChange = function() {
            this.$cursorChange();
            this._signal("changeSelection");
          };
          Editor2.prototype.$updateHighlightActiveLine = function() {
            var session = this.getSession();
            var highlight;
            if (this.$highlightActiveLine) {
              if (this.$selectionStyle != "line" || !this.selection.isMultiLine())
                highlight = this.getCursorPosition();
              if (this.renderer.theme && this.renderer.theme.$selectionColorConflict && !this.selection.isEmpty())
                highlight = false;
              if (this.renderer.$maxLines && this.session.getLength() === 1 && !(this.renderer.$minLines > 1))
                highlight = false;
            }
            if (session.$highlightLineMarker && !highlight) {
              session.removeMarker(session.$highlightLineMarker.id);
              session.$highlightLineMarker = null;
            } else if (!session.$highlightLineMarker && highlight) {
              var range = new Range(highlight.row, highlight.column, highlight.row, Infinity);
              range.id = session.addMarker(range, "ace_active-line", "screenLine");
              session.$highlightLineMarker = range;
            } else if (highlight) {
              session.$highlightLineMarker.start.row = highlight.row;
              session.$highlightLineMarker.end.row = highlight.row;
              session.$highlightLineMarker.start.column = highlight.column;
              session._signal("changeBackMarker");
            }
          };
          Editor2.prototype.onSelectionChange = function(e2) {
            var session = this.session;
            if (session.$selectionMarker) {
              session.removeMarker(session.$selectionMarker);
            }
            session.$selectionMarker = null;
            if (!this.selection.isEmpty()) {
              var range = this.selection.getRange();
              var style = this.getSelectionStyle();
              session.$selectionMarker = session.addMarker(range, "ace_selection", style);
            } else {
              this.$updateHighlightActiveLine();
            }
            var re2 = this.$highlightSelectedWord && this.$getSelectionHighLightRegexp();
            this.session.highlight(re2);
            this._signal("changeSelection");
          };
          Editor2.prototype.$getSelectionHighLightRegexp = function() {
            var session = this.session;
            var selection = this.getSelectionRange();
            if (selection.isEmpty() || selection.isMultiLine())
              return;
            var startColumn = selection.start.column;
            var endColumn = selection.end.column;
            var line = session.getLine(selection.start.row);
            var needle = line.substring(startColumn, endColumn);
            if (needle.length > 5e3 || !/[\w\d]/.test(needle))
              return;
            var re2 = this.$search.$assembleRegExp({
              wholeWord: true,
              caseSensitive: true,
              needle
            });
            var wordWithBoundary = line.substring(startColumn - 1, endColumn + 1);
            if (!re2.test(wordWithBoundary))
              return;
            return re2;
          };
          Editor2.prototype.onChangeFrontMarker = function() {
            this.renderer.updateFrontMarkers();
          };
          Editor2.prototype.onChangeBackMarker = function() {
            this.renderer.updateBackMarkers();
          };
          Editor2.prototype.onChangeBreakpoint = function() {
            this.renderer.updateBreakpoints();
          };
          Editor2.prototype.onChangeAnnotation = function() {
            this.renderer.setAnnotations(this.session.getAnnotations());
          };
          Editor2.prototype.onChangeMode = function(e2) {
            this.renderer.updateText();
            this._emit("changeMode", e2);
          };
          Editor2.prototype.onChangeWrapLimit = function() {
            this.renderer.updateFull();
          };
          Editor2.prototype.onChangeWrapMode = function() {
            this.renderer.onResize(true);
          };
          Editor2.prototype.onChangeFold = function() {
            this.$updateHighlightActiveLine();
            this.renderer.updateFull();
          };
          Editor2.prototype.getSelectedText = function() {
            return this.session.getTextRange(this.getSelectionRange());
          };
          Editor2.prototype.getCopyText = function() {
            var text = this.getSelectedText();
            var nl = this.session.doc.getNewLineCharacter();
            var copyLine = false;
            if (!text && this.$copyWithEmptySelection) {
              copyLine = true;
              var ranges = this.selection.getAllRanges();
              for (var i2 = 0; i2 < ranges.length; i2++) {
                var range = ranges[i2];
                if (i2 && ranges[i2 - 1].start.row == range.start.row)
                  continue;
                text += this.session.getLine(range.start.row) + nl;
              }
            }
            var e2 = { text };
            this._signal("copy", e2);
            clipboard.lineMode = copyLine ? e2.text : false;
            return e2.text;
          };
          Editor2.prototype.onCopy = function() {
            this.commands.exec("copy", this);
          };
          Editor2.prototype.onCut = function() {
            this.commands.exec("cut", this);
          };
          Editor2.prototype.onPaste = function(text, event) {
            var e2 = { text, event };
            this.commands.exec("paste", this, e2);
          };
          Editor2.prototype.$handlePaste = function(e2) {
            if (typeof e2 == "string")
              e2 = { text: e2 };
            this._signal("paste", e2);
            var text = e2.text;
            var lineMode = text === clipboard.lineMode;
            var session = this.session;
            if (!this.inMultiSelectMode || this.inVirtualSelectionMode) {
              if (lineMode)
                session.insert({ row: this.selection.lead.row, column: 0 }, text);
              else
                this.insert(text);
            } else if (lineMode) {
              this.selection.rangeList.ranges.forEach(function(range2) {
                session.insert({ row: range2.start.row, column: 0 }, text);
              });
            } else {
              var lines = text.split(/\r\n|\r|\n/);
              var ranges = this.selection.rangeList.ranges;
              var isFullLine = lines.length == 2 && (!lines[0] || !lines[1]);
              if (lines.length != ranges.length || isFullLine)
                return this.commands.exec("insertstring", this, text);
              for (var i2 = ranges.length; i2--; ) {
                var range = ranges[i2];
                if (!range.isEmpty())
                  session.remove(range);
                session.insert(range.start, lines[i2]);
              }
            }
          };
          Editor2.prototype.execCommand = function(command, args) {
            return this.commands.exec(command, this, args);
          };
          Editor2.prototype.insert = function(text, pasted) {
            var session = this.session;
            var mode = session.getMode();
            var cursor = this.getCursorPosition();
            if (this.getBehavioursEnabled() && !pasted) {
              var transform = mode.transformAction(session.getState(cursor.row), "insertion", this, session, text);
              if (transform) {
                if (text !== transform.text) {
                  if (!this.inVirtualSelectionMode) {
                    this.session.mergeUndoDeltas = false;
                    this.mergeNextCommand = false;
                  }
                }
                text = transform.text;
              }
            }
            if (text == "	")
              text = this.session.getTabString();
            if (!this.selection.isEmpty()) {
              var range = this.getSelectionRange();
              cursor = this.session.remove(range);
              this.clearSelection();
            } else if (this.session.getOverwrite() && text.indexOf("\n") == -1) {
              var range = Range.fromPoints(cursor, cursor);
              range.end.column += text.length;
              this.session.remove(range);
            }
            if (text == "\n" || text == "\r\n") {
              var line = session.getLine(cursor.row);
              if (cursor.column > line.search(/\S|$/)) {
                var d3 = line.substr(cursor.column).search(/\S|$/);
                session.doc.removeInLine(cursor.row, cursor.column, cursor.column + d3);
              }
            }
            this.clearSelection();
            var start = cursor.column;
            var lineState = session.getState(cursor.row);
            var line = session.getLine(cursor.row);
            var shouldOutdent = mode.checkOutdent(lineState, line, text);
            session.insert(cursor, text);
            if (transform && transform.selection) {
              if (transform.selection.length == 2) {
                this.selection.setSelectionRange(new Range(cursor.row, start + transform.selection[0], cursor.row, start + transform.selection[1]));
              } else {
                this.selection.setSelectionRange(new Range(cursor.row + transform.selection[0], transform.selection[1], cursor.row + transform.selection[2], transform.selection[3]));
              }
            }
            if (this.$enableAutoIndent) {
              if (session.getDocument().isNewLine(text)) {
                var lineIndent = mode.getNextLineIndent(lineState, line.slice(0, cursor.column), session.getTabString());
                session.insert({ row: cursor.row + 1, column: 0 }, lineIndent);
              }
              if (shouldOutdent)
                mode.autoOutdent(lineState, session, cursor.row);
            }
          };
          Editor2.prototype.autoIndent = function() {
            var session = this.session;
            var mode = session.getMode();
            var ranges = this.selection.isEmpty() ? [new Range(0, 0, session.doc.getLength() - 1, 0)] : this.selection.getAllRanges();
            var prevLineState = "";
            var prevLine = "";
            var lineIndent = "";
            var tab = session.getTabString();
            for (var i2 = 0; i2 < ranges.length; i2++) {
              var startRow = ranges[i2].start.row;
              var endRow = ranges[i2].end.row;
              for (var row = startRow; row <= endRow; row++) {
                if (row > 0) {
                  prevLineState = session.getState(row - 1);
                  prevLine = session.getLine(row - 1);
                  lineIndent = mode.getNextLineIndent(prevLineState, prevLine, tab);
                }
                var line = session.getLine(row);
                var currIndent = mode.$getIndent(line);
                if (lineIndent !== currIndent) {
                  if (currIndent.length > 0) {
                    var range = new Range(row, 0, row, currIndent.length);
                    session.remove(range);
                  }
                  if (lineIndent.length > 0) {
                    session.insert({ row, column: 0 }, lineIndent);
                  }
                }
                mode.autoOutdent(prevLineState, session, row);
              }
            }
          };
          Editor2.prototype.onTextInput = function(text, composition) {
            if (!composition)
              return this.keyBinding.onTextInput(text);
            this.startOperation({ command: { name: "insertstring" } });
            var applyComposition = this.applyComposition.bind(this, text, composition);
            if (this.selection.rangeCount)
              this.forEachSelection(applyComposition);
            else
              applyComposition();
            this.endOperation();
          };
          Editor2.prototype.applyComposition = function(text, composition) {
            if (composition.extendLeft || composition.extendRight) {
              var r = this.selection.getRange();
              r.start.column -= composition.extendLeft;
              r.end.column += composition.extendRight;
              if (r.start.column < 0) {
                r.start.row--;
                r.start.column += this.session.getLine(r.start.row).length + 1;
              }
              this.selection.setRange(r);
              if (!text && !r.isEmpty())
                this.remove();
            }
            if (text || !this.selection.isEmpty())
              this.insert(text, true);
            if (composition.restoreStart || composition.restoreEnd) {
              var r = this.selection.getRange();
              r.start.column -= composition.restoreStart;
              r.end.column -= composition.restoreEnd;
              this.selection.setRange(r);
            }
          };
          Editor2.prototype.onCommandKey = function(e2, hashId, keyCode) {
            return this.keyBinding.onCommandKey(e2, hashId, keyCode);
          };
          Editor2.prototype.setOverwrite = function(overwrite) {
            this.session.setOverwrite(overwrite);
          };
          Editor2.prototype.getOverwrite = function() {
            return this.session.getOverwrite();
          };
          Editor2.prototype.toggleOverwrite = function() {
            this.session.toggleOverwrite();
          };
          Editor2.prototype.setScrollSpeed = function(speed) {
            this.setOption("scrollSpeed", speed);
          };
          Editor2.prototype.getScrollSpeed = function() {
            return this.getOption("scrollSpeed");
          };
          Editor2.prototype.setDragDelay = function(dragDelay) {
            this.setOption("dragDelay", dragDelay);
          };
          Editor2.prototype.getDragDelay = function() {
            return this.getOption("dragDelay");
          };
          Editor2.prototype.setSelectionStyle = function(val) {
            this.setOption("selectionStyle", val);
          };
          Editor2.prototype.getSelectionStyle = function() {
            return this.getOption("selectionStyle");
          };
          Editor2.prototype.setHighlightActiveLine = function(shouldHighlight) {
            this.setOption("highlightActiveLine", shouldHighlight);
          };
          Editor2.prototype.getHighlightActiveLine = function() {
            return this.getOption("highlightActiveLine");
          };
          Editor2.prototype.setHighlightGutterLine = function(shouldHighlight) {
            this.setOption("highlightGutterLine", shouldHighlight);
          };
          Editor2.prototype.getHighlightGutterLine = function() {
            return this.getOption("highlightGutterLine");
          };
          Editor2.prototype.setHighlightSelectedWord = function(shouldHighlight) {
            this.setOption("highlightSelectedWord", shouldHighlight);
          };
          Editor2.prototype.getHighlightSelectedWord = function() {
            return this.$highlightSelectedWord;
          };
          Editor2.prototype.setAnimatedScroll = function(shouldAnimate) {
            this.renderer.setAnimatedScroll(shouldAnimate);
          };
          Editor2.prototype.getAnimatedScroll = function() {
            return this.renderer.getAnimatedScroll();
          };
          Editor2.prototype.setShowInvisibles = function(showInvisibles) {
            this.renderer.setShowInvisibles(showInvisibles);
          };
          Editor2.prototype.getShowInvisibles = function() {
            return this.renderer.getShowInvisibles();
          };
          Editor2.prototype.setDisplayIndentGuides = function(display) {
            this.renderer.setDisplayIndentGuides(display);
          };
          Editor2.prototype.getDisplayIndentGuides = function() {
            return this.renderer.getDisplayIndentGuides();
          };
          Editor2.prototype.setHighlightIndentGuides = function(highlight) {
            this.renderer.setHighlightIndentGuides(highlight);
          };
          Editor2.prototype.getHighlightIndentGuides = function() {
            return this.renderer.getHighlightIndentGuides();
          };
          Editor2.prototype.setShowPrintMargin = function(showPrintMargin) {
            this.renderer.setShowPrintMargin(showPrintMargin);
          };
          Editor2.prototype.getShowPrintMargin = function() {
            return this.renderer.getShowPrintMargin();
          };
          Editor2.prototype.setPrintMarginColumn = function(showPrintMargin) {
            this.renderer.setPrintMarginColumn(showPrintMargin);
          };
          Editor2.prototype.getPrintMarginColumn = function() {
            return this.renderer.getPrintMarginColumn();
          };
          Editor2.prototype.setReadOnly = function(readOnly) {
            this.setOption("readOnly", readOnly);
          };
          Editor2.prototype.getReadOnly = function() {
            return this.getOption("readOnly");
          };
          Editor2.prototype.setBehavioursEnabled = function(enabled) {
            this.setOption("behavioursEnabled", enabled);
          };
          Editor2.prototype.getBehavioursEnabled = function() {
            return this.getOption("behavioursEnabled");
          };
          Editor2.prototype.setWrapBehavioursEnabled = function(enabled) {
            this.setOption("wrapBehavioursEnabled", enabled);
          };
          Editor2.prototype.getWrapBehavioursEnabled = function() {
            return this.getOption("wrapBehavioursEnabled");
          };
          Editor2.prototype.setShowFoldWidgets = function(show) {
            this.setOption("showFoldWidgets", show);
          };
          Editor2.prototype.getShowFoldWidgets = function() {
            return this.getOption("showFoldWidgets");
          };
          Editor2.prototype.setFadeFoldWidgets = function(fade) {
            this.setOption("fadeFoldWidgets", fade);
          };
          Editor2.prototype.getFadeFoldWidgets = function() {
            return this.getOption("fadeFoldWidgets");
          };
          Editor2.prototype.remove = function(dir) {
            if (this.selection.isEmpty()) {
              if (dir == "left")
                this.selection.selectLeft();
              else
                this.selection.selectRight();
            }
            var range = this.getSelectionRange();
            if (this.getBehavioursEnabled()) {
              var session = this.session;
              var state = session.getState(range.start.row);
              var new_range = session.getMode().transformAction(state, "deletion", this, session, range);
              if (range.end.column === 0) {
                var text = session.getTextRange(range);
                if (text[text.length - 1] == "\n") {
                  var line = session.getLine(range.end.row);
                  if (/^\s+$/.test(line)) {
                    range.end.column = line.length;
                  }
                }
              }
              if (new_range)
                range = new_range;
            }
            this.session.remove(range);
            this.clearSelection();
          };
          Editor2.prototype.removeWordRight = function() {
            if (this.selection.isEmpty())
              this.selection.selectWordRight();
            this.session.remove(this.getSelectionRange());
            this.clearSelection();
          };
          Editor2.prototype.removeWordLeft = function() {
            if (this.selection.isEmpty())
              this.selection.selectWordLeft();
            this.session.remove(this.getSelectionRange());
            this.clearSelection();
          };
          Editor2.prototype.removeToLineStart = function() {
            if (this.selection.isEmpty())
              this.selection.selectLineStart();
            if (this.selection.isEmpty())
              this.selection.selectLeft();
            this.session.remove(this.getSelectionRange());
            this.clearSelection();
          };
          Editor2.prototype.removeToLineEnd = function() {
            if (this.selection.isEmpty())
              this.selection.selectLineEnd();
            var range = this.getSelectionRange();
            if (range.start.column == range.end.column && range.start.row == range.end.row) {
              range.end.column = 0;
              range.end.row++;
            }
            this.session.remove(range);
            this.clearSelection();
          };
          Editor2.prototype.splitLine = function() {
            if (!this.selection.isEmpty()) {
              this.session.remove(this.getSelectionRange());
              this.clearSelection();
            }
            var cursor = this.getCursorPosition();
            this.insert("\n");
            this.moveCursorToPosition(cursor);
          };
          Editor2.prototype.setGhostText = function(text, position) {
            this.renderer.setGhostText(text, position);
          };
          Editor2.prototype.removeGhostText = function() {
            this.renderer.removeGhostText();
          };
          Editor2.prototype.transposeLetters = function() {
            if (!this.selection.isEmpty()) {
              return;
            }
            var cursor = this.getCursorPosition();
            var column = cursor.column;
            if (column === 0)
              return;
            var line = this.session.getLine(cursor.row);
            var swap, range;
            if (column < line.length) {
              swap = line.charAt(column) + line.charAt(column - 1);
              range = new Range(cursor.row, column - 1, cursor.row, column + 1);
            } else {
              swap = line.charAt(column - 1) + line.charAt(column - 2);
              range = new Range(cursor.row, column - 2, cursor.row, column);
            }
            this.session.replace(range, swap);
            this.session.selection.moveToPosition(range.end);
          };
          Editor2.prototype.toLowerCase = function() {
            var originalRange = this.getSelectionRange();
            if (this.selection.isEmpty()) {
              this.selection.selectWord();
            }
            var range = this.getSelectionRange();
            var text = this.session.getTextRange(range);
            this.session.replace(range, text.toLowerCase());
            this.selection.setSelectionRange(originalRange);
          };
          Editor2.prototype.toUpperCase = function() {
            var originalRange = this.getSelectionRange();
            if (this.selection.isEmpty()) {
              this.selection.selectWord();
            }
            var range = this.getSelectionRange();
            var text = this.session.getTextRange(range);
            this.session.replace(range, text.toUpperCase());
            this.selection.setSelectionRange(originalRange);
          };
          Editor2.prototype.indent = function() {
            var session = this.session;
            var range = this.getSelectionRange();
            if (range.start.row < range.end.row) {
              var rows = this.$getSelectedRows();
              session.indentRows(rows.first, rows.last, "	");
              return;
            } else if (range.start.column < range.end.column) {
              var text = session.getTextRange(range);
              if (!/^\s+$/.test(text)) {
                var rows = this.$getSelectedRows();
                session.indentRows(rows.first, rows.last, "	");
                return;
              }
            }
            var line = session.getLine(range.start.row);
            var position = range.start;
            var size = session.getTabSize();
            var column = session.documentToScreenColumn(position.row, position.column);
            if (this.session.getUseSoftTabs()) {
              var count = size - column % size;
              var indentString = lang.stringRepeat(" ", count);
            } else {
              var count = column % size;
              while (line[range.start.column - 1] == " " && count) {
                range.start.column--;
                count--;
              }
              this.selection.setSelectionRange(range);
              indentString = "	";
            }
            return this.insert(indentString);
          };
          Editor2.prototype.blockIndent = function() {
            var rows = this.$getSelectedRows();
            this.session.indentRows(rows.first, rows.last, "	");
          };
          Editor2.prototype.blockOutdent = function() {
            var selection = this.session.getSelection();
            this.session.outdentRows(selection.getRange());
          };
          Editor2.prototype.sortLines = function() {
            var rows = this.$getSelectedRows();
            var session = this.session;
            var lines = [];
            for (var i2 = rows.first; i2 <= rows.last; i2++)
              lines.push(session.getLine(i2));
            lines.sort(function(a3, b2) {
              if (a3.toLowerCase() < b2.toLowerCase())
                return -1;
              if (a3.toLowerCase() > b2.toLowerCase())
                return 1;
              return 0;
            });
            var deleteRange = new Range(0, 0, 0, 0);
            for (var i2 = rows.first; i2 <= rows.last; i2++) {
              var line = session.getLine(i2);
              deleteRange.start.row = i2;
              deleteRange.end.row = i2;
              deleteRange.end.column = line.length;
              session.replace(deleteRange, lines[i2 - rows.first]);
            }
          };
          Editor2.prototype.toggleCommentLines = function() {
            var state = this.session.getState(this.getCursorPosition().row);
            var rows = this.$getSelectedRows();
            this.session.getMode().toggleCommentLines(state, this.session, rows.first, rows.last);
          };
          Editor2.prototype.toggleBlockComment = function() {
            var cursor = this.getCursorPosition();
            var state = this.session.getState(cursor.row);
            var range = this.getSelectionRange();
            this.session.getMode().toggleBlockComment(state, this.session, range, cursor);
          };
          Editor2.prototype.getNumberAt = function(row, column) {
            var _numberRx = /[\-]?[0-9]+(?:\.[0-9]+)?/g;
            _numberRx.lastIndex = 0;
            var s3 = this.session.getLine(row);
            while (_numberRx.lastIndex < column) {
              var m3 = _numberRx.exec(s3);
              if (m3.index <= column && m3.index + m3[0].length >= column) {
                var number = {
                  value: m3[0],
                  start: m3.index,
                  end: m3.index + m3[0].length
                };
                return number;
              }
            }
            return null;
          };
          Editor2.prototype.modifyNumber = function(amount) {
            var row = this.selection.getCursor().row;
            var column = this.selection.getCursor().column;
            var charRange = new Range(row, column - 1, row, column);
            var c2 = this.session.getTextRange(charRange);
            if (!isNaN(parseFloat(c2)) && isFinite(c2)) {
              var nr = this.getNumberAt(row, column);
              if (nr) {
                var fp = nr.value.indexOf(".") >= 0 ? nr.start + nr.value.indexOf(".") + 1 : nr.end;
                var decimals = nr.start + nr.value.length - fp;
                var t2 = parseFloat(nr.value);
                t2 *= Math.pow(10, decimals);
                if (fp !== nr.end && column < fp) {
                  amount *= Math.pow(10, nr.end - column - 1);
                } else {
                  amount *= Math.pow(10, nr.end - column);
                }
                t2 += amount;
                t2 /= Math.pow(10, decimals);
                var nnr = t2.toFixed(decimals);
                var replaceRange = new Range(row, nr.start, row, nr.end);
                this.session.replace(replaceRange, nnr);
                this.moveCursorTo(row, Math.max(nr.start + 1, column + nnr.length - nr.value.length));
              }
            } else {
              this.toggleWord();
            }
          };
          Editor2.prototype.toggleWord = function() {
            var row = this.selection.getCursor().row;
            var column = this.selection.getCursor().column;
            this.selection.selectWord();
            var currentState = this.getSelectedText();
            var currWordStart = this.selection.getWordRange().start.column;
            var wordParts = currentState.replace(/([a-z]+|[A-Z]+)(?=[A-Z_]|$)/g, "$1 ").split(/\s/);
            var delta = column - currWordStart - 1;
            if (delta < 0)
              delta = 0;
            var curLength = 0, itLength = 0;
            var that = this;
            if (currentState.match(/[A-Za-z0-9_]+/)) {
              wordParts.forEach(function(item3, i3) {
                itLength = curLength + item3.length;
                if (delta >= curLength && delta <= itLength) {
                  currentState = item3;
                  that.selection.clearSelection();
                  that.moveCursorTo(row, curLength + currWordStart);
                  that.selection.selectTo(row, itLength + currWordStart);
                }
                curLength = itLength;
              });
            }
            var wordPairs = this.$toggleWordPairs;
            var reg;
            for (var i2 = 0; i2 < wordPairs.length; i2++) {
              var item2 = wordPairs[i2];
              for (var j = 0; j <= 1; j++) {
                var negate = +!j;
                var firstCondition = currentState.match(new RegExp("^\\s?_?(" + lang.escapeRegExp(item2[j]) + ")\\s?$", "i"));
                if (firstCondition) {
                  var secondCondition = currentState.match(new RegExp("([_]|^|\\s)(" + lang.escapeRegExp(firstCondition[1]) + ")($|\\s)", "g"));
                  if (secondCondition) {
                    reg = currentState.replace(new RegExp(lang.escapeRegExp(item2[j]), "i"), function(result) {
                      var res = item2[negate];
                      if (result.toUpperCase() == result) {
                        res = res.toUpperCase();
                      } else if (result.charAt(0).toUpperCase() == result.charAt(0)) {
                        res = res.substr(0, 0) + item2[negate].charAt(0).toUpperCase() + res.substr(1);
                      }
                      return res;
                    });
                    this.insert(reg);
                    reg = "";
                  }
                }
              }
            }
          };
          Editor2.prototype.findLinkAt = function(row, column) {
            var e_1, _a;
            var line = this.session.getLine(row);
            var wordParts = line.split(/((?:https?|ftp):\/\/[\S]+)/);
            var columnPosition = column;
            if (columnPosition < 0)
              columnPosition = 0;
            var previousPosition = 0, currentPosition = 0, match2;
            try {
              for (var wordParts_1 = __values(wordParts), wordParts_1_1 = wordParts_1.next(); !wordParts_1_1.done; wordParts_1_1 = wordParts_1.next()) {
                var item2 = wordParts_1_1.value;
                currentPosition = previousPosition + item2.length;
                if (columnPosition >= previousPosition && columnPosition <= currentPosition) {
                  if (item2.match(/((?:https?|ftp):\/\/[\S]+)/)) {
                    match2 = item2.replace(/[\s:.,'";}\]]+$/, "");
                    break;
                  }
                }
                previousPosition = currentPosition;
              }
            } catch (e_1_1) {
              e_1 = { error: e_1_1 };
            } finally {
              try {
                if (wordParts_1_1 && !wordParts_1_1.done && (_a = wordParts_1.return)) _a.call(wordParts_1);
              } finally {
                if (e_1) throw e_1.error;
              }
            }
            return match2;
          };
          Editor2.prototype.openLink = function() {
            var cursor = this.selection.getCursor();
            var url = this.findLinkAt(cursor.row, cursor.column);
            if (url)
              window.open(url, "_blank");
            return url != null;
          };
          Editor2.prototype.removeLines = function() {
            var rows = this.$getSelectedRows();
            this.session.removeFullLines(rows.first, rows.last);
            this.clearSelection();
          };
          Editor2.prototype.duplicateSelection = function() {
            var sel = this.selection;
            var doc = this.session;
            var range = sel.getRange();
            var reverse = sel.isBackwards();
            if (range.isEmpty()) {
              var row = range.start.row;
              doc.duplicateLines(row, row);
            } else {
              var point = reverse ? range.start : range.end;
              var endPoint = doc.insert(point, doc.getTextRange(range));
              range.start = point;
              range.end = endPoint;
              sel.setSelectionRange(range, reverse);
            }
          };
          Editor2.prototype.moveLinesDown = function() {
            this.$moveLines(1, false);
          };
          Editor2.prototype.moveLinesUp = function() {
            this.$moveLines(-1, false);
          };
          Editor2.prototype.moveText = function(range, toPosition, copy) {
            return this.session.moveText(range, toPosition, copy);
          };
          Editor2.prototype.copyLinesUp = function() {
            this.$moveLines(-1, true);
          };
          Editor2.prototype.copyLinesDown = function() {
            this.$moveLines(1, true);
          };
          Editor2.prototype.$moveLines = function(dir, copy) {
            var rows, moved;
            var selection = this.selection;
            if (!selection.inMultiSelectMode || this.inVirtualSelectionMode) {
              var range = selection.toOrientedRange();
              rows = this.$getSelectedRows(range);
              moved = this.session.$moveLines(rows.first, rows.last, copy ? 0 : dir);
              if (copy && dir == -1)
                moved = 0;
              range.moveBy(moved, 0);
              selection.fromOrientedRange(range);
            } else {
              var ranges = selection.rangeList.ranges;
              selection.rangeList.detach(this.session);
              this.inVirtualSelectionMode = true;
              var diff = 0;
              var totalDiff = 0;
              var l = ranges.length;
              for (var i2 = 0; i2 < l; i2++) {
                var rangeIndex = i2;
                ranges[i2].moveBy(diff, 0);
                rows = this.$getSelectedRows(ranges[i2]);
                var first = rows.first;
                var last = rows.last;
                while (++i2 < l) {
                  if (totalDiff)
                    ranges[i2].moveBy(totalDiff, 0);
                  var subRows = this.$getSelectedRows(ranges[i2]);
                  if (copy && subRows.first != last)
                    break;
                  else if (!copy && subRows.first > last + 1)
                    break;
                  last = subRows.last;
                }
                i2--;
                diff = this.session.$moveLines(first, last, copy ? 0 : dir);
                if (copy && dir == -1)
                  rangeIndex = i2 + 1;
                while (rangeIndex <= i2) {
                  ranges[rangeIndex].moveBy(diff, 0);
                  rangeIndex++;
                }
                if (!copy)
                  diff = 0;
                totalDiff += diff;
              }
              selection.fromOrientedRange(selection.ranges[0]);
              selection.rangeList.attach(this.session);
              this.inVirtualSelectionMode = false;
            }
          };
          Editor2.prototype.$getSelectedRows = function(range) {
            range = (range || this.getSelectionRange()).collapseRows();
            return {
              first: this.session.getRowFoldStart(range.start.row),
              last: this.session.getRowFoldEnd(range.end.row)
            };
          };
          Editor2.prototype.onCompositionStart = function(compositionState) {
            this.renderer.showComposition(compositionState);
          };
          Editor2.prototype.onCompositionUpdate = function(text) {
            this.renderer.setCompositionText(text);
          };
          Editor2.prototype.onCompositionEnd = function() {
            this.renderer.hideComposition();
          };
          Editor2.prototype.getFirstVisibleRow = function() {
            return this.renderer.getFirstVisibleRow();
          };
          Editor2.prototype.getLastVisibleRow = function() {
            return this.renderer.getLastVisibleRow();
          };
          Editor2.prototype.isRowVisible = function(row) {
            return row >= this.getFirstVisibleRow() && row <= this.getLastVisibleRow();
          };
          Editor2.prototype.isRowFullyVisible = function(row) {
            return row >= this.renderer.getFirstFullyVisibleRow() && row <= this.renderer.getLastFullyVisibleRow();
          };
          Editor2.prototype.$getVisibleRowCount = function() {
            return this.renderer.getScrollBottomRow() - this.renderer.getScrollTopRow() + 1;
          };
          Editor2.prototype.$moveByPage = function(dir, select2) {
            var renderer = this.renderer;
            var config2 = this.renderer.layerConfig;
            var rows = dir * Math.floor(config2.height / config2.lineHeight);
            if (select2 === true) {
              this.selection.$moveSelection(function() {
                this.moveCursorBy(rows, 0);
              });
            } else if (select2 === false) {
              this.selection.moveCursorBy(rows, 0);
              this.selection.clearSelection();
            }
            var scrollTop = renderer.scrollTop;
            renderer.scrollBy(0, rows * config2.lineHeight);
            if (select2 != null)
              renderer.scrollCursorIntoView(null, 0.5);
            renderer.animateScrolling(scrollTop);
          };
          Editor2.prototype.selectPageDown = function() {
            this.$moveByPage(1, true);
          };
          Editor2.prototype.selectPageUp = function() {
            this.$moveByPage(-1, true);
          };
          Editor2.prototype.gotoPageDown = function() {
            this.$moveByPage(1, false);
          };
          Editor2.prototype.gotoPageUp = function() {
            this.$moveByPage(-1, false);
          };
          Editor2.prototype.scrollPageDown = function() {
            this.$moveByPage(1);
          };
          Editor2.prototype.scrollPageUp = function() {
            this.$moveByPage(-1);
          };
          Editor2.prototype.scrollToRow = function(row) {
            this.renderer.scrollToRow(row);
          };
          Editor2.prototype.scrollToLine = function(line, center, animate, callback) {
            this.renderer.scrollToLine(line, center, animate, callback);
          };
          Editor2.prototype.centerSelection = function() {
            var range = this.getSelectionRange();
            var pos = {
              row: Math.floor(range.start.row + (range.end.row - range.start.row) / 2),
              column: Math.floor(range.start.column + (range.end.column - range.start.column) / 2)
            };
            this.renderer.alignCursor(pos, 0.5);
          };
          Editor2.prototype.getCursorPosition = function() {
            return this.selection.getCursor();
          };
          Editor2.prototype.getCursorPositionScreen = function() {
            return this.session.documentToScreenPosition(this.getCursorPosition());
          };
          Editor2.prototype.getSelectionRange = function() {
            return this.selection.getRange();
          };
          Editor2.prototype.selectAll = function() {
            this.selection.selectAll();
          };
          Editor2.prototype.clearSelection = function() {
            this.selection.clearSelection();
          };
          Editor2.prototype.moveCursorTo = function(row, column) {
            this.selection.moveCursorTo(row, column);
          };
          Editor2.prototype.moveCursorToPosition = function(pos) {
            this.selection.moveCursorToPosition(pos);
          };
          Editor2.prototype.jumpToMatching = function(select2, expand) {
            var cursor = this.getCursorPosition();
            var iterator = new TokenIterator(this.session, cursor.row, cursor.column);
            var prevToken = iterator.getCurrentToken();
            var tokenCount = 0;
            if (prevToken && prevToken.type.indexOf("tag-name") !== -1) {
              prevToken = iterator.stepBackward();
            }
            var token = prevToken || iterator.stepForward();
            if (!token)
              return;
            var matchType;
            var found = false;
            var depth = {};
            var i2 = cursor.column - token.start;
            var bracketType;
            var brackets = {
              ")": "(",
              "(": "(",
              "]": "[",
              "[": "[",
              "{": "{",
              "}": "{"
            };
            do {
              if (token.value.match(/[{}()\[\]]/g)) {
                for (; i2 < token.value.length && !found; i2++) {
                  if (!brackets[token.value[i2]]) {
                    continue;
                  }
                  bracketType = brackets[token.value[i2]] + "." + token.type.replace("rparen", "lparen");
                  if (isNaN(depth[bracketType])) {
                    depth[bracketType] = 0;
                  }
                  switch (token.value[i2]) {
                    case "(":
                    case "[":
                    case "{":
                      depth[bracketType]++;
                      break;
                    case ")":
                    case "]":
                    case "}":
                      depth[bracketType]--;
                      if (depth[bracketType] === -1) {
                        matchType = "bracket";
                        found = true;
                      }
                      break;
                  }
                }
              } else if (token.type.indexOf("tag-name") !== -1) {
                if (isNaN(depth[token.value])) {
                  depth[token.value] = 0;
                }
                if (prevToken.value === "<" && tokenCount > 1) {
                  depth[token.value]++;
                } else if (prevToken.value === "</") {
                  depth[token.value]--;
                }
                if (depth[token.value] === -1) {
                  matchType = "tag";
                  found = true;
                }
              }
              if (!found) {
                prevToken = token;
                tokenCount++;
                token = iterator.stepForward();
                i2 = 0;
              }
            } while (token && !found);
            if (!matchType)
              return;
            var range, pos;
            if (matchType === "bracket") {
              range = this.session.getBracketRange(cursor);
              if (!range) {
                range = new Range(iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn() + i2 - 1, iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn() + i2 - 1);
                pos = range.start;
                if (expand || pos.row === cursor.row && Math.abs(pos.column - cursor.column) < 2)
                  range = this.session.getBracketRange(pos);
              }
            } else if (matchType === "tag") {
              if (!token || token.type.indexOf("tag-name") === -1)
                return;
              range = new Range(iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn() - 2, iterator.getCurrentTokenRow(), iterator.getCurrentTokenColumn() - 2);
              if (range.compare(cursor.row, cursor.column) === 0) {
                var tagsRanges = this.session.getMatchingTags(cursor);
                if (tagsRanges) {
                  if (tagsRanges.openTag.contains(cursor.row, cursor.column)) {
                    range = tagsRanges.closeTag;
                    pos = range.start;
                  } else {
                    range = tagsRanges.openTag;
                    if (tagsRanges.closeTag.start.row === cursor.row && tagsRanges.closeTag.start.column === cursor.column)
                      pos = range.end;
                    else
                      pos = range.start;
                  }
                }
              }
              pos = pos || range.start;
            }
            pos = range && range.cursor || pos;
            if (pos) {
              if (select2) {
                if (range && expand) {
                  this.selection.setRange(range);
                } else if (range && range.isEqual(this.getSelectionRange())) {
                  this.clearSelection();
                } else {
                  this.selection.selectTo(pos.row, pos.column);
                }
              } else {
                this.selection.moveTo(pos.row, pos.column);
              }
            }
          };
          Editor2.prototype.gotoLine = function(lineNumber, column, animate) {
            this.selection.clearSelection();
            this.session.unfold({ row: lineNumber - 1, column: column || 0 });
            this.exitMultiSelectMode && this.exitMultiSelectMode();
            this.moveCursorTo(lineNumber - 1, column || 0);
            if (!this.isRowFullyVisible(lineNumber - 1))
              this.scrollToLine(lineNumber - 1, true, animate);
          };
          Editor2.prototype.navigateTo = function(row, column) {
            this.selection.moveTo(row, column);
          };
          Editor2.prototype.navigateUp = function(times) {
            if (this.selection.isMultiLine() && !this.selection.isBackwards()) {
              var selectionStart = this.selection.anchor.getPosition();
              return this.moveCursorToPosition(selectionStart);
            }
            this.selection.clearSelection();
            this.selection.moveCursorBy(-times || -1, 0);
          };
          Editor2.prototype.navigateDown = function(times) {
            if (this.selection.isMultiLine() && this.selection.isBackwards()) {
              var selectionEnd = this.selection.anchor.getPosition();
              return this.moveCursorToPosition(selectionEnd);
            }
            this.selection.clearSelection();
            this.selection.moveCursorBy(times || 1, 0);
          };
          Editor2.prototype.navigateLeft = function(times) {
            if (!this.selection.isEmpty()) {
              var selectionStart = this.getSelectionRange().start;
              this.moveCursorToPosition(selectionStart);
            } else {
              times = times || 1;
              while (times--) {
                this.selection.moveCursorLeft();
              }
            }
            this.clearSelection();
          };
          Editor2.prototype.navigateRight = function(times) {
            if (!this.selection.isEmpty()) {
              var selectionEnd = this.getSelectionRange().end;
              this.moveCursorToPosition(selectionEnd);
            } else {
              times = times || 1;
              while (times--) {
                this.selection.moveCursorRight();
              }
            }
            this.clearSelection();
          };
          Editor2.prototype.navigateLineStart = function() {
            this.selection.moveCursorLineStart();
            this.clearSelection();
          };
          Editor2.prototype.navigateLineEnd = function() {
            this.selection.moveCursorLineEnd();
            this.clearSelection();
          };
          Editor2.prototype.navigateFileEnd = function() {
            this.selection.moveCursorFileEnd();
            this.clearSelection();
          };
          Editor2.prototype.navigateFileStart = function() {
            this.selection.moveCursorFileStart();
            this.clearSelection();
          };
          Editor2.prototype.navigateWordRight = function() {
            this.selection.moveCursorWordRight();
            this.clearSelection();
          };
          Editor2.prototype.navigateWordLeft = function() {
            this.selection.moveCursorWordLeft();
            this.clearSelection();
          };
          Editor2.prototype.replace = function(replacement, options) {
            if (options)
              this.$search.set(options);
            var range = this.$search.find(this.session);
            var replaced = 0;
            if (!range)
              return replaced;
            if (this.$tryReplace(range, replacement)) {
              replaced = 1;
            }
            this.selection.setSelectionRange(range);
            this.renderer.scrollSelectionIntoView(range.start, range.end);
            return replaced;
          };
          Editor2.prototype.replaceAll = function(replacement, options) {
            if (options) {
              this.$search.set(options);
            }
            var ranges = this.$search.findAll(this.session);
            var replaced = 0;
            if (!ranges.length)
              return replaced;
            var selection = this.getSelectionRange();
            this.selection.moveTo(0, 0);
            for (var i2 = ranges.length - 1; i2 >= 0; --i2) {
              if (this.$tryReplace(ranges[i2], replacement)) {
                replaced++;
              }
            }
            this.selection.setSelectionRange(selection);
            return replaced;
          };
          Editor2.prototype.$tryReplace = function(range, replacement) {
            var input = this.session.getTextRange(range);
            replacement = this.$search.replace(input, replacement);
            if (replacement !== null) {
              range.end = this.session.replace(range, replacement);
              return range;
            } else {
              return null;
            }
          };
          Editor2.prototype.getLastSearchOptions = function() {
            return this.$search.getOptions();
          };
          Editor2.prototype.find = function(needle, options, animate) {
            if (!options)
              options = {};
            if (typeof needle == "string" || needle instanceof RegExp)
              options.needle = needle;
            else if (typeof needle == "object")
              oop.mixin(options, needle);
            var range = this.selection.getRange();
            if (options.needle == null) {
              needle = this.session.getTextRange(range) || this.$search.$options.needle;
              if (!needle) {
                range = this.session.getWordRange(range.start.row, range.start.column);
                needle = this.session.getTextRange(range);
              }
              this.$search.set({ needle });
            }
            this.$search.set(options);
            if (!options.start)
              this.$search.set({ start: range });
            var newRange = this.$search.find(this.session);
            if (options.preventScroll)
              return newRange;
            if (newRange) {
              this.revealRange(newRange, animate);
              return newRange;
            }
            if (options.backwards)
              range.start = range.end;
            else
              range.end = range.start;
            this.selection.setRange(range);
          };
          Editor2.prototype.findNext = function(options, animate) {
            this.find({ skipCurrent: true, backwards: false }, options, animate);
          };
          Editor2.prototype.findPrevious = function(options, animate) {
            this.find(options, { skipCurrent: true, backwards: true }, animate);
          };
          Editor2.prototype.revealRange = function(range, animate) {
            this.session.unfold(range);
            this.selection.setSelectionRange(range);
            var scrollTop = this.renderer.scrollTop;
            this.renderer.scrollSelectionIntoView(range.start, range.end, 0.5);
            if (animate !== false)
              this.renderer.animateScrolling(scrollTop);
          };
          Editor2.prototype.undo = function() {
            this.session.getUndoManager().undo(this.session);
            this.renderer.scrollCursorIntoView(null, 0.5);
          };
          Editor2.prototype.redo = function() {
            this.session.getUndoManager().redo(this.session);
            this.renderer.scrollCursorIntoView(null, 0.5);
          };
          Editor2.prototype.destroy = function() {
            if (this.$toDestroy) {
              this.$toDestroy.forEach(function(el) {
                el.destroy();
              });
              this.$toDestroy = null;
            }
            if (this.$mouseHandler)
              this.$mouseHandler.destroy();
            this.renderer.destroy();
            this._signal("destroy", this);
            if (this.session)
              this.session.destroy();
            if (this._$emitInputEvent)
              this._$emitInputEvent.cancel();
            this.removeAllListeners();
          };
          Editor2.prototype.setAutoScrollEditorIntoView = function(enable) {
            if (!enable)
              return;
            var rect;
            var self2 = this;
            var shouldScroll = false;
            if (!this.$scrollAnchor)
              this.$scrollAnchor = document.createElement("div");
            var scrollAnchor = this.$scrollAnchor;
            scrollAnchor.style.cssText = "position:absolute";
            this.container.insertBefore(scrollAnchor, this.container.firstChild);
            var onChangeSelection = this.on("changeSelection", function() {
              shouldScroll = true;
            });
            var onBeforeRender = this.renderer.on("beforeRender", function() {
              if (shouldScroll)
                rect = self2.renderer.container.getBoundingClientRect();
            });
            var onAfterRender = this.renderer.on("afterRender", function() {
              if (shouldScroll && rect && (self2.isFocused() || self2.searchBox && self2.searchBox.isFocused())) {
                var renderer = self2.renderer;
                var pos = renderer.$cursorLayer.$pixelPos;
                var config2 = renderer.layerConfig;
                var top = pos.top - config2.offset;
                if (pos.top >= 0 && top + rect.top < 0) {
                  shouldScroll = true;
                } else if (pos.top < config2.height && pos.top + rect.top + config2.lineHeight > window.innerHeight) {
                  shouldScroll = false;
                } else {
                  shouldScroll = null;
                }
                if (shouldScroll != null) {
                  scrollAnchor.style.top = top + "px";
                  scrollAnchor.style.left = pos.left + "px";
                  scrollAnchor.style.height = config2.lineHeight + "px";
                  scrollAnchor.scrollIntoView(shouldScroll);
                }
                shouldScroll = rect = null;
              }
            });
            this.setAutoScrollEditorIntoView = function(enable2) {
              if (enable2)
                return;
              delete this.setAutoScrollEditorIntoView;
              this.off("changeSelection", onChangeSelection);
              this.renderer.off("afterRender", onAfterRender);
              this.renderer.off("beforeRender", onBeforeRender);
            };
          };
          Editor2.prototype.$resetCursorStyle = function() {
            var style = this.$cursorStyle || "ace";
            var cursorLayer = this.renderer.$cursorLayer;
            if (!cursorLayer)
              return;
            cursorLayer.setSmoothBlinking(/smooth/.test(style));
            cursorLayer.isBlinking = !this.$readOnly && style != "wide";
            dom.setCssClass(cursorLayer.element, "ace_slim-cursors", /slim/.test(style));
          };
          Editor2.prototype.prompt = function(message, options, callback) {
            var editor = this;
            config.loadModule("ace/ext/prompt", function(module4) {
              module4.prompt(editor, message, options, callback);
            });
          };
          return Editor2;
        })()
      );
      Editor.$uid = 0;
      Editor.prototype.curOp = null;
      Editor.prototype.prevOp = {};
      Editor.prototype.$mergeableCommands = ["backspace", "del", "insertstring"];
      Editor.prototype.$toggleWordPairs = [
        ["first", "last"],
        ["true", "false"],
        ["yes", "no"],
        ["width", "height"],
        ["top", "bottom"],
        ["right", "left"],
        ["on", "off"],
        ["x", "y"],
        ["get", "set"],
        ["max", "min"],
        ["horizontal", "vertical"],
        ["show", "hide"],
        ["add", "remove"],
        ["up", "down"],
        ["before", "after"],
        ["even", "odd"],
        ["in", "out"],
        ["inside", "outside"],
        ["next", "previous"],
        ["increase", "decrease"],
        ["attach", "detach"],
        ["&&", "||"],
        ["==", "!="]
      ];
      oop.implement(Editor.prototype, EventEmitter);
      config.defineOptions(Editor.prototype, "editor", {
        selectionStyle: {
          set: function(style) {
            this.onSelectionChange();
            this._signal("changeSelectionStyle", { data: style });
          },
          initialValue: "line"
        },
        highlightActiveLine: {
          set: function() {
            this.$updateHighlightActiveLine();
          },
          initialValue: true
        },
        highlightSelectedWord: {
          set: function(shouldHighlight) {
            this.$onSelectionChange();
          },
          initialValue: true
        },
        readOnly: {
          set: function(readOnly) {
            this.textInput.setReadOnly(readOnly);
            this.$resetCursorStyle();
          },
          initialValue: false
        },
        copyWithEmptySelection: {
          set: function(value) {
            this.textInput.setCopyWithEmptySelection(value);
          },
          initialValue: false
        },
        cursorStyle: {
          set: function(val) {
            this.$resetCursorStyle();
          },
          values: ["ace", "slim", "smooth", "wide"],
          initialValue: "ace"
        },
        mergeUndoDeltas: {
          values: [false, true, "always"],
          initialValue: true
        },
        behavioursEnabled: { initialValue: true },
        wrapBehavioursEnabled: { initialValue: true },
        enableAutoIndent: { initialValue: true },
        autoScrollEditorIntoView: {
          set: function(val) {
            this.setAutoScrollEditorIntoView(val);
          }
        },
        keyboardHandler: {
          set: function(val) {
            this.setKeyboardHandler(val);
          },
          get: function() {
            return this.$keybindingId;
          },
          handlesSet: true
        },
        value: {
          set: function(val) {
            this.session.setValue(val);
          },
          get: function() {
            return this.getValue();
          },
          handlesSet: true,
          hidden: true
        },
        session: {
          set: function(val) {
            this.setSession(val);
          },
          get: function() {
            return this.session;
          },
          handlesSet: true,
          hidden: true
        },
        showLineNumbers: {
          set: function(show) {
            this.renderer.$gutterLayer.setShowLineNumbers(show);
            this.renderer.$loop.schedule(this.renderer.CHANGE_GUTTER);
            if (show && this.$relativeLineNumbers)
              relativeNumberRenderer.attach(this);
            else
              relativeNumberRenderer.detach(this);
          },
          initialValue: true
        },
        relativeLineNumbers: {
          set: function(value) {
            if (this.$showLineNumbers && value)
              relativeNumberRenderer.attach(this);
            else
              relativeNumberRenderer.detach(this);
          }
        },
        placeholder: {
          set: function(message) {
            if (!this.$updatePlaceholder) {
              this.$updatePlaceholder = (function() {
                var hasValue = this.session && (this.renderer.$composition || this.session.getLength() > 1 || this.session.getLine(0).length > 0);
                if (hasValue && this.renderer.placeholderNode) {
                  this.renderer.off("afterRender", this.$updatePlaceholder);
                  dom.removeCssClass(this.container, "ace_hasPlaceholder");
                  this.renderer.placeholderNode.remove();
                  this.renderer.placeholderNode = null;
                } else if (!hasValue && !this.renderer.placeholderNode) {
                  this.renderer.on("afterRender", this.$updatePlaceholder);
                  dom.addCssClass(this.container, "ace_hasPlaceholder");
                  var el = dom.createElement("div");
                  el.className = "ace_placeholder";
                  el.textContent = this.$placeholder || "";
                  this.renderer.placeholderNode = el;
                  this.renderer.content.appendChild(this.renderer.placeholderNode);
                } else if (!hasValue && this.renderer.placeholderNode) {
                  this.renderer.placeholderNode.textContent = this.$placeholder || "";
                }
              }).bind(this);
              this.on("input", this.$updatePlaceholder);
            }
            this.$updatePlaceholder();
          }
        },
        enableKeyboardAccessibility: {
          set: function(value) {
            var blurCommand = {
              name: "blurTextInput",
              description: "Set focus to the editor content div to allow tabbing through the page",
              bindKey: "Esc",
              exec: function(editor) {
                editor.blur();
                editor.renderer.scroller.focus();
              },
              readOnly: true
            };
            var focusOnEnterKeyup = function(e2) {
              if (e2.target == this.renderer.scroller && e2.keyCode === keys["enter"]) {
                e2.preventDefault();
                var row = this.getCursorPosition().row;
                if (!this.isRowVisible(row))
                  this.scrollToLine(row, true, true);
                this.focus();
              }
            };
            var gutterKeyboardHandler;
            if (value) {
              this.renderer.enableKeyboardAccessibility = true;
              this.renderer.keyboardFocusClassName = "ace_keyboard-focus";
              this.textInput.getElement().setAttribute("tabindex", -1);
              this.textInput.setNumberOfExtraLines(useragent.isWin ? 3 : 0);
              this.renderer.scroller.setAttribute("tabindex", 0);
              this.renderer.scroller.setAttribute("role", "group");
              this.renderer.scroller.setAttribute("aria-roledescription", nls("editor.scroller.aria-roledescription", "editor"));
              this.renderer.scroller.classList.add(this.renderer.keyboardFocusClassName);
              this.renderer.scroller.setAttribute("aria-label", nls("editor.scroller.aria-label", "Editor content, press Enter to start editing, press Escape to exit"));
              this.renderer.scroller.addEventListener("keyup", focusOnEnterKeyup.bind(this));
              this.commands.addCommand(blurCommand);
              this.renderer.$gutter.setAttribute("tabindex", 0);
              this.renderer.$gutter.setAttribute("aria-hidden", false);
              this.renderer.$gutter.setAttribute("role", "group");
              this.renderer.$gutter.setAttribute("aria-roledescription", nls("editor.gutter.aria-roledescription", "editor gutter"));
              this.renderer.$gutter.setAttribute("aria-label", nls("editor.gutter.aria-label", "Editor gutter, press Enter to interact with controls using arrow keys, press Escape to exit"));
              this.renderer.$gutter.classList.add(this.renderer.keyboardFocusClassName);
              this.renderer.content.setAttribute("aria-hidden", true);
              if (!gutterKeyboardHandler)
                gutterKeyboardHandler = new GutterKeyboardHandler(this);
              gutterKeyboardHandler.addListener();
              this.textInput.setAriaOptions({
                setLabel: true
              });
            } else {
              this.renderer.enableKeyboardAccessibility = false;
              this.textInput.getElement().setAttribute("tabindex", 0);
              this.textInput.setNumberOfExtraLines(0);
              this.renderer.scroller.setAttribute("tabindex", -1);
              this.renderer.scroller.removeAttribute("role");
              this.renderer.scroller.removeAttribute("aria-roledescription");
              this.renderer.scroller.classList.remove(this.renderer.keyboardFocusClassName);
              this.renderer.scroller.removeAttribute("aria-label");
              this.renderer.scroller.removeEventListener("keyup", focusOnEnterKeyup.bind(this));
              this.commands.removeCommand(blurCommand);
              this.renderer.content.removeAttribute("aria-hidden");
              this.renderer.$gutter.setAttribute("tabindex", -1);
              this.renderer.$gutter.setAttribute("aria-hidden", true);
              this.renderer.$gutter.removeAttribute("role");
              this.renderer.$gutter.removeAttribute("aria-roledescription");
              this.renderer.$gutter.removeAttribute("aria-label");
              this.renderer.$gutter.classList.remove(this.renderer.keyboardFocusClassName);
              if (gutterKeyboardHandler)
                gutterKeyboardHandler.removeListener();
            }
          },
          initialValue: false
        },
        textInputAriaLabel: {
          set: function(val) {
            this.$textInputAriaLabel = val;
          },
          initialValue: ""
        },
        enableMobileMenu: {
          set: function(val) {
            this.$enableMobileMenu = val;
          },
          initialValue: true
        },
        customScrollbar: "renderer",
        hScrollBarAlwaysVisible: "renderer",
        vScrollBarAlwaysVisible: "renderer",
        highlightGutterLine: "renderer",
        animatedScroll: "renderer",
        showInvisibles: "renderer",
        showPrintMargin: "renderer",
        printMarginColumn: "renderer",
        printMargin: "renderer",
        fadeFoldWidgets: "renderer",
        showFoldWidgets: "renderer",
        displayIndentGuides: "renderer",
        highlightIndentGuides: "renderer",
        showGutter: "renderer",
        fontSize: "renderer",
        fontFamily: "renderer",
        maxLines: "renderer",
        minLines: "renderer",
        scrollPastEnd: "renderer",
        fixedWidthGutter: "renderer",
        theme: "renderer",
        hasCssTransforms: "renderer",
        maxPixelHeight: "renderer",
        useTextareaForIME: "renderer",
        useResizeObserver: "renderer",
        useSvgGutterIcons: "renderer",
        showFoldedAnnotations: "renderer",
        scrollSpeed: "$mouseHandler",
        dragDelay: "$mouseHandler",
        dragEnabled: "$mouseHandler",
        focusTimeout: "$mouseHandler",
        tooltipFollowsMouse: "$mouseHandler",
        firstLineNumber: "session",
        overwrite: "session",
        newLineMode: "session",
        useWorker: "session",
        useSoftTabs: "session",
        navigateWithinSoftTabs: "session",
        tabSize: "session",
        wrap: "session",
        indentedSoftWrap: "session",
        foldStyle: "session",
        mode: "session"
      });
      var relativeNumberRenderer = {
        getText: function(session, row) {
          return (Math.abs(session.selection.lead.row - row) || row + 1 + (row < 9 ? "" : "")) + "";
        },
        getWidth: function(session, lastLineNumber, config2) {
          return Math.max(lastLineNumber.toString().length, (config2.lastRow + 1).toString().length, 2) * config2.characterWidth;
        },
        update: function(e2, editor) {
          editor.renderer.$loop.schedule(editor.renderer.CHANGE_GUTTER);
        },
        attach: function(editor) {
          editor.renderer.$gutterLayer.$renderer = this;
          editor.on("changeSelection", this.update);
          this.update(null, editor);
        },
        detach: function(editor) {
          if (editor.renderer.$gutterLayer.$renderer == this)
            editor.renderer.$gutterLayer.$renderer = null;
          editor.off("changeSelection", this.update);
          this.update(null, editor);
        }
      };
      exports3.Editor = Editor;
    });
    ace.define("ace/layer/lines", ["require", "exports", "module", "ace/lib/dom"], function(require2, exports3, module3) {
      var dom = require2("../lib/dom");
      var Lines = (
        /** @class */
        (function() {
          function Lines2(element, canvasHeight) {
            this.element = element;
            this.canvasHeight = canvasHeight || 5e5;
            this.element.style.height = this.canvasHeight * 2 + "px";
            this.cells = [];
            this.cellCache = [];
            this.$offsetCoefficient = 0;
          }
          Lines2.prototype.moveContainer = function(config) {
            dom.translate(this.element, 0, -(config.firstRowScreen * config.lineHeight % this.canvasHeight) - config.offset * this.$offsetCoefficient);
          };
          Lines2.prototype.pageChanged = function(oldConfig, newConfig) {
            return Math.floor(oldConfig.firstRowScreen * oldConfig.lineHeight / this.canvasHeight) !== Math.floor(newConfig.firstRowScreen * newConfig.lineHeight / this.canvasHeight);
          };
          Lines2.prototype.computeLineTop = function(row, config, session) {
            var screenTop = config.firstRowScreen * config.lineHeight;
            var screenPage = Math.floor(screenTop / this.canvasHeight);
            var lineTop = session.documentToScreenRow(row, 0) * config.lineHeight;
            return lineTop - screenPage * this.canvasHeight;
          };
          Lines2.prototype.computeLineHeight = function(row, config, session) {
            return config.lineHeight * session.getRowLineCount(row);
          };
          Lines2.prototype.getLength = function() {
            return this.cells.length;
          };
          Lines2.prototype.get = function(index) {
            return this.cells[index];
          };
          Lines2.prototype.shift = function() {
            this.$cacheCell(this.cells.shift());
          };
          Lines2.prototype.pop = function() {
            this.$cacheCell(this.cells.pop());
          };
          Lines2.prototype.push = function(cell) {
            if (Array.isArray(cell)) {
              this.cells.push.apply(this.cells, cell);
              var fragment = dom.createFragment(this.element);
              for (var i2 = 0; i2 < cell.length; i2++) {
                fragment.appendChild(cell[i2].element);
              }
              this.element.appendChild(fragment);
            } else {
              this.cells.push(cell);
              this.element.appendChild(cell.element);
            }
          };
          Lines2.prototype.unshift = function(cell) {
            if (Array.isArray(cell)) {
              this.cells.unshift.apply(this.cells, cell);
              var fragment = dom.createFragment(this.element);
              for (var i2 = 0; i2 < cell.length; i2++) {
                fragment.appendChild(cell[i2].element);
              }
              if (this.element.firstChild)
                this.element.insertBefore(fragment, this.element.firstChild);
              else
                this.element.appendChild(fragment);
            } else {
              this.cells.unshift(cell);
              this.element.insertAdjacentElement("afterbegin", cell.element);
            }
          };
          Lines2.prototype.last = function() {
            if (this.cells.length)
              return this.cells[this.cells.length - 1];
            else
              return null;
          };
          Lines2.prototype.$cacheCell = function(cell) {
            if (!cell)
              return;
            cell.element.remove();
            this.cellCache.push(cell);
          };
          Lines2.prototype.createCell = function(row, config, session, initElement) {
            var cell = this.cellCache.pop();
            if (!cell) {
              var element = dom.createElement("div");
              if (initElement)
                initElement(element);
              this.element.appendChild(element);
              cell = {
                element,
                text: "",
                row
              };
            }
            cell.row = row;
            return cell;
          };
          return Lines2;
        })()
      );
      exports3.Lines = Lines;
    });
    ace.define("ace/layer/gutter", ["require", "exports", "module", "ace/lib/dom", "ace/lib/oop", "ace/lib/lang", "ace/lib/event_emitter", "ace/layer/lines", "ace/config"], function(require2, exports3, module3) {
      var dom = require2("../lib/dom");
      var oop = require2("../lib/oop");
      var lang = require2("../lib/lang");
      var EventEmitter = require2("../lib/event_emitter").EventEmitter;
      var Lines = require2("./lines").Lines;
      var nls = require2("../config").nls;
      var Gutter = (
        /** @class */
        (function() {
          function Gutter2(parentEl) {
            this.element = dom.createElement("div");
            this.element.className = "ace_layer ace_gutter-layer";
            parentEl.appendChild(this.element);
            this.setShowFoldWidgets(this.$showFoldWidgets);
            this.gutterWidth = 0;
            this.$annotations = [];
            this.$updateAnnotations = this.$updateAnnotations.bind(this);
            this.$lines = new Lines(this.element);
            this.$lines.$offsetCoefficient = 1;
          }
          Gutter2.prototype.setSession = function(session) {
            if (this.session)
              this.session.off("change", this.$updateAnnotations);
            this.session = session;
            if (session)
              session.on("change", this.$updateAnnotations);
          };
          Gutter2.prototype.addGutterDecoration = function(row, className) {
            if (window.console)
              console.warn && console.warn("deprecated use session.addGutterDecoration");
            this.session.addGutterDecoration(row, className);
          };
          Gutter2.prototype.removeGutterDecoration = function(row, className) {
            if (window.console)
              console.warn && console.warn("deprecated use session.removeGutterDecoration");
            this.session.removeGutterDecoration(row, className);
          };
          Gutter2.prototype.setAnnotations = function(annotations) {
            this.$annotations = [];
            for (var i2 = 0; i2 < annotations.length; i2++) {
              var annotation = annotations[i2];
              var row = annotation.row;
              var rowInfo = this.$annotations[row];
              if (!rowInfo)
                rowInfo = this.$annotations[row] = { text: [], type: [], displayText: [] };
              var annoText = annotation.text;
              var displayAnnoText = annotation.text;
              var annoType = annotation.type;
              annoText = annoText ? lang.escapeHTML(annoText) : annotation.html || "";
              displayAnnoText = displayAnnoText ? displayAnnoText : annotation.html || "";
              if (rowInfo.text.indexOf(annoText) === -1) {
                rowInfo.text.push(annoText);
                rowInfo.type.push(annoType);
                rowInfo.displayText.push(displayAnnoText);
              }
              var className = annotation.className;
              if (className) {
                rowInfo.className = className;
              } else if (annoType === "error") {
                rowInfo.className = " ace_error";
              } else if (annoType === "security" && !/\bace_error\b/.test(rowInfo.className)) {
                rowInfo.className = " ace_security";
              } else if (annoType === "warning" && !/\bace_(error|security)\b/.test(rowInfo.className)) {
                rowInfo.className = " ace_warning";
              } else if (annoType === "info" && !rowInfo.className) {
                rowInfo.className = " ace_info";
              } else if (annoType === "hint" && !rowInfo.className) {
                rowInfo.className = " ace_hint";
              }
            }
          };
          Gutter2.prototype.$updateAnnotations = function(delta) {
            if (!this.$annotations.length)
              return;
            var firstRow = delta.start.row;
            var len = delta.end.row - firstRow;
            if (len === 0) ;
            else if (delta.action == "remove") {
              this.$annotations.splice(firstRow, len + 1, null);
            } else {
              var args = new Array(len + 1);
              args.unshift(firstRow, 1);
              this.$annotations.splice.apply(this.$annotations, args);
            }
          };
          Gutter2.prototype.update = function(config) {
            this.config = config;
            var session = this.session;
            var firstRow = config.firstRow;
            var lastRow = Math.min(
              config.lastRow + config.gutterOffset,
              // needed to compensate for hor scollbar
              session.getLength() - 1
            );
            this.oldLastRow = lastRow;
            this.config = config;
            this.$lines.moveContainer(config);
            this.$updateCursorRow();
            var fold = session.getNextFoldLine(firstRow);
            var foldStart = fold ? fold.start.row : Infinity;
            var cell = null;
            var index = -1;
            var row = firstRow;
            while (true) {
              if (row > foldStart) {
                row = fold.end.row + 1;
                fold = session.getNextFoldLine(row, fold);
                foldStart = fold ? fold.start.row : Infinity;
              }
              if (row > lastRow) {
                while (this.$lines.getLength() > index + 1)
                  this.$lines.pop();
                break;
              }
              cell = this.$lines.get(++index);
              if (cell) {
                cell.row = row;
              } else {
                cell = this.$lines.createCell(row, config, this.session, onCreateCell);
                this.$lines.push(cell);
              }
              this.$renderCell(cell, config, fold, row);
              row++;
            }
            this._signal("afterRender");
            this.$updateGutterWidth(config);
          };
          Gutter2.prototype.$updateGutterWidth = function(config) {
            var session = this.session;
            var gutterRenderer = session.gutterRenderer || this.$renderer;
            var firstLineNumber = session.$firstLineNumber;
            var lastLineText = this.$lines.last() ? this.$lines.last().text : "";
            if (this.$fixedWidth || session.$useWrapMode)
              lastLineText = session.getLength() + firstLineNumber - 1;
            var gutterWidth = gutterRenderer ? gutterRenderer.getWidth(session, lastLineText, config) : lastLineText.toString().length * config.characterWidth;
            var padding = this.$padding || this.$computePadding();
            gutterWidth += padding.left + padding.right;
            if (gutterWidth !== this.gutterWidth && !isNaN(gutterWidth)) {
              this.gutterWidth = gutterWidth;
              this.element.parentNode.style.width = this.element.style.width = Math.ceil(this.gutterWidth) + "px";
              this._signal("changeGutterWidth", gutterWidth);
            }
          };
          Gutter2.prototype.$updateCursorRow = function() {
            if (!this.$highlightGutterLine)
              return;
            var position = this.session.selection.getCursor();
            if (this.$cursorRow === position.row)
              return;
            this.$cursorRow = position.row;
          };
          Gutter2.prototype.updateLineHighlight = function() {
            if (!this.$highlightGutterLine)
              return;
            var row = this.session.selection.cursor.row;
            this.$cursorRow = row;
            if (this.$cursorCell && this.$cursorCell.row == row)
              return;
            if (this.$cursorCell)
              this.$cursorCell.element.className = this.$cursorCell.element.className.replace("ace_gutter-active-line ", "");
            var cells = this.$lines.cells;
            this.$cursorCell = null;
            for (var i2 = 0; i2 < cells.length; i2++) {
              var cell = cells[i2];
              if (cell.row >= this.$cursorRow) {
                if (cell.row > this.$cursorRow) {
                  var fold = this.session.getFoldLine(this.$cursorRow);
                  if (i2 > 0 && fold && fold.start.row == cells[i2 - 1].row)
                    cell = cells[i2 - 1];
                  else
                    break;
                }
                cell.element.className = "ace_gutter-active-line " + cell.element.className;
                this.$cursorCell = cell;
                break;
              }
            }
          };
          Gutter2.prototype.scrollLines = function(config) {
            var oldConfig = this.config;
            this.config = config;
            this.$updateCursorRow();
            if (this.$lines.pageChanged(oldConfig, config))
              return this.update(config);
            this.$lines.moveContainer(config);
            var lastRow = Math.min(
              config.lastRow + config.gutterOffset,
              // needed to compensate for hor scollbar
              this.session.getLength() - 1
            );
            var oldLastRow = this.oldLastRow;
            this.oldLastRow = lastRow;
            if (!oldConfig || oldLastRow < config.firstRow)
              return this.update(config);
            if (lastRow < oldConfig.firstRow)
              return this.update(config);
            if (oldConfig.firstRow < config.firstRow)
              for (var row = this.session.getFoldedRowCount(oldConfig.firstRow, config.firstRow - 1); row > 0; row--)
                this.$lines.shift();
            if (oldLastRow > lastRow)
              for (var row = this.session.getFoldedRowCount(lastRow + 1, oldLastRow); row > 0; row--)
                this.$lines.pop();
            if (config.firstRow < oldConfig.firstRow) {
              this.$lines.unshift(this.$renderLines(config, config.firstRow, oldConfig.firstRow - 1));
            }
            if (lastRow > oldLastRow) {
              this.$lines.push(this.$renderLines(config, oldLastRow + 1, lastRow));
            }
            this.updateLineHighlight();
            this._signal("afterRender");
            this.$updateGutterWidth(config);
          };
          Gutter2.prototype.$renderLines = function(config, firstRow, lastRow) {
            var fragment = [];
            var row = firstRow;
            var foldLine = this.session.getNextFoldLine(row);
            var foldStart = foldLine ? foldLine.start.row : Infinity;
            while (true) {
              if (row > foldStart) {
                row = foldLine.end.row + 1;
                foldLine = this.session.getNextFoldLine(row, foldLine);
                foldStart = foldLine ? foldLine.start.row : Infinity;
              }
              if (row > lastRow)
                break;
              var cell = this.$lines.createCell(row, config, this.session, onCreateCell);
              this.$renderCell(cell, config, foldLine, row);
              fragment.push(cell);
              row++;
            }
            return fragment;
          };
          Gutter2.prototype.$renderCell = function(cell, config, fold, row) {
            var element = cell.element;
            var session = this.session;
            var textNode = element.childNodes[0];
            var foldWidget = element.childNodes[1];
            var annotationNode = element.childNodes[2];
            var annotationIconNode = annotationNode.firstChild;
            var firstLineNumber = session.$firstLineNumber;
            var breakpoints = session.$breakpoints;
            var decorations = session.$decorations;
            var gutterRenderer = session.gutterRenderer || this.$renderer;
            var foldWidgets = this.$showFoldWidgets && session.foldWidgets;
            var foldStart = fold ? fold.start.row : Number.MAX_VALUE;
            var lineHeight = config.lineHeight + "px";
            var className = this.$useSvgGutterIcons ? "ace_gutter-cell_svg-icons " : "ace_gutter-cell ";
            var iconClassName = this.$useSvgGutterIcons ? "ace_icon_svg" : "ace_icon";
            var rowText = (gutterRenderer ? gutterRenderer.getText(session, row) : row + firstLineNumber).toString();
            if (this.$highlightGutterLine) {
              if (row == this.$cursorRow || fold && row < this.$cursorRow && row >= foldStart && this.$cursorRow <= fold.end.row) {
                className += "ace_gutter-active-line ";
                if (this.$cursorCell != cell) {
                  if (this.$cursorCell)
                    this.$cursorCell.element.className = this.$cursorCell.element.className.replace("ace_gutter-active-line ", "");
                  this.$cursorCell = cell;
                }
              }
            }
            if (breakpoints[row])
              className += breakpoints[row];
            if (decorations[row])
              className += decorations[row];
            if (this.$annotations[row] && row !== foldStart)
              className += this.$annotations[row].className;
            if (foldWidgets) {
              var c2 = foldWidgets[row];
              if (c2 == null)
                c2 = foldWidgets[row] = session.getFoldWidget(row);
            }
            if (c2) {
              var foldClass = "ace_fold-widget ace_" + c2;
              var isClosedFold = c2 == "start" && row == foldStart && row < fold.end.row;
              if (isClosedFold) {
                foldClass += " ace_closed";
                var foldAnnotationClass = "";
                var annotationInFold = false;
                for (var i2 = row + 1; i2 <= fold.end.row; i2++) {
                  if (!this.$annotations[i2])
                    continue;
                  if (this.$annotations[i2].className === " ace_error") {
                    annotationInFold = true;
                    foldAnnotationClass = " ace_error_fold";
                    break;
                  }
                  if (this.$annotations[i2].className === " ace_security") {
                    annotationInFold = true;
                    foldAnnotationClass = " ace_security_fold";
                  } else if (this.$annotations[i2].className === " ace_warning" && foldAnnotationClass !== " ace_security_fold") {
                    annotationInFold = true;
                    foldAnnotationClass = " ace_warning_fold";
                  }
                }
                className += foldAnnotationClass;
              } else
                foldClass += " ace_open";
              if (foldWidget.className != foldClass)
                foldWidget.className = foldClass;
              dom.setStyle(foldWidget.style, "height", lineHeight);
              dom.setStyle(foldWidget.style, "display", "inline-block");
              foldWidget.setAttribute("role", "button");
              foldWidget.setAttribute("tabindex", "-1");
              var foldRange = session.getFoldWidgetRange(row);
              if (foldRange)
                foldWidget.setAttribute("aria-label", nls("gutter.code-folding.range.aria-label", "Toggle code folding, rows $0 through $1", [
                  foldRange.start.row + 1,
                  foldRange.end.row + 1
                ]));
              else {
                if (fold)
                  foldWidget.setAttribute("aria-label", nls("gutter.code-folding.closed.aria-label", "Toggle code folding, rows $0 through $1", [
                    fold.start.row + 1,
                    fold.end.row + 1
                  ]));
                else
                  foldWidget.setAttribute("aria-label", nls("gutter.code-folding.open.aria-label", "Toggle code folding, row $0", [row + 1]));
              }
              if (isClosedFold) {
                foldWidget.setAttribute("aria-expanded", "false");
                foldWidget.setAttribute("title", nls("gutter.code-folding.closed.title", "Unfold code"));
              } else {
                foldWidget.setAttribute("aria-expanded", "true");
                foldWidget.setAttribute("title", nls("gutter.code-folding.open.title", "Fold code"));
              }
            } else {
              if (foldWidget) {
                dom.setStyle(foldWidget.style, "display", "none");
                foldWidget.setAttribute("tabindex", "0");
                foldWidget.removeAttribute("role");
                foldWidget.removeAttribute("aria-label");
              }
            }
            if (annotationInFold && this.$showFoldedAnnotations) {
              annotationNode.className = "ace_gutter_annotation";
              annotationIconNode.className = iconClassName;
              annotationIconNode.className += foldAnnotationClass;
              dom.setStyle(annotationIconNode.style, "height", lineHeight);
              dom.setStyle(annotationNode.style, "display", "block");
              dom.setStyle(annotationNode.style, "height", lineHeight);
              var ariaLabel;
              switch (foldAnnotationClass) {
                case " ace_error_fold":
                  ariaLabel = nls("gutter.annotation.aria-label.error", "Error, read annotations row $0", [rowText]);
                  break;
                case " ace_security_fold":
                  ariaLabel = nls("gutter.annotation.aria-label.security", "Security finding, read annotations row $0", [rowText]);
                  break;
                case " ace_warning_fold":
                  ariaLabel = nls("gutter.annotation.aria-label.warning", "Warning, read annotations row $0", [rowText]);
                  break;
              }
              annotationNode.setAttribute("aria-label", ariaLabel);
              annotationNode.setAttribute("tabindex", "-1");
              annotationNode.setAttribute("role", "button");
            } else if (this.$annotations[row]) {
              annotationNode.className = "ace_gutter_annotation";
              annotationIconNode.className = iconClassName;
              if (this.$useSvgGutterIcons)
                annotationIconNode.className += this.$annotations[row].className;
              else
                element.classList.add(this.$annotations[row].className.replace(" ", ""));
              dom.setStyle(annotationIconNode.style, "height", lineHeight);
              dom.setStyle(annotationNode.style, "display", "block");
              dom.setStyle(annotationNode.style, "height", lineHeight);
              var ariaLabel;
              switch (this.$annotations[row].className) {
                case " ace_error":
                  ariaLabel = nls("gutter.annotation.aria-label.error", "Error, read annotations row $0", [rowText]);
                  break;
                case " ace_security":
                  ariaLabel = nls("gutter.annotation.aria-label.security", "Security finding, read annotations row $0", [rowText]);
                  break;
                case " ace_warning":
                  ariaLabel = nls("gutter.annotation.aria-label.warning", "Warning, read annotations row $0", [rowText]);
                  break;
                case " ace_info":
                  ariaLabel = nls("gutter.annotation.aria-label.info", "Info, read annotations row $0", [rowText]);
                  break;
                case " ace_hint":
                  ariaLabel = nls("gutter.annotation.aria-label.hint", "Suggestion, read annotations row $0", [rowText]);
                  break;
              }
              annotationNode.setAttribute("aria-label", ariaLabel);
              annotationNode.setAttribute("tabindex", "-1");
              annotationNode.setAttribute("role", "button");
            } else {
              dom.setStyle(annotationNode.style, "display", "none");
              annotationNode.removeAttribute("aria-label");
              annotationNode.removeAttribute("role");
              annotationNode.setAttribute("tabindex", "0");
            }
            if (rowText !== textNode.data) {
              textNode.data = rowText;
            }
            if (element.className != className)
              element.className = className;
            dom.setStyle(cell.element.style, "height", this.$lines.computeLineHeight(row, config, session) + "px");
            dom.setStyle(cell.element.style, "top", this.$lines.computeLineTop(row, config, session) + "px");
            cell.text = rowText;
            if (annotationNode.style.display === "none" && foldWidget.style.display === "none")
              cell.element.setAttribute("aria-hidden", true);
            else
              cell.element.setAttribute("aria-hidden", false);
            return cell;
          };
          Gutter2.prototype.setHighlightGutterLine = function(highlightGutterLine) {
            this.$highlightGutterLine = highlightGutterLine;
          };
          Gutter2.prototype.setShowLineNumbers = function(show) {
            this.$renderer = !show && {
              getWidth: function() {
                return 0;
              },
              getText: function() {
                return "";
              }
            };
          };
          Gutter2.prototype.getShowLineNumbers = function() {
            return this.$showLineNumbers;
          };
          Gutter2.prototype.setShowFoldWidgets = function(show) {
            if (show)
              dom.addCssClass(this.element, "ace_folding-enabled");
            else
              dom.removeCssClass(this.element, "ace_folding-enabled");
            this.$showFoldWidgets = show;
            this.$padding = null;
          };
          Gutter2.prototype.getShowFoldWidgets = function() {
            return this.$showFoldWidgets;
          };
          Gutter2.prototype.$computePadding = function() {
            if (!this.element.firstChild)
              return { left: 0, right: 0 };
            var style = dom.computedStyle(
              /**@type{Element}*/
              this.element.firstChild
            );
            this.$padding = {};
            this.$padding.left = (parseInt(style.borderLeftWidth) || 0) + (parseInt(style.paddingLeft) || 0) + 1;
            this.$padding.right = (parseInt(style.borderRightWidth) || 0) + (parseInt(style.paddingRight) || 0);
            return this.$padding;
          };
          Gutter2.prototype.getRegion = function(point) {
            var padding = this.$padding || this.$computePadding();
            var rect = this.element.getBoundingClientRect();
            if (point.x < padding.left + rect.left)
              return "markers";
            if (this.$showFoldWidgets && point.x > rect.right - padding.right)
              return "foldWidgets";
          };
          return Gutter2;
        })()
      );
      Gutter.prototype.$fixedWidth = false;
      Gutter.prototype.$highlightGutterLine = true;
      Gutter.prototype.$renderer = "";
      Gutter.prototype.$showLineNumbers = true;
      Gutter.prototype.$showFoldWidgets = true;
      oop.implement(Gutter.prototype, EventEmitter);
      function onCreateCell(element) {
        var textNode = document.createTextNode("");
        element.appendChild(textNode);
        var foldWidget = dom.createElement("span");
        element.appendChild(foldWidget);
        var annotationNode = dom.createElement("span");
        element.appendChild(annotationNode);
        var annotationIconNode = dom.createElement("span");
        annotationNode.appendChild(annotationIconNode);
        return element;
      }
      exports3.Gutter = Gutter;
    });
    ace.define("ace/layer/marker", ["require", "exports", "module", "ace/range", "ace/lib/dom"], function(require2, exports3, module3) {
      var Range = require2("../range").Range;
      var dom = require2("../lib/dom");
      var Marker = (
        /** @class */
        (function() {
          function Marker2(parentEl) {
            this.element = dom.createElement("div");
            this.element.className = "ace_layer ace_marker-layer";
            parentEl.appendChild(this.element);
          }
          Marker2.prototype.setPadding = function(padding) {
            this.$padding = padding;
          };
          Marker2.prototype.setSession = function(session) {
            this.session = session;
          };
          Marker2.prototype.setMarkers = function(markers) {
            this.markers = markers;
          };
          Marker2.prototype.elt = function(className, css2) {
            var x2 = this.i != -1 && this.element.childNodes[this.i];
            if (!x2) {
              x2 = document.createElement("div");
              this.element.appendChild(x2);
              this.i = -1;
            } else {
              this.i++;
            }
            x2.style.cssText = css2;
            x2.className = className;
          };
          Marker2.prototype.update = function(config) {
            if (!config)
              return;
            this.config = config;
            this.i = 0;
            var html3;
            for (var key in this.markers) {
              var marker = this.markers[key];
              if (!marker.range) {
                marker.update(html3, this, this.session, config);
                continue;
              }
              var range = marker.range.clipRows(config.firstRow, config.lastRow);
              if (range.isEmpty())
                continue;
              range = range.toScreenRange(this.session);
              if (marker.renderer) {
                var top = this.$getTop(range.start.row, config);
                var left = this.$padding + range.start.column * config.characterWidth;
                marker.renderer(html3, range, left, top, config);
              } else if (marker.type == "fullLine") {
                this.drawFullLineMarker(html3, range, marker.clazz, config);
              } else if (marker.type == "screenLine") {
                this.drawScreenLineMarker(html3, range, marker.clazz, config);
              } else if (range.isMultiLine()) {
                if (marker.type == "text")
                  this.drawTextMarker(html3, range, marker.clazz, config);
                else
                  this.drawMultiLineMarker(html3, range, marker.clazz, config);
              } else {
                this.drawSingleLineMarker(html3, range, marker.clazz + " ace_start ace_br15", config);
              }
            }
            if (this.i != -1) {
              while (this.i < this.element.childElementCount)
                this.element.removeChild(this.element.lastChild);
            }
          };
          Marker2.prototype.$getTop = function(row, layerConfig) {
            return (row - layerConfig.firstRowScreen) * layerConfig.lineHeight;
          };
          Marker2.prototype.drawTextMarker = function(stringBuilder, range, clazz, layerConfig, extraStyle) {
            var session = this.session;
            var start = range.start.row;
            var end = range.end.row;
            var row = start;
            var prev = 0;
            var curr = 0;
            var next = session.getScreenLastRowColumn(row);
            var lineRange = new Range(row, range.start.column, row, curr);
            for (; row <= end; row++) {
              lineRange.start.row = lineRange.end.row = row;
              lineRange.start.column = row == start ? range.start.column : session.getRowWrapIndent(row);
              lineRange.end.column = next;
              prev = curr;
              curr = next;
              next = row + 1 < end ? session.getScreenLastRowColumn(row + 1) : row == end ? 0 : range.end.column;
              this.drawSingleLineMarker(stringBuilder, lineRange, clazz + (row == start ? " ace_start" : "") + " ace_br" + getBorderClass(row == start || row == start + 1 && range.start.column, prev < curr, curr > next, row == end), layerConfig, row == end ? 0 : 1, extraStyle);
            }
          };
          Marker2.prototype.drawMultiLineMarker = function(stringBuilder, range, clazz, config, extraStyle) {
            var padding = this.$padding;
            var height = config.lineHeight;
            var top = this.$getTop(range.start.row, config);
            var left = padding + range.start.column * config.characterWidth;
            extraStyle = extraStyle || "";
            if (this.session.$bidiHandler.isBidiRow(range.start.row)) {
              var range1 = range.clone();
              range1.end.row = range1.start.row;
              range1.end.column = this.session.getLine(range1.start.row).length;
              this.drawBidiSingleLineMarker(stringBuilder, range1, clazz + " ace_br1 ace_start", config, null, extraStyle);
            } else {
              this.elt(clazz + " ace_br1 ace_start", "height:" + height + "px;right:" + padding + "px;top:" + top + "px;left:" + left + "px;" + (extraStyle || ""));
            }
            if (this.session.$bidiHandler.isBidiRow(range.end.row)) {
              var range1 = range.clone();
              range1.start.row = range1.end.row;
              range1.start.column = 0;
              this.drawBidiSingleLineMarker(stringBuilder, range1, clazz + " ace_br12", config, null, extraStyle);
            } else {
              top = this.$getTop(range.end.row, config);
              var width = range.end.column * config.characterWidth;
              this.elt(clazz + " ace_br12", "height:" + height + "px;width:" + width + "px;top:" + top + "px;left:" + padding + "px;" + (extraStyle || ""));
            }
            height = (range.end.row - range.start.row - 1) * config.lineHeight;
            if (height <= 0)
              return;
            top = this.$getTop(range.start.row + 1, config);
            var radiusClass = (range.start.column ? 1 : 0) | (range.end.column ? 0 : 8);
            this.elt(clazz + (radiusClass ? " ace_br" + radiusClass : ""), "height:" + height + "px;right:" + padding + "px;top:" + top + "px;left:" + padding + "px;" + (extraStyle || ""));
          };
          Marker2.prototype.drawSingleLineMarker = function(stringBuilder, range, clazz, config, extraLength, extraStyle) {
            if (this.session.$bidiHandler.isBidiRow(range.start.row))
              return this.drawBidiSingleLineMarker(stringBuilder, range, clazz, config, extraLength, extraStyle);
            var height = config.lineHeight;
            var width = (range.end.column + (extraLength || 0) - range.start.column) * config.characterWidth;
            var top = this.$getTop(range.start.row, config);
            var left = this.$padding + range.start.column * config.characterWidth;
            this.elt(clazz, "height:" + height + "px;width:" + width + "px;top:" + top + "px;left:" + left + "px;" + (extraStyle || ""));
          };
          Marker2.prototype.drawBidiSingleLineMarker = function(stringBuilder, range, clazz, config, extraLength, extraStyle) {
            var height = config.lineHeight, top = this.$getTop(range.start.row, config), padding = this.$padding;
            var selections = this.session.$bidiHandler.getSelections(range.start.column, range.end.column);
            selections.forEach(function(selection) {
              this.elt(clazz, "height:" + height + "px;width:" + (selection.width + (extraLength || 0)) + "px;top:" + top + "px;left:" + (padding + selection.left) + "px;" + (extraStyle || ""));
            }, this);
          };
          Marker2.prototype.drawFullLineMarker = function(stringBuilder, range, clazz, config, extraStyle) {
            var top = this.$getTop(range.start.row, config);
            var height = config.lineHeight;
            if (range.start.row != range.end.row)
              height += this.$getTop(range.end.row, config) - top;
            this.elt(clazz, "height:" + height + "px;top:" + top + "px;left:0;right:0;" + (extraStyle || ""));
          };
          Marker2.prototype.drawScreenLineMarker = function(stringBuilder, range, clazz, config, extraStyle) {
            var top = this.$getTop(range.start.row, config);
            var height = config.lineHeight;
            this.elt(clazz, "height:" + height + "px;top:" + top + "px;left:0;right:0;" + (extraStyle || ""));
          };
          return Marker2;
        })()
      );
      Marker.prototype.$padding = 0;
      function getBorderClass(tl, tr, br, bl) {
        return (tl ? 1 : 0) | (tr ? 2 : 0) | (br ? 4 : 0) | (bl ? 8 : 0);
      }
      exports3.Marker = Marker;
    });
    ace.define("ace/layer/text_util", ["require", "exports", "module"], function(require2, exports3, module3) {
      var textTokens = /* @__PURE__ */ new Set(["text", "rparen", "lparen"]);
      exports3.isTextToken = function(tokenType) {
        return textTokens.has(tokenType);
      };
    });
    ace.define("ace/layer/text", ["require", "exports", "module", "ace/lib/oop", "ace/lib/dom", "ace/lib/lang", "ace/layer/lines", "ace/lib/event_emitter", "ace/config", "ace/layer/text_util"], function(require2, exports3, module3) {
      var oop = require2("../lib/oop");
      var dom = require2("../lib/dom");
      var lang = require2("../lib/lang");
      var Lines = require2("./lines").Lines;
      var EventEmitter = require2("../lib/event_emitter").EventEmitter;
      var nls = require2("../config").nls;
      var isTextToken = require2("./text_util").isTextToken;
      var Text2 = (
        /** @class */
        (function() {
          function Text3(parentEl) {
            this.dom = dom;
            this.element = this.dom.createElement("div");
            this.element.className = "ace_layer ace_text-layer";
            parentEl.appendChild(this.element);
            this.$updateEolChar = this.$updateEolChar.bind(this);
            this.$lines = new Lines(this.element);
          }
          Text3.prototype.$updateEolChar = function() {
            var doc = this.session.doc;
            var unixMode = doc.getNewLineCharacter() == "\n" && doc.getNewLineMode() != "windows";
            var EOL_CHAR = unixMode ? this.EOL_CHAR_LF : this.EOL_CHAR_CRLF;
            if (this.EOL_CHAR != EOL_CHAR) {
              this.EOL_CHAR = EOL_CHAR;
              return true;
            }
          };
          Text3.prototype.setPadding = function(padding) {
            this.$padding = padding;
            this.element.style.margin = "0 " + padding + "px";
          };
          Text3.prototype.getLineHeight = function() {
            return this.$fontMetrics.$characterSize.height || 0;
          };
          Text3.prototype.getCharacterWidth = function() {
            return this.$fontMetrics.$characterSize.width || 0;
          };
          Text3.prototype.$setFontMetrics = function(measure) {
            this.$fontMetrics = measure;
            this.$fontMetrics.on(
              "changeCharacterSize",
              (function(e2) {
                this._signal("changeCharacterSize", e2);
              }).bind(this)
            );
            this.$pollSizeChanges();
          };
          Text3.prototype.checkForSizeChanges = function() {
            this.$fontMetrics.checkForSizeChanges();
          };
          Text3.prototype.$pollSizeChanges = function() {
            return this.$pollSizeChangesTimer = this.$fontMetrics.$pollSizeChanges();
          };
          Text3.prototype.setSession = function(session) {
            this.session = session;
            if (session)
              this.$computeTabString();
          };
          Text3.prototype.setShowInvisibles = function(showInvisibles) {
            if (this.showInvisibles == showInvisibles)
              return false;
            this.showInvisibles = showInvisibles;
            if (typeof showInvisibles == "string") {
              this.showSpaces = /tab/i.test(showInvisibles);
              this.showTabs = /space/i.test(showInvisibles);
              this.showEOL = /eol/i.test(showInvisibles);
            } else {
              this.showSpaces = this.showTabs = this.showEOL = showInvisibles;
            }
            this.$computeTabString();
            return true;
          };
          Text3.prototype.setDisplayIndentGuides = function(display) {
            if (this.displayIndentGuides == display)
              return false;
            this.displayIndentGuides = display;
            this.$computeTabString();
            return true;
          };
          Text3.prototype.setHighlightIndentGuides = function(highlight) {
            if (this.$highlightIndentGuides === highlight)
              return false;
            this.$highlightIndentGuides = highlight;
            return highlight;
          };
          Text3.prototype.$computeTabString = function() {
            var tabSize = this.session.getTabSize();
            this.tabSize = tabSize;
            var tabStr = this.$tabStrings = [0];
            for (var i2 = 1; i2 < tabSize + 1; i2++) {
              if (this.showTabs) {
                var span = this.dom.createElement("span");
                span.className = "ace_invisible ace_invisible_tab";
                span.textContent = lang.stringRepeat(this.TAB_CHAR, i2);
                tabStr.push(span);
              } else {
                tabStr.push(this.dom.createTextNode(lang.stringRepeat(" ", i2), this.element));
              }
            }
            if (this.displayIndentGuides) {
              this.$indentGuideRe = /\s\S| \t|\t |\s$/;
              var className = "ace_indent-guide";
              var spaceClass = this.showSpaces ? " ace_invisible ace_invisible_space" : "";
              var spaceContent = this.showSpaces ? lang.stringRepeat(this.SPACE_CHAR, this.tabSize) : lang.stringRepeat(" ", this.tabSize);
              var tabClass = this.showTabs ? " ace_invisible ace_invisible_tab" : "";
              var tabContent = this.showTabs ? lang.stringRepeat(this.TAB_CHAR, this.tabSize) : spaceContent;
              var span = this.dom.createElement("span");
              span.className = className + spaceClass;
              span.textContent = spaceContent;
              this.$tabStrings[" "] = span;
              var span = this.dom.createElement("span");
              span.className = className + tabClass;
              span.textContent = tabContent;
              this.$tabStrings["	"] = span;
            }
          };
          Text3.prototype.updateLines = function(config, firstRow, lastRow) {
            if (this.config.lastRow != config.lastRow || this.config.firstRow != config.firstRow) {
              return this.update(config);
            }
            this.config = config;
            var first = Math.max(firstRow, config.firstRow);
            var last = Math.min(lastRow, config.lastRow);
            var lineElements = this.element.childNodes;
            var lineElementsIdx = 0;
            for (var row = config.firstRow; row < first; row++) {
              var foldLine = this.session.getFoldLine(row);
              if (foldLine) {
                if (foldLine.containsRow(first)) {
                  first = foldLine.start.row;
                  break;
                } else {
                  row = foldLine.end.row;
                }
              }
              lineElementsIdx++;
            }
            var heightChanged = false;
            var row = first;
            var foldLine = this.session.getNextFoldLine(row);
            var foldStart = foldLine ? foldLine.start.row : Infinity;
            while (true) {
              if (row > foldStart) {
                row = foldLine.end.row + 1;
                foldLine = this.session.getNextFoldLine(row, foldLine);
                foldStart = foldLine ? foldLine.start.row : Infinity;
              }
              if (row > last)
                break;
              var lineElement = lineElements[lineElementsIdx++];
              if (lineElement) {
                this.dom.removeChildren(lineElement);
                this.$renderLine(lineElement, row, row == foldStart ? foldLine : false);
                if (heightChanged)
                  lineElement.style.top = this.$lines.computeLineTop(row, config, this.session) + "px";
                var height = config.lineHeight * this.session.getRowLength(row) + "px";
                if (lineElement.style.height != height) {
                  heightChanged = true;
                  lineElement.style.height = height;
                }
              }
              row++;
            }
            if (heightChanged) {
              while (lineElementsIdx < this.$lines.cells.length) {
                var cell = this.$lines.cells[lineElementsIdx++];
                cell.element.style.top = this.$lines.computeLineTop(cell.row, config, this.session) + "px";
              }
            }
          };
          Text3.prototype.scrollLines = function(config) {
            var oldConfig = this.config;
            this.config = config;
            if (this.$lines.pageChanged(oldConfig, config))
              return this.update(config);
            this.$lines.moveContainer(config);
            var lastRow = config.lastRow;
            var oldLastRow = oldConfig ? oldConfig.lastRow : -1;
            if (!oldConfig || oldLastRow < config.firstRow)
              return this.update(config);
            if (lastRow < oldConfig.firstRow)
              return this.update(config);
            if (!oldConfig || oldConfig.lastRow < config.firstRow)
              return this.update(config);
            if (config.lastRow < oldConfig.firstRow)
              return this.update(config);
            if (oldConfig.firstRow < config.firstRow)
              for (var row = this.session.getFoldedRowCount(oldConfig.firstRow, config.firstRow - 1); row > 0; row--)
                this.$lines.shift();
            if (oldConfig.lastRow > config.lastRow)
              for (var row = this.session.getFoldedRowCount(config.lastRow + 1, oldConfig.lastRow); row > 0; row--)
                this.$lines.pop();
            if (config.firstRow < oldConfig.firstRow) {
              this.$lines.unshift(this.$renderLinesFragment(config, config.firstRow, oldConfig.firstRow - 1));
            }
            if (config.lastRow > oldConfig.lastRow) {
              this.$lines.push(this.$renderLinesFragment(config, oldConfig.lastRow + 1, config.lastRow));
            }
            this.$highlightIndentGuide();
          };
          Text3.prototype.$renderLinesFragment = function(config, firstRow, lastRow) {
            var fragment = [];
            var row = firstRow;
            var foldLine = this.session.getNextFoldLine(row);
            var foldStart = foldLine ? foldLine.start.row : Infinity;
            while (true) {
              if (row > foldStart) {
                row = foldLine.end.row + 1;
                foldLine = this.session.getNextFoldLine(row, foldLine);
                foldStart = foldLine ? foldLine.start.row : Infinity;
              }
              if (row > lastRow)
                break;
              var line = this.$lines.createCell(row, config, this.session);
              var lineEl = line.element;
              this.dom.removeChildren(lineEl);
              dom.setStyle(lineEl.style, "height", this.$lines.computeLineHeight(row, config, this.session) + "px");
              dom.setStyle(lineEl.style, "top", this.$lines.computeLineTop(row, config, this.session) + "px");
              this.$renderLine(lineEl, row, row == foldStart ? foldLine : false);
              if (this.$useLineGroups()) {
                lineEl.className = "ace_line_group";
              } else {
                lineEl.className = "ace_line";
              }
              fragment.push(line);
              row++;
            }
            return fragment;
          };
          Text3.prototype.update = function(config) {
            this.$lines.moveContainer(config);
            this.config = config;
            var firstRow = config.firstRow;
            var lastRow = config.lastRow;
            var lines = this.$lines;
            while (lines.getLength())
              lines.pop();
            lines.push(this.$renderLinesFragment(config, firstRow, lastRow));
          };
          Text3.prototype.$renderToken = function(parent, screenColumn, token, value) {
            var self2 = this;
            var re2 = /(\t)|( +)|([\x00-\x1f\x80-\xa0\xad\u1680\u180E\u2000-\u200f\u2028\u2029\u202F\u205F\uFEFF\uFFF9-\uFFFC\u2066\u2067\u2068\u202A\u202B\u202D\u202E\u202C\u2069\u2060\u2061\u2062\u2063\u2064\u206A\u206B\u206B\u206C\u206D\u206E\u206F]+)|(\u3000)|([\u1100-\u115F\u11A3-\u11A7\u11FA-\u11FF\u2329-\u232A\u2E80-\u2E99\u2E9B-\u2EF3\u2F00-\u2FD5\u2FF0-\u2FFB\u3001-\u303E\u3041-\u3096\u3099-\u30FF\u3105-\u312D\u3131-\u318E\u3190-\u31BA\u31C0-\u31E3\u31F0-\u321E\u3220-\u3247\u3250-\u32FE\u3300-\u4DBF\u4E00-\uA48C\uA490-\uA4C6\uA960-\uA97C\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFAFF\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE66\uFE68-\uFE6B\uFF01-\uFF60\uFFE0-\uFFE6]|[\uD800-\uDBFF][\uDC00-\uDFFF])/g;
            var valueFragment = this.dom.createFragment(this.element);
            var m3;
            var i2 = 0;
            while (m3 = re2.exec(value)) {
              var tab = m3[1];
              var simpleSpace = m3[2];
              var controlCharacter = m3[3];
              var cjkSpace = m3[4];
              var cjk = m3[5];
              if (!self2.showSpaces && simpleSpace)
                continue;
              var before = i2 != m3.index ? value.slice(i2, m3.index) : "";
              i2 = m3.index + m3[0].length;
              if (before) {
                valueFragment.appendChild(this.dom.createTextNode(before, this.element));
              }
              if (tab) {
                var tabSize = self2.session.getScreenTabSize(screenColumn + m3.index);
                valueFragment.appendChild(self2.$tabStrings[tabSize].cloneNode(true));
                screenColumn += tabSize - 1;
              } else if (simpleSpace) {
                if (self2.showSpaces) {
                  var span = this.dom.createElement("span");
                  span.className = "ace_invisible ace_invisible_space";
                  span.textContent = lang.stringRepeat(self2.SPACE_CHAR, simpleSpace.length);
                  valueFragment.appendChild(span);
                } else {
                  valueFragment.appendChild(this.dom.createTextNode(simpleSpace, this.element));
                }
              } else if (controlCharacter) {
                var span = this.dom.createElement("span");
                span.className = "ace_invisible ace_invisible_space ace_invalid";
                span.textContent = lang.stringRepeat(self2.SPACE_CHAR, controlCharacter.length);
                valueFragment.appendChild(span);
              } else if (cjkSpace) {
                screenColumn += 1;
                var span = this.dom.createElement("span");
                span.style.width = self2.config.characterWidth * 2 + "px";
                span.className = self2.showSpaces ? "ace_cjk ace_invisible ace_invisible_space" : "ace_cjk";
                span.textContent = self2.showSpaces ? self2.SPACE_CHAR : cjkSpace;
                valueFragment.appendChild(span);
              } else if (cjk) {
                screenColumn += 1;
                var span = this.dom.createElement("span");
                span.style.width = self2.config.characterWidth * 2 + "px";
                span.className = "ace_cjk";
                span.textContent = cjk;
                valueFragment.appendChild(span);
              }
            }
            valueFragment.appendChild(this.dom.createTextNode(i2 ? value.slice(i2) : value, this.element));
            if (!isTextToken(token.type)) {
              var classes = "ace_" + token.type.replace(/\./g, " ace_");
              var span = this.dom.createElement("span");
              if (token.type == "fold") {
                span.style.width = token.value.length * this.config.characterWidth + "px";
                span.setAttribute("title", nls("inline-fold.closed.title", "Unfold code"));
              }
              span.className = classes;
              span.appendChild(valueFragment);
              parent.appendChild(span);
            } else {
              parent.appendChild(valueFragment);
            }
            return screenColumn + value.length;
          };
          Text3.prototype.renderIndentGuide = function(parent, value, max) {
            var cols = value.search(this.$indentGuideRe);
            if (cols <= 0 || cols >= max)
              return value;
            if (value[0] == " ") {
              cols -= cols % this.tabSize;
              var count = cols / this.tabSize;
              for (var i2 = 0; i2 < count; i2++) {
                parent.appendChild(this.$tabStrings[" "].cloneNode(true));
              }
              this.$highlightIndentGuide();
              return value.substr(cols);
            } else if (value[0] == "	") {
              for (var i2 = 0; i2 < cols; i2++) {
                parent.appendChild(this.$tabStrings["	"].cloneNode(true));
              }
              this.$highlightIndentGuide();
              return value.substr(cols);
            }
            this.$highlightIndentGuide();
            return value;
          };
          Text3.prototype.$highlightIndentGuide = function() {
            if (!this.$highlightIndentGuides || !this.displayIndentGuides)
              return;
            this.$highlightIndentGuideMarker = {
              indentLevel: void 0,
              start: void 0,
              end: void 0,
              dir: void 0
            };
            var lines = this.session.doc.$lines;
            if (!lines)
              return;
            var cursor = this.session.selection.getCursor();
            var initialIndent = /^\s*/.exec(this.session.doc.getLine(cursor.row))[0].length;
            var elementIndentLevel = Math.floor(initialIndent / this.tabSize);
            this.$highlightIndentGuideMarker = {
              indentLevel: elementIndentLevel,
              start: cursor.row
            };
            var bracketHighlight = this.session.$bracketHighlight;
            if (bracketHighlight) {
              var ranges = this.session.$bracketHighlight.ranges;
              for (var i2 = 0; i2 < ranges.length; i2++) {
                if (cursor.row !== ranges[i2].start.row) {
                  this.$highlightIndentGuideMarker.end = ranges[i2].start.row + 1;
                  if (cursor.row > ranges[i2].start.row) {
                    this.$highlightIndentGuideMarker.dir = -1;
                  } else {
                    this.$highlightIndentGuideMarker.dir = 1;
                  }
                  break;
                }
              }
            }
            if (!this.$highlightIndentGuideMarker.end) {
              if (lines[cursor.row] !== "" && cursor.column === lines[cursor.row].length) {
                this.$highlightIndentGuideMarker.dir = 1;
                for (var i2 = cursor.row + 1; i2 < lines.length; i2++) {
                  var line = lines[i2];
                  var currentIndent = /^\s*/.exec(line)[0].length;
                  if (line !== "") {
                    this.$highlightIndentGuideMarker.end = i2;
                    if (currentIndent <= initialIndent)
                      break;
                  }
                }
              }
            }
            this.$renderHighlightIndentGuide();
          };
          Text3.prototype.$clearActiveIndentGuide = function() {
            var activeIndentGuides = this.element.querySelectorAll(".ace_indent-guide-active");
            activeIndentGuides.forEach(function(el) {
              el.classList.remove("ace_indent-guide-active");
            });
          };
          Text3.prototype.$setIndentGuideActive = function(cell, indentLevel) {
            var line = this.session.doc.getLine(cell.row);
            if (line !== "") {
              var element = cell.element;
              if (cell.element.classList && cell.element.classList.contains("ace_line_group")) {
                if (cell.element.childNodes.length > 0) {
                  element = cell.element.childNodes[0];
                } else {
                  return;
                }
              }
              var childNodes = element.childNodes;
              if (childNodes) {
                var node = childNodes[indentLevel - 1];
                if (node && node.classList && node.classList.contains("ace_indent-guide"))
                  node.classList.add("ace_indent-guide-active");
              }
            }
          };
          Text3.prototype.$renderHighlightIndentGuide = function() {
            if (!this.$lines)
              return;
            var cells = this.$lines.cells;
            this.$clearActiveIndentGuide();
            var indentLevel = this.$highlightIndentGuideMarker.indentLevel;
            if (indentLevel !== 0) {
              if (this.$highlightIndentGuideMarker.dir === 1) {
                for (var i2 = 0; i2 < cells.length; i2++) {
                  var cell = cells[i2];
                  if (this.$highlightIndentGuideMarker.end && cell.row >= this.$highlightIndentGuideMarker.start + 1) {
                    if (cell.row >= this.$highlightIndentGuideMarker.end)
                      break;
                    this.$setIndentGuideActive(cell, indentLevel);
                  }
                }
              } else {
                for (var i2 = cells.length - 1; i2 >= 0; i2--) {
                  var cell = cells[i2];
                  if (this.$highlightIndentGuideMarker.end && cell.row < this.$highlightIndentGuideMarker.start) {
                    if (cell.row < this.$highlightIndentGuideMarker.end)
                      break;
                    this.$setIndentGuideActive(cell, indentLevel);
                  }
                }
              }
            }
          };
          Text3.prototype.$createLineElement = function(parent) {
            var lineEl = this.dom.createElement("div");
            lineEl.className = "ace_line";
            lineEl.style.height = this.config.lineHeight + "px";
            return lineEl;
          };
          Text3.prototype.$renderWrappedLine = function(parent, tokens, splits) {
            var chars = 0;
            var split2 = 0;
            var splitChars = splits[0];
            var screenColumn = 0;
            var lineEl = this.$createLineElement();
            parent.appendChild(lineEl);
            for (var i2 = 0; i2 < tokens.length; i2++) {
              var token = tokens[i2];
              var value = token.value;
              if (i2 == 0 && this.displayIndentGuides) {
                chars = value.length;
                value = this.renderIndentGuide(lineEl, value, splitChars);
                if (!value)
                  continue;
                chars -= value.length;
              }
              if (chars + value.length < splitChars) {
                screenColumn = this.$renderToken(lineEl, screenColumn, token, value);
                chars += value.length;
              } else {
                while (chars + value.length >= splitChars) {
                  screenColumn = this.$renderToken(lineEl, screenColumn, token, value.substring(0, splitChars - chars));
                  value = value.substring(splitChars - chars);
                  chars = splitChars;
                  lineEl = this.$createLineElement();
                  parent.appendChild(lineEl);
                  lineEl.appendChild(this.dom.createTextNode(lang.stringRepeat("", splits.indent), this.element));
                  split2++;
                  screenColumn = 0;
                  splitChars = splits[split2] || Number.MAX_VALUE;
                }
                if (value.length != 0) {
                  chars += value.length;
                  screenColumn = this.$renderToken(lineEl, screenColumn, token, value);
                }
              }
            }
            if (splits[splits.length - 1] > this.MAX_LINE_LENGTH)
              this.$renderOverflowMessage(lineEl, screenColumn, null, "", true);
          };
          Text3.prototype.$renderSimpleLine = function(parent, tokens) {
            var screenColumn = 0;
            for (var i2 = 0; i2 < tokens.length; i2++) {
              var token = tokens[i2];
              var value = token.value;
              if (i2 == 0 && this.displayIndentGuides) {
                value = this.renderIndentGuide(parent, value);
                if (!value)
                  continue;
              }
              if (screenColumn + value.length > this.MAX_LINE_LENGTH)
                return this.$renderOverflowMessage(parent, screenColumn, token, value);
              screenColumn = this.$renderToken(parent, screenColumn, token, value);
            }
          };
          Text3.prototype.$renderOverflowMessage = function(parent, screenColumn, token, value, hide) {
            token && this.$renderToken(parent, screenColumn, token, value.slice(0, this.MAX_LINE_LENGTH - screenColumn));
            var overflowEl = this.dom.createElement("span");
            overflowEl.className = "ace_inline_button ace_keyword ace_toggle_wrap";
            overflowEl.textContent = hide ? "<hide>" : "<click to see more...>";
            parent.appendChild(overflowEl);
          };
          Text3.prototype.$renderLine = function(parent, row, foldLine) {
            if (!foldLine && foldLine != false)
              foldLine = this.session.getFoldLine(row);
            if (foldLine)
              var tokens = this.$getFoldLineTokens(row, foldLine);
            else
              var tokens = this.session.getTokens(row);
            var lastLineEl = parent;
            if (tokens.length) {
              var splits = this.session.getRowSplitData(row);
              if (splits && splits.length) {
                this.$renderWrappedLine(parent, tokens, splits);
                var lastLineEl = parent.lastChild;
              } else {
                var lastLineEl = parent;
                if (this.$useLineGroups()) {
                  lastLineEl = this.$createLineElement();
                  parent.appendChild(lastLineEl);
                }
                this.$renderSimpleLine(lastLineEl, tokens);
              }
            } else if (this.$useLineGroups()) {
              lastLineEl = this.$createLineElement();
              parent.appendChild(lastLineEl);
            }
            if (this.showEOL && lastLineEl) {
              if (foldLine)
                row = foldLine.end.row;
              var invisibleEl = this.dom.createElement("span");
              invisibleEl.className = "ace_invisible ace_invisible_eol";
              invisibleEl.textContent = row == this.session.getLength() - 1 ? this.EOF_CHAR : this.EOL_CHAR;
              lastLineEl.appendChild(invisibleEl);
            }
          };
          Text3.prototype.$getFoldLineTokens = function(row, foldLine) {
            var session = this.session;
            var renderTokens = [];
            function addTokens(tokens2, from, to) {
              var idx = 0, col = 0;
              while (col + tokens2[idx].value.length < from) {
                col += tokens2[idx].value.length;
                idx++;
                if (idx == tokens2.length)
                  return;
              }
              if (col != from) {
                var value = tokens2[idx].value.substring(from - col);
                if (value.length > to - from)
                  value = value.substring(0, to - from);
                renderTokens.push({
                  type: tokens2[idx].type,
                  value
                });
                col = from + value.length;
                idx += 1;
              }
              while (col < to && idx < tokens2.length) {
                var value = tokens2[idx].value;
                if (value.length + col > to) {
                  renderTokens.push({
                    type: tokens2[idx].type,
                    value: value.substring(0, to - col)
                  });
                } else
                  renderTokens.push(tokens2[idx]);
                col += value.length;
                idx += 1;
              }
            }
            var tokens = session.getTokens(row);
            foldLine.walk(function(placeholder, row2, column, lastColumn, isNewRow) {
              if (placeholder != null) {
                renderTokens.push({
                  type: "fold",
                  value: placeholder
                });
              } else {
                if (isNewRow)
                  tokens = session.getTokens(row2);
                if (tokens.length)
                  addTokens(tokens, lastColumn, column);
              }
            }, foldLine.end.row, this.session.getLine(foldLine.end.row).length);
            return renderTokens;
          };
          Text3.prototype.$useLineGroups = function() {
            return this.session.getUseWrapMode();
          };
          return Text3;
        })()
      );
      Text2.prototype.EOF_CHAR = "";
      Text2.prototype.EOL_CHAR_LF = "";
      Text2.prototype.EOL_CHAR_CRLF = "";
      Text2.prototype.EOL_CHAR = Text2.prototype.EOL_CHAR_LF;
      Text2.prototype.TAB_CHAR = "";
      Text2.prototype.SPACE_CHAR = "";
      Text2.prototype.$padding = 0;
      Text2.prototype.MAX_LINE_LENGTH = 1e4;
      Text2.prototype.showInvisibles = false;
      Text2.prototype.showSpaces = false;
      Text2.prototype.showTabs = false;
      Text2.prototype.showEOL = false;
      Text2.prototype.displayIndentGuides = true;
      Text2.prototype.$highlightIndentGuides = true;
      Text2.prototype.$tabStrings = [];
      Text2.prototype.destroy = {};
      Text2.prototype.onChangeTabSize = Text2.prototype.$computeTabString;
      oop.implement(Text2.prototype, EventEmitter);
      exports3.Text = Text2;
    });
    ace.define("ace/layer/cursor", ["require", "exports", "module", "ace/lib/dom"], function(require2, exports3, module3) {
      var dom = require2("../lib/dom");
      var Cursor = (
        /** @class */
        (function() {
          function Cursor2(parentEl) {
            this.element = dom.createElement("div");
            this.element.className = "ace_layer ace_cursor-layer";
            parentEl.appendChild(this.element);
            this.isVisible = false;
            this.isBlinking = true;
            this.blinkInterval = 1e3;
            this.smoothBlinking = false;
            this.cursors = [];
            this.cursor = this.addCursor();
            dom.addCssClass(this.element, "ace_hidden-cursors");
            this.$updateCursors = this.$updateOpacity.bind(this);
          }
          Cursor2.prototype.$updateOpacity = function(val) {
            var cursors = this.cursors;
            for (var i2 = cursors.length; i2--; )
              dom.setStyle(cursors[i2].style, "opacity", val ? "" : "0");
          };
          Cursor2.prototype.$startCssAnimation = function() {
            var cursors = this.cursors;
            for (var i2 = cursors.length; i2--; )
              cursors[i2].style.animationDuration = this.blinkInterval + "ms";
            this.$isAnimating = true;
            setTimeout((function() {
              if (this.$isAnimating) {
                dom.addCssClass(this.element, "ace_animate-blinking");
              }
            }).bind(this));
          };
          Cursor2.prototype.$stopCssAnimation = function() {
            this.$isAnimating = false;
            dom.removeCssClass(this.element, "ace_animate-blinking");
          };
          Cursor2.prototype.setPadding = function(padding) {
            this.$padding = padding;
          };
          Cursor2.prototype.setSession = function(session) {
            this.session = session;
          };
          Cursor2.prototype.setBlinking = function(blinking) {
            if (blinking != this.isBlinking) {
              this.isBlinking = blinking;
              this.restartTimer();
            }
          };
          Cursor2.prototype.setBlinkInterval = function(blinkInterval) {
            if (blinkInterval != this.blinkInterval) {
              this.blinkInterval = blinkInterval;
              this.restartTimer();
            }
          };
          Cursor2.prototype.setSmoothBlinking = function(smoothBlinking) {
            if (smoothBlinking != this.smoothBlinking) {
              this.smoothBlinking = smoothBlinking;
              dom.setCssClass(this.element, "ace_smooth-blinking", smoothBlinking);
              this.$updateCursors(true);
              this.restartTimer();
            }
          };
          Cursor2.prototype.addCursor = function() {
            var el = dom.createElement("div");
            el.className = "ace_cursor";
            this.element.appendChild(el);
            this.cursors.push(el);
            return el;
          };
          Cursor2.prototype.removeCursor = function() {
            if (this.cursors.length > 1) {
              var el = this.cursors.pop();
              el.parentNode.removeChild(el);
              return el;
            }
          };
          Cursor2.prototype.hideCursor = function() {
            this.isVisible = false;
            dom.addCssClass(this.element, "ace_hidden-cursors");
            this.restartTimer();
          };
          Cursor2.prototype.showCursor = function() {
            this.isVisible = true;
            dom.removeCssClass(this.element, "ace_hidden-cursors");
            this.restartTimer();
          };
          Cursor2.prototype.restartTimer = function() {
            var update = this.$updateCursors;
            clearInterval(this.intervalId);
            clearTimeout(this.timeoutId);
            this.$stopCssAnimation();
            if (this.smoothBlinking) {
              this.$isSmoothBlinking = false;
              dom.removeCssClass(this.element, "ace_smooth-blinking");
            }
            update(true);
            if (!this.isBlinking || !this.blinkInterval || !this.isVisible) {
              this.$stopCssAnimation();
              return;
            }
            if (this.smoothBlinking) {
              this.$isSmoothBlinking = true;
              setTimeout((function() {
                if (this.$isSmoothBlinking) {
                  dom.addCssClass(this.element, "ace_smooth-blinking");
                }
              }).bind(this));
            }
            if (dom.HAS_CSS_ANIMATION) {
              this.$startCssAnimation();
            } else {
              var blink = (
                /**@this{Cursor}*/
                (function() {
                  this.timeoutId = setTimeout(function() {
                    update(false);
                  }, 0.6 * this.blinkInterval);
                }).bind(this)
              );
              this.intervalId = setInterval(function() {
                update(true);
                blink();
              }, this.blinkInterval);
              blink();
            }
          };
          Cursor2.prototype.getPixelPosition = function(position, onScreen) {
            if (!this.config || !this.session)
              return { left: 0, top: 0 };
            if (!position)
              position = this.session.selection.getCursor();
            var pos = this.session.documentToScreenPosition(position);
            var cursorLeft = this.$padding + (this.session.$bidiHandler.isBidiRow(pos.row, position.row) ? this.session.$bidiHandler.getPosLeft(pos.column) : pos.column * this.config.characterWidth);
            var cursorTop = (pos.row - (onScreen ? this.config.firstRowScreen : 0)) * this.config.lineHeight;
            return { left: cursorLeft, top: cursorTop };
          };
          Cursor2.prototype.isCursorInView = function(pixelPos, config) {
            return pixelPos.top >= 0 && pixelPos.top < config.maxHeight;
          };
          Cursor2.prototype.update = function(config) {
            this.config = config;
            var selections = this.session.$selectionMarkers;
            var i2 = 0, cursorIndex = 0;
            if (selections === void 0 || selections.length === 0) {
              selections = [{ cursor: null }];
            }
            for (var i2 = 0, n = selections.length; i2 < n; i2++) {
              var pixelPos = this.getPixelPosition(selections[i2].cursor, true);
              if ((pixelPos.top > config.height + config.offset || pixelPos.top < 0) && i2 > 1) {
                continue;
              }
              var element = this.cursors[cursorIndex++] || this.addCursor();
              var style = element.style;
              if (!this.drawCursor) {
                if (!this.isCursorInView(pixelPos, config)) {
                  dom.setStyle(style, "display", "none");
                } else {
                  dom.setStyle(style, "display", "block");
                  dom.translate(element, pixelPos.left, pixelPos.top);
                  dom.setStyle(style, "width", Math.round(config.characterWidth) + "px");
                  dom.setStyle(style, "height", config.lineHeight + "px");
                }
              } else {
                this.drawCursor(element, pixelPos, config, selections[i2], this.session);
              }
            }
            while (this.cursors.length > cursorIndex)
              this.removeCursor();
            var overwrite = this.session.getOverwrite();
            this.$setOverwrite(overwrite);
            this.$pixelPos = pixelPos;
            this.restartTimer();
          };
          Cursor2.prototype.$setOverwrite = function(overwrite) {
            if (overwrite != this.overwrite) {
              this.overwrite = overwrite;
              if (overwrite)
                dom.addCssClass(this.element, "ace_overwrite-cursors");
              else
                dom.removeCssClass(this.element, "ace_overwrite-cursors");
            }
          };
          Cursor2.prototype.destroy = function() {
            clearInterval(this.intervalId);
            clearTimeout(this.timeoutId);
          };
          return Cursor2;
        })()
      );
      Cursor.prototype.$padding = 0;
      Cursor.prototype.drawCursor = null;
      exports3.Cursor = Cursor;
    });
    ace.define("ace/scrollbar", ["require", "exports", "module", "ace/lib/oop", "ace/lib/dom", "ace/lib/event", "ace/lib/event_emitter"], function(require2, exports3, module3) {
      var __extends = this && this.__extends || /* @__PURE__ */ (function() {
        var extendStatics = function(d3, b2) {
          extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d4, b3) {
            d4.__proto__ = b3;
          } || function(d4, b3) {
            for (var p in b3) if (Object.prototype.hasOwnProperty.call(b3, p)) d4[p] = b3[p];
          };
          return extendStatics(d3, b2);
        };
        return function(d3, b2) {
          if (typeof b2 !== "function" && b2 !== null)
            throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
          extendStatics(d3, b2);
          function __() {
            this.constructor = d3;
          }
          d3.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
        };
      })();
      var oop = require2("./lib/oop");
      var dom = require2("./lib/dom");
      var event = require2("./lib/event");
      var EventEmitter = require2("./lib/event_emitter").EventEmitter;
      var MAX_SCROLL_H = 32768;
      var Scrollbar = (
        /** @class */
        (function() {
          function Scrollbar2(parent, classSuffix) {
            this.element = dom.createElement("div");
            this.element.className = "ace_scrollbar ace_scrollbar" + classSuffix;
            this.inner = dom.createElement("div");
            this.inner.className = "ace_scrollbar-inner";
            this.inner.textContent = "";
            this.element.appendChild(this.inner);
            parent.appendChild(this.element);
            this.setVisible(false);
            this.skipEvent = false;
            event.addListener(this.element, "scroll", this.onScroll.bind(this));
            event.addListener(this.element, "mousedown", event.preventDefault);
          }
          Scrollbar2.prototype.setVisible = function(isVisible) {
            this.element.style.display = isVisible ? "" : "none";
            this.isVisible = isVisible;
            this.coeff = 1;
          };
          return Scrollbar2;
        })()
      );
      oop.implement(Scrollbar.prototype, EventEmitter);
      var VScrollBar = (
        /** @class */
        (function(_super) {
          __extends(VScrollBar2, _super);
          function VScrollBar2(parent, renderer) {
            var _this = _super.call(this, parent, "-v") || this;
            _this.scrollTop = 0;
            _this.scrollHeight = 0;
            renderer.$scrollbarWidth = _this.width = dom.scrollbarWidth(parent.ownerDocument);
            _this.inner.style.width = _this.element.style.width = (_this.width || 15) + 5 + "px";
            _this.$minWidth = 0;
            return _this;
          }
          VScrollBar2.prototype.onScroll = function() {
            if (!this.skipEvent) {
              this.scrollTop = this.element.scrollTop;
              if (this.coeff != 1) {
                var h3 = this.element.clientHeight / this.scrollHeight;
                this.scrollTop = this.scrollTop * (1 - h3) / (this.coeff - h3);
              }
              this._emit("scroll", { data: this.scrollTop });
            }
            this.skipEvent = false;
          };
          VScrollBar2.prototype.getWidth = function() {
            return Math.max(this.isVisible ? this.width : 0, this.$minWidth || 0);
          };
          VScrollBar2.prototype.setHeight = function(height) {
            this.element.style.height = height + "px";
          };
          VScrollBar2.prototype.setScrollHeight = function(height) {
            this.scrollHeight = height;
            if (height > MAX_SCROLL_H) {
              this.coeff = MAX_SCROLL_H / height;
              height = MAX_SCROLL_H;
            } else if (this.coeff != 1) {
              this.coeff = 1;
            }
            this.inner.style.height = height + "px";
          };
          VScrollBar2.prototype.setScrollTop = function(scrollTop) {
            if (this.scrollTop != scrollTop) {
              this.skipEvent = true;
              this.scrollTop = scrollTop;
              this.element.scrollTop = scrollTop * this.coeff;
            }
          };
          return VScrollBar2;
        })(Scrollbar)
      );
      VScrollBar.prototype.setInnerHeight = VScrollBar.prototype.setScrollHeight;
      var HScrollBar = (
        /** @class */
        (function(_super) {
          __extends(HScrollBar2, _super);
          function HScrollBar2(parent, renderer) {
            var _this = _super.call(this, parent, "-h") || this;
            _this.scrollLeft = 0;
            _this.height = renderer.$scrollbarWidth;
            _this.inner.style.height = _this.element.style.height = (_this.height || 15) + 5 + "px";
            return _this;
          }
          HScrollBar2.prototype.onScroll = function() {
            if (!this.skipEvent) {
              this.scrollLeft = this.element.scrollLeft;
              this._emit("scroll", { data: this.scrollLeft });
            }
            this.skipEvent = false;
          };
          HScrollBar2.prototype.getHeight = function() {
            return this.isVisible ? this.height : 0;
          };
          HScrollBar2.prototype.setWidth = function(width) {
            this.element.style.width = width + "px";
          };
          HScrollBar2.prototype.setInnerWidth = function(width) {
            this.inner.style.width = width + "px";
          };
          HScrollBar2.prototype.setScrollWidth = function(width) {
            this.inner.style.width = width + "px";
          };
          HScrollBar2.prototype.setScrollLeft = function(scrollLeft) {
            if (this.scrollLeft != scrollLeft) {
              this.skipEvent = true;
              this.scrollLeft = this.element.scrollLeft = scrollLeft;
            }
          };
          return HScrollBar2;
        })(Scrollbar)
      );
      exports3.ScrollBar = VScrollBar;
      exports3.ScrollBarV = VScrollBar;
      exports3.ScrollBarH = HScrollBar;
      exports3.VScrollBar = VScrollBar;
      exports3.HScrollBar = HScrollBar;
    });
    ace.define("ace/scrollbar_custom", ["require", "exports", "module", "ace/lib/oop", "ace/lib/dom", "ace/lib/event", "ace/lib/event_emitter"], function(require2, exports3, module3) {
      var __extends = this && this.__extends || /* @__PURE__ */ (function() {
        var extendStatics = function(d3, b2) {
          extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d4, b3) {
            d4.__proto__ = b3;
          } || function(d4, b3) {
            for (var p in b3) if (Object.prototype.hasOwnProperty.call(b3, p)) d4[p] = b3[p];
          };
          return extendStatics(d3, b2);
        };
        return function(d3, b2) {
          if (typeof b2 !== "function" && b2 !== null)
            throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
          extendStatics(d3, b2);
          function __() {
            this.constructor = d3;
          }
          d3.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
        };
      })();
      var oop = require2("./lib/oop");
      var dom = require2("./lib/dom");
      var event = require2("./lib/event");
      var EventEmitter = require2("./lib/event_emitter").EventEmitter;
      dom.importCssString(".ace_editor>.ace_sb-v div, .ace_editor>.ace_sb-h div{\n  position: absolute;\n  background: rgba(128, 128, 128, 0.6);\n  -moz-box-sizing: border-box;\n  box-sizing: border-box;\n  border: 1px solid #bbb;\n  border-radius: 2px;\n  z-index: 8;\n}\n.ace_editor>.ace_sb-v, .ace_editor>.ace_sb-h {\n  position: absolute;\n  z-index: 6;\n  background: none;\n  overflow: hidden!important;\n}\n.ace_editor>.ace_sb-v {\n  z-index: 6;\n  right: 0;\n  top: 0;\n  width: 12px;\n}\n.ace_editor>.ace_sb-v div {\n  z-index: 8;\n  right: 0;\n  width: 100%;\n}\n.ace_editor>.ace_sb-h {\n  bottom: 0;\n  left: 0;\n  height: 12px;\n}\n.ace_editor>.ace_sb-h div {\n  bottom: 0;\n  height: 100%;\n}\n.ace_editor>.ace_sb_grabbed {\n  z-index: 8;\n  background: #000;\n}", "ace_scrollbar.css", false);
      var ScrollBar = (
        /** @class */
        (function() {
          function ScrollBar2(parent, classSuffix) {
            this.element = dom.createElement("div");
            this.element.className = "ace_sb" + classSuffix;
            this.inner = dom.createElement("div");
            this.inner.className = "";
            this.element.appendChild(this.inner);
            this.VScrollWidth = 12;
            this.HScrollHeight = 12;
            parent.appendChild(this.element);
            this.setVisible(false);
            this.skipEvent = false;
            event.addMultiMouseDownListener(this.element, [500, 300, 300], this, "onMouseDown");
          }
          ScrollBar2.prototype.setVisible = function(isVisible) {
            this.element.style.display = isVisible ? "" : "none";
            this.isVisible = isVisible;
            this.coeff = 1;
          };
          return ScrollBar2;
        })()
      );
      oop.implement(ScrollBar.prototype, EventEmitter);
      var VScrollBar = (
        /** @class */
        (function(_super) {
          __extends(VScrollBar2, _super);
          function VScrollBar2(parent, renderer) {
            var _this = _super.call(this, parent, "-v") || this;
            _this.scrollTop = 0;
            _this.scrollHeight = 0;
            _this.parent = parent;
            _this.width = _this.VScrollWidth;
            _this.renderer = renderer;
            _this.inner.style.width = _this.element.style.width = (_this.width || 15) + "px";
            _this.$minWidth = 0;
            return _this;
          }
          VScrollBar2.prototype.onMouseDown = function(eType, e2) {
            if (eType !== "mousedown")
              return;
            if (event.getButton(e2) !== 0 || e2.detail === 2) {
              return;
            }
            if (e2.target === this.inner) {
              var self2 = this;
              var mousePageY = e2.clientY;
              var onMouseMove = function(e3) {
                mousePageY = e3.clientY;
              };
              var onMouseUp = function() {
                clearInterval(timerId);
              };
              var startY = e2.clientY;
              var startTop = this.thumbTop;
              var onScrollInterval = function() {
                if (mousePageY === void 0)
                  return;
                var scrollTop = self2.scrollTopFromThumbTop(startTop + mousePageY - startY);
                if (scrollTop === self2.scrollTop)
                  return;
                self2._emit("scroll", { data: scrollTop });
              };
              event.capture(this.inner, onMouseMove, onMouseUp);
              var timerId = setInterval(onScrollInterval, 20);
              return event.preventDefault(e2);
            }
            var top = e2.clientY - this.element.getBoundingClientRect().top - this.thumbHeight / 2;
            this._emit("scroll", { data: this.scrollTopFromThumbTop(top) });
            return event.preventDefault(e2);
          };
          VScrollBar2.prototype.getHeight = function() {
            return this.height;
          };
          VScrollBar2.prototype.scrollTopFromThumbTop = function(thumbTop) {
            var scrollTop = thumbTop * (this.pageHeight - this.viewHeight) / (this.slideHeight - this.thumbHeight);
            scrollTop = scrollTop >> 0;
            if (scrollTop < 0) {
              scrollTop = 0;
            } else if (scrollTop > this.pageHeight - this.viewHeight) {
              scrollTop = this.pageHeight - this.viewHeight;
            }
            return scrollTop;
          };
          VScrollBar2.prototype.getWidth = function() {
            return Math.max(this.isVisible ? this.width : 0, this.$minWidth || 0);
          };
          VScrollBar2.prototype.setHeight = function(height) {
            this.height = Math.max(0, height);
            this.slideHeight = this.height;
            this.viewHeight = this.height;
            this.setScrollHeight(this.pageHeight, true);
          };
          VScrollBar2.prototype.setScrollHeight = function(height, force) {
            if (this.pageHeight === height && !force)
              return;
            this.pageHeight = height;
            this.thumbHeight = this.slideHeight * this.viewHeight / this.pageHeight;
            if (this.thumbHeight > this.slideHeight)
              this.thumbHeight = this.slideHeight;
            if (this.thumbHeight < 15)
              this.thumbHeight = 15;
            this.inner.style.height = this.thumbHeight + "px";
            if (this.scrollTop > this.pageHeight - this.viewHeight) {
              this.scrollTop = this.pageHeight - this.viewHeight;
              if (this.scrollTop < 0)
                this.scrollTop = 0;
              this._emit("scroll", { data: this.scrollTop });
            }
          };
          VScrollBar2.prototype.setScrollTop = function(scrollTop) {
            this.scrollTop = scrollTop;
            if (scrollTop < 0)
              scrollTop = 0;
            this.thumbTop = scrollTop * (this.slideHeight - this.thumbHeight) / (this.pageHeight - this.viewHeight);
            this.inner.style.top = this.thumbTop + "px";
          };
          return VScrollBar2;
        })(ScrollBar)
      );
      VScrollBar.prototype.setInnerHeight = VScrollBar.prototype.setScrollHeight;
      var HScrollBar = (
        /** @class */
        (function(_super) {
          __extends(HScrollBar2, _super);
          function HScrollBar2(parent, renderer) {
            var _this = _super.call(this, parent, "-h") || this;
            _this.scrollLeft = 0;
            _this.scrollWidth = 0;
            _this.height = _this.HScrollHeight;
            _this.inner.style.height = _this.element.style.height = (_this.height || 12) + "px";
            _this.renderer = renderer;
            return _this;
          }
          HScrollBar2.prototype.onMouseDown = function(eType, e2) {
            if (eType !== "mousedown")
              return;
            if (event.getButton(e2) !== 0 || e2.detail === 2) {
              return;
            }
            if (e2.target === this.inner) {
              var self2 = this;
              var mousePageX = e2.clientX;
              var onMouseMove = function(e3) {
                mousePageX = e3.clientX;
              };
              var onMouseUp = function() {
                clearInterval(timerId);
              };
              var startX = e2.clientX;
              var startLeft = this.thumbLeft;
              var onScrollInterval = function() {
                if (mousePageX === void 0)
                  return;
                var scrollLeft = self2.scrollLeftFromThumbLeft(startLeft + mousePageX - startX);
                if (scrollLeft === self2.scrollLeft)
                  return;
                self2._emit("scroll", { data: scrollLeft });
              };
              event.capture(this.inner, onMouseMove, onMouseUp);
              var timerId = setInterval(onScrollInterval, 20);
              return event.preventDefault(e2);
            }
            var left = e2.clientX - this.element.getBoundingClientRect().left - this.thumbWidth / 2;
            this._emit("scroll", { data: this.scrollLeftFromThumbLeft(left) });
            return event.preventDefault(e2);
          };
          HScrollBar2.prototype.getHeight = function() {
            return this.isVisible ? this.height : 0;
          };
          HScrollBar2.prototype.scrollLeftFromThumbLeft = function(thumbLeft) {
            var scrollLeft = thumbLeft * (this.pageWidth - this.viewWidth) / (this.slideWidth - this.thumbWidth);
            scrollLeft = scrollLeft >> 0;
            if (scrollLeft < 0) {
              scrollLeft = 0;
            } else if (scrollLeft > this.pageWidth - this.viewWidth) {
              scrollLeft = this.pageWidth - this.viewWidth;
            }
            return scrollLeft;
          };
          HScrollBar2.prototype.setWidth = function(width) {
            this.width = Math.max(0, width);
            this.element.style.width = this.width + "px";
            this.slideWidth = this.width;
            this.viewWidth = this.width;
            this.setScrollWidth(this.pageWidth, true);
          };
          HScrollBar2.prototype.setScrollWidth = function(width, force) {
            if (this.pageWidth === width && !force)
              return;
            this.pageWidth = width;
            this.thumbWidth = this.slideWidth * this.viewWidth / this.pageWidth;
            if (this.thumbWidth > this.slideWidth)
              this.thumbWidth = this.slideWidth;
            if (this.thumbWidth < 15)
              this.thumbWidth = 15;
            this.inner.style.width = this.thumbWidth + "px";
            if (this.scrollLeft > this.pageWidth - this.viewWidth) {
              this.scrollLeft = this.pageWidth - this.viewWidth;
              if (this.scrollLeft < 0)
                this.scrollLeft = 0;
              this._emit("scroll", { data: this.scrollLeft });
            }
          };
          HScrollBar2.prototype.setScrollLeft = function(scrollLeft) {
            this.scrollLeft = scrollLeft;
            if (scrollLeft < 0)
              scrollLeft = 0;
            this.thumbLeft = scrollLeft * (this.slideWidth - this.thumbWidth) / (this.pageWidth - this.viewWidth);
            this.inner.style.left = this.thumbLeft + "px";
          };
          return HScrollBar2;
        })(ScrollBar)
      );
      HScrollBar.prototype.setInnerWidth = HScrollBar.prototype.setScrollWidth;
      exports3.ScrollBar = VScrollBar;
      exports3.ScrollBarV = VScrollBar;
      exports3.ScrollBarH = HScrollBar;
      exports3.VScrollBar = VScrollBar;
      exports3.HScrollBar = HScrollBar;
    });
    ace.define("ace/renderloop", ["require", "exports", "module", "ace/lib/event"], function(require2, exports3, module3) {
      var event = require2("./lib/event");
      var RenderLoop = (
        /** @class */
        (function() {
          function RenderLoop2(onRender, win) {
            this.onRender = onRender;
            this.pending = false;
            this.changes = 0;
            this.$recursionLimit = 2;
            this.window = win || window;
            var _self = this;
            this._flush = function(ts) {
              _self.pending = false;
              var changes = _self.changes;
              if (changes) {
                event.blockIdle(100);
                _self.changes = 0;
                _self.onRender(changes);
              }
              if (_self.changes) {
                if (_self.$recursionLimit-- < 0)
                  return;
                _self.schedule();
              } else {
                _self.$recursionLimit = 2;
              }
            };
          }
          RenderLoop2.prototype.schedule = function(change) {
            this.changes = this.changes | change;
            if (this.changes && !this.pending) {
              event.nextFrame(this._flush);
              this.pending = true;
            }
          };
          RenderLoop2.prototype.clear = function(change) {
            var changes = this.changes;
            this.changes = 0;
            return changes;
          };
          return RenderLoop2;
        })()
      );
      exports3.RenderLoop = RenderLoop;
    });
    ace.define("ace/layer/font_metrics", ["require", "exports", "module", "ace/lib/oop", "ace/lib/dom", "ace/lib/lang", "ace/lib/event", "ace/lib/useragent", "ace/lib/event_emitter"], function(require2, exports3, module3) {
      var oop = require2("../lib/oop");
      var dom = require2("../lib/dom");
      var lang = require2("../lib/lang");
      var event = require2("../lib/event");
      var useragent = require2("../lib/useragent");
      var EventEmitter = require2("../lib/event_emitter").EventEmitter;
      var CHAR_COUNT = 512;
      var USE_OBSERVER = typeof ResizeObserver == "function";
      var L2 = 200;
      var FontMetrics = (
        /** @class */
        (function() {
          function FontMetrics2(parentEl) {
            this.el = dom.createElement("div");
            this.$setMeasureNodeStyles(this.el.style, true);
            this.$main = dom.createElement("div");
            this.$setMeasureNodeStyles(this.$main.style);
            this.$measureNode = dom.createElement("div");
            this.$setMeasureNodeStyles(this.$measureNode.style);
            this.el.appendChild(this.$main);
            this.el.appendChild(this.$measureNode);
            parentEl.appendChild(this.el);
            this.$measureNode.textContent = lang.stringRepeat("X", CHAR_COUNT);
            this.$characterSize = { width: 0, height: 0 };
            if (USE_OBSERVER)
              this.$addObserver();
            else
              this.checkForSizeChanges();
          }
          FontMetrics2.prototype.$setMeasureNodeStyles = function(style, isRoot) {
            style.width = style.height = "auto";
            style.left = style.top = "0px";
            style.visibility = "hidden";
            style.position = "absolute";
            style.whiteSpace = "pre";
            if (useragent.isIE < 8) {
              style["font-family"] = "inherit";
            } else {
              style.font = "inherit";
            }
            style.overflow = isRoot ? "hidden" : "visible";
          };
          FontMetrics2.prototype.checkForSizeChanges = function(size) {
            if (size === void 0)
              size = this.$measureSizes();
            if (size && (this.$characterSize.width !== size.width || this.$characterSize.height !== size.height)) {
              this.$measureNode.style.fontWeight = "bold";
              var boldSize = this.$measureSizes();
              this.$measureNode.style.fontWeight = "";
              this.$characterSize = size;
              this.charSizes = /* @__PURE__ */ Object.create(null);
              this.allowBoldFonts = boldSize && boldSize.width === size.width && boldSize.height === size.height;
              this._emit("changeCharacterSize", { data: size });
            }
          };
          FontMetrics2.prototype.$addObserver = function() {
            var self2 = this;
            this.$observer = new window.ResizeObserver(function(e2) {
              self2.checkForSizeChanges();
            });
            this.$observer.observe(this.$measureNode);
          };
          FontMetrics2.prototype.$pollSizeChanges = function() {
            if (this.$pollSizeChangesTimer || this.$observer)
              return this.$pollSizeChangesTimer;
            var self2 = this;
            return this.$pollSizeChangesTimer = event.onIdle(function cb() {
              self2.checkForSizeChanges();
              event.onIdle(cb, 500);
            }, 500);
          };
          FontMetrics2.prototype.setPolling = function(val) {
            if (val) {
              this.$pollSizeChanges();
            } else if (this.$pollSizeChangesTimer) {
              clearInterval(this.$pollSizeChangesTimer);
              this.$pollSizeChangesTimer = 0;
            }
          };
          FontMetrics2.prototype.$measureSizes = function(node) {
            var size = {
              height: (node || this.$measureNode).clientHeight,
              width: (node || this.$measureNode).clientWidth / CHAR_COUNT
            };
            if (size.width === 0 || size.height === 0)
              return null;
            return size;
          };
          FontMetrics2.prototype.$measureCharWidth = function(ch) {
            this.$main.textContent = lang.stringRepeat(ch, CHAR_COUNT);
            var rect = this.$main.getBoundingClientRect();
            return rect.width / CHAR_COUNT;
          };
          FontMetrics2.prototype.getCharacterWidth = function(ch) {
            var w2 = this.charSizes[ch];
            if (w2 === void 0) {
              w2 = this.charSizes[ch] = this.$measureCharWidth(ch) / this.$characterSize.width;
            }
            return w2;
          };
          FontMetrics2.prototype.destroy = function() {
            clearInterval(this.$pollSizeChangesTimer);
            if (this.$observer)
              this.$observer.disconnect();
            if (this.el && this.el.parentNode)
              this.el.parentNode.removeChild(this.el);
          };
          FontMetrics2.prototype.$getZoom = function(element) {
            if (!element || !element.parentElement)
              return 1;
            return (Number(window.getComputedStyle(element)["zoom"]) || 1) * this.$getZoom(element.parentElement);
          };
          FontMetrics2.prototype.$initTransformMeasureNodes = function() {
            var t2 = function(t3, l) {
              return ["div", {
                style: "position: absolute;top:" + t3 + "px;left:" + l + "px;"
              }];
            };
            this.els = dom.buildDom([t2(0, 0), t2(L2, 0), t2(0, L2), t2(L2, L2)], this.el);
          };
          FontMetrics2.prototype.transformCoordinates = function(clientPos, elPos) {
            if (clientPos) {
              var zoom = this.$getZoom(this.el);
              clientPos = mul(1 / zoom, clientPos);
            }
            function solve(l1, l2, r) {
              var det = l1[1] * l2[0] - l1[0] * l2[1];
              return [
                (-l2[1] * r[0] + l2[0] * r[1]) / det,
                (+l1[1] * r[0] - l1[0] * r[1]) / det
              ];
            }
            function sub(a4, b3) {
              return [a4[0] - b3[0], a4[1] - b3[1]];
            }
            function add(a4, b3) {
              return [a4[0] + b3[0], a4[1] + b3[1]];
            }
            function mul(a4, b3) {
              return [a4 * b3[0], a4 * b3[1]];
            }
            if (!this.els)
              this.$initTransformMeasureNodes();
            function p(el) {
              var r = el.getBoundingClientRect();
              return [r.left, r.top];
            }
            var a3 = p(this.els[0]);
            var b2 = p(this.els[1]);
            var c2 = p(this.els[2]);
            var d3 = p(this.els[3]);
            var h3 = solve(sub(d3, b2), sub(d3, c2), sub(add(b2, c2), add(d3, a3)));
            var m1 = mul(1 + h3[0], sub(b2, a3));
            var m22 = mul(1 + h3[1], sub(c2, a3));
            if (elPos) {
              var x2 = elPos;
              var k2 = h3[0] * x2[0] / L2 + h3[1] * x2[1] / L2 + 1;
              var ut = add(mul(x2[0], m1), mul(x2[1], m22));
              return add(mul(1 / k2 / L2, ut), a3);
            }
            var u2 = sub(clientPos, a3);
            var f = solve(sub(m1, mul(h3[0], u2)), sub(m22, mul(h3[1], u2)), u2);
            return mul(L2, f);
          };
          return FontMetrics2;
        })()
      );
      FontMetrics.prototype.$characterSize = { width: 0, height: 0 };
      oop.implement(FontMetrics.prototype, EventEmitter);
      exports3.FontMetrics = FontMetrics;
    });
    ace.define("ace/css/editor-css", ["require", "exports", "module"], function(require2, exports3, module3) {
      module3.exports = `
.ace_br1 {border-top-left-radius    : 3px;}
.ace_br2 {border-top-right-radius   : 3px;}
.ace_br3 {border-top-left-radius    : 3px; border-top-right-radius:    3px;}
.ace_br4 {border-bottom-right-radius: 3px;}
.ace_br5 {border-top-left-radius    : 3px; border-bottom-right-radius: 3px;}
.ace_br6 {border-top-right-radius   : 3px; border-bottom-right-radius: 3px;}
.ace_br7 {border-top-left-radius    : 3px; border-top-right-radius:    3px; border-bottom-right-radius: 3px;}
.ace_br8 {border-bottom-left-radius : 3px;}
.ace_br9 {border-top-left-radius    : 3px; border-bottom-left-radius:  3px;}
.ace_br10{border-top-right-radius   : 3px; border-bottom-left-radius:  3px;}
.ace_br11{border-top-left-radius    : 3px; border-top-right-radius:    3px; border-bottom-left-radius:  3px;}
.ace_br12{border-bottom-right-radius: 3px; border-bottom-left-radius:  3px;}
.ace_br13{border-top-left-radius    : 3px; border-bottom-right-radius: 3px; border-bottom-left-radius:  3px;}
.ace_br14{border-top-right-radius   : 3px; border-bottom-right-radius: 3px; border-bottom-left-radius:  3px;}
.ace_br15{border-top-left-radius    : 3px; border-top-right-radius:    3px; border-bottom-right-radius: 3px; border-bottom-left-radius: 3px;}


.ace_editor {
    position: relative;
    overflow: hidden;
    padding: 0;
    font: 12px/normal 'Monaco', 'Menlo', 'Ubuntu Mono', 'Consolas', 'Source Code Pro', 'source-code-pro', monospace;
    direction: ltr;
    text-align: left;
    -webkit-tap-highlight-color: rgba(0, 0, 0, 0);
    forced-color-adjust: none;
}

.ace_scroller {
    position: absolute;
    overflow: hidden;
    top: 0;
    bottom: 0;
    background-color: inherit;
    -ms-user-select: none;
    -moz-user-select: none;
    -webkit-user-select: none;
    user-select: none;
    cursor: text;
}

.ace_content {
    position: absolute;
    box-sizing: border-box;
    min-width: 100%;
    contain: style size layout;
    font-variant-ligatures: no-common-ligatures;
}

.ace_keyboard-focus:focus {
    box-shadow: inset 0 0 0 2px #5E9ED6;
    outline: none;
}

.ace_dragging .ace_scroller:before{
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    content: '';
    background: rgba(250, 250, 250, 0.01);
    z-index: 1000;
}
.ace_dragging.ace_dark .ace_scroller:before{
    background: rgba(0, 0, 0, 0.01);
}

.ace_gutter {
    position: absolute;
    overflow : hidden;
    width: auto;
    top: 0;
    bottom: 0;
    left: 0;
    cursor: default;
    z-index: 4;
    -ms-user-select: none;
    -moz-user-select: none;
    -webkit-user-select: none;
    user-select: none;
    contain: style size layout;
}

.ace_gutter-active-line {
    position: absolute;
    left: 0;
    right: 0;
}

.ace_scroller.ace_scroll-left:after {
    content: "";
    position: absolute;
    top: 0;
    right: 0;
    bottom: 0;
    left: 0;
    box-shadow: 17px 0 16px -16px rgba(0, 0, 0, 0.4) inset;
    pointer-events: none;
}

.ace_gutter-cell, .ace_gutter-cell_svg-icons {
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    padding-left: 19px;
    padding-right: 6px;
    background-repeat: no-repeat;
}

.ace_gutter-cell_svg-icons .ace_gutter_annotation {
    margin-left: -14px;
    float: left;
}

.ace_gutter-cell .ace_gutter_annotation {
    margin-left: -19px;
    float: left;
}

.ace_gutter-cell.ace_error, .ace_icon.ace_error, .ace_icon.ace_error_fold, .ace_gutter-cell.ace_security, .ace_icon.ace_security, .ace_icon.ace_security_fold {
    background-image: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAMAAAAoLQ9TAAABOFBMVEX/////////QRswFAb/Ui4wFAYwFAYwFAaWGAfDRymzOSH/PxswFAb/SiUwFAYwFAbUPRvjQiDllog5HhHdRybsTi3/Tyv9Tir+Syj/UC3////XurebMBIwFAb/RSHbPx/gUzfdwL3kzMivKBAwFAbbvbnhPx66NhowFAYwFAaZJg8wFAaxKBDZurf/RB6mMxb/SCMwFAYwFAbxQB3+RB4wFAb/Qhy4Oh+4QifbNRcwFAYwFAYwFAb/QRzdNhgwFAYwFAbav7v/Uy7oaE68MBK5LxLewr/r2NXewLswFAaxJw4wFAbkPRy2PyYwFAaxKhLm1tMwFAazPiQwFAaUGAb/QBrfOx3bvrv/VC/maE4wFAbRPBq6MRO8Qynew8Dp2tjfwb0wFAbx6eju5+by6uns4uH9/f36+vr/GkHjAAAAYnRSTlMAGt+64rnWu/bo8eAA4InH3+DwoN7j4eLi4xP99Nfg4+b+/u9B/eDs1MD1mO7+4PHg2MXa347g7vDizMLN4eG+Pv7i5evs/v79yu7S3/DV7/498Yv24eH+4ufQ3Ozu/v7+y13sRqwAAADLSURBVHjaZc/XDsFgGIBhtDrshlitmk2IrbHFqL2pvXf/+78DPokj7+Fz9qpU/9UXJIlhmPaTaQ6QPaz0mm+5gwkgovcV6GZzd5JtCQwgsxoHOvJO15kleRLAnMgHFIESUEPmawB9ngmelTtipwwfASilxOLyiV5UVUyVAfbG0cCPHig+GBkzAENHS0AstVF6bacZIOzgLmxsHbt2OecNgJC83JERmePUYq8ARGkJx6XtFsdddBQgZE2nPR6CICZhawjA4Fb/chv+399kfR+MMMDGOQAAAABJRU5ErkJggg==");
    background-repeat: no-repeat;
    background-position: 2px center;
}

.ace_gutter-cell.ace_warning, .ace_icon.ace_warning, .ace_icon.ace_warning_fold {
    background-image: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAMAAAAoLQ9TAAAAmVBMVEX///8AAAD///8AAAAAAABPSzb/5sAAAAB/blH/73z/ulkAAAAAAAD85pkAAAAAAAACAgP/vGz/rkDerGbGrV7/pkQICAf////e0IsAAAD/oED/qTvhrnUAAAD/yHD/njcAAADuv2r/nz//oTj/p064oGf/zHAAAAA9Nir/tFIAAAD/tlTiuWf/tkIAAACynXEAAAAAAAAtIRW7zBpBAAAAM3RSTlMAABR1m7RXO8Ln31Z36zT+neXe5OzooRDfn+TZ4p3h2hTf4t3k3ucyrN1K5+Xaks52Sfs9CXgrAAAAjklEQVR42o3PbQ+CIBQFYEwboPhSYgoYunIqqLn6/z8uYdH8Vmdnu9vz4WwXgN/xTPRD2+sgOcZjsge/whXZgUaYYvT8QnuJaUrjrHUQreGczuEafQCO/SJTufTbroWsPgsllVhq3wJEk2jUSzX3CUEDJC84707djRc5MTAQxoLgupWRwW6UB5fS++NV8AbOZgnsC7BpEAAAAABJRU5ErkJggg==");
    background-repeat: no-repeat;
    background-position: 2px center;
}

.ace_gutter-cell.ace_info, .ace_icon.ace_info, .ace_gutter-cell.ace_hint, .ace_icon.ace_hint {
    background-image: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAAAAAA6mKC9AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAAJ0Uk5TAAB2k804AAAAPklEQVQY02NgIB68QuO3tiLznjAwpKTgNyDbMegwisCHZUETUZV0ZqOquBpXj2rtnpSJT1AEnnRmL2OgGgAAIKkRQap2htgAAAAASUVORK5CYII=");
    background-repeat: no-repeat;
    background-position: 2px center;
}

.ace_dark .ace_gutter-cell.ace_info, .ace_dark .ace_icon.ace_info, .ace_dark .ace_gutter-cell.ace_hint, .ace_dark .ace_icon.ace_hint {
    background-image: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQBAMAAADt3eJSAAAAJFBMVEUAAAChoaGAgIAqKiq+vr6tra1ZWVmUlJSbm5s8PDxubm56enrdgzg3AAAAAXRSTlMAQObYZgAAAClJREFUeNpjYMAPdsMYHegyJZFQBlsUlMFVCWUYKkAZMxZAGdxlDMQBAG+TBP4B6RyJAAAAAElFTkSuQmCC");
}

.ace_icon_svg.ace_error {
    -webkit-mask-image: url("data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAyMCAxNiI+CjxnIHN0cm9rZS13aWR0aD0iMiIgc3Ryb2tlPSJyZWQiIHNoYXBlLXJlbmRlcmluZz0iZ2VvbWV0cmljUHJlY2lzaW9uIj4KPGNpcmNsZSBmaWxsPSJub25lIiBjeD0iOCIgY3k9IjgiIHI9IjciIHN0cm9rZS1saW5lam9pbj0icm91bmQiLz4KPGxpbmUgeDE9IjExIiB5MT0iNSIgeDI9IjUiIHkyPSIxMSIvPgo8bGluZSB4MT0iMTEiIHkxPSIxMSIgeDI9IjUiIHkyPSI1Ii8+CjwvZz4KPC9zdmc+");
    background-color: crimson;
}
.ace_icon_svg.ace_security {
    -webkit-mask-image: url("data:image/svg+xml;base64,PHN2ZyB2aWV3Qm94PSIwIDAgMjAgMTYiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+CiAgICA8ZyBzdHJva2Utd2lkdGg9IjIiIHN0cm9rZT0iZGFya29yYW5nZSIgZmlsbD0ibm9uZSIgc2hhcGUtcmVuZGVyaW5nPSJnZW9tZXRyaWNQcmVjaXNpb24iPgogICAgICAgIDxwYXRoIGNsYXNzPSJzdHJva2UtbGluZWpvaW4tcm91bmQiIGQ9Ik04IDE0LjgzMDdDOCAxNC44MzA3IDIgMTIuOTA0NyAyIDguMDg5OTJWMy4yNjU0OEM1LjMxIDMuMjY1NDggNy45ODk5OSAxLjM0OTE4IDcuOTg5OTkgMS4zNDkxOEM3Ljk4OTk5IDEuMzQ5MTggMTAuNjkgMy4yNjU0OCAxNCAzLjI2NTQ4VjguMDg5OTJDMTQgMTIuOTA0NyA4IDE0LjgzMDcgOCAxNC44MzA3WiIvPgogICAgICAgIDxwYXRoIGQ9Ik0yIDguMDg5OTJWMy4yNjU0OEM1LjMxIDMuMjY1NDggNy45ODk5OSAxLjM0OTE4IDcuOTg5OTkgMS4zNDkxOCIvPgogICAgICAgIDxwYXRoIGQ9Ik0xMy45OSA4LjA4OTkyVjMuMjY1NDhDMTAuNjggMy4yNjU0OCA4IDEuMzQ5MTggOCAxLjM0OTE4Ii8+CiAgICAgICAgPHBhdGggY2xhc3M9InN0cm9rZS1saW5lam9pbi1yb3VuZCIgZD0iTTggNFY5Ii8+CiAgICAgICAgPHBhdGggY2xhc3M9InN0cm9rZS1saW5lam9pbi1yb3VuZCIgZD0iTTggMTBWMTIiLz4KICAgIDwvZz4KPC9zdmc+");
    background-color: crimson;
}
.ace_icon_svg.ace_warning {
    -webkit-mask-image: url("data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAyMCAxNiI+CjxnIHN0cm9rZS13aWR0aD0iMiIgc3Ryb2tlPSJkYXJrb3JhbmdlIiBzaGFwZS1yZW5kZXJpbmc9Imdlb21ldHJpY1ByZWNpc2lvbiI+Cjxwb2x5Z29uIHN0cm9rZS1saW5lam9pbj0icm91bmQiIGZpbGw9Im5vbmUiIHBvaW50cz0iOCAxIDE1IDE1IDEgMTUgOCAxIi8+CjxyZWN0IHg9IjgiIHk9IjEyIiB3aWR0aD0iMC4wMSIgaGVpZ2h0PSIwLjAxIi8+CjxsaW5lIHgxPSI4IiB5MT0iNiIgeDI9IjgiIHkyPSIxMCIvPgo8L2c+Cjwvc3ZnPg==");
    background-color: darkorange;
}
.ace_icon_svg.ace_info {
    -webkit-mask-image: url("data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAyMCAxNiI+CjxnIHN0cm9rZS13aWR0aD0iMiIgc3Ryb2tlPSJibHVlIiBzaGFwZS1yZW5kZXJpbmc9Imdlb21ldHJpY1ByZWNpc2lvbiI+CjxjaXJjbGUgZmlsbD0ibm9uZSIgY3g9IjgiIGN5PSI4IiByPSI3IiBzdHJva2UtbGluZWpvaW49InJvdW5kIi8+Cjxwb2x5bGluZSBwb2ludHM9IjggMTEgOCA4Ii8+Cjxwb2x5bGluZSBwb2ludHM9IjkgOCA2IDgiLz4KPGxpbmUgeDE9IjEwIiB5MT0iMTEiIHgyPSI2IiB5Mj0iMTEiLz4KPHJlY3QgeD0iOCIgeT0iNSIgd2lkdGg9IjAuMDEiIGhlaWdodD0iMC4wMSIvPgo8L2c+Cjwvc3ZnPg==");
    background-color: royalblue;
}
.ace_icon_svg.ace_hint {
    -webkit-mask-image: url("data:image/svg+xml;base64,PHN2ZyB2aWV3Qm94PSIwIDAgMjAgMTYiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+CiAgICA8ZyBzdHJva2Utd2lkdGg9IjIiIHN0cm9rZT0ic2lsdmVyIiBmaWxsPSJub25lIiBzaGFwZS1yZW5kZXJpbmc9Imdlb21ldHJpY1ByZWNpc2lvbiI+CiAgICAgICAgPHBhdGggY2xhc3M9InN0cm9rZS1saW5lam9pbi1yb3VuZCIgZD0iTTYgMTRIMTAiLz4KICAgICAgICA8cGF0aCBkPSJNOCAxMUg5QzkgOS40NzAwMiAxMiA4LjU0MDAyIDEyIDUuNzYwMDJDMTIuMDIgNC40MDAwMiAxMS4zOSAzLjM2MDAyIDEwLjQzIDIuNjcwMDJDOSAxLjY0MDAyIDcuMDAwMDEgMS42NDAwMiA1LjU3MDAxIDIuNjcwMDJDNC42MTAwMSAzLjM2MDAyIDMuOTggNC40MDAwMiA0IDUuNzYwMDJDNCA4LjU0MDAyIDcuMDAwMDEgOS40NzAwMiA3LjAwMDAxIDExSDhaIi8+CiAgICA8L2c+Cjwvc3ZnPg==");
    background-color: silver;
}

.ace_icon_svg.ace_error_fold {
    -webkit-mask-image: url("data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAyMCAxNiIgZmlsbD0ibm9uZSI+CiAgPHBhdGggZD0ibSAxOC45Mjk4NTEsNy44Mjk4MDc2IGMgMC4xNDYzNTMsNi4zMzc0NjA0IC02LjMyMzE0Nyw3Ljc3Nzg0NDQgLTcuNDc3OTEyLDcuNzc3ODQ0NCAtMi4xMDcyNzI2LC0wLjEyODc1IDUuMTE3Njc4LDAuMzU2MjQ5IDUuMDUxNjk4LC03Ljg3MDA2MTggLTAuNjA0NjcyLC04LjAwMzk3MzQ5IC03LjA3NzI3MDYsLTcuNTYzMTE4OSAtNC44NTczLC03LjQzMDM5NTU2IDEuNjA2LC0wLjExNTE0MjI1IDYuODk3NDg1LDEuMjYyNTQ1OTYgNy4yODM1MTQsNy41MjI2MTI5NiB6IiBmaWxsPSJjcmltc29uIiBzdHJva2Utd2lkdGg9IjIiLz4KICA8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0ibSA4LjExNDc1NjIsMi4wNTI5ODI4IGMgMy4zNDkxNjk4LDAgNi4wNjQxMzI4LDIuNjc2ODYyNyA2LjA2NDEzMjgsNS45Nzg5NTMgMCwzLjMwMjExMjIgLTIuNzE0OTYzLDUuOTc4OTIwMiAtNi4wNjQxMzI4LDUuOTc4OTIwMiAtMy4zNDkxNDczLDAgLTYuMDY0MTc3MiwtMi42NzY4MDggLTYuMDY0MTc3MiwtNS45Nzg5MjAyIDAuMDA1MzksLTMuMjk5ODg2MSAyLjcxNzI2NTYsLTUuOTczNjQwOCA2LjA2NDE3NzIsLTUuOTc4OTUzIHogbSAwLC0xLjczNTgyNzE5IGMgLTQuMzIxNDgzNiwwIC03LjgyNDc0MDM4LDMuNDU0MDE4NDkgLTcuODI0NzQwMzgsNy43MTQ3ODAxOSAwLDQuMjYwNzI4MiAzLjUwMzI1Njc4LDcuNzE0NzQ1MiA3LjgyNDc0MDM4LDcuNzE0NzQ1MiA0LjMyMTQ0OTgsMCA3LjgyNDY5OTgsLTMuNDU0MDE3IDcuODI0Njk5OCwtNy43MTQ3NDUyIDAsLTIuMDQ2MDkxNCAtMC44MjQzOTIsLTQuMDA4MzY3MiAtMi4yOTE3NTYsLTUuNDU1MTc0NiBDIDEyLjE4MDIyNSwxLjEyOTk2NDggMTAuMTkwMDEzLDAuMzE3MTU1NjEgOC4xMTQ3NTYyLDAuMzE3MTU1NjEgWiBNIDYuOTM3NDU2Myw4LjI0MDU5ODUgNC42NzE4Njg1LDEwLjQ4NTg1MiA2LjAwODY4MTQsMTEuODc2NzI4IDguMzE3MDAzNSw5LjYwMDc5MTEgMTAuNjI1MzM3LDExLjg3NjcyOCAxMS45NjIxMzgsMTAuNDg1ODUyIDkuNjk2NTUwOCw4LjI0MDU5ODUgMTEuOTYyMTM4LDYuMDA2ODA2NiAxMC41NzMyNDYsNC42Mzc0MzM1IDguMzE3MDAzNSw2Ljg3MzQyOTcgNi4wNjA3NjA3LDQuNjM3NDMzNSA0LjY3MTg2ODUsNi4wMDY4MDY2IFoiIGZpbGw9ImNyaW1zb24iIHN0cm9rZS13aWR0aD0iMiIvPgo8L3N2Zz4=");
    background-color: crimson;
}
.ace_icon_svg.ace_security_fold {
    -webkit-mask-image: url("data:image/svg+xml;base64,CjxzdmcgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB2aWV3Qm94PSIwIDAgMTcgMTQiIGZpbGw9Im5vbmUiPgogICAgPHBhdGggZD0iTTEwLjAwMDEgMTMuNjk5MkMxMC4wMDAxIDEzLjY5OTIgMTEuOTI0MSAxMy40NzYzIDEzIDEyLjY5OTJDMTQuNDEzOSAxMS42NzgxIDE2IDEwLjUgMTYuMTI1MSA2LjgxMTI2VjIuNTg5ODdDMTYuMTI1MSAyLjU0NzY4IDE2LjEyMjEgMi41MDYxOSAxNi4xMTY0IDIuNDY1NTlWMS43MTQ4NUgxNS4yNDE0TDE1LjIzMDcgMS43MTQ4NEwxNC42MjUxIDEuNjk5MjJWNi44MTEyM0MxNC42MjUxIDguNTEwNjEgMTQuNjI1MSA5LjQ2NDYxIDEyLjc4MjQgMTEuNzIxQzEyLjE1ODYgMTIuNDg0OCAxMC4wMDAxIDEzLjY5OTIgMTAuMDAwMSAxMy42OTkyWiIgZmlsbD0iY3JpbXNvbiIgc3Ryb2tlLXdpZHRoPSIyIi8+CiAgICA8cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTcuMzM2MDkgMC4zNjc0NzVDNy4wMzIxNCAwLjE1MjY1MiA2LjYyNTQ4IDAuMTUzNjE0IDYuMzIyNTMgMC4zNjk5OTdMNi4zMDg2OSAwLjM3OTU1NEM2LjI5NTUzIDAuMzg4NTg4IDYuMjczODggMC40MDMyNjYgNi4yNDQxNyAwLjQyMjc4OUM2LjE4NDcxIDAuNDYxODYgNi4wOTMyMSAwLjUyMDE3MSA1Ljk3MzEzIDAuNTkxMzczQzUuNzMyNTEgMC43MzQwNTkgNS4zNzk5IDAuOTI2ODY0IDQuOTQyNzkgMS4xMjAwOUM0LjA2MTQ0IDEuNTA5NyAyLjg3NTQxIDEuODgzNzcgMS41ODk4NCAxLjg4Mzc3SDAuNzE0ODQ0VjIuNzU4NzdWNi45ODAxNUMwLjcxNDg0NCA5LjQ5Mzc0IDIuMjg4NjYgMTEuMTk3MyAzLjcwMjU0IDEyLjIxODVDNC40MTg0NSAxMi43MzU1IDUuMTI4NzQgMTMuMTA1MyA1LjY1NzMzIDEzLjM0NTdDNS45MjI4NCAxMy40NjY0IDYuMTQ1NjYgMTMuNTU1OSA2LjMwNDY1IDEzLjYxNjFDNi4zODQyMyAxMy42NDYyIDYuNDQ4MDUgMTMuNjY5IDYuNDkzNDkgMTMuNjg0OEM2LjUxNjIyIDEzLjY5MjcgNi41MzQzOCAxMy42OTg5IDYuNTQ3NjQgMTMuNzAzM0w2LjU2MzgyIDEzLjcwODdMNi41NjkwOCAxMy43MTA0TDYuNTcwOTkgMTMuNzExTDYuODM5ODQgMTMuNzUzM0w2LjU3MjQyIDEzLjcxMTVDNi43NDYzMyAxMy43NjczIDYuOTMzMzUgMTMuNzY3MyA3LjEwNzI3IDEzLjcxMTVMNy4xMDg3IDEzLjcxMUw3LjExMDYxIDEzLjcxMDRMNy4xMTU4NyAxMy43MDg3TDcuMTMyMDUgMTMuNzAzM0M3LjE0NTMxIDEzLjY5ODkgNy4xNjM0NiAxMy42OTI3IDcuMTg2MTkgMTMuNjg0OEM3LjIzMTY0IDEzLjY2OSA3LjI5NTQ2IDEzLjY0NjIgNy4zNzUwMyAxMy42MTYxQzcuNTM0MDMgMTMuNTU1OSA3Ljc1Njg1IDEzLjQ2NjQgOC4wMjIzNiAxMy4zNDU3QzguNTUwOTUgMTMuMTA1MyA5LjI2MTIzIDEyLjczNTUgOS45NzcxNSAxMi4yMTg1QzExLjM5MSAxMS4xOTczIDEyLjk2NDggOS40OTM3NyAxMi45NjQ4IDYuOTgwMThWMi43NTg4QzEyLjk2NDggMi43MTY2IDEyLjk2MTkgMi42NzUxMSAxMi45NTYxIDIuNjM0NTFWMS44ODM3N0gxMi4wODExQzEyLjA3NzUgMS44ODM3NyAxMi4wNzQgMS44ODM3NyAxMi4wNzA0IDEuODgzNzdDMTAuNzk3OSAxLjg4MDA0IDkuNjE5NjIgMS41MTEwMiA4LjczODk0IDEuMTI0ODZDOC43MzUzNCAxLjEyMzI3IDguNzMxNzQgMS4xMjE2OCA4LjcyODE0IDEuMTIwMDlDOC4yOTEwMyAwLjkyNjg2NCA3LjkzODQyIDAuNzM0MDU5IDcuNjk3NzkgMC41OTEzNzNDNy41Nzc3MiAwLjUyMDE3MSA3LjQ4NjIyIDAuNDYxODYgNy40MjY3NiAwLjQyMjc4OUM3LjM5NzA1IDAuNDAzMjY2IDcuMzc1MzkgMC4zODg1ODggNy4zNjIyNCAwLjM3OTU1NEw3LjM0ODk2IDAuMzcwMzVDNy4zNDg5NiAwLjM3MDM1IDcuMzQ4NDcgMC4zNzAwMiA3LjM0NTYzIDAuMzc0MDU0TDcuMzM3NzkgMC4zNjg2NTlMNy4zMzYwOSAwLjM2NzQ3NVpNOC4wMzQ3MSAyLjcyNjkxQzguODYwNCAzLjA5MDYzIDkuOTYwNjYgMy40NjMwOSAxMS4yMDYxIDMuNTg5MDdWNi45ODAxNUgxMS4yMTQ4QzExLjIxNDggOC42Nzk1MyAxMC4xNjM3IDkuOTI1MDcgOC45NTI1NCAxMC43OTk4QzguMzU1OTUgMTEuMjMwNiA3Ljc1Mzc0IDExLjU0NTQgNy4yOTc5NiAxMS43NTI3QzcuMTE2NzEgMTEuODM1MSA2Ljk2MDYyIDExLjg5OTYgNi44Mzk4NCAxMS45NDY5QzYuNzE5MDYgMTEuODk5NiA2LjU2Mjk3IDExLjgzNTEgNi4zODE3MyAxMS43NTI3QzUuOTI1OTUgMTEuNTQ1NCA1LjMyMzczIDExLjIzMDYgNC43MjcxNSAxMC43OTk4QzMuNTE2MDMgOS45MjUwNyAyLjQ2NDg0IDguNjc5NTUgMi40NjQ4NCA2Ljk4MDE4VjMuNTg5MDlDMy43MTczOCAzLjQ2MjM5IDQuODIzMDggMy4wODYzOSA1LjY1MDMzIDIuNzIwNzFDNi4xNDIyOCAyLjUwMzI0IDYuNTQ0ODUgMi4yODUzNyA2LjgzMjU0IDIuMTE2MjRDNy4xMjE4MSAyLjI4NTM1IDcuNTI3IDIuNTAzNTIgOC4wMjE5NiAyLjcyMTMxQzguMDI2MiAyLjcyMzE3IDguMDMwNDUgMi43MjUwNCA4LjAzNDcxIDIuNzI2OTFaTTUuOTY0ODQgMy40MDE0N1Y3Ljc3NjQ3SDcuNzE0ODRWMy40MDE0N0g1Ljk2NDg0Wk01Ljk2NDg0IDEwLjQwMTVWOC42NTE0N0g3LjcxNDg0VjEwLjQwMTVINS45NjQ4NFoiIGZpbGw9ImNyaW1zb24iIHN0cm9rZS13aWR0aD0iMiIvPgo8L3N2Zz4=");
    background-color: crimson;
}
.ace_icon_svg.ace_warning_fold {
    -webkit-mask-image: url("data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMTYiIHZpZXdCb3g9IjAgMCAyMCAxNiIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPHBhdGggZmlsbC1ydWxlPSJldmVub2RkIiBjbGlwLXJ1bGU9ImV2ZW5vZGQiIGQ9Ik0xNC43NzY5IDE0LjczMzdMOC42NTE5MiAyLjQ4MzY5QzguMzI5NDYgMS44Mzg3NyA3LjQwOTEzIDEuODM4NzcgNy4wODY2NyAyLjQ4MzY5TDAuOTYxNjY5IDE0LjczMzdDMC42NzA3NzUgMTUuMzE1NSAxLjA5MzgzIDE2IDEuNzQ0MjkgMTZIMTMuOTk0M0MxNC42NDQ4IDE2IDE1LjA2NzggMTUuMzE1NSAxNC43NzY5IDE0LjczMzdaTTMuMTYwMDcgMTQuMjVMNy44NjkyOSA0LjgzMTU2TDEyLjU3ODUgMTQuMjVIMy4xNjAwN1pNOC43NDQyOSAxMS42MjVWMTMuMzc1SDYuOTk0MjlWMTEuNjI1SDguNzQ0MjlaTTYuOTk0MjkgMTAuNzVWNy4yNUg4Ljc0NDI5VjEwLjc1SDYuOTk0MjlaIiBmaWxsPSIjRUM3MjExIi8+CjxwYXRoIGQ9Ik0xMS4xOTkxIDIuOTUyMzhDMTAuODgwOSAyLjMxNDY3IDEwLjM1MzcgMS44MDUyNiA5LjcwNTUgMS41MDlMMTEuMDQxIDEuMDY5NzhDMTEuNjg4MyAwLjk0OTgxNCAxMi4zMzcgMS4yNzI2MyAxMi42MzE3IDEuODYxNDFMMTcuNjEzNiAxMS44MTYxQzE4LjM1MjcgMTMuMjkyOSAxNy41OTM4IDE1LjA4MDQgMTYuMDE4IDE1LjU3NDVDMTYuNDA0NCAxNC40NTA3IDE2LjMyMzEgMTMuMjE4OCAxNS43OTI0IDEyLjE1NTVMMTEuMTk5MSAyLjk1MjM4WiIgZmlsbD0iI0VDNzIxMSIvPgo8L3N2Zz4=");
    background-color: darkorange;
}

.ace_scrollbar {
    contain: strict;
    position: absolute;
    right: 0;
    bottom: 0;
    z-index: 6;
}

.ace_scrollbar-inner {
    position: absolute;
    cursor: text;
    left: 0;
    top: 0;
}

.ace_scrollbar-v{
    overflow-x: hidden;
    overflow-y: scroll;
    top: 0;
}

.ace_scrollbar-h {
    overflow-x: scroll;
    overflow-y: hidden;
    left: 0;
}

.ace_print-margin {
    position: absolute;
    height: 100%;
}

.ace_text-input {
    position: absolute;
    z-index: 0;
    width: 0.5em;
    height: 1em;
    opacity: 0;
    background: transparent;
    -moz-appearance: none;
    appearance: none;
    border: none;
    resize: none;
    outline: none;
    overflow: hidden;
    font: inherit;
    padding: 0 1px;
    margin: 0 -1px;
    contain: strict;
    -ms-user-select: text;
    -moz-user-select: text;
    -webkit-user-select: text;
    user-select: text;
    /*with \`pre-line\` chrome inserts &nbsp; instead of space*/
    white-space: pre!important;
}
.ace_text-input.ace_composition {
    background: transparent;
    color: inherit;
    z-index: 1000;
    opacity: 1;
}
.ace_composition_placeholder { color: transparent }
.ace_composition_marker { 
    border-bottom: 1px solid;
    position: absolute;
    border-radius: 0;
    margin-top: 1px;
}

[ace_nocontext=true] {
    transform: none!important;
    filter: none!important;
    clip-path: none!important;
    mask : none!important;
    contain: none!important;
    perspective: none!important;
    mix-blend-mode: initial!important;
    z-index: auto;
}

.ace_layer {
    z-index: 1;
    position: absolute;
    overflow: hidden;
    /* workaround for chrome bug https://github.com/ajaxorg/ace/issues/2312*/
    word-wrap: normal;
    white-space: pre;
    height: 100%;
    width: 100%;
    box-sizing: border-box;
    /* setting pointer-events: auto; on node under the mouse, which changes
        during scroll, will break mouse wheel scrolling in Safari */
    pointer-events: none;
}

.ace_gutter-layer {
    position: relative;
    width: auto;
    text-align: right;
    pointer-events: auto;
    height: 1000000px;
    contain: style size layout;
}

.ace_text-layer {
    font: inherit !important;
    position: absolute;
    height: 1000000px;
    width: 1000000px;
    contain: style size layout;
}

.ace_text-layer > .ace_line, .ace_text-layer > .ace_line_group {
    contain: style size layout;
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
}

.ace_hidpi .ace_text-layer,
.ace_hidpi .ace_gutter-layer,
.ace_hidpi .ace_content,
.ace_hidpi .ace_gutter {
    contain: strict;
}
.ace_hidpi .ace_text-layer > .ace_line, 
.ace_hidpi .ace_text-layer > .ace_line_group {
    contain: strict;
}

.ace_cjk {
    display: inline-block;
    text-align: center;
}

.ace_cursor-layer {
    z-index: 4;
}

.ace_cursor {
    z-index: 4;
    position: absolute;
    box-sizing: border-box;
    border-left: 2px solid;
    /* workaround for smooth cursor repaintng whole screen in chrome */
    transform: translatez(0);
}

.ace_multiselect .ace_cursor {
    border-left-width: 1px;
}

.ace_slim-cursors .ace_cursor {
    border-left-width: 1px;
}

.ace_overwrite-cursors .ace_cursor {
    border-left-width: 0;
    border-bottom: 1px solid;
}

.ace_hidden-cursors .ace_cursor {
    opacity: 0.2;
}

.ace_hasPlaceholder .ace_hidden-cursors .ace_cursor {
    opacity: 0;
}

.ace_smooth-blinking .ace_cursor {
    transition: opacity 0.18s;
}

.ace_animate-blinking .ace_cursor {
    animation-duration: 1000ms;
    animation-timing-function: step-end;
    animation-name: blink-ace-animate;
    animation-iteration-count: infinite;
}

.ace_animate-blinking.ace_smooth-blinking .ace_cursor {
    animation-duration: 1000ms;
    animation-timing-function: ease-in-out;
    animation-name: blink-ace-animate-smooth;
}
    
@keyframes blink-ace-animate {
    from, to { opacity: 1; }
    60% { opacity: 0; }
}

@keyframes blink-ace-animate-smooth {
    from, to { opacity: 1; }
    45% { opacity: 1; }
    60% { opacity: 0; }
    85% { opacity: 0; }
}

.ace_marker-layer .ace_step, .ace_marker-layer .ace_stack {
    position: absolute;
    z-index: 3;
}

.ace_marker-layer .ace_selection {
    position: absolute;
    z-index: 5;
}

.ace_marker-layer .ace_bracket {
    position: absolute;
    z-index: 6;
}

.ace_marker-layer .ace_error_bracket {
    position: absolute;
    border-bottom: 1px solid #DE5555;
    border-radius: 0;
}

.ace_marker-layer .ace_active-line {
    position: absolute;
    z-index: 2;
}

.ace_marker-layer .ace_selected-word {
    position: absolute;
    z-index: 4;
    box-sizing: border-box;
}

.ace_line .ace_fold {
    box-sizing: border-box;

    display: inline-block;
    height: 11px;
    margin-top: -2px;
    vertical-align: middle;

    background-image:
        url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABEAAAAJCAYAAADU6McMAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAJpJREFUeNpi/P//PwOlgAXGYGRklAVSokD8GmjwY1wasKljQpYACtpCFeADcHVQfQyMQAwzwAZI3wJKvCLkfKBaMSClBlR7BOQikCFGQEErIH0VqkabiGCAqwUadAzZJRxQr/0gwiXIal8zQQPnNVTgJ1TdawL0T5gBIP1MUJNhBv2HKoQHHjqNrA4WO4zY0glyNKLT2KIfIMAAQsdgGiXvgnYAAAAASUVORK5CYII="),
        url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAA3CAYAAADNNiA5AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAACJJREFUeNpi+P//fxgTAwPDBxDxD078RSX+YeEyDFMCIMAAI3INmXiwf2YAAAAASUVORK5CYII=");
    background-repeat: no-repeat, repeat-x;
    background-position: center center, top left;
    color: transparent;

    border: 1px solid black;
    border-radius: 2px;

    cursor: pointer;
    pointer-events: auto;
}

.ace_dark .ace_fold {
}

.ace_fold:hover{
    background-image:
        url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABEAAAAJCAYAAADU6McMAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAJpJREFUeNpi/P//PwOlgAXGYGRklAVSokD8GmjwY1wasKljQpYACtpCFeADcHVQfQyMQAwzwAZI3wJKvCLkfKBaMSClBlR7BOQikCFGQEErIH0VqkabiGCAqwUadAzZJRxQr/0gwiXIal8zQQPnNVTgJ1TdawL0T5gBIP1MUJNhBv2HKoQHHjqNrA4WO4zY0glyNKLT2KIfIMAAQsdgGiXvgnYAAAAASUVORK5CYII="),
        url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAA3CAYAAADNNiA5AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAACBJREFUeNpi+P//fz4TAwPDZxDxD5X4i5fLMEwJgAADAEPVDbjNw87ZAAAAAElFTkSuQmCC");
}

.ace_tooltip {
    background-color: #f5f5f5;
    border: 1px solid gray;
    border-radius: 1px;
    box-shadow: 0 1px 2px rgba(0, 0, 0, 0.3);
    color: black;
    max-width: 100%;
    padding: 3px 4px;
    position: fixed;
    z-index: 999999;
    box-sizing: border-box;
    cursor: default;
    white-space: pre-wrap;
    word-wrap: break-word;
    line-height: normal;
    font-style: normal;
    font-weight: normal;
    letter-spacing: normal;
    pointer-events: none;
    overflow: auto;
    max-width: min(60em, 66vw);
    overscroll-behavior: contain;
}
.ace_tooltip pre {
    white-space: pre-wrap;
}

.ace_tooltip.ace_dark {
    background-color: #636363;
    color: #fff;
}

.ace_tooltip:focus {
    outline: 1px solid #5E9ED6;
}

.ace_icon {
    display: inline-block;
    width: 18px;
    vertical-align: top;
}

.ace_icon_svg {
    display: inline-block;
    width: 12px;
    vertical-align: top;
    -webkit-mask-repeat: no-repeat;
    -webkit-mask-size: 12px;
    -webkit-mask-position: center;
}

.ace_folding-enabled > .ace_gutter-cell, .ace_folding-enabled > .ace_gutter-cell_svg-icons {
    padding-right: 13px;
}

.ace_fold-widget {
    box-sizing: border-box;

    margin: 0 -12px 0 1px;
    display: none;
    width: 11px;
    vertical-align: top;

    background-image: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAFCAYAAACNbyblAAAANElEQVR42mWKsQ0AMAzC8ixLlrzQjzmBiEjp0A6WwBCSPgKAXoLkqSot7nN3yMwR7pZ32NzpKkVoDBUxKAAAAABJRU5ErkJggg==");
    background-repeat: no-repeat;
    background-position: center;

    border-radius: 3px;
    
    border: 1px solid transparent;
    cursor: pointer;
}

.ace_folding-enabled .ace_fold-widget {
    display: inline-block;   
}

.ace_fold-widget.ace_end {
    background-image: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAFCAYAAACNbyblAAAANElEQVR42m3HwQkAMAhD0YzsRchFKI7sAikeWkrxwScEB0nh5e7KTPWimZki4tYfVbX+MNl4pyZXejUO1QAAAABJRU5ErkJggg==");
}

.ace_fold-widget.ace_closed {
    background-image: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAMAAAAGCAYAAAAG5SQMAAAAOUlEQVR42jXKwQkAMAgDwKwqKD4EwQ26sSOkVWjgIIHAzPiCgaqiqnJHZnKICBERHN194O5b9vbLuAVRL+l0YWnZAAAAAElFTkSuQmCCXA==");
}

.ace_fold-widget:hover {
    border: 1px solid rgba(0, 0, 0, 0.3);
    background-color: rgba(255, 255, 255, 0.2);
    box-shadow: 0 1px 1px rgba(255, 255, 255, 0.7);
}

.ace_fold-widget:active {
    border: 1px solid rgba(0, 0, 0, 0.4);
    background-color: rgba(0, 0, 0, 0.05);
    box-shadow: 0 1px 1px rgba(255, 255, 255, 0.8);
}
/**
 * Dark version for fold widgets
 */
.ace_dark .ace_fold-widget {
    background-image: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAFCAYAAACNbyblAAAAHklEQVQIW2P4//8/AzoGEQ7oGCaLLAhWiSwB146BAQCSTPYocqT0AAAAAElFTkSuQmCC");
}
.ace_dark .ace_fold-widget.ace_end {
    background-image: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAFCAYAAACNbyblAAAAH0lEQVQIW2P4//8/AxQ7wNjIAjDMgC4AxjCVKBirIAAF0kz2rlhxpAAAAABJRU5ErkJggg==");
}
.ace_dark .ace_fold-widget.ace_closed {
    background-image: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAMAAAAFCAYAAACAcVaiAAAAHElEQVQIW2P4//+/AxAzgDADlOOAznHAKgPWAwARji8UIDTfQQAAAABJRU5ErkJggg==");
}
.ace_dark .ace_fold-widget:hover {
    box-shadow: 0 1px 1px rgba(255, 255, 255, 0.2);
    background-color: rgba(255, 255, 255, 0.1);
}
.ace_dark .ace_fold-widget:active {
    box-shadow: 0 1px 1px rgba(255, 255, 255, 0.2);
}

.ace_inline_button {
    border: 1px solid lightgray;
    display: inline-block;
    margin: -1px 8px;
    padding: 0 5px;
    pointer-events: auto;
    cursor: pointer;
}
.ace_inline_button:hover {
    border-color: gray;
    background: rgba(200,200,200,0.2);
    display: inline-block;
    pointer-events: auto;
}

.ace_fold-widget.ace_invalid {
    background-color: #FFB4B4;
    border-color: #DE5555;
}

.ace_fade-fold-widgets .ace_fold-widget {
    transition: opacity 0.4s ease 0.05s;
    opacity: 0;
}

.ace_fade-fold-widgets:hover .ace_fold-widget {
    transition: opacity 0.05s ease 0.05s;
    opacity:1;
}

.ace_underline {
    text-decoration: underline;
}

.ace_bold {
    font-weight: bold;
}

.ace_nobold .ace_bold {
    font-weight: normal;
}

.ace_italic {
    font-style: italic;
}


.ace_error-marker {
    background-color: rgba(255, 0, 0,0.2);
    position: absolute;
    z-index: 9;
}

.ace_highlight-marker {
    background-color: rgba(255, 255, 0,0.2);
    position: absolute;
    z-index: 8;
}

.ace_mobile-menu {
    position: absolute;
    line-height: 1.5;
    border-radius: 4px;
    -ms-user-select: none;
    -moz-user-select: none;
    -webkit-user-select: none;
    user-select: none;
    background: white;
    box-shadow: 1px 3px 2px grey;
    border: 1px solid #dcdcdc;
    color: black;
}
.ace_dark > .ace_mobile-menu {
    background: #333;
    color: #ccc;
    box-shadow: 1px 3px 2px grey;
    border: 1px solid #444;

}
.ace_mobile-button {
    padding: 2px;
    cursor: pointer;
    overflow: hidden;
}
.ace_mobile-button:hover {
    background-color: #eee;
    opacity:1;
}
.ace_mobile-button:active {
    background-color: #ddd;
}

.ace_placeholder {
    position: relative;
    font-family: arial;
    transform: scale(0.9);
    transform-origin: left;
    white-space: pre;
    opacity: 0.7;
    margin: 0 10px;
    z-index: 1;
}

.ace_ghost_text {
    opacity: 0.5;
    font-style: italic;
}

.ace_ghost_text_container > div {
    white-space: pre;
}

.ghost_text_line_wrapped::after {
    content: "";
    position: absolute;
}

.ace_lineWidgetContainer.ace_ghost_text {
    margin: 0px 4px
}

.ace_screenreader-only {
    position:absolute;
    left:-10000px;
    top:auto;
    width:1px;
    height:1px;
    overflow:hidden;
}

.ace_hidden_token {
    display: none;
}`;
    });
    ace.define("ace/layer/decorators", ["require", "exports", "module", "ace/lib/dom", "ace/lib/oop", "ace/lib/event_emitter"], function(require2, exports3, module3) {
      var dom = require2("../lib/dom");
      var oop = require2("../lib/oop");
      var EventEmitter = require2("../lib/event_emitter").EventEmitter;
      var Decorator = (
        /** @class */
        (function() {
          function Decorator2(parent, renderer) {
            this.canvas = dom.createElement("canvas");
            this.renderer = renderer;
            this.pixelRatio = 1;
            this.maxHeight = renderer.layerConfig.maxHeight;
            this.lineHeight = renderer.layerConfig.lineHeight;
            this.canvasHeight = parent.parent.scrollHeight;
            this.heightRatio = this.canvasHeight / this.maxHeight;
            this.canvasWidth = parent.width;
            this.minDecorationHeight = 2 * this.pixelRatio | 0;
            this.halfMinDecorationHeight = this.minDecorationHeight / 2 | 0;
            this.canvas.width = this.canvasWidth;
            this.canvas.height = this.canvasHeight;
            this.canvas.style.top = "0px";
            this.canvas.style.right = "0px";
            this.canvas.style.zIndex = "7px";
            this.canvas.style.position = "absolute";
            this.colors = {};
            this.colors.dark = {
              "error": "rgba(255, 18, 18, 1)",
              "warning": "rgba(18, 136, 18, 1)",
              "info": "rgba(18, 18, 136, 1)"
            };
            this.colors.light = {
              "error": "rgb(255,51,51)",
              "warning": "rgb(32,133,72)",
              "info": "rgb(35,68,138)"
            };
            parent.element.appendChild(this.canvas);
          }
          Decorator2.prototype.$updateDecorators = function(config) {
            var colors = this.renderer.theme.isDark === true ? this.colors.dark : this.colors.light;
            if (config) {
              this.maxHeight = config.maxHeight;
              this.lineHeight = config.lineHeight;
              this.canvasHeight = config.height;
              var allLineHeight = (config.lastRow + 1) * this.lineHeight;
              if (allLineHeight < this.canvasHeight) {
                this.heightRatio = 1;
              } else {
                this.heightRatio = this.canvasHeight / this.maxHeight;
              }
            }
            var ctx = this.canvas.getContext("2d");
            function compare2(a3, b2) {
              if (a3.priority < b2.priority)
                return -1;
              if (a3.priority > b2.priority)
                return 1;
              return 0;
            }
            var annotations = this.renderer.session.$annotations;
            ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
            if (annotations) {
              var priorities = {
                "info": 1,
                "warning": 2,
                "error": 3
              };
              annotations.forEach(function(item2) {
                item2.priority = priorities[item2.type] || null;
              });
              annotations = annotations.sort(compare2);
              var foldData = this.renderer.session.$foldData;
              for (var i2 = 0; i2 < annotations.length; i2++) {
                var row = annotations[i2].row;
                var compensateFold = this.compensateFoldRows(row, foldData);
                var currentY = Math.round((row - compensateFold) * this.lineHeight * this.heightRatio);
                var y1 = Math.round((row - compensateFold) * this.lineHeight * this.heightRatio);
                var y22 = Math.round(((row - compensateFold) * this.lineHeight + this.lineHeight) * this.heightRatio);
                var height = y22 - y1;
                if (height < this.minDecorationHeight) {
                  var yCenter = (y1 + y22) / 2 | 0;
                  if (yCenter < this.halfMinDecorationHeight) {
                    yCenter = this.halfMinDecorationHeight;
                  } else if (yCenter + this.halfMinDecorationHeight > this.canvasHeight) {
                    yCenter = this.canvasHeight - this.halfMinDecorationHeight;
                  }
                  y1 = Math.round(yCenter - this.halfMinDecorationHeight);
                  y22 = Math.round(yCenter + this.halfMinDecorationHeight);
                }
                ctx.fillStyle = colors[annotations[i2].type] || null;
                ctx.fillRect(0, currentY, this.canvasWidth, y22 - y1);
              }
            }
            var cursor = this.renderer.session.selection.getCursor();
            if (cursor) {
              var compensateFold = this.compensateFoldRows(cursor.row, foldData);
              var currentY = Math.round((cursor.row - compensateFold) * this.lineHeight * this.heightRatio);
              ctx.fillStyle = "rgba(0, 0, 0, 0.5)";
              ctx.fillRect(0, currentY, this.canvasWidth, 2);
            }
          };
          Decorator2.prototype.compensateFoldRows = function(row, foldData) {
            var compensateFold = 0;
            if (foldData && foldData.length > 0) {
              for (var j = 0; j < foldData.length; j++) {
                if (row > foldData[j].start.row && row < foldData[j].end.row) {
                  compensateFold += row - foldData[j].start.row;
                } else if (row >= foldData[j].end.row) {
                  compensateFold += foldData[j].end.row - foldData[j].start.row;
                }
              }
            }
            return compensateFold;
          };
          return Decorator2;
        })()
      );
      oop.implement(Decorator.prototype, EventEmitter);
      exports3.Decorator = Decorator;
    });
    ace.define("ace/virtual_renderer", ["require", "exports", "module", "ace/lib/oop", "ace/lib/dom", "ace/lib/lang", "ace/config", "ace/layer/gutter", "ace/layer/marker", "ace/layer/text", "ace/layer/cursor", "ace/scrollbar", "ace/scrollbar", "ace/scrollbar_custom", "ace/scrollbar_custom", "ace/renderloop", "ace/layer/font_metrics", "ace/lib/event_emitter", "ace/css/editor-css", "ace/layer/decorators", "ace/lib/useragent", "ace/layer/text_util"], function(require2, exports3, module3) {
      var oop = require2("./lib/oop");
      var dom = require2("./lib/dom");
      var lang = require2("./lib/lang");
      var config = require2("./config");
      var GutterLayer = require2("./layer/gutter").Gutter;
      var MarkerLayer = require2("./layer/marker").Marker;
      var TextLayer = require2("./layer/text").Text;
      var CursorLayer = require2("./layer/cursor").Cursor;
      var HScrollBar = require2("./scrollbar").HScrollBar;
      var VScrollBar = require2("./scrollbar").VScrollBar;
      var HScrollBarCustom = require2("./scrollbar_custom").HScrollBar;
      var VScrollBarCustom = require2("./scrollbar_custom").VScrollBar;
      var RenderLoop = require2("./renderloop").RenderLoop;
      var FontMetrics = require2("./layer/font_metrics").FontMetrics;
      var EventEmitter = require2("./lib/event_emitter").EventEmitter;
      var editorCss = require2("./css/editor-css");
      var Decorator = require2("./layer/decorators").Decorator;
      var useragent = require2("./lib/useragent");
      var isTextToken = require2("./layer/text_util").isTextToken;
      dom.importCssString(editorCss, "ace_editor.css", false);
      var VirtualRenderer = (
        /** @class */
        (function() {
          function VirtualRenderer2(container, theme) {
            var _self = this;
            this.container = container || dom.createElement("div");
            dom.addCssClass(this.container, "ace_editor");
            if (dom.HI_DPI)
              dom.addCssClass(this.container, "ace_hidpi");
            this.setTheme(theme);
            if (config.get("useStrictCSP") == null)
              config.set("useStrictCSP", false);
            this.$gutter = dom.createElement("div");
            this.$gutter.className = "ace_gutter";
            this.container.appendChild(this.$gutter);
            this.$gutter.setAttribute("aria-hidden", "true");
            this.scroller = dom.createElement("div");
            this.scroller.className = "ace_scroller";
            this.container.appendChild(this.scroller);
            this.content = dom.createElement("div");
            this.content.className = "ace_content";
            this.scroller.appendChild(this.content);
            this.$gutterLayer = new GutterLayer(this.$gutter);
            this.$gutterLayer.on("changeGutterWidth", this.onGutterResize.bind(this));
            this.$markerBack = new MarkerLayer(this.content);
            var textLayer = this.$textLayer = new TextLayer(this.content);
            this.canvas = textLayer.element;
            this.$markerFront = new MarkerLayer(this.content);
            this.$cursorLayer = new CursorLayer(this.content);
            this.$horizScroll = false;
            this.$vScroll = false;
            this.scrollBar = this.scrollBarV = new VScrollBar(this.container, this);
            this.scrollBarH = new HScrollBar(this.container, this);
            this.scrollBarV.on("scroll", function(e2) {
              if (!_self.$scrollAnimation)
                _self.session.setScrollTop(e2.data - _self.scrollMargin.top);
            });
            this.scrollBarH.on("scroll", function(e2) {
              if (!_self.$scrollAnimation)
                _self.session.setScrollLeft(e2.data - _self.scrollMargin.left);
            });
            this.scrollTop = 0;
            this.scrollLeft = 0;
            this.cursorPos = {
              row: 0,
              column: 0
            };
            this.$fontMetrics = new FontMetrics(this.container);
            this.$textLayer.$setFontMetrics(this.$fontMetrics);
            this.$textLayer.on("changeCharacterSize", function(e2) {
              _self.updateCharacterSize();
              _self.onResize(true, _self.gutterWidth, _self.$size.width, _self.$size.height);
              _self._signal("changeCharacterSize", e2);
            });
            this.$size = {
              width: 0,
              height: 0,
              scrollerHeight: 0,
              scrollerWidth: 0,
              $dirty: true
            };
            this.layerConfig = {
              width: 1,
              padding: 0,
              firstRow: 0,
              firstRowScreen: 0,
              lastRow: 0,
              lineHeight: 0,
              characterWidth: 0,
              minHeight: 1,
              maxHeight: 1,
              offset: 0,
              height: 1,
              gutterOffset: 1
            };
            this.scrollMargin = {
              left: 0,
              right: 0,
              top: 0,
              bottom: 0,
              v: 0,
              h: 0
            };
            this.margin = {
              left: 0,
              right: 0,
              top: 0,
              bottom: 0,
              v: 0,
              h: 0
            };
            this.$keepTextAreaAtCursor = !useragent.isIOS;
            this.$loop = new RenderLoop(this.$renderChanges.bind(this), this.container.ownerDocument.defaultView);
            this.$loop.schedule(this.CHANGE_FULL);
            this.updateCharacterSize();
            this.setPadding(4);
            this.$addResizeObserver();
            config.resetOptions(this);
            config._signal("renderer", this);
          }
          VirtualRenderer2.prototype.updateCharacterSize = function() {
            if (this.$textLayer.allowBoldFonts != this.$allowBoldFonts) {
              this.$allowBoldFonts = this.$textLayer.allowBoldFonts;
              this.setStyle("ace_nobold", !this.$allowBoldFonts);
            }
            this.layerConfig.characterWidth = this.characterWidth = this.$textLayer.getCharacterWidth();
            this.layerConfig.lineHeight = this.lineHeight = this.$textLayer.getLineHeight();
            this.$updatePrintMargin();
            dom.setStyle(this.scroller.style, "line-height", this.lineHeight + "px");
          };
          VirtualRenderer2.prototype.setSession = function(session) {
            if (this.session)
              this.session.doc.off("changeNewLineMode", this.onChangeNewLineMode);
            this.session = session;
            if (session && this.scrollMargin.top && session.getScrollTop() <= 0)
              session.setScrollTop(-this.scrollMargin.top);
            this.$cursorLayer.setSession(session);
            this.$markerBack.setSession(session);
            this.$markerFront.setSession(session);
            this.$gutterLayer.setSession(session);
            this.$textLayer.setSession(session);
            if (!session)
              return;
            this.$loop.schedule(this.CHANGE_FULL);
            this.session.$setFontMetrics(this.$fontMetrics);
            this.scrollBarH.scrollLeft = this.scrollBarV.scrollTop = null;
            this.onChangeNewLineMode = this.onChangeNewLineMode.bind(this);
            this.onChangeNewLineMode();
            this.session.doc.on("changeNewLineMode", this.onChangeNewLineMode);
          };
          VirtualRenderer2.prototype.updateLines = function(firstRow, lastRow, force) {
            if (lastRow === void 0)
              lastRow = Infinity;
            if (!this.$changedLines) {
              this.$changedLines = {
                firstRow,
                lastRow
              };
            } else {
              if (this.$changedLines.firstRow > firstRow)
                this.$changedLines.firstRow = firstRow;
              if (this.$changedLines.lastRow < lastRow)
                this.$changedLines.lastRow = lastRow;
            }
            if (this.$changedLines.lastRow < this.layerConfig.firstRow) {
              if (force)
                this.$changedLines.lastRow = this.layerConfig.lastRow;
              else
                return;
            }
            if (this.$changedLines.firstRow > this.layerConfig.lastRow)
              return;
            this.$loop.schedule(this.CHANGE_LINES);
          };
          VirtualRenderer2.prototype.onChangeNewLineMode = function() {
            this.$loop.schedule(this.CHANGE_TEXT);
            this.$textLayer.$updateEolChar();
            this.session.$bidiHandler.setEolChar(this.$textLayer.EOL_CHAR);
          };
          VirtualRenderer2.prototype.onChangeTabSize = function() {
            this.$loop.schedule(this.CHANGE_TEXT | this.CHANGE_MARKER);
            this.$textLayer.onChangeTabSize();
          };
          VirtualRenderer2.prototype.updateText = function() {
            this.$loop.schedule(this.CHANGE_TEXT);
          };
          VirtualRenderer2.prototype.updateFull = function(force) {
            if (force)
              this.$renderChanges(this.CHANGE_FULL, true);
            else
              this.$loop.schedule(this.CHANGE_FULL);
          };
          VirtualRenderer2.prototype.updateFontSize = function() {
            this.$textLayer.checkForSizeChanges();
          };
          VirtualRenderer2.prototype.$updateSizeAsync = function() {
            if (this.$loop.pending)
              this.$size.$dirty = true;
            else
              this.onResize();
          };
          VirtualRenderer2.prototype.onResize = function(force, gutterWidth, width, height) {
            if (this.resizing > 2)
              return;
            else if (this.resizing > 0)
              this.resizing++;
            else
              this.resizing = force ? 1 : 0;
            var el = this.container;
            if (!height)
              height = el.clientHeight || el.scrollHeight;
            if (!height && this.$maxLines && this.lineHeight > 1) {
              if (!el.style.height || el.style.height == "0px") {
                el.style.height = "1px";
                height = el.clientHeight || el.scrollHeight;
              }
            }
            if (!width)
              width = el.clientWidth || el.scrollWidth;
            var changes = this.$updateCachedSize(force, gutterWidth, width, height);
            if (this.$resizeTimer)
              this.$resizeTimer.cancel();
            if (!this.$size.scrollerHeight || !width && !height)
              return this.resizing = 0;
            if (force)
              this.$gutterLayer.$padding = null;
            if (force)
              this.$renderChanges(changes | this.$changes, true);
            else
              this.$loop.schedule(changes | this.$changes);
            if (this.resizing)
              this.resizing = 0;
            this.scrollBarH.scrollLeft = this.scrollBarV.scrollTop = null;
            if (this.$customScrollbar) {
              this.$updateCustomScrollbar(true);
            }
          };
          VirtualRenderer2.prototype.$updateCachedSize = function(force, gutterWidth, width, height) {
            height -= this.$extraHeight || 0;
            var changes = 0;
            var size = this.$size;
            var oldSize = {
              width: size.width,
              height: size.height,
              scrollerHeight: size.scrollerHeight,
              scrollerWidth: size.scrollerWidth
            };
            if (height && (force || size.height != height)) {
              size.height = height;
              changes |= this.CHANGE_SIZE;
              size.scrollerHeight = size.height;
              if (this.$horizScroll)
                size.scrollerHeight -= this.scrollBarH.getHeight();
              this.scrollBarV.setHeight(size.scrollerHeight);
              this.scrollBarV.element.style.bottom = this.scrollBarH.getHeight() + "px";
              changes = changes | this.CHANGE_SCROLL;
            }
            if (width && (force || size.width != width)) {
              changes |= this.CHANGE_SIZE;
              size.width = width;
              if (gutterWidth == null)
                gutterWidth = this.$showGutter ? this.$gutter.offsetWidth : 0;
              this.gutterWidth = gutterWidth;
              dom.setStyle(this.scrollBarH.element.style, "left", gutterWidth + "px");
              dom.setStyle(this.scroller.style, "left", gutterWidth + this.margin.left + "px");
              size.scrollerWidth = Math.max(0, width - gutterWidth - this.scrollBarV.getWidth() - this.margin.h);
              dom.setStyle(this.$gutter.style, "left", this.margin.left + "px");
              var right = this.scrollBarV.getWidth() + "px";
              dom.setStyle(this.scrollBarH.element.style, "right", right);
              dom.setStyle(this.scroller.style, "right", right);
              dom.setStyle(this.scroller.style, "bottom", this.scrollBarH.getHeight());
              this.scrollBarH.setWidth(size.scrollerWidth);
              if (this.session && this.session.getUseWrapMode() && this.adjustWrapLimit() || force) {
                changes |= this.CHANGE_FULL;
              }
            }
            size.$dirty = !width || !height;
            if (changes)
              this._signal("resize", oldSize);
            return changes;
          };
          VirtualRenderer2.prototype.onGutterResize = function(width) {
            var gutterWidth = this.$showGutter ? width : 0;
            if (gutterWidth != this.gutterWidth)
              this.$changes |= this.$updateCachedSize(true, gutterWidth, this.$size.width, this.$size.height);
            if (this.session.getUseWrapMode() && this.adjustWrapLimit()) {
              this.$loop.schedule(this.CHANGE_FULL);
            } else if (this.$size.$dirty) {
              this.$loop.schedule(this.CHANGE_FULL);
            } else {
              this.$computeLayerConfig();
            }
          };
          VirtualRenderer2.prototype.adjustWrapLimit = function() {
            var availableWidth = this.$size.scrollerWidth - this.$padding * 2;
            var limit = Math.floor(availableWidth / this.characterWidth);
            return this.session.adjustWrapLimit(limit, this.$showPrintMargin && this.$printMarginColumn);
          };
          VirtualRenderer2.prototype.setAnimatedScroll = function(shouldAnimate) {
            this.setOption("animatedScroll", shouldAnimate);
          };
          VirtualRenderer2.prototype.getAnimatedScroll = function() {
            return this.$animatedScroll;
          };
          VirtualRenderer2.prototype.setShowInvisibles = function(showInvisibles) {
            this.setOption("showInvisibles", showInvisibles);
            this.session.$bidiHandler.setShowInvisibles(showInvisibles);
          };
          VirtualRenderer2.prototype.getShowInvisibles = function() {
            return this.getOption("showInvisibles");
          };
          VirtualRenderer2.prototype.getDisplayIndentGuides = function() {
            return this.getOption("displayIndentGuides");
          };
          VirtualRenderer2.prototype.setDisplayIndentGuides = function(display) {
            this.setOption("displayIndentGuides", display);
          };
          VirtualRenderer2.prototype.getHighlightIndentGuides = function() {
            return this.getOption("highlightIndentGuides");
          };
          VirtualRenderer2.prototype.setHighlightIndentGuides = function(highlight) {
            this.setOption("highlightIndentGuides", highlight);
          };
          VirtualRenderer2.prototype.setShowPrintMargin = function(showPrintMargin) {
            this.setOption("showPrintMargin", showPrintMargin);
          };
          VirtualRenderer2.prototype.getShowPrintMargin = function() {
            return this.getOption("showPrintMargin");
          };
          VirtualRenderer2.prototype.setPrintMarginColumn = function(printMarginColumn) {
            this.setOption("printMarginColumn", printMarginColumn);
          };
          VirtualRenderer2.prototype.getPrintMarginColumn = function() {
            return this.getOption("printMarginColumn");
          };
          VirtualRenderer2.prototype.getShowGutter = function() {
            return this.getOption("showGutter");
          };
          VirtualRenderer2.prototype.setShowGutter = function(show) {
            return this.setOption("showGutter", show);
          };
          VirtualRenderer2.prototype.getFadeFoldWidgets = function() {
            return this.getOption("fadeFoldWidgets");
          };
          VirtualRenderer2.prototype.setFadeFoldWidgets = function(show) {
            this.setOption("fadeFoldWidgets", show);
          };
          VirtualRenderer2.prototype.setHighlightGutterLine = function(shouldHighlight) {
            this.setOption("highlightGutterLine", shouldHighlight);
          };
          VirtualRenderer2.prototype.getHighlightGutterLine = function() {
            return this.getOption("highlightGutterLine");
          };
          VirtualRenderer2.prototype.$updatePrintMargin = function() {
            if (!this.$showPrintMargin && !this.$printMarginEl)
              return;
            if (!this.$printMarginEl) {
              var containerEl = dom.createElement("div");
              containerEl.className = "ace_layer ace_print-margin-layer";
              this.$printMarginEl = dom.createElement("div");
              this.$printMarginEl.className = "ace_print-margin";
              containerEl.appendChild(this.$printMarginEl);
              this.content.insertBefore(containerEl, this.content.firstChild);
            }
            var style = this.$printMarginEl.style;
            style.left = Math.round(this.characterWidth * this.$printMarginColumn + this.$padding) + "px";
            style.visibility = this.$showPrintMargin ? "visible" : "hidden";
            if (this.session && this.session.$wrap == -1)
              this.adjustWrapLimit();
          };
          VirtualRenderer2.prototype.getContainerElement = function() {
            return this.container;
          };
          VirtualRenderer2.prototype.getMouseEventTarget = function() {
            return this.scroller;
          };
          VirtualRenderer2.prototype.getTextAreaContainer = function() {
            return this.container;
          };
          VirtualRenderer2.prototype.$moveTextAreaToCursor = function() {
            if (this.$isMousePressed)
              return;
            var style = this.textarea.style;
            var composition = this.$composition;
            if (!this.$keepTextAreaAtCursor && !composition) {
              dom.translate(this.textarea, -100, 0);
              return;
            }
            var pixelPos = this.$cursorLayer.$pixelPos;
            if (!pixelPos)
              return;
            if (composition && composition.markerRange)
              pixelPos = this.$cursorLayer.getPixelPosition(composition.markerRange.start, true);
            var config2 = this.layerConfig;
            var posTop = pixelPos.top;
            var posLeft = pixelPos.left;
            posTop -= config2.offset;
            var h3 = composition && composition.useTextareaForIME || useragent.isMobile ? this.lineHeight : 1;
            if (posTop < 0 || posTop > config2.height - h3) {
              dom.translate(this.textarea, 0, 0);
              return;
            }
            var w2 = 1;
            var maxTop = this.$size.height - h3;
            if (!composition) {
              posTop += this.lineHeight;
            } else {
              if (composition.useTextareaForIME) {
                var val = this.textarea.value;
                w2 = this.characterWidth * this.session.$getStringScreenWidth(val)[0];
              } else {
                posTop += this.lineHeight + 2;
              }
            }
            posLeft -= this.scrollLeft;
            if (posLeft > this.$size.scrollerWidth - w2)
              posLeft = this.$size.scrollerWidth - w2;
            posLeft += this.gutterWidth + this.margin.left;
            dom.setStyle(style, "height", h3 + "px");
            dom.setStyle(style, "width", w2 + "px");
            dom.translate(this.textarea, Math.min(posLeft, this.$size.scrollerWidth - w2), Math.min(posTop, maxTop));
          };
          VirtualRenderer2.prototype.getFirstVisibleRow = function() {
            return this.layerConfig.firstRow;
          };
          VirtualRenderer2.prototype.getFirstFullyVisibleRow = function() {
            return this.layerConfig.firstRow + (this.layerConfig.offset === 0 ? 0 : 1);
          };
          VirtualRenderer2.prototype.getLastFullyVisibleRow = function() {
            var config2 = this.layerConfig;
            var lastRow = config2.lastRow;
            var top = this.session.documentToScreenRow(lastRow, 0) * config2.lineHeight;
            if (top - this.session.getScrollTop() > config2.height - config2.lineHeight)
              return lastRow - 1;
            return lastRow;
          };
          VirtualRenderer2.prototype.getLastVisibleRow = function() {
            return this.layerConfig.lastRow;
          };
          VirtualRenderer2.prototype.setPadding = function(padding) {
            this.$padding = padding;
            this.$textLayer.setPadding(padding);
            this.$cursorLayer.setPadding(padding);
            this.$markerFront.setPadding(padding);
            this.$markerBack.setPadding(padding);
            this.$loop.schedule(this.CHANGE_FULL);
            this.$updatePrintMargin();
          };
          VirtualRenderer2.prototype.setScrollMargin = function(top, bottom, left, right) {
            var sm = this.scrollMargin;
            sm.top = top | 0;
            sm.bottom = bottom | 0;
            sm.right = right | 0;
            sm.left = left | 0;
            sm.v = sm.top + sm.bottom;
            sm.h = sm.left + sm.right;
            if (sm.top && this.scrollTop <= 0 && this.session)
              this.session.setScrollTop(-sm.top);
            this.updateFull();
          };
          VirtualRenderer2.prototype.setMargin = function(top, bottom, left, right) {
            var sm = this.margin;
            sm.top = top | 0;
            sm.bottom = bottom | 0;
            sm.right = right | 0;
            sm.left = left | 0;
            sm.v = sm.top + sm.bottom;
            sm.h = sm.left + sm.right;
            this.$updateCachedSize(true, this.gutterWidth, this.$size.width, this.$size.height);
            this.updateFull();
          };
          VirtualRenderer2.prototype.getHScrollBarAlwaysVisible = function() {
            return this.$hScrollBarAlwaysVisible;
          };
          VirtualRenderer2.prototype.setHScrollBarAlwaysVisible = function(alwaysVisible) {
            this.setOption("hScrollBarAlwaysVisible", alwaysVisible);
          };
          VirtualRenderer2.prototype.getVScrollBarAlwaysVisible = function() {
            return this.$vScrollBarAlwaysVisible;
          };
          VirtualRenderer2.prototype.setVScrollBarAlwaysVisible = function(alwaysVisible) {
            this.setOption("vScrollBarAlwaysVisible", alwaysVisible);
          };
          VirtualRenderer2.prototype.$updateScrollBarV = function() {
            var scrollHeight = this.layerConfig.maxHeight;
            var scrollerHeight = this.$size.scrollerHeight;
            if (!this.$maxLines && this.$scrollPastEnd) {
              scrollHeight -= (scrollerHeight - this.lineHeight) * this.$scrollPastEnd;
              if (this.scrollTop > scrollHeight - scrollerHeight) {
                scrollHeight = this.scrollTop + scrollerHeight;
                this.scrollBarV.scrollTop = null;
              }
            }
            this.scrollBarV.setScrollHeight(scrollHeight + this.scrollMargin.v);
            this.scrollBarV.setScrollTop(this.scrollTop + this.scrollMargin.top);
          };
          VirtualRenderer2.prototype.$updateScrollBarH = function() {
            this.scrollBarH.setScrollWidth(this.layerConfig.width + 2 * this.$padding + this.scrollMargin.h);
            this.scrollBarH.setScrollLeft(this.scrollLeft + this.scrollMargin.left);
          };
          VirtualRenderer2.prototype.freeze = function() {
            this.$frozen = true;
          };
          VirtualRenderer2.prototype.unfreeze = function() {
            this.$frozen = false;
          };
          VirtualRenderer2.prototype.$renderChanges = function(changes, force) {
            if (this.$changes) {
              changes |= this.$changes;
              this.$changes = 0;
            }
            if (!this.session || !this.container.offsetWidth || this.$frozen || !changes && !force) {
              this.$changes |= changes;
              return;
            }
            if (this.$size.$dirty) {
              this.$changes |= changes;
              return this.onResize(true);
            }
            if (!this.lineHeight) {
              this.$textLayer.checkForSizeChanges();
            }
            this._signal("beforeRender", changes);
            if (this.session && this.session.$bidiHandler)
              this.session.$bidiHandler.updateCharacterWidths(this.$fontMetrics);
            var config2 = this.layerConfig;
            if (changes & this.CHANGE_FULL || changes & this.CHANGE_SIZE || changes & this.CHANGE_TEXT || changes & this.CHANGE_LINES || changes & this.CHANGE_SCROLL || changes & this.CHANGE_H_SCROLL) {
              changes |= this.$computeLayerConfig() | this.$loop.clear();
              if (config2.firstRow != this.layerConfig.firstRow && config2.firstRowScreen == this.layerConfig.firstRowScreen) {
                var st = this.scrollTop + (config2.firstRow - Math.max(this.layerConfig.firstRow, 0)) * this.lineHeight;
                if (st > 0) {
                  this.scrollTop = st;
                  changes = changes | this.CHANGE_SCROLL;
                  changes |= this.$computeLayerConfig() | this.$loop.clear();
                }
              }
              config2 = this.layerConfig;
              this.$updateScrollBarV();
              if (changes & this.CHANGE_H_SCROLL)
                this.$updateScrollBarH();
              dom.translate(this.content, -this.scrollLeft, -config2.offset);
              var width = config2.width + 2 * this.$padding + "px";
              var height = config2.minHeight + "px";
              dom.setStyle(this.content.style, "width", width);
              dom.setStyle(this.content.style, "height", height);
            }
            if (changes & this.CHANGE_H_SCROLL) {
              dom.translate(this.content, -this.scrollLeft, -config2.offset);
              this.scroller.className = this.scrollLeft <= 0 ? "ace_scroller " : "ace_scroller ace_scroll-left ";
              if (this.enableKeyboardAccessibility)
                this.scroller.className += this.keyboardFocusClassName;
            }
            if (changes & this.CHANGE_FULL) {
              this.$changedLines = null;
              this.$textLayer.update(config2);
              if (this.$showGutter)
                this.$gutterLayer.update(config2);
              if (this.$customScrollbar) {
                this.$scrollDecorator.$updateDecorators(config2);
              }
              this.$markerBack.update(config2);
              this.$markerFront.update(config2);
              this.$cursorLayer.update(config2);
              this.$moveTextAreaToCursor();
              this._signal("afterRender", changes);
              return;
            }
            if (changes & this.CHANGE_SCROLL) {
              this.$changedLines = null;
              if (changes & this.CHANGE_TEXT || changes & this.CHANGE_LINES)
                this.$textLayer.update(config2);
              else
                this.$textLayer.scrollLines(config2);
              if (this.$showGutter) {
                if (changes & this.CHANGE_GUTTER || changes & this.CHANGE_LINES)
                  this.$gutterLayer.update(config2);
                else
                  this.$gutterLayer.scrollLines(config2);
              }
              if (this.$customScrollbar) {
                this.$scrollDecorator.$updateDecorators(config2);
              }
              this.$markerBack.update(config2);
              this.$markerFront.update(config2);
              this.$cursorLayer.update(config2);
              this.$moveTextAreaToCursor();
              this._signal("afterRender", changes);
              return;
            }
            if (changes & this.CHANGE_TEXT) {
              this.$changedLines = null;
              this.$textLayer.update(config2);
              if (this.$showGutter)
                this.$gutterLayer.update(config2);
              if (this.$customScrollbar) {
                this.$scrollDecorator.$updateDecorators(config2);
              }
            } else if (changes & this.CHANGE_LINES) {
              if (this.$updateLines() || changes & this.CHANGE_GUTTER && this.$showGutter)
                this.$gutterLayer.update(config2);
              if (this.$customScrollbar) {
                this.$scrollDecorator.$updateDecorators(config2);
              }
            } else if (changes & this.CHANGE_TEXT || changes & this.CHANGE_GUTTER) {
              if (this.$showGutter)
                this.$gutterLayer.update(config2);
              if (this.$customScrollbar) {
                this.$scrollDecorator.$updateDecorators(config2);
              }
            } else if (changes & this.CHANGE_CURSOR) {
              if (this.$highlightGutterLine)
                this.$gutterLayer.updateLineHighlight(config2);
              if (this.$customScrollbar) {
                this.$scrollDecorator.$updateDecorators(config2);
              }
            }
            if (changes & this.CHANGE_CURSOR) {
              this.$cursorLayer.update(config2);
              this.$moveTextAreaToCursor();
            }
            if (changes & (this.CHANGE_MARKER | this.CHANGE_MARKER_FRONT)) {
              this.$markerFront.update(config2);
            }
            if (changes & (this.CHANGE_MARKER | this.CHANGE_MARKER_BACK)) {
              this.$markerBack.update(config2);
            }
            this._signal("afterRender", changes);
          };
          VirtualRenderer2.prototype.$autosize = function() {
            var height = this.session.getScreenLength() * this.lineHeight;
            var maxHeight = this.$maxLines * this.lineHeight;
            var desiredHeight = Math.min(maxHeight, Math.max((this.$minLines || 1) * this.lineHeight, height)) + this.scrollMargin.v + (this.$extraHeight || 0);
            if (this.$horizScroll)
              desiredHeight += this.scrollBarH.getHeight();
            if (this.$maxPixelHeight && desiredHeight > this.$maxPixelHeight)
              desiredHeight = this.$maxPixelHeight;
            var hideScrollbars = desiredHeight <= 2 * this.lineHeight;
            var vScroll = !hideScrollbars && height > maxHeight;
            if (desiredHeight != this.desiredHeight || this.$size.height != this.desiredHeight || vScroll != this.$vScroll) {
              if (vScroll != this.$vScroll) {
                this.$vScroll = vScroll;
                this.scrollBarV.setVisible(vScroll);
              }
              var w2 = this.container.clientWidth;
              this.container.style.height = desiredHeight + "px";
              this.$updateCachedSize(true, this.$gutterWidth, w2, desiredHeight);
              this.desiredHeight = desiredHeight;
              this._signal("autosize");
            }
          };
          VirtualRenderer2.prototype.$computeLayerConfig = function() {
            var session = this.session;
            var size = this.$size;
            var hideScrollbars = size.height <= 2 * this.lineHeight;
            var screenLines = this.session.getScreenLength();
            var maxHeight = screenLines * this.lineHeight;
            var longestLine = this.$getLongestLine();
            var horizScroll = !hideScrollbars && (this.$hScrollBarAlwaysVisible || size.scrollerWidth - longestLine - 2 * this.$padding < 0);
            var hScrollChanged = this.$horizScroll !== horizScroll;
            if (hScrollChanged) {
              this.$horizScroll = horizScroll;
              this.scrollBarH.setVisible(horizScroll);
            }
            var vScrollBefore = this.$vScroll;
            if (this.$maxLines && this.lineHeight > 1) {
              this.$autosize();
              hideScrollbars = size.height <= 2 * this.lineHeight;
            }
            var minHeight = size.scrollerHeight + this.lineHeight;
            var scrollPastEnd = !this.$maxLines && this.$scrollPastEnd ? (size.scrollerHeight - this.lineHeight) * this.$scrollPastEnd : 0;
            maxHeight += scrollPastEnd;
            var sm = this.scrollMargin;
            this.session.setScrollTop(Math.max(-sm.top, Math.min(this.scrollTop, maxHeight - size.scrollerHeight + sm.bottom)));
            this.session.setScrollLeft(Math.max(-sm.left, Math.min(this.scrollLeft, longestLine + 2 * this.$padding - size.scrollerWidth + sm.right)));
            var vScroll = !hideScrollbars && (this.$vScrollBarAlwaysVisible || size.scrollerHeight - maxHeight + scrollPastEnd < 0 || this.scrollTop > sm.top);
            var vScrollChanged = vScrollBefore !== vScroll;
            if (vScrollChanged) {
              this.$vScroll = vScroll;
              this.scrollBarV.setVisible(vScroll);
            }
            var offset = this.scrollTop % this.lineHeight;
            var lineCount = Math.ceil(minHeight / this.lineHeight) - 1;
            var firstRow = Math.max(0, Math.round((this.scrollTop - offset) / this.lineHeight));
            var lastRow = firstRow + lineCount;
            var firstRowScreen, firstRowHeight;
            var lineHeight = this.lineHeight;
            firstRow = session.screenToDocumentRow(firstRow, 0);
            var foldLine = session.getFoldLine(firstRow);
            if (foldLine) {
              firstRow = foldLine.start.row;
            }
            firstRowScreen = session.documentToScreenRow(firstRow, 0);
            firstRowHeight = session.getRowLength(firstRow) * lineHeight;
            lastRow = Math.min(session.screenToDocumentRow(lastRow, 0), session.getLength() - 1);
            minHeight = size.scrollerHeight + session.getRowLength(lastRow) * lineHeight + firstRowHeight;
            offset = this.scrollTop - firstRowScreen * lineHeight;
            var changes = 0;
            if (this.layerConfig.width != longestLine || hScrollChanged)
              changes = this.CHANGE_H_SCROLL;
            if (hScrollChanged || vScrollChanged) {
              changes |= this.$updateCachedSize(true, this.gutterWidth, size.width, size.height);
              this._signal("scrollbarVisibilityChanged");
              if (vScrollChanged)
                longestLine = this.$getLongestLine();
            }
            this.layerConfig = {
              width: longestLine,
              padding: this.$padding,
              firstRow,
              firstRowScreen,
              lastRow,
              lineHeight,
              characterWidth: this.characterWidth,
              minHeight,
              maxHeight,
              offset,
              gutterOffset: lineHeight ? Math.max(0, Math.ceil((offset + size.height - size.scrollerHeight) / lineHeight)) : 0,
              height: this.$size.scrollerHeight
            };
            if (this.session.$bidiHandler)
              this.session.$bidiHandler.setContentWidth(longestLine - this.$padding);
            return changes;
          };
          VirtualRenderer2.prototype.$updateLines = function() {
            if (!this.$changedLines)
              return;
            var firstRow = this.$changedLines.firstRow;
            var lastRow = this.$changedLines.lastRow;
            this.$changedLines = null;
            var layerConfig = this.layerConfig;
            if (firstRow > layerConfig.lastRow + 1) {
              return;
            }
            if (lastRow < layerConfig.firstRow) {
              return;
            }
            if (lastRow === Infinity) {
              if (this.$showGutter)
                this.$gutterLayer.update(layerConfig);
              this.$textLayer.update(layerConfig);
              return;
            }
            this.$textLayer.updateLines(layerConfig, firstRow, lastRow);
            return true;
          };
          VirtualRenderer2.prototype.$getLongestLine = function() {
            var charCount = this.session.getScreenWidth();
            if (this.showInvisibles && !this.session.$useWrapMode)
              charCount += 1;
            if (this.$textLayer && charCount > this.$textLayer.MAX_LINE_LENGTH)
              charCount = this.$textLayer.MAX_LINE_LENGTH + 30;
            return Math.max(this.$size.scrollerWidth - 2 * this.$padding, Math.round(charCount * this.characterWidth));
          };
          VirtualRenderer2.prototype.updateFrontMarkers = function() {
            this.$markerFront.setMarkers(this.session.getMarkers(true));
            this.$loop.schedule(this.CHANGE_MARKER_FRONT);
          };
          VirtualRenderer2.prototype.updateBackMarkers = function() {
            this.$markerBack.setMarkers(this.session.getMarkers());
            this.$loop.schedule(this.CHANGE_MARKER_BACK);
          };
          VirtualRenderer2.prototype.addGutterDecoration = function(row, className) {
            this.$gutterLayer.addGutterDecoration(row, className);
          };
          VirtualRenderer2.prototype.removeGutterDecoration = function(row, className) {
            this.$gutterLayer.removeGutterDecoration(row, className);
          };
          VirtualRenderer2.prototype.updateBreakpoints = function(rows) {
            this._rows = rows;
            this.$loop.schedule(this.CHANGE_GUTTER);
          };
          VirtualRenderer2.prototype.setAnnotations = function(annotations) {
            this.$gutterLayer.setAnnotations(annotations);
            this.$loop.schedule(this.CHANGE_GUTTER);
          };
          VirtualRenderer2.prototype.updateCursor = function() {
            this.$loop.schedule(this.CHANGE_CURSOR);
          };
          VirtualRenderer2.prototype.hideCursor = function() {
            this.$cursorLayer.hideCursor();
          };
          VirtualRenderer2.prototype.showCursor = function() {
            this.$cursorLayer.showCursor();
          };
          VirtualRenderer2.prototype.scrollSelectionIntoView = function(anchor, lead, offset) {
            this.scrollCursorIntoView(anchor, offset);
            this.scrollCursorIntoView(lead, offset);
          };
          VirtualRenderer2.prototype.scrollCursorIntoView = function(cursor, offset, $viewMargin) {
            if (this.$size.scrollerHeight === 0)
              return;
            var pos = this.$cursorLayer.getPixelPosition(cursor);
            var newLeft = pos.left;
            var newTop = pos.top;
            var topMargin = $viewMargin && $viewMargin.top || 0;
            var bottomMargin = $viewMargin && $viewMargin.bottom || 0;
            if (this.$scrollAnimation) {
              this.$stopAnimation = true;
            }
            var currentTop = this.$scrollAnimation ? this.session.getScrollTop() : this.scrollTop;
            if (currentTop + topMargin > newTop) {
              if (offset && currentTop + topMargin > newTop + this.lineHeight)
                newTop -= offset * this.$size.scrollerHeight;
              if (newTop === 0)
                newTop = -this.scrollMargin.top;
              this.session.setScrollTop(newTop);
            } else if (currentTop + this.$size.scrollerHeight - bottomMargin < newTop + this.lineHeight) {
              if (offset && currentTop + this.$size.scrollerHeight - bottomMargin < newTop - this.lineHeight)
                newTop += offset * this.$size.scrollerHeight;
              this.session.setScrollTop(newTop + this.lineHeight + bottomMargin - this.$size.scrollerHeight);
            }
            var currentLeft = this.scrollLeft;
            var twoCharsWidth = 2 * this.layerConfig.characterWidth;
            if (newLeft - twoCharsWidth < currentLeft) {
              newLeft -= twoCharsWidth;
              if (newLeft < this.$padding + twoCharsWidth) {
                newLeft = -this.scrollMargin.left;
              }
              this.session.setScrollLeft(newLeft);
            } else {
              newLeft += twoCharsWidth;
              if (currentLeft + this.$size.scrollerWidth < newLeft + this.characterWidth) {
                this.session.setScrollLeft(Math.round(newLeft + this.characterWidth - this.$size.scrollerWidth));
              } else if (currentLeft <= this.$padding && newLeft - currentLeft < this.characterWidth) {
                this.session.setScrollLeft(0);
              }
            }
          };
          VirtualRenderer2.prototype.getScrollTop = function() {
            return this.session.getScrollTop();
          };
          VirtualRenderer2.prototype.getScrollLeft = function() {
            return this.session.getScrollLeft();
          };
          VirtualRenderer2.prototype.getScrollTopRow = function() {
            return this.scrollTop / this.lineHeight;
          };
          VirtualRenderer2.prototype.getScrollBottomRow = function() {
            return Math.max(0, Math.floor((this.scrollTop + this.$size.scrollerHeight) / this.lineHeight) - 1);
          };
          VirtualRenderer2.prototype.scrollToRow = function(row) {
            this.session.setScrollTop(row * this.lineHeight);
          };
          VirtualRenderer2.prototype.alignCursor = function(cursor, alignment) {
            if (typeof cursor == "number")
              cursor = { row: cursor, column: 0 };
            var pos = this.$cursorLayer.getPixelPosition(cursor);
            var h3 = this.$size.scrollerHeight - this.lineHeight;
            var offset = pos.top - h3 * (alignment || 0);
            this.session.setScrollTop(offset);
            return offset;
          };
          VirtualRenderer2.prototype.$calcSteps = function(fromValue, toValue) {
            var i2 = 0;
            var l = this.STEPS;
            var steps = [];
            var func = function(t2, x_min, dx) {
              return dx * (Math.pow(t2 - 1, 3) + 1) + x_min;
            };
            for (i2 = 0; i2 < l; ++i2)
              steps.push(func(i2 / this.STEPS, fromValue, toValue - fromValue));
            return steps;
          };
          VirtualRenderer2.prototype.scrollToLine = function(line, center, animate, callback) {
            var pos = this.$cursorLayer.getPixelPosition({ row: line, column: 0 });
            var offset = pos.top;
            if (center)
              offset -= this.$size.scrollerHeight / 2;
            var initialScroll = this.scrollTop;
            this.session.setScrollTop(offset);
            if (animate !== false)
              this.animateScrolling(initialScroll, callback);
          };
          VirtualRenderer2.prototype.animateScrolling = function(fromValue, callback) {
            var toValue = this.scrollTop;
            if (!this.$animatedScroll)
              return;
            var _self = this;
            if (fromValue == toValue)
              return;
            if (this.$scrollAnimation) {
              var oldSteps = this.$scrollAnimation.steps;
              if (oldSteps.length) {
                fromValue = oldSteps[0];
                if (fromValue == toValue)
                  return;
              }
            }
            var steps = _self.$calcSteps(fromValue, toValue);
            this.$scrollAnimation = { from: fromValue, to: toValue, steps };
            clearInterval(this.$timer);
            _self.session.setScrollTop(steps.shift());
            _self.session.$scrollTop = toValue;
            function endAnimation() {
              _self.$timer = clearInterval(_self.$timer);
              _self.$scrollAnimation = null;
              _self.$stopAnimation = false;
              callback && callback();
            }
            this.$timer = setInterval(function() {
              if (_self.$stopAnimation) {
                endAnimation();
                return;
              }
              if (!_self.session)
                return clearInterval(_self.$timer);
              if (steps.length) {
                _self.session.setScrollTop(steps.shift());
                _self.session.$scrollTop = toValue;
              } else if (toValue != null) {
                _self.session.$scrollTop = -1;
                _self.session.setScrollTop(toValue);
                toValue = null;
              } else {
                endAnimation();
              }
            }, 10);
          };
          VirtualRenderer2.prototype.scrollToY = function(scrollTop) {
            if (this.scrollTop !== scrollTop) {
              this.$loop.schedule(this.CHANGE_SCROLL);
              this.scrollTop = scrollTop;
            }
          };
          VirtualRenderer2.prototype.scrollToX = function(scrollLeft) {
            if (this.scrollLeft !== scrollLeft)
              this.scrollLeft = scrollLeft;
            this.$loop.schedule(this.CHANGE_H_SCROLL);
          };
          VirtualRenderer2.prototype.scrollTo = function(x2, y3) {
            this.session.setScrollTop(y3);
            this.session.setScrollLeft(x2);
          };
          VirtualRenderer2.prototype.scrollBy = function(deltaX, deltaY) {
            deltaY && this.session.setScrollTop(this.session.getScrollTop() + deltaY);
            deltaX && this.session.setScrollLeft(this.session.getScrollLeft() + deltaX);
          };
          VirtualRenderer2.prototype.isScrollableBy = function(deltaX, deltaY) {
            if (deltaY < 0 && this.session.getScrollTop() >= 1 - this.scrollMargin.top)
              return true;
            if (deltaY > 0 && this.session.getScrollTop() + this.$size.scrollerHeight - this.layerConfig.maxHeight < -1 + this.scrollMargin.bottom)
              return true;
            if (deltaX < 0 && this.session.getScrollLeft() >= 1 - this.scrollMargin.left)
              return true;
            if (deltaX > 0 && this.session.getScrollLeft() + this.$size.scrollerWidth - this.layerConfig.width < -1 + this.scrollMargin.right)
              return true;
          };
          VirtualRenderer2.prototype.pixelToScreenCoordinates = function(x2, y3) {
            var canvasPos;
            if (this.$hasCssTransforms) {
              canvasPos = { top: 0, left: 0 };
              var p = this.$fontMetrics.transformCoordinates([x2, y3]);
              x2 = p[1] - this.gutterWidth - this.margin.left;
              y3 = p[0];
            } else {
              canvasPos = this.scroller.getBoundingClientRect();
            }
            var offsetX = x2 + this.scrollLeft - canvasPos.left - this.$padding;
            var offset = offsetX / this.characterWidth;
            var row = Math.floor((y3 + this.scrollTop - canvasPos.top) / this.lineHeight);
            var col = this.$blockCursor ? Math.floor(offset) : Math.round(offset);
            return { row, column: col, side: offset - col > 0 ? 1 : -1, offsetX };
          };
          VirtualRenderer2.prototype.screenToTextCoordinates = function(x2, y3) {
            var canvasPos;
            if (this.$hasCssTransforms) {
              canvasPos = { top: 0, left: 0 };
              var p = this.$fontMetrics.transformCoordinates([x2, y3]);
              x2 = p[1] - this.gutterWidth - this.margin.left;
              y3 = p[0];
            } else {
              canvasPos = this.scroller.getBoundingClientRect();
            }
            var offsetX = x2 + this.scrollLeft - canvasPos.left - this.$padding;
            var offset = offsetX / this.characterWidth;
            var col = this.$blockCursor ? Math.floor(offset) : Math.round(offset);
            var row = Math.floor((y3 + this.scrollTop - canvasPos.top) / this.lineHeight);
            return this.session.screenToDocumentPosition(row, Math.max(col, 0), offsetX);
          };
          VirtualRenderer2.prototype.textToScreenCoordinates = function(row, column) {
            var canvasPos = this.scroller.getBoundingClientRect();
            var pos = this.session.documentToScreenPosition(row, column);
            var x2 = this.$padding + (this.session.$bidiHandler.isBidiRow(pos.row, row) ? this.session.$bidiHandler.getPosLeft(pos.column) : Math.round(pos.column * this.characterWidth));
            var y3 = pos.row * this.lineHeight;
            return {
              pageX: canvasPos.left + x2 - this.scrollLeft,
              pageY: canvasPos.top + y3 - this.scrollTop
            };
          };
          VirtualRenderer2.prototype.visualizeFocus = function() {
            dom.addCssClass(this.container, "ace_focus");
          };
          VirtualRenderer2.prototype.visualizeBlur = function() {
            dom.removeCssClass(this.container, "ace_focus");
          };
          VirtualRenderer2.prototype.showComposition = function(composition) {
            this.$composition = composition;
            if (!composition.cssText) {
              composition.cssText = this.textarea.style.cssText;
            }
            if (composition.useTextareaForIME == void 0)
              composition.useTextareaForIME = this.$useTextareaForIME;
            if (this.$useTextareaForIME) {
              dom.addCssClass(this.textarea, "ace_composition");
              this.textarea.style.cssText = "";
              this.$moveTextAreaToCursor();
              this.$cursorLayer.element.style.display = "none";
            } else {
              composition.markerId = this.session.addMarker(composition.markerRange, "ace_composition_marker", "text");
            }
          };
          VirtualRenderer2.prototype.setCompositionText = function(text) {
            var cursor = this.session.selection.cursor;
            this.addToken(text, "composition_placeholder", cursor.row, cursor.column);
            this.$moveTextAreaToCursor();
          };
          VirtualRenderer2.prototype.hideComposition = function() {
            if (!this.$composition)
              return;
            if (this.$composition.markerId)
              this.session.removeMarker(this.$composition.markerId);
            dom.removeCssClass(this.textarea, "ace_composition");
            this.textarea.style.cssText = this.$composition.cssText;
            var cursor = this.session.selection.cursor;
            this.removeExtraToken(cursor.row, cursor.column);
            this.$composition = null;
            this.$cursorLayer.element.style.display = "";
          };
          VirtualRenderer2.prototype.setGhostText = function(text, position) {
            var cursor = this.session.selection.cursor;
            var insertPosition = position || { row: cursor.row, column: cursor.column };
            this.removeGhostText();
            var textChunks = this.$calculateWrappedTextChunks(text, insertPosition);
            this.addToken(textChunks[0].text, "ghost_text", insertPosition.row, insertPosition.column);
            this.$ghostText = {
              text,
              position: {
                row: insertPosition.row,
                column: insertPosition.column
              }
            };
            var widgetDiv = dom.createElement("div");
            if (textChunks.length > 1) {
              var hiddenTokens = this.hideTokensAfterPosition(insertPosition.row, insertPosition.column);
              var lastLineDiv;
              textChunks.slice(1).forEach(function(el2) {
                var chunkDiv = dom.createElement("div");
                var chunkSpan = dom.createElement("span");
                chunkSpan.className = "ace_ghost_text";
                if (el2.wrapped)
                  chunkDiv.className = "ghost_text_line_wrapped";
                if (el2.text.length === 0)
                  el2.text = " ";
                chunkSpan.appendChild(dom.createTextNode(el2.text));
                chunkDiv.appendChild(chunkSpan);
                widgetDiv.appendChild(chunkDiv);
                lastLineDiv = chunkDiv;
              });
              hiddenTokens.forEach(function(token) {
                var element = dom.createElement("span");
                if (!isTextToken(token.type))
                  element.className = "ace_" + token.type.replace(/\./g, " ace_");
                element.appendChild(dom.createTextNode(token.value));
                lastLineDiv.appendChild(element);
              });
              this.$ghostTextWidget = {
                el: widgetDiv,
                row: insertPosition.row,
                column: insertPosition.column,
                className: "ace_ghost_text_container"
              };
              this.session.widgetManager.addLineWidget(this.$ghostTextWidget);
              var pixelPosition = this.$cursorLayer.getPixelPosition(insertPosition, true);
              var el = this.container;
              var height = el.getBoundingClientRect().height;
              var ghostTextHeight = textChunks.length * this.lineHeight;
              var fitsY = ghostTextHeight < height - pixelPosition.top;
              if (fitsY)
                return;
              if (ghostTextHeight < height) {
                this.scrollBy(0, (textChunks.length - 1) * this.lineHeight);
              } else {
                this.scrollToRow(insertPosition.row);
              }
            }
          };
          VirtualRenderer2.prototype.$calculateWrappedTextChunks = function(text, position) {
            var availableWidth = this.$size.scrollerWidth - this.$padding * 2;
            var limit = Math.floor(availableWidth / this.characterWidth) - 2;
            limit = limit <= 0 ? 60 : limit;
            var textLines = text.split(/\r?\n/);
            var textChunks = [];
            for (var i2 = 0; i2 < textLines.length; i2++) {
              var displayTokens = this.session.$getDisplayTokens(textLines[i2], position.column);
              var wrapSplits = this.session.$computeWrapSplits(displayTokens, limit, this.session.$tabSize);
              if (wrapSplits.length > 0) {
                var start = 0;
                wrapSplits.push(textLines[i2].length);
                for (var j = 0; j < wrapSplits.length; j++) {
                  var textSlice = textLines[i2].slice(start, wrapSplits[j]);
                  textChunks.push({ text: textSlice, wrapped: true });
                  start = wrapSplits[j];
                }
              } else {
                textChunks.push({ text: textLines[i2], wrapped: false });
              }
            }
            return textChunks;
          };
          VirtualRenderer2.prototype.removeGhostText = function() {
            if (!this.$ghostText)
              return;
            var position = this.$ghostText.position;
            this.removeExtraToken(position.row, position.column);
            if (this.$ghostTextWidget) {
              this.session.widgetManager.removeLineWidget(this.$ghostTextWidget);
              this.$ghostTextWidget = null;
            }
            this.$ghostText = null;
          };
          VirtualRenderer2.prototype.addToken = function(text, type, row, column) {
            var session = this.session;
            session.bgTokenizer.lines[row] = null;
            var newToken = { type, value: text };
            var tokens = session.getTokens(row);
            if (column == null || !tokens.length) {
              tokens.push(newToken);
            } else {
              var l = 0;
              for (var i2 = 0; i2 < tokens.length; i2++) {
                var token = tokens[i2];
                l += token.value.length;
                if (column <= l) {
                  var diff = token.value.length - (l - column);
                  var before = token.value.slice(0, diff);
                  var after = token.value.slice(diff);
                  tokens.splice(i2, 1, { type: token.type, value: before }, newToken, { type: token.type, value: after });
                  break;
                }
              }
            }
            this.updateLines(row, row);
          };
          VirtualRenderer2.prototype.hideTokensAfterPosition = function(row, column) {
            var tokens = this.session.getTokens(row);
            var l = 0;
            var hasPassedCursor = false;
            var hiddenTokens = [];
            for (var i2 = 0; i2 < tokens.length; i2++) {
              var token = tokens[i2];
              l += token.value.length;
              if (token.type === "ghost_text")
                continue;
              if (hasPassedCursor) {
                hiddenTokens.push({ type: token.type, value: token.value });
                token.type = "hidden_token";
                continue;
              }
              if (l === column) {
                hasPassedCursor = true;
              }
            }
            this.updateLines(row, row);
            return hiddenTokens;
          };
          VirtualRenderer2.prototype.removeExtraToken = function(row, column) {
            this.session.bgTokenizer.lines[row] = null;
            this.updateLines(row, row);
          };
          VirtualRenderer2.prototype.setTheme = function(theme, cb) {
            var _self = this;
            this.$themeId = theme;
            _self._dispatchEvent("themeChange", { theme });
            if (!theme || typeof theme == "string") {
              var moduleName = theme || this.$options.theme.initialValue;
              config.loadModule(["theme", moduleName], afterLoad);
            } else {
              afterLoad(theme);
            }
            function afterLoad(module4) {
              if (_self.$themeId != theme)
                return cb && cb();
              if (!module4 || !module4.cssClass)
                throw new Error("couldn't load module " + theme + " or it didn't call define");
              if (module4.$id)
                _self.$themeId = module4.$id;
              dom.importCssString(module4.cssText, module4.cssClass, _self.container);
              if (_self.theme)
                dom.removeCssClass(_self.container, _self.theme.cssClass);
              var padding = "padding" in module4 ? module4.padding : "padding" in (_self.theme || {}) ? 4 : _self.$padding;
              if (_self.$padding && padding != _self.$padding)
                _self.setPadding(padding);
              _self.$theme = module4.cssClass;
              _self.theme = module4;
              dom.addCssClass(_self.container, module4.cssClass);
              dom.setCssClass(_self.container, "ace_dark", module4.isDark);
              if (_self.$size) {
                _self.$size.width = 0;
                _self.$updateSizeAsync();
              }
              _self._dispatchEvent("themeLoaded", { theme: module4 });
              cb && cb();
              if (useragent.isSafari && _self.scroller) {
                _self.scroller.style.background = "red";
                _self.scroller.style.background = "";
              }
            }
          };
          VirtualRenderer2.prototype.getTheme = function() {
            return this.$themeId;
          };
          VirtualRenderer2.prototype.setStyle = function(style, include) {
            dom.setCssClass(this.container, style, include !== false);
          };
          VirtualRenderer2.prototype.unsetStyle = function(style) {
            dom.removeCssClass(this.container, style);
          };
          VirtualRenderer2.prototype.setCursorStyle = function(style) {
            dom.setStyle(this.scroller.style, "cursor", style);
          };
          VirtualRenderer2.prototype.setMouseCursor = function(cursorStyle) {
            dom.setStyle(this.scroller.style, "cursor", cursorStyle);
          };
          VirtualRenderer2.prototype.attachToShadowRoot = function() {
            dom.importCssString(editorCss, "ace_editor.css", this.container);
          };
          VirtualRenderer2.prototype.destroy = function() {
            this.freeze();
            this.$fontMetrics.destroy();
            this.$cursorLayer.destroy();
            this.removeAllListeners();
            this.container.textContent = "";
            this.setOption("useResizeObserver", false);
          };
          VirtualRenderer2.prototype.$updateCustomScrollbar = function(val) {
            var _self = this;
            this.$horizScroll = this.$vScroll = null;
            this.scrollBarV.element.remove();
            this.scrollBarH.element.remove();
            if (this.$scrollDecorator) {
              delete this.$scrollDecorator;
            }
            if (val === true) {
              this.scrollBarV = new VScrollBarCustom(this.container, this);
              this.scrollBarH = new HScrollBarCustom(this.container, this);
              this.scrollBarV.setHeight(this.$size.scrollerHeight);
              this.scrollBarH.setWidth(this.$size.scrollerWidth);
              this.scrollBarV.addEventListener("scroll", function(e2) {
                if (!_self.$scrollAnimation)
                  _self.session.setScrollTop(e2.data - _self.scrollMargin.top);
              });
              this.scrollBarH.addEventListener("scroll", function(e2) {
                if (!_self.$scrollAnimation)
                  _self.session.setScrollLeft(e2.data - _self.scrollMargin.left);
              });
              this.$scrollDecorator = new Decorator(this.scrollBarV, this);
              this.$scrollDecorator.$updateDecorators();
            } else {
              this.scrollBarV = new VScrollBar(this.container, this);
              this.scrollBarH = new HScrollBar(this.container, this);
              this.scrollBarV.addEventListener("scroll", function(e2) {
                if (!_self.$scrollAnimation)
                  _self.session.setScrollTop(e2.data - _self.scrollMargin.top);
              });
              this.scrollBarH.addEventListener("scroll", function(e2) {
                if (!_self.$scrollAnimation)
                  _self.session.setScrollLeft(e2.data - _self.scrollMargin.left);
              });
            }
          };
          VirtualRenderer2.prototype.$addResizeObserver = function() {
            if (!window.ResizeObserver || this.$resizeObserver)
              return;
            var self2 = this;
            this.$resizeTimer = lang.delayedCall(function() {
              if (!self2.destroyed)
                self2.onResize();
            }, 50);
            this.$resizeObserver = new window.ResizeObserver(function(e2) {
              var w2 = e2[0].contentRect.width;
              var h3 = e2[0].contentRect.height;
              if (Math.abs(self2.$size.width - w2) > 1 || Math.abs(self2.$size.height - h3) > 1) {
                self2.$resizeTimer.delay();
              } else {
                self2.$resizeTimer.cancel();
              }
            });
            this.$resizeObserver.observe(this.container);
          };
          return VirtualRenderer2;
        })()
      );
      VirtualRenderer.prototype.CHANGE_CURSOR = 1;
      VirtualRenderer.prototype.CHANGE_MARKER = 2;
      VirtualRenderer.prototype.CHANGE_GUTTER = 4;
      VirtualRenderer.prototype.CHANGE_SCROLL = 8;
      VirtualRenderer.prototype.CHANGE_LINES = 16;
      VirtualRenderer.prototype.CHANGE_TEXT = 32;
      VirtualRenderer.prototype.CHANGE_SIZE = 64;
      VirtualRenderer.prototype.CHANGE_MARKER_BACK = 128;
      VirtualRenderer.prototype.CHANGE_MARKER_FRONT = 256;
      VirtualRenderer.prototype.CHANGE_FULL = 512;
      VirtualRenderer.prototype.CHANGE_H_SCROLL = 1024;
      VirtualRenderer.prototype.$changes = 0;
      VirtualRenderer.prototype.$padding = null;
      VirtualRenderer.prototype.$frozen = false;
      VirtualRenderer.prototype.STEPS = 8;
      oop.implement(VirtualRenderer.prototype, EventEmitter);
      config.defineOptions(VirtualRenderer.prototype, "renderer", {
        useResizeObserver: {
          set: function(value) {
            if (!value && this.$resizeObserver) {
              this.$resizeObserver.disconnect();
              this.$resizeTimer.cancel();
              this.$resizeTimer = this.$resizeObserver = null;
            } else if (value && !this.$resizeObserver) {
              this.$addResizeObserver();
            }
          }
        },
        animatedScroll: { initialValue: false },
        showInvisibles: {
          set: function(value) {
            if (this.$textLayer.setShowInvisibles(value))
              this.$loop.schedule(this.CHANGE_TEXT);
          },
          initialValue: false
        },
        showPrintMargin: {
          set: function() {
            this.$updatePrintMargin();
          },
          initialValue: true
        },
        printMarginColumn: {
          set: function() {
            this.$updatePrintMargin();
          },
          initialValue: 80
        },
        printMargin: {
          set: function(val) {
            if (typeof val == "number")
              this.$printMarginColumn = val;
            this.$showPrintMargin = !!val;
            this.$updatePrintMargin();
          },
          get: function() {
            return this.$showPrintMargin && this.$printMarginColumn;
          }
        },
        showGutter: {
          set: function(show) {
            this.$gutter.style.display = show ? "block" : "none";
            this.$loop.schedule(this.CHANGE_FULL);
            this.onGutterResize();
          },
          initialValue: true
        },
        useSvgGutterIcons: {
          set: function(value) {
            this.$gutterLayer.$useSvgGutterIcons = value;
          },
          initialValue: false
        },
        showFoldedAnnotations: {
          set: function(value) {
            this.$gutterLayer.$showFoldedAnnotations = value;
          },
          initialValue: false
        },
        fadeFoldWidgets: {
          set: function(show) {
            dom.setCssClass(this.$gutter, "ace_fade-fold-widgets", show);
          },
          initialValue: false
        },
        showFoldWidgets: {
          set: function(show) {
            this.$gutterLayer.setShowFoldWidgets(show);
            this.$loop.schedule(this.CHANGE_GUTTER);
          },
          initialValue: true
        },
        displayIndentGuides: {
          set: function(show) {
            if (this.$textLayer.setDisplayIndentGuides(show))
              this.$loop.schedule(this.CHANGE_TEXT);
          },
          initialValue: true
        },
        highlightIndentGuides: {
          set: function(show) {
            if (this.$textLayer.setHighlightIndentGuides(show) == true) {
              this.$textLayer.$highlightIndentGuide();
            } else {
              this.$textLayer.$clearActiveIndentGuide(this.$textLayer.$lines.cells);
            }
          },
          initialValue: true
        },
        highlightGutterLine: {
          set: function(shouldHighlight) {
            this.$gutterLayer.setHighlightGutterLine(shouldHighlight);
            this.$loop.schedule(this.CHANGE_GUTTER);
          },
          initialValue: true
        },
        hScrollBarAlwaysVisible: {
          set: function(val) {
            if (!this.$hScrollBarAlwaysVisible || !this.$horizScroll)
              this.$loop.schedule(this.CHANGE_SCROLL);
          },
          initialValue: false
        },
        vScrollBarAlwaysVisible: {
          set: function(val) {
            if (!this.$vScrollBarAlwaysVisible || !this.$vScroll)
              this.$loop.schedule(this.CHANGE_SCROLL);
          },
          initialValue: false
        },
        fontSize: {
          set: function(size) {
            if (typeof size == "number")
              size = size + "px";
            this.container.style.fontSize = size;
            this.updateFontSize();
          },
          initialValue: 12
        },
        fontFamily: {
          set: function(name) {
            this.container.style.fontFamily = name;
            this.updateFontSize();
          }
        },
        maxLines: {
          set: function(val) {
            this.updateFull();
          }
        },
        minLines: {
          set: function(val) {
            if (!(this.$minLines < 562949953421311))
              this.$minLines = 0;
            this.updateFull();
          }
        },
        maxPixelHeight: {
          set: function(val) {
            this.updateFull();
          },
          initialValue: 0
        },
        scrollPastEnd: {
          set: function(val) {
            val = +val || 0;
            if (this.$scrollPastEnd == val)
              return;
            this.$scrollPastEnd = val;
            this.$loop.schedule(this.CHANGE_SCROLL);
          },
          initialValue: 0,
          handlesSet: true
        },
        fixedWidthGutter: {
          set: function(val) {
            this.$gutterLayer.$fixedWidth = !!val;
            this.$loop.schedule(this.CHANGE_GUTTER);
          }
        },
        customScrollbar: {
          set: function(val) {
            this.$updateCustomScrollbar(val);
          },
          initialValue: false
        },
        theme: {
          set: function(val) {
            this.setTheme(val);
          },
          get: function() {
            return this.$themeId || this.theme;
          },
          initialValue: "./theme/textmate",
          handlesSet: true
        },
        hasCssTransforms: {},
        useTextareaForIME: {
          initialValue: !useragent.isMobile && !useragent.isIE
        }
      });
      exports3.VirtualRenderer = VirtualRenderer;
    });
    ace.define("ace/worker/worker_client", ["require", "exports", "module", "ace/lib/oop", "ace/lib/net", "ace/lib/event_emitter", "ace/config"], function(require2, exports3, module3) {
      var oop = require2("../lib/oop");
      var net = require2("../lib/net");
      var EventEmitter = require2("../lib/event_emitter").EventEmitter;
      var config = require2("../config");
      function $workerBlob(workerUrl) {
        var script = "importScripts('" + net.qualifyURL(workerUrl) + "');";
        try {
          return new Blob([script], { "type": "application/javascript" });
        } catch (e2) {
          var BlobBuilder = window.BlobBuilder || window.WebKitBlobBuilder || window.MozBlobBuilder;
          var blobBuilder = new BlobBuilder();
          blobBuilder.append(script);
          return blobBuilder.getBlob("application/javascript");
        }
      }
      function createWorker(workerUrl) {
        if (typeof Worker == "undefined")
          return { postMessage: function() {
          }, terminate: function() {
          } };
        if (config.get("loadWorkerFromBlob")) {
          var blob = $workerBlob(workerUrl);
          var URL2 = window.URL || window.webkitURL;
          var blobURL = URL2.createObjectURL(blob);
          return new Worker(blobURL);
        }
        return new Worker(workerUrl);
      }
      var WorkerClient = function(worker) {
        if (!worker.postMessage)
          worker = this.$createWorkerFromOldConfig.apply(this, arguments);
        this.$worker = worker;
        this.$sendDeltaQueue = this.$sendDeltaQueue.bind(this);
        this.changeListener = this.changeListener.bind(this);
        this.onMessage = this.onMessage.bind(this);
        this.callbackId = 1;
        this.callbacks = {};
        this.$worker.onmessage = this.onMessage;
      };
      (function() {
        oop.implement(this, EventEmitter);
        this.$createWorkerFromOldConfig = function(topLevelNamespaces, mod, classname, workerUrl, importScripts) {
          if (require2.nameToUrl && !require2.toUrl)
            require2.toUrl = require2.nameToUrl;
          if (config.get("packaged") || !require2.toUrl) {
            workerUrl = workerUrl || config.moduleUrl(mod, "worker");
          } else {
            var normalizePath = this.$normalizePath;
            workerUrl = workerUrl || normalizePath(require2.toUrl("ace/worker/worker.js", null, "_"));
            var tlns = {};
            topLevelNamespaces.forEach(function(ns) {
              tlns[ns] = normalizePath(require2.toUrl(ns, null, "_").replace(/(\.js)?(\?.*)?$/, ""));
            });
          }
          this.$worker = createWorker(workerUrl);
          if (importScripts) {
            this.send("importScripts", importScripts);
          }
          this.$worker.postMessage({
            init: true,
            tlns,
            module: mod,
            classname
          });
          return this.$worker;
        };
        this.onMessage = function(e2) {
          var msg = e2.data;
          switch (msg.type) {
            case "event":
              this._signal(msg.name, { data: msg.data });
              break;
            case "call":
              var callback = this.callbacks[msg.id];
              if (callback) {
                callback(msg.data);
                delete this.callbacks[msg.id];
              }
              break;
            case "error":
              this.reportError(msg.data);
              break;
            case "log":
              window.console && console.log && console.log.apply(console, msg.data);
              break;
          }
        };
        this.reportError = function(err) {
          window.console && console.error && console.error(err);
        };
        this.$normalizePath = function(path) {
          return net.qualifyURL(path);
        };
        this.terminate = function() {
          this._signal("terminate", {});
          this.deltaQueue = null;
          this.$worker.terminate();
          this.$worker.onerror = function(e2) {
            e2.preventDefault();
          };
          this.$worker = null;
          if (this.$doc)
            this.$doc.off("change", this.changeListener);
          this.$doc = null;
        };
        this.send = function(cmd, args) {
          this.$worker.postMessage({ command: cmd, args });
        };
        this.call = function(cmd, args, callback) {
          if (callback) {
            var id = this.callbackId++;
            this.callbacks[id] = callback;
            args.push(id);
          }
          this.send(cmd, args);
        };
        this.emit = function(event, data) {
          try {
            if (data.data && data.data.err)
              data.data.err = { message: data.data.err.message, stack: data.data.err.stack, code: data.data.err.code };
            this.$worker && this.$worker.postMessage({ event, data: { data: data.data } });
          } catch (ex) {
            console.error(ex.stack);
          }
        };
        this.attachToDocument = function(doc) {
          if (this.$doc)
            this.terminate();
          this.$doc = doc;
          this.call("setValue", [doc.getValue()]);
          doc.on("change", this.changeListener, true);
        };
        this.changeListener = function(delta) {
          if (!this.deltaQueue) {
            this.deltaQueue = [];
            setTimeout(this.$sendDeltaQueue, 0);
          }
          if (delta.action == "insert")
            this.deltaQueue.push(delta.start, delta.lines);
          else
            this.deltaQueue.push(delta.start, delta.end);
        };
        this.$sendDeltaQueue = function() {
          var q2 = this.deltaQueue;
          if (!q2) return;
          this.deltaQueue = null;
          if (q2.length > 50 && q2.length > this.$doc.getLength() >> 1) {
            this.call("setValue", [this.$doc.getValue()]);
          } else
            this.emit("change", { data: q2 });
        };
      }).call(WorkerClient.prototype);
      var UIWorkerClient = function(topLevelNamespaces, mod, classname) {
        var main = null;
        var emitSync = false;
        var sender = Object.create(EventEmitter);
        var messageBuffer = [];
        var workerClient = new WorkerClient({
          messageBuffer,
          terminate: function() {
          },
          postMessage: function(e2) {
            messageBuffer.push(e2);
            if (!main) return;
            if (emitSync)
              setTimeout(processNext);
            else
              processNext();
          }
        });
        workerClient.setEmitSync = function(val) {
          emitSync = val;
        };
        var processNext = function() {
          var msg = messageBuffer.shift();
          if (msg.command)
            main[msg.command].apply(main, msg.args);
          else if (msg.event)
            sender._signal(msg.event, msg.data);
        };
        sender.postMessage = function(msg) {
          workerClient.onMessage({ data: msg });
        };
        sender.callback = function(data, callbackId) {
          this.postMessage({ type: "call", id: callbackId, data });
        };
        sender.emit = function(name, data) {
          this.postMessage({ type: "event", name, data });
        };
        config.loadModule(["worker", mod], function(Main) {
          main = new Main[classname](sender);
          while (messageBuffer.length)
            processNext();
        });
        return workerClient;
      };
      exports3.UIWorkerClient = UIWorkerClient;
      exports3.WorkerClient = WorkerClient;
      exports3.createWorker = createWorker;
    });
    ace.define("ace/placeholder", ["require", "exports", "module", "ace/range", "ace/lib/event_emitter", "ace/lib/oop"], function(require2, exports3, module3) {
      var Range = require2("./range").Range;
      var EventEmitter = require2("./lib/event_emitter").EventEmitter;
      var oop = require2("./lib/oop");
      var PlaceHolder = (
        /** @class */
        (function() {
          function PlaceHolder2(session, length, pos, others, mainClass, othersClass) {
            var _self = this;
            this.length = length;
            this.session = session;
            this.doc = session.getDocument();
            this.mainClass = mainClass;
            this.othersClass = othersClass;
            this.$onUpdate = this.onUpdate.bind(this);
            this.doc.on("change", this.$onUpdate, true);
            this.$others = others;
            this.$onCursorChange = function() {
              setTimeout(function() {
                _self.onCursorChange();
              });
            };
            this.$pos = pos;
            var undoStack = session.getUndoManager().$undoStack || session.getUndoManager()["$undostack"] || { length: -1 };
            this.$undoStackDepth = undoStack.length;
            this.setup();
            session.selection.on("changeCursor", this.$onCursorChange);
          }
          PlaceHolder2.prototype.setup = function() {
            var _self = this;
            var doc = this.doc;
            var session = this.session;
            this.selectionBefore = session.selection.toJSON();
            if (session.selection.inMultiSelectMode)
              session.selection.toSingleRange();
            this.pos = doc.createAnchor(this.$pos.row, this.$pos.column);
            var pos = this.pos;
            pos.$insertRight = true;
            pos.detach();
            pos.markerId = session.addMarker(new Range(pos.row, pos.column, pos.row, pos.column + this.length), this.mainClass, null, false);
            this.others = [];
            this.$others.forEach(function(other) {
              var anchor = doc.createAnchor(other.row, other.column);
              anchor.$insertRight = true;
              anchor.detach();
              _self.others.push(anchor);
            });
            session.setUndoSelect(false);
          };
          PlaceHolder2.prototype.showOtherMarkers = function() {
            if (this.othersActive)
              return;
            var session = this.session;
            var _self = this;
            this.othersActive = true;
            this.others.forEach(function(anchor) {
              anchor.markerId = session.addMarker(new Range(anchor.row, anchor.column, anchor.row, anchor.column + _self.length), _self.othersClass, null, false);
            });
          };
          PlaceHolder2.prototype.hideOtherMarkers = function() {
            if (!this.othersActive)
              return;
            this.othersActive = false;
            for (var i2 = 0; i2 < this.others.length; i2++) {
              this.session.removeMarker(this.others[i2].markerId);
            }
          };
          PlaceHolder2.prototype.onUpdate = function(delta) {
            if (this.$updating)
              return this.updateAnchors(delta);
            var range = delta;
            if (range.start.row !== range.end.row)
              return;
            if (range.start.row !== this.pos.row)
              return;
            this.$updating = true;
            var lengthDiff = delta.action === "insert" ? range.end.column - range.start.column : range.start.column - range.end.column;
            var inMainRange = range.start.column >= this.pos.column && range.start.column <= this.pos.column + this.length + 1;
            var distanceFromStart = range.start.column - this.pos.column;
            this.updateAnchors(delta);
            if (inMainRange)
              this.length += lengthDiff;
            if (inMainRange && !this.session.$fromUndo) {
              if (delta.action === "insert") {
                for (var i2 = this.others.length - 1; i2 >= 0; i2--) {
                  var otherPos = this.others[i2];
                  var newPos = { row: otherPos.row, column: otherPos.column + distanceFromStart };
                  this.doc.insertMergedLines(newPos, delta.lines);
                }
              } else if (delta.action === "remove") {
                for (var i2 = this.others.length - 1; i2 >= 0; i2--) {
                  var otherPos = this.others[i2];
                  var newPos = { row: otherPos.row, column: otherPos.column + distanceFromStart };
                  this.doc.remove(new Range(newPos.row, newPos.column, newPos.row, newPos.column - lengthDiff));
                }
              }
            }
            this.$updating = false;
            this.updateMarkers();
          };
          PlaceHolder2.prototype.updateAnchors = function(delta) {
            this.pos.onChange(delta);
            for (var i2 = this.others.length; i2--; )
              this.others[i2].onChange(delta);
            this.updateMarkers();
          };
          PlaceHolder2.prototype.updateMarkers = function() {
            if (this.$updating)
              return;
            var _self = this;
            var session = this.session;
            var updateMarker = function(pos, className) {
              session.removeMarker(pos.markerId);
              pos.markerId = session.addMarker(new Range(pos.row, pos.column, pos.row, pos.column + _self.length), className, null, false);
            };
            updateMarker(this.pos, this.mainClass);
            for (var i2 = this.others.length; i2--; )
              updateMarker(this.others[i2], this.othersClass);
          };
          PlaceHolder2.prototype.onCursorChange = function(event) {
            if (this.$updating || !this.session)
              return;
            var pos = this.session.selection.getCursor();
            if (pos.row === this.pos.row && pos.column >= this.pos.column && pos.column <= this.pos.column + this.length) {
              this.showOtherMarkers();
              this._emit("cursorEnter", event);
            } else {
              this.hideOtherMarkers();
              this._emit("cursorLeave", event);
            }
          };
          PlaceHolder2.prototype.detach = function() {
            this.session.removeMarker(this.pos && this.pos.markerId);
            this.hideOtherMarkers();
            this.doc.off("change", this.$onUpdate);
            this.session.selection.off("changeCursor", this.$onCursorChange);
            this.session.setUndoSelect(true);
            this.session = null;
          };
          PlaceHolder2.prototype.cancel = function() {
            if (this.$undoStackDepth === -1)
              return;
            var undoManager = this.session.getUndoManager();
            var undosRequired = (undoManager.$undoStack || undoManager["$undostack"]).length - this.$undoStackDepth;
            for (var i2 = 0; i2 < undosRequired; i2++) {
              undoManager.undo(this.session, true);
            }
            if (this.selectionBefore)
              this.session.selection.fromJSON(this.selectionBefore);
          };
          return PlaceHolder2;
        })()
      );
      oop.implement(PlaceHolder.prototype, EventEmitter);
      exports3.PlaceHolder = PlaceHolder;
    });
    ace.define("ace/mouse/multi_select_handler", ["require", "exports", "module", "ace/lib/event", "ace/lib/useragent"], function(require2, exports3, module3) {
      var event = require2("../lib/event");
      var useragent = require2("../lib/useragent");
      function isSamePoint(p1, p2) {
        return p1.row == p2.row && p1.column == p2.column;
      }
      function onMouseDown(e2) {
        var ev = e2.domEvent;
        var alt = ev.altKey;
        var shift = ev.shiftKey;
        var ctrl = ev.ctrlKey;
        var accel = e2.getAccelKey();
        var button2 = e2.getButton();
        if (ctrl && useragent.isMac)
          button2 = ev.button;
        if (e2.editor.inMultiSelectMode && button2 == 2) {
          e2.editor.textInput.onContextMenu(e2.domEvent);
          return;
        }
        if (!ctrl && !alt && !accel) {
          if (button2 === 0 && e2.editor.inMultiSelectMode)
            e2.editor.exitMultiSelectMode();
          return;
        }
        if (button2 !== 0)
          return;
        var editor = e2.editor;
        var selection = editor.selection;
        var isMultiSelect = editor.inMultiSelectMode;
        var pos = e2.getDocumentPosition();
        var cursor = selection.getCursor();
        var inSelection = e2.inSelection() || selection.isEmpty() && isSamePoint(pos, cursor);
        var mouseX = e2.x, mouseY = e2.y;
        var onMouseSelection = function(e3) {
          mouseX = e3.clientX;
          mouseY = e3.clientY;
        };
        var session = editor.session;
        var screenAnchor = editor.renderer.pixelToScreenCoordinates(mouseX, mouseY);
        var screenCursor = screenAnchor;
        var selectionMode;
        if (editor.$mouseHandler.$enableJumpToDef) {
          if (ctrl && alt || accel && alt)
            selectionMode = shift ? "block" : "add";
          else if (alt && editor.$blockSelectEnabled)
            selectionMode = "block";
        } else {
          if (accel && !alt) {
            selectionMode = "add";
            if (!isMultiSelect && shift)
              return;
          } else if (alt && editor.$blockSelectEnabled) {
            selectionMode = "block";
          }
        }
        if (selectionMode && useragent.isMac && ev.ctrlKey) {
          editor.$mouseHandler.cancelContextMenu();
        }
        if (selectionMode == "add") {
          if (!isMultiSelect && inSelection)
            return;
          if (!isMultiSelect) {
            var range = selection.toOrientedRange();
            editor.addSelectionMarker(range);
          }
          var oldRange = selection.rangeList.rangeAtPoint(pos);
          editor.inVirtualSelectionMode = true;
          if (shift) {
            oldRange = null;
            range = selection.ranges[0] || range;
            editor.removeSelectionMarker(range);
          }
          editor.once("mouseup", function() {
            var tmpSel = selection.toOrientedRange();
            if (oldRange && tmpSel.isEmpty() && isSamePoint(oldRange.cursor, tmpSel.cursor))
              selection.substractPoint(tmpSel.cursor);
            else {
              if (shift) {
                selection.substractPoint(range.cursor);
              } else if (range) {
                editor.removeSelectionMarker(range);
                selection.addRange(range);
              }
              selection.addRange(tmpSel);
            }
            editor.inVirtualSelectionMode = false;
          });
        } else if (selectionMode == "block") {
          e2.stop();
          editor.inVirtualSelectionMode = true;
          var initialRange;
          var rectSel = [];
          var blockSelect = function() {
            var newCursor = editor.renderer.pixelToScreenCoordinates(mouseX, mouseY);
            var cursor2 = session.screenToDocumentPosition(newCursor.row, newCursor.column, newCursor.offsetX);
            if (isSamePoint(screenCursor, newCursor) && isSamePoint(cursor2, selection.lead))
              return;
            screenCursor = newCursor;
            editor.selection.moveToPosition(cursor2);
            editor.renderer.scrollCursorIntoView();
            editor.removeSelectionMarkers(rectSel);
            rectSel = selection.rectangularRangeBlock(screenCursor, screenAnchor);
            if (editor.$mouseHandler.$clickSelection && rectSel.length == 1 && rectSel[0].isEmpty())
              rectSel[0] = editor.$mouseHandler.$clickSelection.clone();
            rectSel.forEach(editor.addSelectionMarker, editor);
            editor.updateSelectionMarkers();
          };
          if (isMultiSelect && !accel) {
            selection.toSingleRange();
          } else if (!isMultiSelect && accel) {
            initialRange = selection.toOrientedRange();
            editor.addSelectionMarker(initialRange);
          }
          if (shift)
            screenAnchor = session.documentToScreenPosition(selection.lead);
          else
            selection.moveToPosition(pos);
          screenCursor = { row: -1, column: -1 };
          var onMouseSelectionEnd = function(e3) {
            blockSelect();
            clearInterval(timerId);
            editor.removeSelectionMarkers(rectSel);
            if (!rectSel.length)
              rectSel = [selection.toOrientedRange()];
            if (initialRange) {
              editor.removeSelectionMarker(initialRange);
              selection.toSingleRange(initialRange);
            }
            for (var i2 = 0; i2 < rectSel.length; i2++)
              selection.addRange(rectSel[i2]);
            editor.inVirtualSelectionMode = false;
            editor.$mouseHandler.$clickSelection = null;
          };
          var onSelectionInterval = blockSelect;
          event.capture(editor.container, onMouseSelection, onMouseSelectionEnd);
          var timerId = setInterval(function() {
            onSelectionInterval();
          }, 20);
          return e2.preventDefault();
        }
      }
      exports3.onMouseDown = onMouseDown;
    });
    ace.define("ace/commands/multi_select_commands", ["require", "exports", "module", "ace/keyboard/hash_handler"], function(require2, exports3, module3) {
      exports3.defaultCommands = [{
        name: "addCursorAbove",
        description: "Add cursor above",
        exec: function(editor) {
          editor.selectMoreLines(-1);
        },
        bindKey: { win: "Ctrl-Alt-Up", mac: "Ctrl-Alt-Up" },
        scrollIntoView: "cursor",
        readOnly: true
      }, {
        name: "addCursorBelow",
        description: "Add cursor below",
        exec: function(editor) {
          editor.selectMoreLines(1);
        },
        bindKey: { win: "Ctrl-Alt-Down", mac: "Ctrl-Alt-Down" },
        scrollIntoView: "cursor",
        readOnly: true
      }, {
        name: "addCursorAboveSkipCurrent",
        description: "Add cursor above (skip current)",
        exec: function(editor) {
          editor.selectMoreLines(-1, true);
        },
        bindKey: { win: "Ctrl-Alt-Shift-Up", mac: "Ctrl-Alt-Shift-Up" },
        scrollIntoView: "cursor",
        readOnly: true
      }, {
        name: "addCursorBelowSkipCurrent",
        description: "Add cursor below (skip current)",
        exec: function(editor) {
          editor.selectMoreLines(1, true);
        },
        bindKey: { win: "Ctrl-Alt-Shift-Down", mac: "Ctrl-Alt-Shift-Down" },
        scrollIntoView: "cursor",
        readOnly: true
      }, {
        name: "selectMoreBefore",
        description: "Select more before",
        exec: function(editor) {
          editor.selectMore(-1);
        },
        bindKey: { win: "Ctrl-Alt-Left", mac: "Ctrl-Alt-Left" },
        scrollIntoView: "cursor",
        readOnly: true
      }, {
        name: "selectMoreAfter",
        description: "Select more after",
        exec: function(editor) {
          editor.selectMore(1);
        },
        bindKey: { win: "Ctrl-Alt-Right", mac: "Ctrl-Alt-Right" },
        scrollIntoView: "cursor",
        readOnly: true
      }, {
        name: "selectNextBefore",
        description: "Select next before",
        exec: function(editor) {
          editor.selectMore(-1, true);
        },
        bindKey: { win: "Ctrl-Alt-Shift-Left", mac: "Ctrl-Alt-Shift-Left" },
        scrollIntoView: "cursor",
        readOnly: true
      }, {
        name: "selectNextAfter",
        description: "Select next after",
        exec: function(editor) {
          editor.selectMore(1, true);
        },
        bindKey: { win: "Ctrl-Alt-Shift-Right", mac: "Ctrl-Alt-Shift-Right" },
        scrollIntoView: "cursor",
        readOnly: true
      }, {
        name: "toggleSplitSelectionIntoLines",
        description: "Split selection into lines",
        exec: function(editor) {
          if (editor.multiSelect.rangeCount > 1)
            editor.multiSelect.joinSelections();
          else
            editor.multiSelect.splitIntoLines();
        },
        bindKey: { win: "Ctrl-Alt-L", mac: "Ctrl-Alt-L" },
        readOnly: true
      }, {
        name: "splitSelectionIntoLines",
        description: "Split into lines",
        exec: function(editor) {
          editor.multiSelect.splitIntoLines();
        },
        readOnly: true
      }, {
        name: "alignCursors",
        description: "Align cursors",
        exec: function(editor) {
          editor.alignCursors();
        },
        bindKey: { win: "Ctrl-Alt-A", mac: "Ctrl-Alt-A" },
        scrollIntoView: "cursor"
      }, {
        name: "findAll",
        description: "Find all",
        exec: function(editor) {
          editor.findAll();
        },
        bindKey: { win: "Ctrl-Alt-K", mac: "Ctrl-Alt-G" },
        scrollIntoView: "cursor",
        readOnly: true
      }];
      exports3.multiSelectCommands = [{
        name: "singleSelection",
        description: "Single selection",
        bindKey: "esc",
        exec: function(editor) {
          editor.exitMultiSelectMode();
        },
        scrollIntoView: "cursor",
        readOnly: true,
        isAvailable: function(editor) {
          return editor && editor.inMultiSelectMode;
        }
      }];
      var HashHandler = require2("../keyboard/hash_handler").HashHandler;
      exports3.keyboardHandler = new HashHandler(exports3.multiSelectCommands);
    });
    ace.define("ace/multi_select", ["require", "exports", "module", "ace/range_list", "ace/range", "ace/selection", "ace/mouse/multi_select_handler", "ace/lib/event", "ace/lib/lang", "ace/commands/multi_select_commands", "ace/search", "ace/edit_session", "ace/editor", "ace/config"], function(require2, exports3, module3) {
      var RangeList = require2("./range_list").RangeList;
      var Range = require2("./range").Range;
      var Selection = require2("./selection").Selection;
      var onMouseDown = require2("./mouse/multi_select_handler").onMouseDown;
      var event = require2("./lib/event");
      var lang = require2("./lib/lang");
      var commands = require2("./commands/multi_select_commands");
      exports3.commands = commands.defaultCommands.concat(commands.multiSelectCommands);
      var Search = require2("./search").Search;
      var search = new Search();
      function find(session, needle, dir) {
        search.$options.wrap = true;
        search.$options.needle = needle;
        search.$options.backwards = dir == -1;
        return search.find(session);
      }
      var EditSession = require2("./edit_session").EditSession;
      (function() {
        this.getSelectionMarkers = function() {
          return this.$selectionMarkers;
        };
      }).call(EditSession.prototype);
      (function() {
        this.ranges = null;
        this.rangeList = null;
        this.addRange = function(range, $blockChangeEvents) {
          if (!range)
            return;
          if (!this.inMultiSelectMode && this.rangeCount === 0) {
            var oldRange = this.toOrientedRange();
            this.rangeList.add(oldRange);
            this.rangeList.add(range);
            if (this.rangeList.ranges.length != 2) {
              this.rangeList.removeAll();
              return $blockChangeEvents || this.fromOrientedRange(range);
            }
            this.rangeList.removeAll();
            this.rangeList.add(oldRange);
            this.$onAddRange(oldRange);
          }
          if (!range.cursor)
            range.cursor = range.end;
          var removed = this.rangeList.add(range);
          this.$onAddRange(range);
          if (removed.length)
            this.$onRemoveRange(removed);
          if (this.rangeCount > 1 && !this.inMultiSelectMode) {
            this._signal("multiSelect");
            this.inMultiSelectMode = true;
            this.session.$undoSelect = false;
            this.rangeList.attach(this.session);
          }
          return $blockChangeEvents || this.fromOrientedRange(range);
        };
        this.toSingleRange = function(range) {
          range = range || this.ranges[0];
          var removed = this.rangeList.removeAll();
          if (removed.length)
            this.$onRemoveRange(removed);
          range && this.fromOrientedRange(range);
        };
        this.substractPoint = function(pos) {
          var removed = this.rangeList.substractPoint(pos);
          if (removed) {
            this.$onRemoveRange(removed);
            return removed[0];
          }
        };
        this.mergeOverlappingRanges = function() {
          var removed = this.rangeList.merge();
          if (removed.length)
            this.$onRemoveRange(removed);
        };
        this.$onAddRange = function(range) {
          this.rangeCount = this.rangeList.ranges.length;
          this.ranges.unshift(range);
          this._signal("addRange", { range });
        };
        this.$onRemoveRange = function(removed) {
          this.rangeCount = this.rangeList.ranges.length;
          if (this.rangeCount == 1 && this.inMultiSelectMode) {
            var lastRange = this.rangeList.ranges.pop();
            removed.push(lastRange);
            this.rangeCount = 0;
          }
          for (var i2 = removed.length; i2--; ) {
            var index = this.ranges.indexOf(removed[i2]);
            this.ranges.splice(index, 1);
          }
          this._signal("removeRange", { ranges: removed });
          if (this.rangeCount === 0 && this.inMultiSelectMode) {
            this.inMultiSelectMode = false;
            this._signal("singleSelect");
            this.session.$undoSelect = true;
            this.rangeList.detach(this.session);
          }
          lastRange = lastRange || this.ranges[0];
          if (lastRange && !lastRange.isEqual(this.getRange()))
            this.fromOrientedRange(lastRange);
        };
        this.$initRangeList = function() {
          if (this.rangeList)
            return;
          this.rangeList = new RangeList();
          this.ranges = [];
          this.rangeCount = 0;
        };
        this.getAllRanges = function() {
          return this.rangeCount ? this.rangeList.ranges.concat() : [this.getRange()];
        };
        this.splitIntoLines = function() {
          var ranges = this.ranges.length ? this.ranges : [this.getRange()];
          var newRanges = [];
          for (var i2 = 0; i2 < ranges.length; i2++) {
            var range = ranges[i2];
            var row = range.start.row;
            var endRow = range.end.row;
            if (row === endRow) {
              newRanges.push(range.clone());
            } else {
              newRanges.push(new Range(row, range.start.column, row, this.session.getLine(row).length));
              while (++row < endRow)
                newRanges.push(this.getLineRange(row, true));
              newRanges.push(new Range(endRow, 0, endRow, range.end.column));
            }
            if (i2 == 0 && !this.isBackwards())
              newRanges = newRanges.reverse();
          }
          this.toSingleRange();
          for (var i2 = newRanges.length; i2--; )
            this.addRange(newRanges[i2]);
        };
        this.joinSelections = function() {
          var ranges = this.rangeList.ranges;
          var lastRange = ranges[ranges.length - 1];
          var range = Range.fromPoints(ranges[0].start, lastRange.end);
          this.toSingleRange();
          this.setSelectionRange(range, lastRange.cursor == lastRange.start);
        };
        this.toggleBlockSelection = function() {
          if (this.rangeCount > 1) {
            var ranges = this.rangeList.ranges;
            var lastRange = ranges[ranges.length - 1];
            var range = Range.fromPoints(ranges[0].start, lastRange.end);
            this.toSingleRange();
            this.setSelectionRange(range, lastRange.cursor == lastRange.start);
          } else {
            var cursor = this.session.documentToScreenPosition(this.cursor);
            var anchor = this.session.documentToScreenPosition(this.anchor);
            var rectSel = this.rectangularRangeBlock(cursor, anchor);
            rectSel.forEach(this.addRange, this);
          }
        };
        this.rectangularRangeBlock = function(screenCursor, screenAnchor, includeEmptyLines) {
          var rectSel = [];
          var xBackwards = screenCursor.column < screenAnchor.column;
          if (xBackwards) {
            var startColumn = screenCursor.column;
            var endColumn = screenAnchor.column;
            var startOffsetX = screenCursor.offsetX;
            var endOffsetX = screenAnchor.offsetX;
          } else {
            var startColumn = screenAnchor.column;
            var endColumn = screenCursor.column;
            var startOffsetX = screenAnchor.offsetX;
            var endOffsetX = screenCursor.offsetX;
          }
          var yBackwards = screenCursor.row < screenAnchor.row;
          if (yBackwards) {
            var startRow = screenCursor.row;
            var endRow = screenAnchor.row;
          } else {
            var startRow = screenAnchor.row;
            var endRow = screenCursor.row;
          }
          if (startColumn < 0)
            startColumn = 0;
          if (startRow < 0)
            startRow = 0;
          if (startRow == endRow)
            includeEmptyLines = true;
          var docEnd;
          for (var row = startRow; row <= endRow; row++) {
            var range = Range.fromPoints(this.session.screenToDocumentPosition(row, startColumn, startOffsetX), this.session.screenToDocumentPosition(row, endColumn, endOffsetX));
            if (range.isEmpty()) {
              if (docEnd && isSamePoint(range.end, docEnd))
                break;
              docEnd = range.end;
            }
            range.cursor = xBackwards ? range.start : range.end;
            rectSel.push(range);
          }
          if (yBackwards)
            rectSel.reverse();
          if (!includeEmptyLines) {
            var end = rectSel.length - 1;
            while (rectSel[end].isEmpty() && end > 0)
              end--;
            if (end > 0) {
              var start = 0;
              while (rectSel[start].isEmpty())
                start++;
            }
            for (var i2 = end; i2 >= start; i2--) {
              if (rectSel[i2].isEmpty())
                rectSel.splice(i2, 1);
            }
          }
          return rectSel;
        };
      }).call(Selection.prototype);
      var Editor = require2("./editor").Editor;
      (function() {
        this.updateSelectionMarkers = function() {
          this.renderer.updateCursor();
          this.renderer.updateBackMarkers();
        };
        this.addSelectionMarker = function(orientedRange) {
          if (!orientedRange.cursor)
            orientedRange.cursor = orientedRange.end;
          var style = this.getSelectionStyle();
          orientedRange.marker = this.session.addMarker(orientedRange, "ace_selection", style);
          this.session.$selectionMarkers.push(orientedRange);
          this.session.selectionMarkerCount = this.session.$selectionMarkers.length;
          return orientedRange;
        };
        this.removeSelectionMarker = function(range) {
          if (!range.marker)
            return;
          this.session.removeMarker(range.marker);
          var index = this.session.$selectionMarkers.indexOf(range);
          if (index != -1)
            this.session.$selectionMarkers.splice(index, 1);
          this.session.selectionMarkerCount = this.session.$selectionMarkers.length;
        };
        this.removeSelectionMarkers = function(ranges) {
          var markerList = this.session.$selectionMarkers;
          for (var i2 = ranges.length; i2--; ) {
            var range = ranges[i2];
            if (!range.marker)
              continue;
            this.session.removeMarker(range.marker);
            var index = markerList.indexOf(range);
            if (index != -1)
              markerList.splice(index, 1);
          }
          this.session.selectionMarkerCount = markerList.length;
        };
        this.$onAddRange = function(e2) {
          this.addSelectionMarker(e2.range);
          this.renderer.updateCursor();
          this.renderer.updateBackMarkers();
        };
        this.$onRemoveRange = function(e2) {
          this.removeSelectionMarkers(e2.ranges);
          this.renderer.updateCursor();
          this.renderer.updateBackMarkers();
        };
        this.$onMultiSelect = function(e2) {
          if (this.inMultiSelectMode)
            return;
          this.inMultiSelectMode = true;
          this.setStyle("ace_multiselect");
          this.keyBinding.addKeyboardHandler(commands.keyboardHandler);
          this.commands.setDefaultHandler("exec", this.$onMultiSelectExec);
          this.renderer.updateCursor();
          this.renderer.updateBackMarkers();
        };
        this.$onSingleSelect = function(e2) {
          if (this.session.multiSelect.inVirtualMode)
            return;
          this.inMultiSelectMode = false;
          this.unsetStyle("ace_multiselect");
          this.keyBinding.removeKeyboardHandler(commands.keyboardHandler);
          this.commands.removeDefaultHandler("exec", this.$onMultiSelectExec);
          this.renderer.updateCursor();
          this.renderer.updateBackMarkers();
          this._emit("changeSelection");
        };
        this.$onMultiSelectExec = function(e2) {
          var command = e2.command;
          var editor = e2.editor;
          if (!editor.multiSelect)
            return;
          if (!command.multiSelectAction) {
            var result = command.exec(editor, e2.args || {});
            editor.multiSelect.addRange(editor.multiSelect.toOrientedRange());
            editor.multiSelect.mergeOverlappingRanges();
          } else if (command.multiSelectAction == "forEach") {
            result = editor.forEachSelection(command, e2.args);
          } else if (command.multiSelectAction == "forEachLine") {
            result = editor.forEachSelection(command, e2.args, true);
          } else if (command.multiSelectAction == "single") {
            editor.exitMultiSelectMode();
            result = command.exec(editor, e2.args || {});
          } else {
            result = command.multiSelectAction(editor, e2.args || {});
          }
          return result;
        };
        this.forEachSelection = function(cmd, args, options) {
          if (this.inVirtualSelectionMode)
            return;
          var keepOrder = options && options.keepOrder;
          var $byLines = options == true || options && options.$byLines;
          var session = this.session;
          var selection = this.selection;
          var rangeList = selection.rangeList;
          var ranges = (keepOrder ? selection : rangeList).ranges;
          var result;
          if (!ranges.length)
            return cmd.exec ? cmd.exec(this, args || {}) : cmd(this, args || {});
          var reg = selection._eventRegistry;
          selection._eventRegistry = {};
          var tmpSel = new Selection(session);
          this.inVirtualSelectionMode = true;
          for (var i2 = ranges.length; i2--; ) {
            if ($byLines) {
              while (i2 > 0 && ranges[i2].start.row == ranges[i2 - 1].end.row)
                i2--;
            }
            tmpSel.fromOrientedRange(ranges[i2]);
            tmpSel.index = i2;
            this.selection = session.selection = tmpSel;
            var cmdResult = cmd.exec ? cmd.exec(this, args || {}) : cmd(this, args || {});
            if (!result && cmdResult !== void 0)
              result = cmdResult;
            tmpSel.toOrientedRange(ranges[i2]);
          }
          tmpSel.detach();
          this.selection = session.selection = selection;
          this.inVirtualSelectionMode = false;
          selection._eventRegistry = reg;
          selection.mergeOverlappingRanges();
          if (selection.ranges[0])
            selection.fromOrientedRange(selection.ranges[0]);
          var anim = this.renderer.$scrollAnimation;
          this.onCursorChange();
          this.onSelectionChange();
          if (anim && anim.from == anim.to)
            this.renderer.animateScrolling(anim.from);
          return result;
        };
        this.exitMultiSelectMode = function() {
          if (!this.inMultiSelectMode || this.inVirtualSelectionMode)
            return;
          this.multiSelect.toSingleRange();
        };
        this.getSelectedText = function() {
          var text = "";
          if (this.inMultiSelectMode && !this.inVirtualSelectionMode) {
            var ranges = this.multiSelect.rangeList.ranges;
            var buf = [];
            for (var i2 = 0; i2 < ranges.length; i2++) {
              buf.push(this.session.getTextRange(ranges[i2]));
            }
            var nl = this.session.getDocument().getNewLineCharacter();
            text = buf.join(nl);
            if (text.length == (buf.length - 1) * nl.length)
              text = "";
          } else if (!this.selection.isEmpty()) {
            text = this.session.getTextRange(this.getSelectionRange());
          }
          return text;
        };
        this.$checkMultiselectChange = function(e2, anchor) {
          if (this.inMultiSelectMode && !this.inVirtualSelectionMode) {
            var range = this.multiSelect.ranges[0];
            if (this.multiSelect.isEmpty() && anchor == this.multiSelect.anchor)
              return;
            var pos = anchor == this.multiSelect.anchor ? range.cursor == range.start ? range.end : range.start : range.cursor;
            if (pos.row != anchor.row || this.session.$clipPositionToDocument(pos.row, pos.column).column != anchor.column)
              this.multiSelect.toSingleRange(this.multiSelect.toOrientedRange());
            else
              this.multiSelect.mergeOverlappingRanges();
          }
        };
        this.findAll = function(needle, options, additive) {
          options = options || {};
          options.needle = needle || options.needle;
          if (options.needle == void 0) {
            var range = this.selection.isEmpty() ? this.selection.getWordRange() : this.selection.getRange();
            options.needle = this.session.getTextRange(range);
          }
          this.$search.set(options);
          var ranges = this.$search.findAll(this.session);
          if (!ranges.length)
            return 0;
          var selection = this.multiSelect;
          if (!additive)
            selection.toSingleRange(ranges[0]);
          for (var i2 = ranges.length; i2--; )
            selection.addRange(ranges[i2], true);
          if (range && selection.rangeList.rangeAtPoint(range.start))
            selection.addRange(range, true);
          return ranges.length;
        };
        this.selectMoreLines = function(dir, skip) {
          var range = this.selection.toOrientedRange();
          var isBackwards = range.cursor == range.end;
          var screenLead = this.session.documentToScreenPosition(range.cursor);
          if (this.selection.$desiredColumn)
            screenLead.column = this.selection.$desiredColumn;
          var lead = this.session.screenToDocumentPosition(screenLead.row + dir, screenLead.column);
          if (!range.isEmpty()) {
            var screenAnchor = this.session.documentToScreenPosition(isBackwards ? range.end : range.start);
            var anchor = this.session.screenToDocumentPosition(screenAnchor.row + dir, screenAnchor.column);
          } else {
            var anchor = lead;
          }
          if (isBackwards) {
            var newRange = Range.fromPoints(lead, anchor);
            newRange.cursor = newRange.start;
          } else {
            var newRange = Range.fromPoints(anchor, lead);
            newRange.cursor = newRange.end;
          }
          newRange.desiredColumn = screenLead.column;
          if (!this.selection.inMultiSelectMode) {
            this.selection.addRange(range);
          } else {
            if (skip)
              var toRemove = range.cursor;
          }
          this.selection.addRange(newRange);
          if (toRemove)
            this.selection.substractPoint(toRemove);
        };
        this.transposeSelections = function(dir) {
          var session = this.session;
          var sel = session.multiSelect;
          var all = sel.ranges;
          for (var i2 = all.length; i2--; ) {
            var range = all[i2];
            if (range.isEmpty()) {
              var tmp_1 = session.getWordRange(range.start.row, range.start.column);
              range.start.row = tmp_1.start.row;
              range.start.column = tmp_1.start.column;
              range.end.row = tmp_1.end.row;
              range.end.column = tmp_1.end.column;
            }
          }
          sel.mergeOverlappingRanges();
          var words = [];
          for (var i2 = all.length; i2--; ) {
            var range = all[i2];
            words.unshift(session.getTextRange(range));
          }
          if (dir < 0)
            words.unshift(words.pop());
          else
            words.push(words.shift());
          for (var i2 = all.length; i2--; ) {
            var range = all[i2];
            var tmp = range.clone();
            session.replace(range, words[i2]);
            range.start.row = tmp.start.row;
            range.start.column = tmp.start.column;
          }
          sel.fromOrientedRange(sel.ranges[0]);
        };
        this.selectMore = function(dir, skip, stopAtFirst) {
          var session = this.session;
          var sel = session.multiSelect;
          var range = sel.toOrientedRange();
          if (range.isEmpty()) {
            range = session.getWordRange(range.start.row, range.start.column);
            range.cursor = dir == -1 ? range.start : range.end;
            this.multiSelect.addRange(range);
            if (stopAtFirst)
              return;
          }
          var needle = session.getTextRange(range);
          var newRange = find(session, needle, dir);
          if (newRange) {
            newRange.cursor = dir == -1 ? newRange.start : newRange.end;
            this.session.unfold(newRange);
            this.multiSelect.addRange(newRange);
            this.renderer.scrollCursorIntoView(null, 0.5);
          }
          if (skip)
            this.multiSelect.substractPoint(range.cursor);
        };
        this.alignCursors = function() {
          var session = this.session;
          var sel = session.multiSelect;
          var ranges = sel.ranges;
          var row = -1;
          var sameRowRanges = ranges.filter(function(r) {
            if (r.cursor.row == row)
              return true;
            row = r.cursor.row;
          });
          if (!ranges.length || sameRowRanges.length == ranges.length - 1) {
            var range = this.selection.getRange();
            var fr = range.start.row, lr = range.end.row;
            var guessRange = fr == lr;
            if (guessRange) {
              var max = this.session.getLength();
              var line;
              do {
                line = this.session.getLine(lr);
              } while (/[=:]/.test(line) && ++lr < max);
              do {
                line = this.session.getLine(fr);
              } while (/[=:]/.test(line) && --fr > 0);
              if (fr < 0)
                fr = 0;
              if (lr >= max)
                lr = max - 1;
            }
            var lines = this.session.removeFullLines(fr, lr);
            lines = this.$reAlignText(lines, guessRange);
            this.session.insert({ row: fr, column: 0 }, lines.join("\n") + "\n");
            if (!guessRange) {
              range.start.column = 0;
              range.end.column = lines[lines.length - 1].length;
            }
            this.selection.setRange(range);
          } else {
            sameRowRanges.forEach(function(r) {
              sel.substractPoint(r.cursor);
            });
            var maxCol = 0;
            var minSpace = Infinity;
            var spaceOffsets = ranges.map(function(r) {
              var p = r.cursor;
              var line2 = session.getLine(p.row);
              var spaceOffset = line2.substr(p.column).search(/\S/g);
              if (spaceOffset == -1)
                spaceOffset = 0;
              if (p.column > maxCol)
                maxCol = p.column;
              if (spaceOffset < minSpace)
                minSpace = spaceOffset;
              return spaceOffset;
            });
            ranges.forEach(function(r, i2) {
              var p = r.cursor;
              var l = maxCol - p.column;
              var d3 = spaceOffsets[i2] - minSpace;
              if (l > d3)
                session.insert(p, lang.stringRepeat(" ", l - d3));
              else
                session.remove(new Range(p.row, p.column, p.row, p.column - l + d3));
              r.start.column = r.end.column = maxCol;
              r.start.row = r.end.row = p.row;
              r.cursor = r.end;
            });
            sel.fromOrientedRange(ranges[0]);
            this.renderer.updateCursor();
            this.renderer.updateBackMarkers();
          }
        };
        this.$reAlignText = function(lines, forceLeft) {
          var isLeftAligned = true, isRightAligned = true;
          var startW, textW, endW;
          return lines.map(function(line) {
            var m3 = line.match(/(\s*)(.*?)(\s*)([=:].*)/);
            if (!m3)
              return [line];
            if (startW == null) {
              startW = m3[1].length;
              textW = m3[2].length;
              endW = m3[3].length;
              return m3;
            }
            if (startW + textW + endW != m3[1].length + m3[2].length + m3[3].length)
              isRightAligned = false;
            if (startW != m3[1].length)
              isLeftAligned = false;
            if (startW > m3[1].length)
              startW = m3[1].length;
            if (textW < m3[2].length)
              textW = m3[2].length;
            if (endW > m3[3].length)
              endW = m3[3].length;
            return m3;
          }).map(forceLeft ? alignLeft : isLeftAligned ? isRightAligned ? alignRight : alignLeft : unAlign);
          function spaces(n) {
            return lang.stringRepeat(" ", n);
          }
          function alignLeft(m3) {
            return !m3[2] ? m3[0] : spaces(startW) + m3[2] + spaces(textW - m3[2].length + endW) + m3[4].replace(/^([=:])\s+/, "$1 ");
          }
          function alignRight(m3) {
            return !m3[2] ? m3[0] : spaces(startW + textW - m3[2].length) + m3[2] + spaces(endW) + m3[4].replace(/^([=:])\s+/, "$1 ");
          }
          function unAlign(m3) {
            return !m3[2] ? m3[0] : spaces(startW) + m3[2] + spaces(endW) + m3[4].replace(/^([=:])\s+/, "$1 ");
          }
        };
      }).call(Editor.prototype);
      function isSamePoint(p1, p2) {
        return p1.row == p2.row && p1.column == p2.column;
      }
      exports3.onSessionChange = function(e2) {
        var session = e2.session;
        if (session && !session.multiSelect) {
          session.$selectionMarkers = [];
          session.selection.$initRangeList();
          session.multiSelect = session.selection;
        }
        this.multiSelect = session && session.multiSelect;
        var oldSession = e2.oldSession;
        if (oldSession) {
          oldSession.multiSelect.off("addRange", this.$onAddRange);
          oldSession.multiSelect.off("removeRange", this.$onRemoveRange);
          oldSession.multiSelect.off("multiSelect", this.$onMultiSelect);
          oldSession.multiSelect.off("singleSelect", this.$onSingleSelect);
          oldSession.multiSelect.lead.off("change", this.$checkMultiselectChange);
          oldSession.multiSelect.anchor.off("change", this.$checkMultiselectChange);
        }
        if (session) {
          session.multiSelect.on("addRange", this.$onAddRange);
          session.multiSelect.on("removeRange", this.$onRemoveRange);
          session.multiSelect.on("multiSelect", this.$onMultiSelect);
          session.multiSelect.on("singleSelect", this.$onSingleSelect);
          session.multiSelect.lead.on("change", this.$checkMultiselectChange);
          session.multiSelect.anchor.on("change", this.$checkMultiselectChange);
        }
        if (session && this.inMultiSelectMode != session.selection.inMultiSelectMode) {
          if (session.selection.inMultiSelectMode)
            this.$onMultiSelect();
          else
            this.$onSingleSelect();
        }
      };
      function MultiSelect(editor) {
        if (editor.$multiselectOnSessionChange)
          return;
        editor.$onAddRange = editor.$onAddRange.bind(editor);
        editor.$onRemoveRange = editor.$onRemoveRange.bind(editor);
        editor.$onMultiSelect = editor.$onMultiSelect.bind(editor);
        editor.$onSingleSelect = editor.$onSingleSelect.bind(editor);
        editor.$multiselectOnSessionChange = exports3.onSessionChange.bind(editor);
        editor.$checkMultiselectChange = editor.$checkMultiselectChange.bind(editor);
        editor.$multiselectOnSessionChange(editor);
        editor.on("changeSession", editor.$multiselectOnSessionChange);
        editor.on("mousedown", onMouseDown);
        editor.commands.addCommands(commands.defaultCommands);
        addAltCursorListeners(editor);
      }
      function addAltCursorListeners(editor) {
        if (!editor.textInput)
          return;
        var el = editor.textInput.getElement();
        var altCursor = false;
        event.addListener(el, "keydown", function(e2) {
          var altDown = e2.keyCode == 18 && !(e2.ctrlKey || e2.shiftKey || e2.metaKey);
          if (editor.$blockSelectEnabled && altDown) {
            if (!altCursor) {
              editor.renderer.setMouseCursor("crosshair");
              altCursor = true;
            }
          } else if (altCursor) {
            reset();
          }
        }, editor);
        event.addListener(el, "keyup", reset, editor);
        event.addListener(el, "blur", reset, editor);
        function reset(e2) {
          if (altCursor) {
            editor.renderer.setMouseCursor("");
            altCursor = false;
          }
        }
      }
      exports3.MultiSelect = MultiSelect;
      require2("./config").defineOptions(Editor.prototype, "editor", {
        enableMultiselect: {
          set: function(val) {
            MultiSelect(this);
            if (val) {
              this.on("mousedown", onMouseDown);
            } else {
              this.off("mousedown", onMouseDown);
            }
          },
          value: true
        },
        enableBlockSelect: {
          set: function(val) {
            this.$blockSelectEnabled = val;
          },
          value: true
        }
      });
    });
    ace.define("ace/mode/folding/fold_mode", ["require", "exports", "module", "ace/range"], function(require2, exports3, module3) {
      var Range = require2("../../range").Range;
      var FoldMode = exports3.FoldMode = function() {
      };
      (function() {
        this.foldingStartMarker = null;
        this.foldingStopMarker = null;
        this.getFoldWidget = function(session, foldStyle, row) {
          var line = session.getLine(row);
          if (this.foldingStartMarker.test(line))
            return "start";
          if (foldStyle == "markbeginend" && this.foldingStopMarker && this.foldingStopMarker.test(line))
            return "end";
          return "";
        };
        this.getFoldWidgetRange = function(session, foldStyle, row) {
          return null;
        };
        this.indentationBlock = function(session, row, column) {
          var re2 = /\S/;
          var line = session.getLine(row);
          var startLevel = line.search(re2);
          if (startLevel == -1)
            return;
          var startColumn = column || line.length;
          var maxRow = session.getLength();
          var startRow = row;
          var endRow = row;
          while (++row < maxRow) {
            var level = session.getLine(row).search(re2);
            if (level == -1)
              continue;
            if (level <= startLevel) {
              var token = session.getTokenAt(row, 0);
              if (!token || token.type !== "string")
                break;
            }
            endRow = row;
          }
          if (endRow > startRow) {
            var endColumn = session.getLine(endRow).length;
            return new Range(startRow, startColumn, endRow, endColumn);
          }
        };
        this.openingBracketBlock = function(session, bracket, row, column, typeRe) {
          var start = { row, column: column + 1 };
          var end = session.$findClosingBracket(bracket, start, typeRe);
          if (!end)
            return;
          var fw = session.foldWidgets[end.row];
          if (fw == null)
            fw = session.getFoldWidget(end.row);
          if (fw == "start" && end.row > start.row) {
            end.row--;
            end.column = session.getLine(end.row).length;
          }
          return Range.fromPoints(start, end);
        };
        this.closingBracketBlock = function(session, bracket, row, column, typeRe) {
          var end = { row, column };
          var start = session.$findOpeningBracket(bracket, end);
          if (!start)
            return;
          start.column++;
          end.column--;
          return Range.fromPoints(start, end);
        };
      }).call(FoldMode.prototype);
    });
    ace.define("ace/ext/error_marker", ["require", "exports", "module", "ace/lib/dom", "ace/range", "ace/config"], function(require2, exports3, module3) {
      var dom = require2("../lib/dom");
      var Range = require2("../range").Range;
      var nls = require2("../config").nls;
      function binarySearch(array, needle, comparator) {
        var first = 0;
        var last = array.length - 1;
        while (first <= last) {
          var mid = first + last >> 1;
          var c2 = comparator(needle, array[mid]);
          if (c2 > 0)
            first = mid + 1;
          else if (c2 < 0)
            last = mid - 1;
          else
            return mid;
        }
        return -(first + 1);
      }
      function findAnnotations(session, row, dir) {
        var annotations = session.getAnnotations().sort(Range.comparePoints);
        if (!annotations.length)
          return;
        var i2 = binarySearch(annotations, { row, column: -1 }, Range.comparePoints);
        if (i2 < 0)
          i2 = -i2 - 1;
        if (i2 >= annotations.length)
          i2 = dir > 0 ? 0 : annotations.length - 1;
        else if (i2 === 0 && dir < 0)
          i2 = annotations.length - 1;
        var annotation = annotations[i2];
        if (!annotation || !dir)
          return;
        if (annotation.row === row) {
          do {
            annotation = annotations[i2 += dir];
          } while (annotation && annotation.row === row);
          if (!annotation)
            return annotations.slice();
        }
        var matched = [];
        row = annotation.row;
        do {
          matched[dir < 0 ? "unshift" : "push"](annotation);
          annotation = annotations[i2 += dir];
        } while (annotation && annotation.row == row);
        return matched.length && matched;
      }
      exports3.showErrorMarker = function(editor, dir) {
        var session = editor.session;
        var pos = editor.getCursorPosition();
        var row = pos.row;
        var oldWidget = session.widgetManager.getWidgetsAtRow(row).filter(function(w3) {
          return w3.type == "errorMarker";
        })[0];
        if (oldWidget) {
          oldWidget.destroy();
        } else {
          row -= dir;
        }
        var annotations = findAnnotations(session, row, dir);
        var gutterAnno;
        if (annotations) {
          var annotation = annotations[0];
          pos.column = (annotation.pos && typeof annotation.column != "number" ? annotation.pos.sc : annotation.column) || 0;
          pos.row = annotation.row;
          gutterAnno = editor.renderer.$gutterLayer.$annotations[pos.row];
        } else if (oldWidget) {
          return;
        } else {
          gutterAnno = {
            displayText: [nls("error-marker.good-state", "Looks good!")],
            className: "ace_ok"
          };
        }
        editor.session.unfold(pos.row);
        editor.selection.moveToPosition(pos);
        var w2 = {
          row: pos.row,
          fixedWidth: true,
          coverGutter: true,
          el: dom.createElement("div"),
          type: "errorMarker"
        };
        var el = w2.el.appendChild(dom.createElement("div"));
        var arrow = w2.el.appendChild(dom.createElement("div"));
        arrow.className = "error_widget_arrow " + gutterAnno.className;
        var left = editor.renderer.$cursorLayer.getPixelPosition(pos).left;
        arrow.style.left = left + editor.renderer.gutterWidth - 5 + "px";
        w2.el.className = "error_widget_wrapper";
        el.className = "error_widget " + gutterAnno.className;
        gutterAnno.displayText.forEach(function(annoTextLine, i2) {
          el.appendChild(dom.createTextNode(annoTextLine));
          if (i2 < gutterAnno.displayText.length - 1) {
            el.appendChild(dom.createElement("br"));
          }
        });
        el.appendChild(dom.createElement("div"));
        var kb = function(_, hashId, keyString) {
          if (hashId === 0 && (keyString === "esc" || keyString === "return")) {
            w2.destroy();
            return { command: "null" };
          }
        };
        w2.destroy = function() {
          if (editor.$mouseHandler.isMousePressed)
            return;
          editor.keyBinding.removeKeyboardHandler(kb);
          session.widgetManager.removeLineWidget(w2);
          editor.off("changeSelection", w2.destroy);
          editor.off("changeSession", w2.destroy);
          editor.off("mouseup", w2.destroy);
          editor.off("change", w2.destroy);
        };
        editor.keyBinding.addKeyboardHandler(kb);
        editor.on("changeSelection", w2.destroy);
        editor.on("changeSession", w2.destroy);
        editor.on("mouseup", w2.destroy);
        editor.on("change", w2.destroy);
        editor.session.widgetManager.addLineWidget(w2);
        w2.el.onmousedown = editor.focus.bind(editor);
        editor.renderer.scrollCursorIntoView(null, 0.5, { bottom: w2.el.offsetHeight });
      };
      dom.importCssString("\n    .error_widget_wrapper {\n        background: inherit;\n        color: inherit;\n        border:none\n    }\n    .error_widget {\n        border-top: solid 2px;\n        border-bottom: solid 2px;\n        margin: 5px 0;\n        padding: 10px 40px;\n        white-space: pre-wrap;\n    }\n    .error_widget.ace_error, .error_widget_arrow.ace_error{\n        border-color: #ff5a5a\n    }\n    .error_widget.ace_warning, .error_widget_arrow.ace_warning{\n        border-color: #F1D817\n    }\n    .error_widget.ace_info, .error_widget_arrow.ace_info{\n        border-color: #5a5a5a\n    }\n    .error_widget.ace_ok, .error_widget_arrow.ace_ok{\n        border-color: #5aaa5a\n    }\n    .error_widget_arrow {\n        position: absolute;\n        border: solid 5px;\n        border-top-color: transparent!important;\n        border-right-color: transparent!important;\n        border-left-color: transparent!important;\n        top: -5px;\n    }\n", "error_marker.css", false);
    });
    ace.define("ace/ace", ["require", "exports", "module", "ace/lib/dom", "ace/range", "ace/editor", "ace/edit_session", "ace/undomanager", "ace/virtual_renderer", "ace/worker/worker_client", "ace/keyboard/hash_handler", "ace/placeholder", "ace/multi_select", "ace/mode/folding/fold_mode", "ace/theme/textmate", "ace/ext/error_marker", "ace/config", "ace/loader_build"], function(require2, exports3, module3) {
      require2("./loader_build")(exports3);
      var dom = require2("./lib/dom");
      var Range = require2("./range").Range;
      var Editor = require2("./editor").Editor;
      var EditSession = require2("./edit_session").EditSession;
      var UndoManager = require2("./undomanager").UndoManager;
      var Renderer = require2("./virtual_renderer").VirtualRenderer;
      require2("./worker/worker_client");
      require2("./keyboard/hash_handler");
      require2("./placeholder");
      require2("./multi_select");
      require2("./mode/folding/fold_mode");
      require2("./theme/textmate");
      require2("./ext/error_marker");
      exports3.config = require2("./config");
      exports3.edit = function(el, options) {
        if (typeof el == "string") {
          var _id = el;
          el = document.getElementById(_id);
          if (!el)
            throw new Error("ace.edit can't find div #" + _id);
        }
        if (el && el.env && el.env.editor instanceof Editor)
          return el.env.editor;
        var value = "";
        if (el && /input|textarea/i.test(el.tagName)) {
          var oldNode = el;
          value = oldNode.value;
          el = dom.createElement("pre");
          oldNode.parentNode.replaceChild(el, oldNode);
        } else if (el) {
          value = el.textContent;
          el.innerHTML = "";
        }
        var doc = exports3.createEditSession(value);
        var editor = new Editor(new Renderer(el), doc, options);
        var env = {
          document: doc,
          editor,
          onResize: editor.resize.bind(editor, null)
        };
        if (oldNode)
          env.textarea = oldNode;
        editor.on("destroy", function() {
          env.editor.container.env = null;
        });
        editor.container.env = editor.env = env;
        return editor;
      };
      exports3.createEditSession = function(text, mode) {
        var doc = new EditSession(text, mode);
        doc.setUndoManager(new UndoManager());
        return doc;
      };
      exports3.Range = Range;
      exports3.Editor = Editor;
      exports3.EditSession = EditSession;
      exports3.UndoManager = UndoManager;
      exports3.VirtualRenderer = Renderer;
      var version2 = exports3.config.version;
      exports3.version = version2;
    });
    (function() {
      ace.require(["ace/ace"], function(a3) {
        if (a3) {
          a3.config.init(true);
          a3.define = ace.define;
        }
        var global2 = /* @__PURE__ */ (function() {
          return this;
        })();
        if (!global2 && typeof window != "undefined") global2 = window;
        if (!global2 && typeof self != "undefined") global2 = self;
        if (!global2.ace)
          global2.ace = a3;
        for (var key in a3) if (a3.hasOwnProperty(key))
          global2.ace[key] = a3[key];
        global2.ace["default"] = global2.ace;
        if (module2) {
          module2.exports = global2.ace;
        }
      });
    })();
  })(ace$1);
  return ace$1.exports;
}
requireAce();
ace.config.setModuleLoader("ace/ext/beautify", () => __vitePreload(() => import("./ext-beautify-Dl9B--v5.js").then((n) => n.e), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/ext/code_lens", () => __vitePreload(() => import("./ext-code_lens-CqdMTDGA.js").then((n) => n.e), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/ext/command_bar", () => __vitePreload(() => import("./ext-command_bar-BSj3pTTr.js").then((n) => n.e), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/ext/elastic_tabstops_lite", () => __vitePreload(() => import("./ext-elastic_tabstops_lite-YK0AT8v7.js").then((n) => n.e), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/ext/emmet", () => __vitePreload(() => import("./ext-emmet-BFGnO_UW.js").then((n) => n.e), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/ext/error_marker", () => __vitePreload(() => import("./ext-error_marker-BWj8h7OB.js").then((n) => n.e), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/ext/hardwrap", () => __vitePreload(() => import("./ext-hardwrap-pHgvqGpf.js").then((n) => n.e), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/ext/inline_autocomplete", () => __vitePreload(() => import("./ext-inline_autocomplete-CM_HX5Be.js").then((n) => n.e), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/ext/keyboard_menu", () => __vitePreload(() => import("./ext-keybinding_menu-mFeWNyJP.js").then((n) => n.e), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/ext/language_tools", () => __vitePreload(() => Promise.resolve().then(() => extLanguage_tools$1), true ? void 0 : void 0, import.meta.url));
ace.config.setModuleLoader("ace/ext/linking", () => __vitePreload(() => import("./ext-linking-BmmAlJ6E.js").then((n) => n.e), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/ext/modelist", () => __vitePreload(() => import("./ext-modelist-DGZuS92W.js").then((n) => n.e), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/ext/options", () => __vitePreload(() => import("./ext-options-Bygm6pVJ.js").then((n) => n.e), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/ext/prompt", () => __vitePreload(() => import("./ext-prompt-DjufohbJ.js").then((n) => n.e), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/ext/rtl", () => __vitePreload(() => import("./ext-rtl-CGnuhf6c.js").then((n) => n.e), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/ext/searchbox", () => __vitePreload(() => import("./ext-searchbox-p1_h9Gnz.js").then((n) => n.e), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/ext/settings_menu", () => __vitePreload(() => import("./ext-settings_menu-D50WWwXR.js").then((n) => n.e), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/ext/simple_tokenizer", () => __vitePreload(() => import("./ext-simple_tokenizer-Cvxflvap.js").then((n) => n.e), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/ext/spellcheck", () => __vitePreload(() => import("./ext-spellcheck-y4plFcMI.js").then((n) => n.e), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/ext/split", () => __vitePreload(() => import("./ext-split-C5QZuRWB.js").then((n) => n.e), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/ext/static_highlight", () => __vitePreload(() => import("./ext-static_highlight-CoTBZoOu.js").then((n) => n.e), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/ext/statusbar", () => __vitePreload(() => import("./ext-statusbar-D4HEDRqS.js").then((n) => n.e), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/ext/textarea", () => __vitePreload(() => import("./ext-textarea-vhIRSru2.js").then((n) => n.e), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/ext/themelist", () => __vitePreload(() => import("./ext-themelist-CwGWX997.js").then((n) => n.e), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/ext/whitespace", () => __vitePreload(() => import("./ext-whitespace-nf-6xEAt.js").then((n) => n.e), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/keyboard/emacs", () => __vitePreload(() => import("./keybinding-emacs-BKNOL6hJ.js").then((n) => n.k), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/keyboard/sublime", () => __vitePreload(() => import("./keybinding-sublime-DlexItxy.js").then((n) => n.k), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/keyboard/vim", () => __vitePreload(() => import("./keybinding-vim-ChkXBf03.js").then((n) => n.k), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/keyboard/vscode", () => __vitePreload(() => import("./keybinding-vscode-BIvB5OoU.js").then((n) => n.k), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/mode/abap", () => __vitePreload(() => import("./mode-abap-CoJIYoUs.js").then((n) => n.m), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/mode/abc", () => __vitePreload(() => import("./mode-abc-K6Jv4kf6.js").then((n) => n.m), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/mode/actionscript", () => __vitePreload(() => import("./mode-actionscript-DZZi5Gzc.js").then((n) => n.m), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/mode/ada", () => __vitePreload(() => import("./mode-ada-BFyXi8hd.js").then((n) => n.m), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/mode/alda", () => __vitePreload(() => import("./mode-alda-DFmVZKVT.js").then((n) => n.m), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/mode/apache_conf", () => __vitePreload(() => import("./mode-apache_conf-Bpp-wdKN.js").then((n) => n.m), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/mode/apex", () => __vitePreload(() => import("./mode-apex-Ba9SdJaH.js").then((n) => n.m), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/mode/applescript", () => __vitePreload(() => import("./mode-applescript-DjhmgZAC.js").then((n) => n.m), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/mode/aql", () => __vitePreload(() => import("./mode-aql-BfoNYja0.js").then((n) => n.m), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/mode/asciidoc", () => __vitePreload(() => import("./mode-asciidoc-DOzjnkU4.js").then((n) => n.m), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/mode/asl", () => __vitePreload(() => import("./mode-asl-Cq_RLdBC.js").then((n) => n.m), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/mode/assembly_arm32", () => __vitePreload(() => import("./mode-assembly_arm32-CUjw2ZGw.js").then((n) => n.m), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/mode/assembly_x86", () => __vitePreload(() => import("./mode-assembly_x86-BP5Zq3k0.js").then((n) => n.m), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/mode/astro", () => __vitePreload(() => import("./mode-astro-DXvJCiIB.js").then((n) => n.m), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/mode/autohotkey", () => __vitePreload(() => import("./mode-autohotkey-Byt9AXcC.js").then((n) => n.m), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/mode/basic", () => __vitePreload(() => import("./mode-basic-BMhVS773.js").then((n) => n.m), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/mode/batchfile", () => __vitePreload(() => import("./mode-batchfile-U6QOc10r.js").then((n) => n.m), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/mode/bibtex", () => __vitePreload(() => import("./mode-bibtex-fWWGeveu.js").then((n) => n.m), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/mode/c9search", () => __vitePreload(() => import("./mode-c9search-BLBa3iXk.js").then((n) => n.m), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/mode/c_cpp", () => __vitePreload(() => import("./mode-c_cpp-D15GVCuO.js").then((n) => n.m), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/mode/cirru", () => __vitePreload(() => import("./mode-cirru-C5CFEgbx.js").then((n) => n.m), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/mode/clojure", () => __vitePreload(() => import("./mode-clojure-BbZxdP9O.js").then((n) => n.m), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/mode/cobol", () => __vitePreload(() => import("./mode-cobol-tl8JUhKv.js").then((n) => n.m), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/mode/coffee", () => __vitePreload(() => import("./mode-coffee-CKgOsbly.js").then((n) => n.m), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/mode/coldfusion", () => __vitePreload(() => import("./mode-coldfusion-DBc7dVDP.js").then((n) => n.m), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/mode/crystal", () => __vitePreload(() => import("./mode-crystal-D5hlE0Ir.js").then((n) => n.m), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/mode/csharp", () => __vitePreload(() => import("./mode-csharp-BD4J11fi.js").then((n) => n.m), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/mode/csound_document", () => __vitePreload(() => import("./mode-csound_document-diNo1koQ.js").then((n) => n.m), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/mode/csound_orchestra", () => __vitePreload(() => import("./mode-csound_orchestra-Cjv9S6zv.js").then((n) => n.m), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/mode/csound_score", () => __vitePreload(() => import("./mode-csound_score-OXliK_l1.js").then((n) => n.m), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/mode/csp", () => __vitePreload(() => import("./mode-csp-BHtfAvxi.js").then((n) => n.m), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/mode/css", () => __vitePreload(() => import("./mode-css-6I_Ngj6P.js").then((n) => n.m), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/mode/csv", () => __vitePreload(() => import("./mode-csv-QRYZFb-t.js").then((n) => n.m), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/mode/curly", () => __vitePreload(() => import("./mode-curly-DCj2X2hl.js").then((n) => n.m), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/mode/cuttlefish", () => __vitePreload(() => import("./mode-cuttlefish-Dj7CxUyf.js").then((n) => n.m), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/mode/d", () => __vitePreload(() => import("./mode-d-DprYn0hM.js").then((n) => n.m), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/mode/dart", () => __vitePreload(() => import("./mode-dart-B43ot3jB.js").then((n) => n.m), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/mode/diff", () => __vitePreload(() => import("./mode-diff-KJt0dvcZ.js").then((n) => n.m), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/mode/django", () => __vitePreload(() => import("./mode-django-LofrBer5.js").then((n) => n.m), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/mode/dockerfile", () => __vitePreload(() => import("./mode-dockerfile-ChLvuPQv.js").then((n) => n.m), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/mode/dot", () => __vitePreload(() => import("./mode-dot-vdjRoPiM.js").then((n) => n.m), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/mode/drools", () => __vitePreload(() => import("./mode-drools-CFDGdl6F.js").then((n) => n.m), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/mode/edifact", () => __vitePreload(() => import("./mode-edifact-DXrLmAa7.js").then((n) => n.m), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/mode/eiffel", () => __vitePreload(() => import("./mode-eiffel-BouebS_K.js").then((n) => n.m), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/mode/ejs", () => __vitePreload(() => import("./mode-ejs-bak0zREt.js").then((n) => n.m), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/mode/elixir", () => __vitePreload(() => import("./mode-elixir-BUFdbHWD.js").then((n) => n.m), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/mode/elm", () => __vitePreload(() => import("./mode-elm-DQqfX21K.js").then((n) => n.m), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/mode/erlang", () => __vitePreload(() => import("./mode-erlang-BabKqYFK.js").then((n) => n.m), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/mode/flix", () => __vitePreload(() => import("./mode-flix-CdiznzhR.js").then((n) => n.m), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/mode/forth", () => __vitePreload(() => import("./mode-forth-CJVERO74.js").then((n) => n.m), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/mode/fortran", () => __vitePreload(() => import("./mode-fortran-BGnkwwBY.js").then((n) => n.m), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/mode/fsharp", () => __vitePreload(() => import("./mode-fsharp-BuG6zKeS.js").then((n) => n.m), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/mode/fsl", () => __vitePreload(() => import("./mode-fsl-C6mGzeAA.js").then((n) => n.m), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/mode/ftl", () => __vitePreload(() => import("./mode-ftl-B4oix0P8.js").then((n) => n.m), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/mode/gcode", () => __vitePreload(() => import("./mode-gcode-C4MZyuFj.js").then((n) => n.m), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/mode/gherkin", () => __vitePreload(() => import("./mode-gherkin-DZ__B1dq.js").then((n) => n.m), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/mode/gitignore", () => __vitePreload(() => import("./mode-gitignore-Cg5ZY9zk.js").then((n) => n.m), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/mode/glsl", () => __vitePreload(() => import("./mode-glsl-DDXprz8e.js").then((n) => n.m), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/mode/gobstones", () => __vitePreload(() => import("./mode-gobstones-BJlz9eSg.js").then((n) => n.m), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/mode/golang", () => __vitePreload(() => import("./mode-golang-Dl2altwz.js").then((n) => n.m), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/mode/graphqlschema", () => __vitePreload(() => import("./mode-graphqlschema-D6gnkemc.js").then((n) => n.m), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/mode/groovy", () => __vitePreload(() => import("./mode-groovy-DhfP5HHW.js").then((n) => n.m), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/mode/haml", () => __vitePreload(() => import("./mode-haml-CqLqpbeG.js").then((n) => n.m), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/mode/handlebars", () => __vitePreload(() => import("./mode-handlebars-euGUhLK6.js").then((n) => n.m), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/mode/haskell", () => __vitePreload(() => import("./mode-haskell-C8OWZL27.js").then((n) => n.m), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/mode/haskell_cabal", () => __vitePreload(() => import("./mode-haskell_cabal-DF_q1BbF.js").then((n) => n.m), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/mode/haxe", () => __vitePreload(() => import("./mode-haxe-D-TOYd8-.js").then((n) => n.m), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/mode/hjson", () => __vitePreload(() => import("./mode-hjson-B-shm2wY.js").then((n) => n.m), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/mode/html", () => __vitePreload(() => import("./mode-html-CJNq3Ucw.js").then((n) => n.m), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/mode/html_elixir", () => __vitePreload(() => import("./mode-html_elixir-BXV9N0H_.js").then((n) => n.m), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/mode/html_ruby", () => __vitePreload(() => import("./mode-html_ruby-Dzd_jkdv.js").then((n) => n.m), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/mode/ini", () => __vitePreload(() => import("./mode-ini-0cSv0LQp.js").then((n) => n.m), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/mode/io", () => __vitePreload(() => import("./mode-io-gBJx_OIO.js").then((n) => n.m), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/mode/ion", () => __vitePreload(() => import("./mode-ion-DDePBip0.js").then((n) => n.m), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/mode/jack", () => __vitePreload(() => import("./mode-jack-BA9P6FVu.js").then((n) => n.m), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/mode/jade", () => __vitePreload(() => import("./mode-jade-m-Kmpx1E.js").then((n) => n.m), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/mode/java", () => __vitePreload(() => import("./mode-java-Cl_vdz-Z.js").then((n) => n.m), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/mode/javascript", () => __vitePreload(() => import("./mode-javascript-Cx6RF9Bb.js").then((n) => n.m), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/mode/jexl", () => __vitePreload(() => import("./mode-jexl-DEIWZiyt.js").then((n) => n.m), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/mode/json", () => __vitePreload(() => import("./mode-json-DK4Fnegh.js").then((n) => n.m), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/mode/json5", () => __vitePreload(() => import("./mode-json5-DfRMzHBN.js").then((n) => n.m), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/mode/jsoniq", () => __vitePreload(() => import("./mode-jsoniq-D6YPaKvF.js").then((n) => n.m), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/mode/jsp", () => __vitePreload(() => import("./mode-jsp-7G7GOP0G.js").then((n) => n.m), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/mode/jssm", () => __vitePreload(() => import("./mode-jssm-BZKTUlI-.js").then((n) => n.m), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/mode/jsx", () => __vitePreload(() => import("./mode-jsx-C-zFIkoR.js").then((n) => n.m), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/mode/julia", () => __vitePreload(() => import("./mode-julia-Cyq55iuO.js").then((n) => n.m), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/mode/kotlin", () => __vitePreload(() => import("./mode-kotlin-D8ZJE4jV.js").then((n) => n.m), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/mode/latex", () => __vitePreload(() => import("./mode-latex-BfcLf0nZ.js").then((n) => n.m), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/mode/latte", () => __vitePreload(() => import("./mode-latte-BvGEzwSA.js").then((n) => n.m), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/mode/less", () => __vitePreload(() => import("./mode-less-BKUk4aI-.js").then((n) => n.m), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/mode/liquid", () => __vitePreload(() => import("./mode-liquid-CWChmWi7.js").then((n) => n.m), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/mode/lisp", () => __vitePreload(() => import("./mode-lisp-BhbCaMU7.js").then((n) => n.m), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/mode/livescript", () => __vitePreload(() => import("./mode-livescript-YQ1eZl0V.js").then((n) => n.m), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/mode/logiql", () => __vitePreload(() => import("./mode-logiql-B6GTihil.js").then((n) => n.m), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/mode/logtalk", () => __vitePreload(() => import("./mode-logtalk-B5_0emHC.js").then((n) => n.m), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/mode/lsl", () => __vitePreload(() => import("./mode-lsl-DYDu8EGZ.js").then((n) => n.m), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/mode/lua", () => __vitePreload(() => import("./mode-lua-CwY6vMo9.js").then((n) => n.m), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/mode/luapage", () => __vitePreload(() => import("./mode-luapage-Cddhpam9.js").then((n) => n.m), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/mode/lucene", () => __vitePreload(() => import("./mode-lucene-CE6WdvRb.js").then((n) => n.m), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/mode/makefile", () => __vitePreload(() => import("./mode-makefile-QOCu1Y0e.js").then((n) => n.m), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/mode/markdown", () => __vitePreload(() => import("./mode-markdown-BfGBRyjj.js").then((n) => n.m), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/mode/mask", () => __vitePreload(() => import("./mode-mask-xAvndP-m.js").then((n) => n.m), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/mode/matlab", () => __vitePreload(() => import("./mode-matlab-hsVrORqj.js").then((n) => n.m), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/mode/maze", () => __vitePreload(() => import("./mode-maze-CeEJbSNe.js").then((n) => n.m), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/mode/mediawiki", () => __vitePreload(() => import("./mode-mediawiki-ffY-kBP0.js").then((n) => n.m), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/mode/mel", () => __vitePreload(() => import("./mode-mel-Bl1QnKqw.js").then((n) => n.m), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/mode/mips", () => __vitePreload(() => import("./mode-mips-CYP0EDu8.js").then((n) => n.m), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/mode/mixal", () => __vitePreload(() => import("./mode-mixal-B-YXHjpY.js").then((n) => n.m), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/mode/mushcode", () => __vitePreload(() => import("./mode-mushcode-CpeQRBG8.js").then((n) => n.m), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/mode/mysql", () => __vitePreload(() => import("./mode-mysql-DppzlSwV.js").then((n) => n.m), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/mode/nasal", () => __vitePreload(() => import("./mode-nasal-DH1B-0M2.js").then((n) => n.m), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/mode/nginx", () => __vitePreload(() => import("./mode-nginx-C-h3NP5t.js").then((n) => n.m), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/mode/nim", () => __vitePreload(() => import("./mode-nim-DPq9tfNf.js").then((n) => n.m), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/mode/nix", () => __vitePreload(() => import("./mode-nix-CaoIzjHO.js").then((n) => n.m), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/mode/nsis", () => __vitePreload(() => import("./mode-nsis-LBwFZuIJ.js").then((n) => n.m), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/mode/nunjucks", () => __vitePreload(() => import("./mode-nunjucks-DHqFWhD5.js").then((n) => n.m), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/mode/objectivec", () => __vitePreload(() => import("./mode-objectivec-Cp9q1uqU.js").then((n) => n.m), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/mode/ocaml", () => __vitePreload(() => import("./mode-ocaml-55mRilij.js").then((n) => n.m), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/mode/odin", () => __vitePreload(() => import("./mode-odin-C2UW-QDW.js").then((n) => n.m), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/mode/partiql", () => __vitePreload(() => import("./mode-partiql-BtIie6hx.js").then((n) => n.m), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/mode/pascal", () => __vitePreload(() => import("./mode-pascal-CI1Fsao0.js").then((n) => n.m), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/mode/perl", () => __vitePreload(() => import("./mode-perl-DZL3ReED.js").then((n) => n.m), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/mode/pgsql", () => __vitePreload(() => import("./mode-pgsql-3y9nMMeO.js").then((n) => n.m), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/mode/php", () => __vitePreload(() => import("./mode-php-VrFGijsV.js").then((n) => n.m), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/mode/php_laravel_blade", () => __vitePreload(() => import("./mode-php_laravel_blade-8Zak9TcW.js").then((n) => n.m), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/mode/pig", () => __vitePreload(() => import("./mode-pig-DlOLo6Q5.js").then((n) => n.m), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/mode/plain_text", () => __vitePreload(() => import("./mode-plain_text-BveFa2oV.js").then((n) => n.m), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/mode/plsql", () => __vitePreload(() => import("./mode-plsql-B-VCYcwI.js").then((n) => n.m), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/mode/powershell", () => __vitePreload(() => import("./mode-powershell-DKHqPGWi.js").then((n) => n.m), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/mode/praat", () => __vitePreload(() => import("./mode-praat-CpmvAplF.js").then((n) => n.m), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/mode/prisma", () => __vitePreload(() => import("./mode-prisma-Dopr4iO0.js").then((n) => n.m), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/mode/prolog", () => __vitePreload(() => import("./mode-prolog-vn1Wz0CM.js").then((n) => n.m), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/mode/properties", () => __vitePreload(() => import("./mode-properties-7Jaw3TwR.js").then((n) => n.m), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/mode/protobuf", () => __vitePreload(() => import("./mode-protobuf-yN8WfFV-.js").then((n) => n.m), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/mode/prql", () => __vitePreload(() => import("./mode-prql-xoVHyPUx.js").then((n) => n.m), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/mode/puppet", () => __vitePreload(() => import("./mode-puppet-cTm2pGYh.js").then((n) => n.m), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/mode/python", () => __vitePreload(() => import("./mode-python-BiUJzI1Z.js").then((n) => n.m), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/mode/qml", () => __vitePreload(() => import("./mode-qml-C3iruRyx.js").then((n) => n.m), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/mode/r", () => __vitePreload(() => import("./mode-r-DvlFEBJf.js").then((n) => n.m), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/mode/raku", () => __vitePreload(() => import("./mode-raku-Dl6Fg8Jy.js").then((n) => n.m), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/mode/razor", () => __vitePreload(() => import("./mode-razor-CVM4j5MS.js").then((n) => n.m), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/mode/rdoc", () => __vitePreload(() => import("./mode-rdoc-CTYG0jON.js").then((n) => n.m), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/mode/red", () => __vitePreload(() => import("./mode-red-2NKXEL0_.js").then((n) => n.m), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/mode/redshift", () => __vitePreload(() => import("./mode-redshift-exEp-S3N.js").then((n) => n.m), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/mode/rhtml", () => __vitePreload(() => import("./mode-rhtml-Dq2csXGw.js").then((n) => n.m), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/mode/robot", () => __vitePreload(() => import("./mode-robot-CrgDCVQc.js").then((n) => n.m), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/mode/rst", () => __vitePreload(() => import("./mode-rst-BUGuVVP6.js").then((n) => n.m), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/mode/ruby", () => __vitePreload(() => import("./mode-ruby-B-_iaIFL.js").then((n) => n.m), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/mode/rust", () => __vitePreload(() => import("./mode-rust-v-tvpQdh.js").then((n) => n.m), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/mode/sac", () => __vitePreload(() => import("./mode-sac-BzgZwnjY.js").then((n) => n.m), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/mode/sass", () => __vitePreload(() => import("./mode-sass-BmK9Df5T.js").then((n) => n.m), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/mode/scad", () => __vitePreload(() => import("./mode-scad-BuJcuizI.js").then((n) => n.m), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/mode/scala", () => __vitePreload(() => import("./mode-scala-SHdEv1jB.js").then((n) => n.m), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/mode/scheme", () => __vitePreload(() => import("./mode-scheme-D_BNhqzq.js").then((n) => n.m), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/mode/scrypt", () => __vitePreload(() => import("./mode-scrypt-COYOFwAr.js").then((n) => n.m), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/mode/scss", () => __vitePreload(() => import("./mode-scss-C3zSRuXT.js").then((n) => n.m), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/mode/sh", () => __vitePreload(() => import("./mode-sh-o2mZN-ca.js").then((n) => n.m), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/mode/sjs", () => __vitePreload(() => import("./mode-sjs-DKTTil45.js").then((n) => n.m), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/mode/slim", () => __vitePreload(() => import("./mode-slim-D_wp-l8a.js").then((n) => n.m), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/mode/smarty", () => __vitePreload(() => import("./mode-smarty-B2JJLeWy.js").then((n) => n.m), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/mode/smithy", () => __vitePreload(() => import("./mode-smithy-BnRCN8o-.js").then((n) => n.m), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/mode/snippets", () => __vitePreload(() => import("./mode-snippets-ClduVerj.js").then((n) => n.m), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/mode/soy_template", () => __vitePreload(() => import("./mode-soy_template-Dgwg8mlK.js").then((n) => n.m), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/mode/space", () => __vitePreload(() => import("./mode-space-ea6Zwj6q.js").then((n) => n.m), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/mode/sparql", () => __vitePreload(() => import("./mode-sparql-CZqcDa5l.js").then((n) => n.m), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/mode/sql", () => __vitePreload(() => import("./mode-sql-39PkWdCB.js").then((n) => n.m), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/mode/sqlserver", () => __vitePreload(() => import("./mode-sqlserver-B_qV9Zkl.js").then((n) => n.m), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/mode/stylus", () => __vitePreload(() => import("./mode-stylus-C9cJiwrm.js").then((n) => n.m), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/mode/svg", () => __vitePreload(() => import("./mode-svg-BGOFkmmZ.js").then((n) => n.m), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/mode/swift", () => __vitePreload(() => import("./mode-swift-CNtCOE0_.js").then((n) => n.m), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/mode/tcl", () => __vitePreload(() => import("./mode-tcl-BdwD0F0f.js").then((n) => n.m), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/mode/terraform", () => __vitePreload(() => import("./mode-terraform-CW5gJOk5.js").then((n) => n.m), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/mode/tex", () => __vitePreload(() => import("./mode-tex-DqlEZ-sz.js").then((n) => n.m), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/mode/text", () => __vitePreload(() => import("./mode-text-l0F3jLri.js").then((n) => n.m), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/mode/textile", () => __vitePreload(() => import("./mode-textile-5cu--4Yk.js").then((n) => n.m), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/mode/toml", () => __vitePreload(() => import("./mode-toml-Lp-7cRt-.js").then((n) => n.m), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/mode/tsv", () => __vitePreload(() => import("./mode-tsv-BtBntP9Z.js").then((n) => n.m), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/mode/tsx", () => __vitePreload(() => import("./mode-tsx-BB_McIE1.js").then((n) => n.m), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/mode/turtle", () => __vitePreload(() => import("./mode-turtle-BwWPzpEp.js").then((n) => n.m), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/mode/twig", () => __vitePreload(() => import("./mode-twig-BW6g3667.js").then((n) => n.m), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/mode/typescript", () => __vitePreload(() => import("./mode-typescript-D5hmkVsl.js").then((n) => n.m), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/mode/vala", () => __vitePreload(() => import("./mode-vala-pp2mhh3R.js").then((n) => n.m), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/mode/vbscript", () => __vitePreload(() => import("./mode-vbscript-CVCS86Wt.js").then((n) => n.m), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/mode/velocity", () => __vitePreload(() => import("./mode-velocity-ChnZ-4PS.js").then((n) => n.m), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/mode/verilog", () => __vitePreload(() => import("./mode-verilog-CWW49TCv.js").then((n) => n.m), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/mode/vhdl", () => __vitePreload(() => import("./mode-vhdl-9anfttAh.js").then((n) => n.m), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/mode/visualforce", () => __vitePreload(() => import("./mode-visualforce-C9dv1Vx9.js").then((n) => n.m), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/mode/vue", () => __vitePreload(() => import("./mode-vue-Dac41fvY.js").then((n) => n.m), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/mode/wollok", () => __vitePreload(() => import("./mode-wollok-ChpqQwIm.js").then((n) => n.m), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/mode/xml", () => __vitePreload(() => import("./mode-xml-B_Ulsrlx.js").then((n) => n.m), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/mode/xquery", () => __vitePreload(() => import("./mode-xquery-C36dWvlY.js").then((n) => n.m), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/mode/yaml", () => __vitePreload(() => import("./mode-yaml-BP9npEs2.js").then((n) => n.m), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/mode/zeek", () => __vitePreload(() => import("./mode-zeek-B1kiR5-v.js").then((n) => n.m), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/mode/zig", () => __vitePreload(() => import("./mode-zig-CcA6box7.js").then((n) => n.m), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/theme/ambiance", () => __vitePreload(() => import("./theme-ambiance-DBH6YNc8.js").then((n) => n.t), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/theme/chaos", () => __vitePreload(() => import("./theme-chaos-Bxp06iRJ.js").then((n) => n.t), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/theme/chrome", () => __vitePreload(() => import("./theme-chrome-BZ1qI3ir.js").then((n) => n.t), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/theme/cloud9_day", () => __vitePreload(() => import("./theme-cloud9_day-sFlSCFXs.js").then((n) => n.t), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/theme/cloud9_night", () => __vitePreload(() => import("./theme-cloud9_night-BVKExPfP.js").then((n) => n.t), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/theme/cloud9_night_low_color", () => __vitePreload(() => import("./theme-cloud9_night_low_color-ClqoJOf5.js").then((n) => n.t), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/theme/cloud_editor", () => __vitePreload(() => import("./theme-cloud_editor-CMRRc3WA.js").then((n) => n.t), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/theme/cloud_editor_dark", () => __vitePreload(() => import("./theme-cloud_editor_dark-C6ATY407.js").then((n) => n.t), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/theme/clouds", () => __vitePreload(() => import("./theme-clouds-CsXWWASn.js").then((n) => n.t), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/theme/clouds_midnight", () => __vitePreload(() => import("./theme-clouds_midnight-D542P5fa.js").then((n) => n.t), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/theme/cobalt", () => __vitePreload(() => import("./theme-cobalt-CXrxpGuz.js").then((n) => n.t), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/theme/crimson_editor", () => __vitePreload(() => import("./theme-crimson_editor-DiGfxtl8.js").then((n) => n.t), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/theme/dawn", () => __vitePreload(() => import("./theme-dawn-ZrK_oDfx.js").then((n) => n.t), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/theme/dracula", () => __vitePreload(() => import("./theme-dracula-phz6VyXe.js").then((n) => n.t), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/theme/dreamweaver", () => __vitePreload(() => import("./theme-dreamweaver-YHGvUJjf.js").then((n) => n.t), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/theme/eclipse", () => __vitePreload(() => import("./theme-eclipse-CMGWSYox.js").then((n) => n.t), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/theme/github", () => __vitePreload(() => import("./theme-github-DsfPVYNl.js").then((n) => n.t), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/theme/github_dark", () => __vitePreload(() => import("./theme-github_dark-DYuOTbJD.js").then((n) => n.t), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/theme/github_light_default", () => __vitePreload(() => import("./theme-github_light_default-G5qAbxWO.js").then((n) => n.t), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/theme/gob", () => __vitePreload(() => import("./theme-gob-DvV8zUb-.js").then((n) => n.t), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/theme/gruvbox", () => __vitePreload(() => import("./theme-gruvbox-DYncCUA4.js").then((n) => n.t), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/theme/gruvbox_dark_hard", () => __vitePreload(() => import("./theme-gruvbox_dark_hard-HjhgcMFx.js").then((n) => n.t), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/theme/gruvbox_light_hard", () => __vitePreload(() => import("./theme-gruvbox_light_hard-BX8XRcVN.js").then((n) => n.t), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/theme/idle_fingers", () => __vitePreload(() => import("./theme-idle_fingers-C220QpyQ.js").then((n) => n.t), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/theme/iplastic", () => __vitePreload(() => import("./theme-iplastic-8jrkKmIP.js").then((n) => n.t), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/theme/katzenmilch", () => __vitePreload(() => import("./theme-katzenmilch-DaYCZ8TH.js").then((n) => n.t), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/theme/kr_theme", () => __vitePreload(() => import("./theme-kr_theme-CePFl_Q4.js").then((n) => n.t), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/theme/kuroir", () => __vitePreload(() => import("./theme-kuroir-BMUyiBdJ.js").then((n) => n.t), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/theme/merbivore", () => __vitePreload(() => import("./theme-merbivore-BdLcrjRU.js").then((n) => n.t), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/theme/merbivore_soft", () => __vitePreload(() => import("./theme-merbivore_soft-CIar1c9q.js").then((n) => n.t), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/theme/mono_industrial", () => __vitePreload(() => import("./theme-mono_industrial-DqhegeF7.js").then((n) => n.t), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/theme/monokai", () => __vitePreload(() => import("./theme-monokai-CIsUqAs6.js").then((n) => n.t), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/theme/nord_dark", () => __vitePreload(() => import("./theme-nord_dark-DD_K3z6r.js").then((n) => n.t), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/theme/one_dark", () => __vitePreload(() => import("./theme-one_dark-5jLboru-.js").then((n) => n.t), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/theme/pastel_on_dark", () => __vitePreload(() => import("./theme-pastel_on_dark-Y-bNCSSm.js").then((n) => n.t), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/theme/solarized_dark", () => __vitePreload(() => import("./theme-solarized_dark-DirBUamG.js").then((n) => n.t), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/theme/solarized_light", () => __vitePreload(() => import("./theme-solarized_light-BONjq_Dz.js").then((n) => n.t), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/theme/sqlserver", () => __vitePreload(() => import("./theme-sqlserver-Cat_KStn.js").then((n) => n.t), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/theme/terminal", () => __vitePreload(() => import("./theme-terminal-DZy15PSG.js").then((n) => n.t), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/theme/textmate", () => __vitePreload(() => import("./theme-textmate-B0ZxdHBY.js").then((n) => n.t), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/theme/tomorrow", () => __vitePreload(() => import("./theme-tomorrow-DAhv_gCw.js").then((n) => n.t), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/theme/tomorrow_night", () => __vitePreload(() => import("./theme-tomorrow_night-BKyAFSsK.js").then((n) => n.t), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/theme/tomorrow_night_blue", () => __vitePreload(() => import("./theme-tomorrow_night_blue-8qP4vKpv.js").then((n) => n.t), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/theme/tomorrow_night_bright", () => __vitePreload(() => import("./theme-tomorrow_night_bright-C5ZHYVyF.js").then((n) => n.t), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/theme/tomorrow_night_eighties", () => __vitePreload(() => import("./theme-tomorrow_night_eighties-DjxhnCRo.js").then((n) => n.t), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/theme/twilight", () => __vitePreload(() => import("./theme-twilight-wUejPIIF.js").then((n) => n.t), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/theme/vibrant_ink", () => __vitePreload(() => import("./theme-vibrant_ink-Vth4hmzP.js").then((n) => n.t), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/theme/xcode", () => __vitePreload(() => import("./theme-xcode-DuYF42Lh.js").then((n) => n.t), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/mode/base_worker", () => __vitePreload(() => import("./worker-base-twUBBALK.js").then((n) => n.w), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/mode/coffee_worker", () => __vitePreload(() => import("./worker-coffee-BJvg7Q92.js").then((n) => n.w), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/mode/css_worker", () => __vitePreload(() => import("./worker-css-CyPNhSrS.js").then((n) => n.w), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/mode/html_worker", () => __vitePreload(() => import("./worker-html-CDoKRDco.js").then((n) => n.w), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/mode/javascript_worker", () => __vitePreload(() => import("./worker-javascript-BNGmLTnb.js").then((n) => n.w), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/mode/json_worker", () => __vitePreload(() => import("./worker-json-3QTsJU8o.js").then((n) => n.w), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/mode/lua_worker", () => __vitePreload(() => import("./worker-lua-B3nazEL-.js").then((n) => n.w), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/mode/php_worker", () => __vitePreload(() => import("./worker-php-D9uPQaCi.js").then((n) => n.w), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/mode/xml_worker", () => __vitePreload(() => import("./worker-xml-CkWGByxO.js").then((n) => n.w), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/mode/xquery_worker", () => __vitePreload(() => import("./worker-xquery-D2C-QciK.js").then((n) => n.w), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/mode/yaml_worker", () => __vitePreload(() => import("./worker-yaml-BO1Wl9RI.js").then((n) => n.w), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/snippets/abap", () => __vitePreload(() => import("./abap-CPLhrGLb.js").then((n) => n.a), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/snippets/abc", () => __vitePreload(() => import("./abc-DjNSq81p.js").then((n) => n.a), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/snippets/actionscript", () => __vitePreload(() => import("./actionscript-B5WUYTyo.js").then((n) => n.a), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/snippets/ada", () => __vitePreload(() => import("./ada-DdrlL_FO.js").then((n) => n.a), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/snippets/alda", () => __vitePreload(() => import("./alda-BYsJ1K_b.js").then((n) => n.a), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/snippets/apache_conf", () => __vitePreload(() => import("./apache_conf-BG81ppA2.js").then((n) => n.a), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/snippets/apex", () => __vitePreload(() => import("./apex-B6eQIH4u.js").then((n) => n.a), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/snippets/applescript", () => __vitePreload(() => import("./applescript-Cv8XTwFd.js").then((n) => n.a), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/snippets/aql", () => __vitePreload(() => import("./aql-CZxh8h3z.js").then((n) => n.a), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/snippets/asciidoc", () => __vitePreload(() => import("./asciidoc-Dqxolpvq.js").then((n) => n.a), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/snippets/asl", () => __vitePreload(() => import("./asl-DOBi0y_f.js").then((n) => n.a), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/snippets/assembly_arm32", () => __vitePreload(() => import("./assembly_arm32-DgKH-2RH.js").then((n) => n.a), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/snippets/assembly_x86", () => __vitePreload(() => import("./assembly_x86-Blq03FxV.js").then((n) => n.a), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/snippets/astro", () => __vitePreload(() => import("./astro-BsT-bCVO.js").then((n) => n.a), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/snippets/autohotkey", () => __vitePreload(() => import("./autohotkey-CZ_Piv11.js").then((n) => n.a), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/snippets/basic", () => __vitePreload(() => import("./basic-B4UU94cN.js").then((n) => n.b), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/snippets/batchfile", () => __vitePreload(() => import("./batchfile-Bk1T9Olk.js").then((n) => n.b), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/snippets/bibtex", () => __vitePreload(() => import("./bibtex-DAQyn-B7.js").then((n) => n.b), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/snippets/c9search", () => __vitePreload(() => import("./c9search-CkpbmbVS.js").then((n) => n.c), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/snippets/c_cpp", () => __vitePreload(() => import("./c_cpp-BMsIRJ7z.js").then((n) => n.c), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/snippets/cirru", () => __vitePreload(() => import("./cirru-DT4EP6_5.js").then((n) => n.c), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/snippets/clojure", () => __vitePreload(() => import("./clojure-BS2ZcFaz.js").then((n) => n.c), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/snippets/cobol", () => __vitePreload(() => import("./cobol-CmQQHNLX.js").then((n) => n.c), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/snippets/coffee", () => __vitePreload(() => import("./coffee-C4kJ-dN3.js").then((n) => n.c), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/snippets/coldfusion", () => __vitePreload(() => import("./coldfusion-DpMmfRhV.js").then((n) => n.c), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/snippets/crystal", () => __vitePreload(() => import("./crystal-QTJmQkOM.js").then((n) => n.c), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/snippets/csharp", () => __vitePreload(() => import("./csharp-DjnvzZeu.js").then((n) => n.c), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/snippets/csound_document", () => __vitePreload(() => import("./csound_document-B4KpWsr5.js").then((n) => n.c), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/snippets/csound_orchestra", () => __vitePreload(() => import("./csound_orchestra-xOiO3s4p.js").then((n) => n.c), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/snippets/csound_score", () => __vitePreload(() => import("./csound_score-DaTV_t_P.js").then((n) => n.c), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/snippets/csp", () => __vitePreload(() => import("./csp-Dj-dgVOf.js").then((n) => n.c), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/snippets/css", () => __vitePreload(() => import("./css-dVnS8iRZ.js").then((n) => n.c), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/snippets/csv", () => __vitePreload(() => import("./csv-4S7YuZwW.js").then((n) => n.c), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/snippets/curly", () => __vitePreload(() => import("./curly-BmRbIPcO.js").then((n) => n.c), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/snippets/cuttlefish", () => __vitePreload(() => import("./cuttlefish-DRmwa2yh.js").then((n) => n.c), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/snippets/d", () => __vitePreload(() => import("./d-C5AsRHP_.js").then((n) => n.d), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/snippets/dart", () => __vitePreload(() => import("./dart-B4puCPKJ.js").then((n) => n.d), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/snippets/diff", () => __vitePreload(() => import("./diff-xfW_ZoLj.js").then((n) => n.d), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/snippets/django", () => __vitePreload(() => import("./django-DNry8Yf3.js").then((n) => n.d), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/snippets/dockerfile", () => __vitePreload(() => import("./dockerfile-CTQBGXyv.js").then((n) => n.d), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/snippets/dot", () => __vitePreload(() => import("./dot-DS8KePkE.js").then((n) => n.d), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/snippets/drools", () => __vitePreload(() => import("./drools-D-MVOdDK.js").then((n) => n.d), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/snippets/edifact", () => __vitePreload(() => import("./edifact-CVRlEwoa.js").then((n) => n.e), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/snippets/eiffel", () => __vitePreload(() => import("./eiffel-UmIHoIGg.js").then((n) => n.e), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/snippets/ejs", () => __vitePreload(() => import("./ejs-ClZ-Dz_t.js").then((n) => n.e), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/snippets/elixir", () => __vitePreload(() => import("./elixir-ChBBcpa5.js").then((n) => n.e), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/snippets/elm", () => __vitePreload(() => import("./elm-B3CdoPlX.js").then((n) => n.e), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/snippets/erlang", () => __vitePreload(() => import("./erlang-CI6MLa2a.js").then((n) => n.e), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/snippets/flix", () => __vitePreload(() => import("./flix-BJ86Wny2.js").then((n) => n.f), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/snippets/forth", () => __vitePreload(() => import("./forth-DW3Hm__a.js").then((n) => n.f), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/snippets/fortran", () => __vitePreload(() => import("./fortran-D6JyfC8-.js").then((n) => n.f), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/snippets/fsharp", () => __vitePreload(() => import("./fsharp-jsn-sgBb.js").then((n) => n.f), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/snippets/fsl", () => __vitePreload(() => import("./fsl-BMZAlDW3.js").then((n) => n.f), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/snippets/ftl", () => __vitePreload(() => import("./ftl-CYjyPu2u.js").then((n) => n.f), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/snippets/gcode", () => __vitePreload(() => import("./gcode-FQKk2nsC.js").then((n) => n.g), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/snippets/gherkin", () => __vitePreload(() => import("./gherkin-D1fmKt_D.js").then((n) => n.g), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/snippets/gitignore", () => __vitePreload(() => import("./gitignore-BeWtYn0_.js").then((n) => n.g), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/snippets/glsl", () => __vitePreload(() => import("./glsl-Bb4KPWY1.js").then((n) => n.g), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/snippets/gobstones", () => __vitePreload(() => import("./gobstones-BFXltZjr.js").then((n) => n.g), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/snippets/golang", () => __vitePreload(() => import("./golang-Csn1cpm8.js").then((n) => n.g), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/snippets/graphqlschema", () => __vitePreload(() => import("./graphqlschema-CRys0r-t.js").then((n) => n.g), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/snippets/groovy", () => __vitePreload(() => import("./groovy-Bzg_KKae.js").then((n) => n.g), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/snippets/haml", () => __vitePreload(() => import("./haml-bXeFMcRs.js").then((n) => n.h), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/snippets/handlebars", () => __vitePreload(() => import("./handlebars-LoUR2hao.js").then((n) => n.h), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/snippets/haskell", () => __vitePreload(() => import("./haskell-9q5FYLwd.js").then((n) => n.h), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/snippets/haskell_cabal", () => __vitePreload(() => import("./haskell_cabal-VZ1_fIKy.js").then((n) => n.h), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/snippets/haxe", () => __vitePreload(() => import("./haxe-CuWiNQM4.js").then((n) => n.h), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/snippets/hjson", () => __vitePreload(() => import("./hjson-C7mjJwsV.js").then((n) => n.h), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/snippets/html", () => __vitePreload(() => import("./html-rhH0FjxH.js").then((n) => n.h), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/snippets/html_elixir", () => __vitePreload(() => import("./html_elixir-W1nN4IBE.js").then((n) => n.h), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/snippets/html_ruby", () => __vitePreload(() => import("./html_ruby-DiyxJKSY.js").then((n) => n.h), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/snippets/ini", () => __vitePreload(() => import("./ini-C5ebUEXz.js").then((n) => n.i), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/snippets/io", () => __vitePreload(() => import("./io-RFpdnKpp.js").then((n) => n.i), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/snippets/ion", () => __vitePreload(() => import("./ion-BO0Ot4dR.js").then((n) => n.i), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/snippets/jack", () => __vitePreload(() => import("./jack-Cz_wdyMw.js").then((n) => n.j), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/snippets/jade", () => __vitePreload(() => import("./jade-kYYHZSKt.js").then((n) => n.j), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/snippets/java", () => __vitePreload(() => import("./java-DR7zS3X2.js").then((n) => n.j), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/snippets/javascript", () => __vitePreload(() => import("./javascript-CX82ho_N.js").then((n) => n.j), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/snippets/jexl", () => __vitePreload(() => import("./jexl-CN16mElf.js").then((n) => n.j), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/snippets/json", () => __vitePreload(() => import("./json-BcJ8iRPu.js").then((n) => n.j), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/snippets/json5", () => __vitePreload(() => import("./json5-BIgZS1vS.js").then((n) => n.j), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/snippets/jsoniq", () => __vitePreload(() => import("./jsoniq-B8_eFC-F.js").then((n) => n.j), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/snippets/jsp", () => __vitePreload(() => import("./jsp-CXgh4BZl.js").then((n) => n.j), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/snippets/jssm", () => __vitePreload(() => import("./jssm-Dh-ZuVKv.js").then((n) => n.j), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/snippets/jsx", () => __vitePreload(() => import("./jsx-CrD5_znW.js").then((n) => n.j), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/snippets/julia", () => __vitePreload(() => import("./julia-C4dIm8Bg.js").then((n) => n.j), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/snippets/kotlin", () => __vitePreload(() => import("./kotlin-DJJES3Jw.js").then((n) => n.k), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/snippets/latex", () => __vitePreload(() => import("./latex-Br4LnBTN.js").then((n) => n.l), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/snippets/latte", () => __vitePreload(() => import("./latte-BkrZxDCP.js").then((n) => n.l), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/snippets/less", () => __vitePreload(() => import("./less-BXBaUKBV.js").then((n) => n.l), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/snippets/liquid", () => __vitePreload(() => import("./liquid-Cn10oRmM.js").then((n) => n.l), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/snippets/lisp", () => __vitePreload(() => import("./lisp-CA3JhKr9.js").then((n) => n.l), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/snippets/livescript", () => __vitePreload(() => import("./livescript-jKpBosdr.js").then((n) => n.l), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/snippets/logiql", () => __vitePreload(() => import("./logiql-Qeo5OurH.js").then((n) => n.l), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/snippets/logtalk", () => __vitePreload(() => import("./logtalk-BOrzWuV7.js").then((n) => n.l), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/snippets/lsl", () => __vitePreload(() => import("./lsl-DgzpOYjk.js").then((n) => n.l), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/snippets/lua", () => __vitePreload(() => import("./lua-Dk4E0gJp.js").then((n) => n.l), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/snippets/luapage", () => __vitePreload(() => import("./luapage-CFrFA4S9.js").then((n) => n.l), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/snippets/lucene", () => __vitePreload(() => import("./lucene-UN_yJX_Y.js").then((n) => n.l), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/snippets/makefile", () => __vitePreload(() => import("./makefile-D18k22WR.js").then((n) => n.m), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/snippets/markdown", () => __vitePreload(() => import("./markdown-sgdcYNJu.js").then((n) => n.m), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/snippets/mask", () => __vitePreload(() => import("./mask-C0arhQvV.js").then((n) => n.m), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/snippets/matlab", () => __vitePreload(() => import("./matlab-BxSZeFxD.js").then((n) => n.m), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/snippets/maze", () => __vitePreload(() => import("./maze-C9oliHke.js").then((n) => n.m), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/snippets/mediawiki", () => __vitePreload(() => import("./mediawiki-BxvYQ4VJ.js").then((n) => n.m), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/snippets/mel", () => __vitePreload(() => import("./mel-xx8bSKzV.js").then((n) => n.m), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/snippets/mips", () => __vitePreload(() => import("./mips-ByO5fYuy.js").then((n) => n.m), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/snippets/mixal", () => __vitePreload(() => import("./mixal-BybvuyW0.js").then((n) => n.m), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/snippets/mushcode", () => __vitePreload(() => import("./mushcode-CgFwYJaG.js").then((n) => n.m), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/snippets/mysql", () => __vitePreload(() => import("./mysql-B5vSV0Xn.js").then((n) => n.m), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/snippets/nasal", () => __vitePreload(() => import("./nasal-DXvBLzEr.js").then((n) => n.n), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/snippets/nginx", () => __vitePreload(() => import("./nginx-CEDyqdVZ.js").then((n) => n.n), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/snippets/nim", () => __vitePreload(() => import("./nim-BBaYEK4t.js").then((n) => n.n), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/snippets/nix", () => __vitePreload(() => import("./nix-Cbha_end.js").then((n) => n.n), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/snippets/nsis", () => __vitePreload(() => import("./nsis-R0CZyKn2.js").then((n) => n.n), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/snippets/nunjucks", () => __vitePreload(() => import("./nunjucks-CCjTdXi-.js").then((n) => n.n), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/snippets/objectivec", () => __vitePreload(() => import("./objectivec-BBLppuLs.js").then((n) => n.o), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/snippets/ocaml", () => __vitePreload(() => import("./ocaml-BbqT4psI.js").then((n) => n.o), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/snippets/odin", () => __vitePreload(() => import("./odin-DxTgx3n_.js").then((n) => n.o), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/snippets/partiql", () => __vitePreload(() => import("./partiql-d7A5lWs3.js").then((n) => n.p), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/snippets/pascal", () => __vitePreload(() => import("./pascal-BwbNgy6i.js").then((n) => n.p), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/snippets/perl", () => __vitePreload(() => import("./perl-D0hQ4v83.js").then((n) => n.p), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/snippets/pgsql", () => __vitePreload(() => import("./pgsql-C4EpXtX9.js").then((n) => n.p), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/snippets/php", () => __vitePreload(() => import("./php-GCHFqp9O.js").then((n) => n.p), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/snippets/php_laravel_blade", () => __vitePreload(() => import("./php_laravel_blade-CWNGoepI.js").then((n) => n.p), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/snippets/pig", () => __vitePreload(() => import("./pig-BbzjQjiU.js").then((n) => n.p), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/snippets/plain_text", () => __vitePreload(() => import("./plain_text-By0pL3hV.js").then((n) => n.p), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/snippets/plsql", () => __vitePreload(() => import("./plsql-DWQQOpKy.js").then((n) => n.p), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/snippets/powershell", () => __vitePreload(() => import("./powershell-DcpwDfYB.js").then((n) => n.p), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/snippets/praat", () => __vitePreload(() => import("./praat-Be3Wgi3H.js").then((n) => n.p), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/snippets/prisma", () => __vitePreload(() => import("./prisma-DMxRccj4.js").then((n) => n.p), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/snippets/prolog", () => __vitePreload(() => import("./prolog-p72wzUfH.js").then((n) => n.p), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/snippets/properties", () => __vitePreload(() => import("./properties-0jSnI92N.js").then((n) => n.p), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/snippets/protobuf", () => __vitePreload(() => import("./protobuf-BgjivLxX.js").then((n) => n.p), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/snippets/prql", () => __vitePreload(() => import("./prql-CDKWoZld.js").then((n) => n.p), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/snippets/puppet", () => __vitePreload(() => import("./puppet-CgA5iLvD.js").then((n) => n.p), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/snippets/python", () => __vitePreload(() => import("./python-K9lnS0Ey.js").then((n) => n.p), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/snippets/qml", () => __vitePreload(() => import("./qml-BgfT8p-X.js").then((n) => n.q), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/snippets/r", () => __vitePreload(() => import("./r-CEwwheLX.js").then((n) => n.r), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/snippets/raku", () => __vitePreload(() => import("./raku-CzNTOoY_.js").then((n) => n.r), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/snippets/razor", () => __vitePreload(() => import("./razor-dxwXWs4v.js").then((n) => n.r), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/snippets/rdoc", () => __vitePreload(() => import("./rdoc-BND153zE.js").then((n) => n.r), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/snippets/red", () => __vitePreload(() => import("./red-BWuQ7DNy.js").then((n) => n.r), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/snippets/redshift", () => __vitePreload(() => import("./redshift-DNX6H6Zf.js").then((n) => n.r), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/snippets/rhtml", () => __vitePreload(() => import("./rhtml-NVVM1vZe.js").then((n) => n.r), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/snippets/robot", () => __vitePreload(() => import("./robot-BMw7E7nQ.js").then((n) => n.r), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/snippets/rst", () => __vitePreload(() => import("./rst-CJNuGUzb.js").then((n) => n.r), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/snippets/ruby", () => __vitePreload(() => import("./ruby-D6C65iyE.js").then((n) => n.r), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/snippets/rust", () => __vitePreload(() => import("./rust-B0lD1xKn.js").then((n) => n.r), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/snippets/sac", () => __vitePreload(() => import("./sac-D5AM3hja.js").then((n) => n.s), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/snippets/sass", () => __vitePreload(() => import("./sass-Dnetujno.js").then((n) => n.s), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/snippets/scad", () => __vitePreload(() => import("./scad-DIbXIhQa.js").then((n) => n.s), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/snippets/scala", () => __vitePreload(() => import("./scala-CMGn0KoA.js").then((n) => n.s), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/snippets/scheme", () => __vitePreload(() => import("./scheme-CPnbU1GF.js").then((n) => n.s), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/snippets/scrypt", () => __vitePreload(() => import("./scrypt-BQQHH2eK.js").then((n) => n.s), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/snippets/scss", () => __vitePreload(() => import("./scss-Bzmqd2Pi.js").then((n) => n.s), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/snippets/sh", () => __vitePreload(() => import("./sh-DuZJUs9B.js").then((n) => n.s), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/snippets/sjs", () => __vitePreload(() => import("./sjs-Dvmjx2x-.js").then((n) => n.s), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/snippets/slim", () => __vitePreload(() => import("./slim-B7uwe512.js").then((n) => n.s), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/snippets/smarty", () => __vitePreload(() => import("./smarty-BRTOWlem.js").then((n) => n.s), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/snippets/smithy", () => __vitePreload(() => import("./smithy-DTH4AVu7.js").then((n) => n.s), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/snippets/snippets", () => __vitePreload(() => import("./snippets-p4Lj8Kdm.js").then((n) => n.s), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/snippets/soy_template", () => __vitePreload(() => import("./soy_template-BWbn4MDY.js").then((n) => n.s), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/snippets/space", () => __vitePreload(() => import("./space-DJdBgMQE.js").then((n) => n.s), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/snippets/sparql", () => __vitePreload(() => import("./sparql-CakaH3HV.js").then((n) => n.s), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/snippets/sql", () => __vitePreload(() => import("./sql-D7xL-SU_.js").then((n) => n.s), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/snippets/sqlserver", () => __vitePreload(() => import("./sqlserver-N5hgGj4k.js").then((n) => n.s), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/snippets/stylus", () => __vitePreload(() => import("./stylus-6GKGwpw9.js").then((n) => n.s), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/snippets/svg", () => __vitePreload(() => import("./svg-Crbqowk2.js").then((n) => n.s), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/snippets/swift", () => __vitePreload(() => import("./swift-Coi8p8Gw.js").then((n) => n.s), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/snippets/tcl", () => __vitePreload(() => import("./tcl-D-7dR9E-.js").then((n) => n.t), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/snippets/terraform", () => __vitePreload(() => import("./terraform-CqF6Ue7n.js").then((n) => n.t), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/snippets/tex", () => __vitePreload(() => import("./tex-BfYgOpnu.js").then((n) => n.t), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/snippets/text", () => __vitePreload(() => import("./text-BsTcRx--.js").then((n) => n.t), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/snippets/textile", () => __vitePreload(() => import("./textile-aWbWQZll.js").then((n) => n.t), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/snippets/toml", () => __vitePreload(() => import("./toml-CH203xxw.js").then((n) => n.t), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/snippets/tsv", () => __vitePreload(() => import("./tsv-C02W5e4o.js").then((n) => n.t), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/snippets/tsx", () => __vitePreload(() => import("./tsx-BWfD0weh.js").then((n) => n.t), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/snippets/turtle", () => __vitePreload(() => import("./turtle-vQxETWtW.js").then((n) => n.t), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/snippets/twig", () => __vitePreload(() => import("./twig-DnfUNCk3.js").then((n) => n.t), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/snippets/typescript", () => __vitePreload(() => import("./typescript-C2iWmIS2.js").then((n) => n.t), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/snippets/vala", () => __vitePreload(() => import("./vala-krcAtnlS.js").then((n) => n.v), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/snippets/vbscript", () => __vitePreload(() => import("./vbscript-BCXBJcUt.js").then((n) => n.v), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/snippets/velocity", () => __vitePreload(() => import("./velocity-Dpy21ymn.js").then((n) => n.v), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/snippets/verilog", () => __vitePreload(() => import("./verilog-58SuTtm6.js").then((n) => n.v), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/snippets/vhdl", () => __vitePreload(() => import("./vhdl-B4RvRog4.js").then((n) => n.v), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/snippets/visualforce", () => __vitePreload(() => import("./visualforce-e3_-kw_q.js").then((n) => n.v), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/snippets/vue", () => __vitePreload(() => import("./vue-D9sf8Y-5.js").then((n) => n.v), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/snippets/wollok", () => __vitePreload(() => import("./wollok-PT7NeSw9.js").then((n) => n.w), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/snippets/xml", () => __vitePreload(() => import("./xml-L_35VrzA.js").then((n) => n.x), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/snippets/xquery", () => __vitePreload(() => import("./xquery-CI4bKskm.js").then((n) => n.x), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/snippets/yaml", () => __vitePreload(() => import("./yaml-BECC8aqS.js").then((n) => n.y), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/snippets/zeek", () => __vitePreload(() => import("./zeek-C6Xehyii.js").then((n) => n.z), true ? [] : void 0, import.meta.url));
ace.config.setModuleLoader("ace/snippets/zig", () => __vitePreload(() => import("./zig-CVFTATEW.js").then((n) => n.z), true ? [] : void 0, import.meta.url));
var extLanguage_tools$2 = { exports: {} };
var hasRequiredExtLanguage_tools;
function requireExtLanguage_tools() {
  if (hasRequiredExtLanguage_tools) return extLanguage_tools$2.exports;
  hasRequiredExtLanguage_tools = 1;
  (function(module2, exports2) {
    ace.define("ace/snippets", ["require", "exports", "module", "ace/lib/dom", "ace/lib/oop", "ace/lib/event_emitter", "ace/lib/lang", "ace/range", "ace/range_list", "ace/keyboard/hash_handler", "ace/tokenizer", "ace/clipboard", "ace/editor"], function(require2, exports3, module3) {
      var dom = require2("./lib/dom");
      var oop = require2("./lib/oop");
      var EventEmitter = require2("./lib/event_emitter").EventEmitter;
      var lang = require2("./lib/lang");
      var Range = require2("./range").Range;
      var RangeList = require2("./range_list").RangeList;
      var HashHandler = require2("./keyboard/hash_handler").HashHandler;
      var Tokenizer = require2("./tokenizer").Tokenizer;
      var clipboard = require2("./clipboard");
      var VARIABLES = {
        CURRENT_WORD: function(editor) {
          return editor.session.getTextRange(editor.session.getWordRange());
        },
        SELECTION: function(editor, name, indentation) {
          var text = editor.session.getTextRange();
          if (indentation)
            return text.replace(/\n\r?([ \t]*\S)/g, "\n" + indentation + "$1");
          return text;
        },
        CURRENT_LINE: function(editor) {
          return editor.session.getLine(editor.getCursorPosition().row);
        },
        PREV_LINE: function(editor) {
          return editor.session.getLine(editor.getCursorPosition().row - 1);
        },
        LINE_INDEX: function(editor) {
          return editor.getCursorPosition().row;
        },
        LINE_NUMBER: function(editor) {
          return editor.getCursorPosition().row + 1;
        },
        SOFT_TABS: function(editor) {
          return editor.session.getUseSoftTabs() ? "YES" : "NO";
        },
        TAB_SIZE: function(editor) {
          return editor.session.getTabSize();
        },
        CLIPBOARD: function(editor) {
          return clipboard.getText && clipboard.getText();
        },
        FILENAME: function(editor) {
          return /[^/\\]*$/.exec(this.FILEPATH(editor))[0];
        },
        FILENAME_BASE: function(editor) {
          return /[^/\\]*$/.exec(this.FILEPATH(editor))[0].replace(/\.[^.]*$/, "");
        },
        DIRECTORY: function(editor) {
          return this.FILEPATH(editor).replace(/[^/\\]*$/, "");
        },
        FILEPATH: function(editor) {
          return "/not implemented.txt";
        },
        WORKSPACE_NAME: function() {
          return "Unknown";
        },
        FULLNAME: function() {
          return "Unknown";
        },
        BLOCK_COMMENT_START: function(editor) {
          var mode = editor.session.$mode || {};
          return mode.blockComment && mode.blockComment.start || "";
        },
        BLOCK_COMMENT_END: function(editor) {
          var mode = editor.session.$mode || {};
          return mode.blockComment && mode.blockComment.end || "";
        },
        LINE_COMMENT: function(editor) {
          var mode = editor.session.$mode || {};
          return mode.lineCommentStart || "";
        },
        CURRENT_YEAR: date.bind(null, { year: "numeric" }),
        CURRENT_YEAR_SHORT: date.bind(null, { year: "2-digit" }),
        CURRENT_MONTH: date.bind(null, { month: "numeric" }),
        CURRENT_MONTH_NAME: date.bind(null, { month: "long" }),
        CURRENT_MONTH_NAME_SHORT: date.bind(null, { month: "short" }),
        CURRENT_DATE: date.bind(null, { day: "2-digit" }),
        CURRENT_DAY_NAME: date.bind(null, { weekday: "long" }),
        CURRENT_DAY_NAME_SHORT: date.bind(null, { weekday: "short" }),
        CURRENT_HOUR: date.bind(null, { hour: "2-digit", hour12: false }),
        CURRENT_MINUTE: date.bind(null, { minute: "2-digit" }),
        CURRENT_SECOND: date.bind(null, { second: "2-digit" })
      };
      VARIABLES.SELECTED_TEXT = VARIABLES.SELECTION;
      function date(dateFormat) {
        var str = (/* @__PURE__ */ new Date()).toLocaleString("en-us", dateFormat);
        return str.length == 1 ? "0" + str : str;
      }
      var SnippetManager = (
        /** @class */
        (function() {
          function SnippetManager2() {
            this.snippetMap = {};
            this.snippetNameMap = {};
            this.variables = VARIABLES;
          }
          SnippetManager2.prototype.getTokenizer = function() {
            return SnippetManager2["$tokenizer"] || this.createTokenizer();
          };
          SnippetManager2.prototype.createTokenizer = function() {
            function TabstopToken(str) {
              str = str.substr(1);
              if (/^\d+$/.test(str))
                return [{ tabstopId: parseInt(str, 10) }];
              return [{ text: str }];
            }
            function escape(ch) {
              return "(?:[^\\\\" + ch + "]|\\\\.)";
            }
            var formatMatcher = {
              regex: "/(" + escape("/") + "+)/",
              onMatch: function(val, state, stack) {
                var ts = stack[0];
                ts.fmtString = true;
                ts.guard = val.slice(1, -1);
                ts.flag = "";
                return "";
              },
              next: "formatString"
            };
            SnippetManager2["$tokenizer"] = new Tokenizer({
              start: [
                { regex: /\\./, onMatch: function(val, state, stack) {
                  var ch = val[1];
                  if (ch == "}" && stack.length) {
                    val = ch;
                  } else if ("`$\\".indexOf(ch) != -1) {
                    val = ch;
                  }
                  return [val];
                } },
                { regex: /}/, onMatch: function(val, state, stack) {
                  return [stack.length ? stack.shift() : val];
                } },
                { regex: /\$(?:\d+|\w+)/, onMatch: TabstopToken },
                { regex: /\$\{[\dA-Z_a-z]+/, onMatch: function(str, state, stack) {
                  var t2 = TabstopToken(str.substr(1));
                  stack.unshift(t2[0]);
                  return t2;
                }, next: "snippetVar" },
                { regex: /\n/, token: "newline", merge: false }
              ],
              snippetVar: [
                { regex: "\\|" + escape("\\|") + "*\\|", onMatch: function(val, state, stack) {
                  var choices = val.slice(1, -1).replace(/\\[,|\\]|,/g, function(operator) {
                    return operator.length == 2 ? operator[1] : "\0";
                  }).split("\0").map(function(value) {
                    return { value };
                  });
                  stack[0].choices = choices;
                  return [choices[0]];
                }, next: "start" },
                formatMatcher,
                { regex: "([^:}\\\\]|\\\\.)*:?", token: "", next: "start" }
              ],
              formatString: [
                { regex: /:/, onMatch: function(val, state, stack) {
                  if (stack.length && stack[0].expectElse) {
                    stack[0].expectElse = false;
                    stack[0].ifEnd = { elseEnd: stack[0] };
                    return [stack[0].ifEnd];
                  }
                  return ":";
                } },
                { regex: /\\./, onMatch: function(val, state, stack) {
                  var ch = val[1];
                  if (ch == "}" && stack.length)
                    val = ch;
                  else if ("`$\\".indexOf(ch) != -1)
                    val = ch;
                  else if (ch == "n")
                    val = "\n";
                  else if (ch == "t")
                    val = "	";
                  else if ("ulULE".indexOf(ch) != -1)
                    val = { changeCase: ch, local: ch > "a" };
                  return [val];
                } },
                { regex: "/\\w*}", onMatch: function(val, state, stack) {
                  var next = stack.shift();
                  if (next)
                    next.flag = val.slice(1, -1);
                  this.next = next && next.tabstopId ? "start" : "";
                  return [next || val];
                }, next: "start" },
                { regex: /\$(?:\d+|\w+)/, onMatch: function(val, state, stack) {
                  return [{ text: val.slice(1) }];
                } },
                { regex: /\${\w+/, onMatch: function(val, state, stack) {
                  var token = { text: val.slice(2) };
                  stack.unshift(token);
                  return [token];
                }, next: "formatStringVar" },
                { regex: /\n/, token: "newline", merge: false },
                { regex: /}/, onMatch: function(val, state, stack) {
                  var next = stack.shift();
                  this.next = next && next.tabstopId ? "start" : "";
                  return [next || val];
                }, next: "start" }
              ],
              formatStringVar: [
                { regex: /:\/\w+}/, onMatch: function(val, state, stack) {
                  var ts = stack[0];
                  ts.formatFunction = val.slice(2, -1);
                  return [stack.shift()];
                }, next: "formatString" },
                formatMatcher,
                { regex: /:[\?\-+]?/, onMatch: function(val, state, stack) {
                  if (val[1] == "+")
                    stack[0].ifEnd = stack[0];
                  if (val[1] == "?")
                    stack[0].expectElse = true;
                }, next: "formatString" },
                { regex: "([^:}\\\\]|\\\\.)*:?", token: "", next: "formatString" }
              ]
            });
            return SnippetManager2["$tokenizer"];
          };
          SnippetManager2.prototype.tokenizeTmSnippet = function(str, startState) {
            return this.getTokenizer().getLineTokens(str, startState).tokens.map(function(x2) {
              return x2.value || x2;
            });
          };
          SnippetManager2.prototype.getVariableValue = function(editor, name, indentation) {
            if (/^\d+$/.test(name))
              return (this.variables.__ || {})[name] || "";
            if (/^[A-Z]\d+$/.test(name))
              return (this.variables[name[0] + "__"] || {})[name.substr(1)] || "";
            name = name.replace(/^TM_/, "");
            if (!this.variables.hasOwnProperty(name))
              return "";
            var value = this.variables[name];
            if (typeof value == "function")
              value = this.variables[name](editor, name, indentation);
            return value == null ? "" : value;
          };
          SnippetManager2.prototype.tmStrFormat = function(str, ch, editor) {
            if (!ch.fmt)
              return str;
            var flag = ch.flag || "";
            var re2 = ch.guard;
            re2 = new RegExp(re2, flag.replace(/[^gim]/g, ""));
            var fmtTokens = typeof ch.fmt == "string" ? this.tokenizeTmSnippet(ch.fmt, "formatString") : ch.fmt;
            var _self = this;
            var formatted = str.replace(re2, function() {
              var oldArgs = _self.variables.__;
              _self.variables.__ = [].slice.call(arguments);
              var fmtParts = _self.resolveVariables(fmtTokens, editor);
              var gChangeCase = "E";
              for (var i2 = 0; i2 < fmtParts.length; i2++) {
                var ch2 = fmtParts[i2];
                if (typeof ch2 == "object") {
                  fmtParts[i2] = "";
                  if (ch2.changeCase && ch2.local) {
                    var next = fmtParts[i2 + 1];
                    if (next && typeof next == "string") {
                      if (ch2.changeCase == "u")
                        fmtParts[i2] = next[0].toUpperCase();
                      else
                        fmtParts[i2] = next[0].toLowerCase();
                      fmtParts[i2 + 1] = next.substr(1);
                    }
                  } else if (ch2.changeCase) {
                    gChangeCase = ch2.changeCase;
                  }
                } else if (gChangeCase == "U") {
                  fmtParts[i2] = ch2.toUpperCase();
                } else if (gChangeCase == "L") {
                  fmtParts[i2] = ch2.toLowerCase();
                }
              }
              _self.variables.__ = oldArgs;
              return fmtParts.join("");
            });
            return formatted;
          };
          SnippetManager2.prototype.tmFormatFunction = function(str, ch, editor) {
            if (ch.formatFunction == "upcase")
              return str.toUpperCase();
            if (ch.formatFunction == "downcase")
              return str.toLowerCase();
            return str;
          };
          SnippetManager2.prototype.resolveVariables = function(snippet, editor) {
            var result = [];
            var indentation = "";
            var afterNewLine = true;
            for (var i2 = 0; i2 < snippet.length; i2++) {
              var ch = snippet[i2];
              if (typeof ch == "string") {
                result.push(ch);
                if (ch == "\n") {
                  afterNewLine = true;
                  indentation = "";
                } else if (afterNewLine) {
                  indentation = /^\t*/.exec(ch)[0];
                  afterNewLine = /\S/.test(ch);
                }
                continue;
              }
              if (!ch)
                continue;
              afterNewLine = false;
              if (ch.fmtString) {
                var j = snippet.indexOf(ch, i2 + 1);
                if (j == -1)
                  j = snippet.length;
                ch.fmt = snippet.slice(i2 + 1, j);
                i2 = j;
              }
              if (ch.text) {
                var value = this.getVariableValue(editor, ch.text, indentation) + "";
                if (ch.fmtString)
                  value = this.tmStrFormat(value, ch, editor);
                if (ch.formatFunction)
                  value = this.tmFormatFunction(value, ch, editor);
                if (value && !ch.ifEnd) {
                  result.push(value);
                  gotoNext(ch);
                } else if (!value && ch.ifEnd) {
                  gotoNext(ch.ifEnd);
                }
              } else if (ch.elseEnd) {
                gotoNext(ch.elseEnd);
              } else if (ch.tabstopId != null) {
                result.push(ch);
              } else if (ch.changeCase != null) {
                result.push(ch);
              }
            }
            function gotoNext(ch2) {
              var i1 = snippet.indexOf(ch2, i2 + 1);
              if (i1 != -1)
                i2 = i1;
            }
            return result;
          };
          SnippetManager2.prototype.getDisplayTextForSnippet = function(editor, snippetText) {
            var processedSnippet = processSnippetText.call(this, editor, snippetText);
            return processedSnippet.text;
          };
          SnippetManager2.prototype.insertSnippetForSelection = function(editor, snippetText, options) {
            if (options === void 0) {
              options = {};
            }
            var processedSnippet = processSnippetText.call(this, editor, snippetText, options);
            var range = editor.getSelectionRange();
            var end = editor.session.replace(range, processedSnippet.text);
            var tabstopManager = new TabstopManager(editor);
            var selectionId = editor.inVirtualSelectionMode && editor.selection.index;
            tabstopManager.addTabstops(processedSnippet.tabstops, range.start, end, selectionId);
          };
          SnippetManager2.prototype.insertSnippet = function(editor, snippetText, options) {
            if (options === void 0) {
              options = {};
            }
            var self2 = this;
            if (editor.inVirtualSelectionMode)
              return self2.insertSnippetForSelection(editor, snippetText, options);
            editor.forEachSelection(function() {
              self2.insertSnippetForSelection(editor, snippetText, options);
            }, null, { keepOrder: true });
            if (editor.tabstopManager)
              editor.tabstopManager.tabNext();
          };
          SnippetManager2.prototype.$getScope = function(editor) {
            var scope = editor.session.$mode.$id || "";
            scope = scope.split("/").pop();
            if (scope === "html" || scope === "php") {
              if (scope === "php" && !editor.session.$mode.inlinePhp)
                scope = "html";
              var c2 = editor.getCursorPosition();
              var state = editor.session.getState(c2.row);
              if (typeof state === "object") {
                state = state[0];
              }
              if (state.substring) {
                if (state.substring(0, 3) == "js-")
                  scope = "javascript";
                else if (state.substring(0, 4) == "css-")
                  scope = "css";
                else if (state.substring(0, 4) == "php-")
                  scope = "php";
              }
            }
            return scope;
          };
          SnippetManager2.prototype.getActiveScopes = function(editor) {
            var scope = this.$getScope(editor);
            var scopes = [scope];
            var snippetMap = this.snippetMap;
            if (snippetMap[scope] && snippetMap[scope].includeScopes) {
              scopes.push.apply(scopes, snippetMap[scope].includeScopes);
            }
            scopes.push("_");
            return scopes;
          };
          SnippetManager2.prototype.expandWithTab = function(editor, options) {
            var self2 = this;
            var result = editor.forEachSelection(function() {
              return self2.expandSnippetForSelection(editor, options);
            }, null, { keepOrder: true });
            if (result && editor.tabstopManager)
              editor.tabstopManager.tabNext();
            return result;
          };
          SnippetManager2.prototype.expandSnippetForSelection = function(editor, options) {
            var cursor = editor.getCursorPosition();
            var line = editor.session.getLine(cursor.row);
            var before = line.substring(0, cursor.column);
            var after = line.substr(cursor.column);
            var snippetMap = this.snippetMap;
            var snippet;
            this.getActiveScopes(editor).some(function(scope) {
              var snippets = snippetMap[scope];
              if (snippets)
                snippet = this.findMatchingSnippet(snippets, before, after);
              return !!snippet;
            }, this);
            if (!snippet)
              return false;
            if (options && options.dryRun)
              return true;
            editor.session.doc.removeInLine(cursor.row, cursor.column - snippet.replaceBefore.length, cursor.column + snippet.replaceAfter.length);
            this.variables.M__ = snippet.matchBefore;
            this.variables.T__ = snippet.matchAfter;
            this.insertSnippetForSelection(editor, snippet.content);
            this.variables.M__ = this.variables.T__ = null;
            return true;
          };
          SnippetManager2.prototype.findMatchingSnippet = function(snippetList, before, after) {
            for (var i2 = snippetList.length; i2--; ) {
              var s3 = snippetList[i2];
              if (s3.startRe && !s3.startRe.test(before))
                continue;
              if (s3.endRe && !s3.endRe.test(after))
                continue;
              if (!s3.startRe && !s3.endRe)
                continue;
              s3.matchBefore = s3.startRe ? s3.startRe.exec(before) : [""];
              s3.matchAfter = s3.endRe ? s3.endRe.exec(after) : [""];
              s3.replaceBefore = s3.triggerRe ? s3.triggerRe.exec(before)[0] : "";
              s3.replaceAfter = s3.endTriggerRe ? s3.endTriggerRe.exec(after)[0] : "";
              return s3;
            }
          };
          SnippetManager2.prototype.register = function(snippets, scope) {
            var snippetMap = this.snippetMap;
            var snippetNameMap = this.snippetNameMap;
            var self2 = this;
            if (!snippets)
              snippets = [];
            function wrapRegexp(src) {
              if (src && !/^\^?\(.*\)\$?$|^\\b$/.test(src))
                src = "(?:" + src + ")";
              return src || "";
            }
            function guardedRegexp(re2, guard, opening) {
              re2 = wrapRegexp(re2);
              guard = wrapRegexp(guard);
              {
                re2 = guard + re2;
                if (re2 && re2[re2.length - 1] != "$")
                  re2 = re2 + "$";
              }
              return new RegExp(re2);
            }
            function addSnippet(s3) {
              if (!s3.scope)
                s3.scope = scope || "_";
              scope = s3.scope;
              if (!snippetMap[scope]) {
                snippetMap[scope] = [];
                snippetNameMap[scope] = {};
              }
              var map = snippetNameMap[scope];
              if (s3.name) {
                var old = map[s3.name];
                if (old)
                  self2.unregister(old);
                map[s3.name] = s3;
              }
              snippetMap[scope].push(s3);
              if (s3.prefix)
                s3.tabTrigger = s3.prefix;
              if (!s3.content && s3.body)
                s3.content = Array.isArray(s3.body) ? s3.body.join("\n") : s3.body;
              if (s3.tabTrigger && !s3.trigger) {
                if (!s3.guard && /^\w/.test(s3.tabTrigger))
                  s3.guard = "\\b";
                s3.trigger = lang.escapeRegExp(s3.tabTrigger);
              }
              if (!s3.trigger && !s3.guard && !s3.endTrigger && !s3.endGuard)
                return;
              s3.startRe = guardedRegexp(s3.trigger, s3.guard);
              s3.triggerRe = new RegExp(s3.trigger);
              s3.endRe = guardedRegexp(s3.endTrigger, s3.endGuard);
              s3.endTriggerRe = new RegExp(s3.endTrigger);
            }
            if (Array.isArray(snippets)) {
              snippets.forEach(addSnippet);
            } else {
              Object.keys(snippets).forEach(function(key) {
                addSnippet(snippets[key]);
              });
            }
            this._signal("registerSnippets", { scope });
          };
          SnippetManager2.prototype.unregister = function(snippets, scope) {
            var snippetMap = this.snippetMap;
            var snippetNameMap = this.snippetNameMap;
            function removeSnippet(s3) {
              var nameMap = snippetNameMap[s3.scope || scope];
              if (nameMap && nameMap[s3.name]) {
                delete nameMap[s3.name];
                var map = snippetMap[s3.scope || scope];
                var i2 = map && map.indexOf(s3);
                if (i2 >= 0)
                  map.splice(i2, 1);
              }
            }
            if (snippets.content)
              removeSnippet(snippets);
            else if (Array.isArray(snippets))
              snippets.forEach(removeSnippet);
          };
          SnippetManager2.prototype.parseSnippetFile = function(str) {
            str = str.replace(/\r/g, "");
            var list = [], snippet = {};
            var re2 = /^#.*|^({[\s\S]*})\s*$|^(\S+) (.*)$|^((?:\n*\t.*)+)/gm;
            var m3;
            while (m3 = re2.exec(str)) {
              if (m3[1]) {
                try {
                  snippet = JSON.parse(m3[1]);
                  list.push(snippet);
                } catch (e2) {
                }
              }
              if (m3[4]) {
                snippet.content = m3[4].replace(/^\t/gm, "");
                list.push(snippet);
                snippet = {};
              } else {
                var key = m3[2], val = m3[3];
                if (key == "regex") {
                  var guardRe = /\/((?:[^\/\\]|\\.)*)|$/g;
                  snippet.guard = guardRe.exec(val)[1];
                  snippet.trigger = guardRe.exec(val)[1];
                  snippet.endTrigger = guardRe.exec(val)[1];
                  snippet.endGuard = guardRe.exec(val)[1];
                } else if (key == "snippet") {
                  snippet.tabTrigger = val.match(/^\S*/)[0];
                  if (!snippet.name)
                    snippet.name = val;
                } else if (key) {
                  snippet[key] = val;
                }
              }
            }
            return list;
          };
          SnippetManager2.prototype.getSnippetByName = function(name, editor) {
            var snippetMap = this.snippetNameMap;
            var snippet;
            this.getActiveScopes(editor).some(function(scope) {
              var snippets = snippetMap[scope];
              if (snippets)
                snippet = snippets[name];
              return !!snippet;
            }, this);
            return snippet;
          };
          return SnippetManager2;
        })()
      );
      oop.implement(SnippetManager.prototype, EventEmitter);
      var processSnippetText = function(editor, snippetText, options) {
        if (options === void 0) {
          options = {};
        }
        var cursor = editor.getCursorPosition();
        var line = editor.session.getLine(cursor.row);
        var tabString = editor.session.getTabString();
        var indentString = line.match(/^\s*/)[0];
        if (cursor.column < indentString.length)
          indentString = indentString.slice(0, cursor.column);
        snippetText = snippetText.replace(/\r/g, "");
        var tokens = this.tokenizeTmSnippet(snippetText);
        tokens = this.resolveVariables(tokens, editor);
        tokens = tokens.map(function(x2) {
          if (x2 == "\n" && !options.excludeExtraIndent)
            return x2 + indentString;
          if (typeof x2 == "string")
            return x2.replace(/\t/g, tabString);
          return x2;
        });
        var tabstops = [];
        tokens.forEach(function(p2, i3) {
          if (typeof p2 != "object")
            return;
          var id2 = p2.tabstopId;
          var ts2 = tabstops[id2];
          if (!ts2) {
            ts2 = tabstops[id2] = [];
            ts2.index = id2;
            ts2.value = "";
            ts2.parents = {};
          }
          if (ts2.indexOf(p2) !== -1)
            return;
          if (p2.choices && !ts2.choices)
            ts2.choices = p2.choices;
          ts2.push(p2);
          var i12 = tokens.indexOf(p2, i3 + 1);
          if (i12 === -1)
            return;
          var value2 = tokens.slice(i3 + 1, i12);
          var isNested = value2.some(function(t2) {
            return typeof t2 === "object";
          });
          if (isNested && !ts2.value) {
            ts2.value = value2;
          } else if (value2.length && (!ts2.value || typeof ts2.value !== "string")) {
            ts2.value = value2.join("");
          }
        });
        tabstops.forEach(function(ts2) {
          ts2.length = 0;
        });
        var expanding = {};
        function copyValue(val) {
          var copy = [];
          for (var i3 = 0; i3 < val.length; i3++) {
            var p2 = val[i3];
            if (typeof p2 == "object") {
              if (expanding[p2.tabstopId])
                continue;
              var j = val.lastIndexOf(p2, i3 - 1);
              p2 = copy[j] || { tabstopId: p2.tabstopId };
            }
            copy[i3] = p2;
          }
          return copy;
        }
        for (var i2 = 0; i2 < tokens.length; i2++) {
          var p = tokens[i2];
          if (typeof p != "object")
            continue;
          var id = p.tabstopId;
          var ts = tabstops[id];
          var i1 = tokens.indexOf(p, i2 + 1);
          if (expanding[id]) {
            if (expanding[id] === p) {
              delete expanding[id];
              Object.keys(expanding).forEach(function(parentId) {
                ts.parents[parentId] = true;
              });
            }
            continue;
          }
          expanding[id] = p;
          var value = ts.value;
          if (typeof value !== "string")
            value = copyValue(value);
          else if (p.fmt)
            value = this.tmStrFormat(value, p, editor);
          tokens.splice.apply(tokens, [i2 + 1, Math.max(0, i1 - i2)].concat(value, p));
          if (ts.indexOf(p) === -1)
            ts.push(p);
        }
        var row = 0, column = 0;
        var text = "";
        tokens.forEach(function(t2) {
          if (typeof t2 === "string") {
            var lines = t2.split("\n");
            if (lines.length > 1) {
              column = lines[lines.length - 1].length;
              row += lines.length - 1;
            } else
              column += t2.length;
            text += t2;
          } else if (t2) {
            if (!t2.start)
              t2.start = { row, column };
            else
              t2.end = { row, column };
          }
        });
        return {
          text,
          tabstops,
          tokens
        };
      };
      var TabstopManager = (
        /** @class */
        (function() {
          function TabstopManager2(editor) {
            this.index = 0;
            this.ranges = [];
            this.tabstops = [];
            if (editor.tabstopManager)
              return editor.tabstopManager;
            editor.tabstopManager = this;
            this.$onChange = this.onChange.bind(this);
            this.$onChangeSelection = lang.delayedCall(this.onChangeSelection.bind(this)).schedule;
            this.$onChangeSession = this.onChangeSession.bind(this);
            this.$onAfterExec = this.onAfterExec.bind(this);
            this.attach(editor);
          }
          TabstopManager2.prototype.attach = function(editor) {
            this.$openTabstops = null;
            this.selectedTabstop = null;
            this.editor = editor;
            this.session = editor.session;
            this.editor.on("change", this.$onChange);
            this.editor.on("changeSelection", this.$onChangeSelection);
            this.editor.on("changeSession", this.$onChangeSession);
            this.editor.commands.on("afterExec", this.$onAfterExec);
            this.editor.keyBinding.addKeyboardHandler(this.keyboardHandler);
          };
          TabstopManager2.prototype.detach = function() {
            this.tabstops.forEach(this.removeTabstopMarkers, this);
            this.ranges.length = 0;
            this.tabstops.length = 0;
            this.selectedTabstop = null;
            this.editor.off("change", this.$onChange);
            this.editor.off("changeSelection", this.$onChangeSelection);
            this.editor.off("changeSession", this.$onChangeSession);
            this.editor.commands.off("afterExec", this.$onAfterExec);
            this.editor.keyBinding.removeKeyboardHandler(this.keyboardHandler);
            this.editor.tabstopManager = null;
            this.session = null;
            this.editor = null;
          };
          TabstopManager2.prototype.onChange = function(delta) {
            var isRemove = delta.action[0] == "r";
            var selectedTabstop = this.selectedTabstop || {};
            var parents = selectedTabstop.parents || {};
            var tabstops = this.tabstops.slice();
            for (var i2 = 0; i2 < tabstops.length; i2++) {
              var ts = tabstops[i2];
              var active = ts == selectedTabstop || parents[ts.index];
              ts.rangeList.$bias = active ? 0 : 1;
              if (delta.action == "remove" && ts !== selectedTabstop) {
                var parentActive = ts.parents && ts.parents[selectedTabstop.index];
                var startIndex = ts.rangeList.pointIndex(delta.start, parentActive);
                startIndex = startIndex < 0 ? -startIndex - 1 : startIndex + 1;
                var endIndex = ts.rangeList.pointIndex(delta.end, parentActive);
                endIndex = endIndex < 0 ? -endIndex - 1 : endIndex - 1;
                var toRemove = ts.rangeList.ranges.slice(startIndex, endIndex);
                for (var j = 0; j < toRemove.length; j++)
                  this.removeRange(toRemove[j]);
              }
              ts.rangeList.$onChange(delta);
            }
            var session = this.session;
            if (!this.$inChange && isRemove && session.getLength() == 1 && !session.getValue())
              this.detach();
          };
          TabstopManager2.prototype.updateLinkedFields = function() {
            var ts = this.selectedTabstop;
            if (!ts || !ts.hasLinkedRanges || !ts.firstNonLinked)
              return;
            this.$inChange = true;
            var session = this.session;
            var text = session.getTextRange(ts.firstNonLinked);
            for (var i2 = 0; i2 < ts.length; i2++) {
              var range = ts[i2];
              if (!range.linked)
                continue;
              var original = range.original;
              var fmt = exports3.snippetManager.tmStrFormat(text, original, this.editor);
              session.replace(range, fmt);
            }
            this.$inChange = false;
          };
          TabstopManager2.prototype.onAfterExec = function(e2) {
            if (e2.command && !e2.command.readOnly)
              this.updateLinkedFields();
          };
          TabstopManager2.prototype.onChangeSelection = function() {
            if (!this.editor)
              return;
            var lead = this.editor.selection.lead;
            var anchor = this.editor.selection.anchor;
            var isEmpty = this.editor.selection.isEmpty();
            for (var i2 = 0; i2 < this.ranges.length; i2++) {
              if (this.ranges[i2].linked)
                continue;
              var containsLead = this.ranges[i2].contains(lead.row, lead.column);
              var containsAnchor = isEmpty || this.ranges[i2].contains(anchor.row, anchor.column);
              if (containsLead && containsAnchor)
                return;
            }
            this.detach();
          };
          TabstopManager2.prototype.onChangeSession = function() {
            this.detach();
          };
          TabstopManager2.prototype.tabNext = function(dir) {
            var max = this.tabstops.length;
            var index = this.index + (dir || 1);
            index = Math.min(Math.max(index, 1), max);
            if (index == max)
              index = 0;
            this.selectTabstop(index);
            this.updateTabstopMarkers();
            if (index === 0) {
              this.detach();
            }
          };
          TabstopManager2.prototype.selectTabstop = function(index) {
            this.$openTabstops = null;
            var ts = this.tabstops[this.index];
            if (ts)
              this.addTabstopMarkers(ts);
            this.index = index;
            ts = this.tabstops[this.index];
            if (!ts || !ts.length)
              return;
            this.selectedTabstop = ts;
            var range = ts.firstNonLinked || ts;
            if (ts.choices)
              range.cursor = range.start;
            if (!this.editor.inVirtualSelectionMode) {
              var sel = this.editor.multiSelect;
              sel.toSingleRange(range);
              for (var i2 = 0; i2 < ts.length; i2++) {
                if (ts.hasLinkedRanges && ts[i2].linked)
                  continue;
                sel.addRange(ts[i2].clone(), true);
              }
            } else {
              this.editor.selection.fromOrientedRange(range);
            }
            this.editor.keyBinding.addKeyboardHandler(this.keyboardHandler);
            if (this.selectedTabstop && this.selectedTabstop.choices)
              this.editor.execCommand("startAutocomplete", { matches: this.selectedTabstop.choices });
          };
          TabstopManager2.prototype.addTabstops = function(tabstops, start, end) {
            var useLink = this.useLink || !this.editor.getOption("enableMultiselect");
            if (!this.$openTabstops)
              this.$openTabstops = [];
            if (!tabstops[0]) {
              var p = Range.fromPoints(end, end);
              moveRelative(p.start, start);
              moveRelative(p.end, start);
              tabstops[0] = [p];
              tabstops[0].index = 0;
            }
            var i2 = this.index;
            var arg = [i2 + 1, 0];
            var ranges = this.ranges;
            var snippetId = this.snippetId = (this.snippetId || 0) + 1;
            tabstops.forEach(function(ts, index) {
              var dest = this.$openTabstops[index] || ts;
              dest.snippetId = snippetId;
              for (var i3 = 0; i3 < ts.length; i3++) {
                var p2 = ts[i3];
                var range = Range.fromPoints(p2.start, p2.end || p2.start);
                movePoint(range.start, start);
                movePoint(range.end, start);
                range.original = p2;
                range.tabstop = dest;
                ranges.push(range);
                if (dest != ts)
                  dest.unshift(range);
                else
                  dest[i3] = range;
                if (p2.fmtString || dest.firstNonLinked && useLink) {
                  range.linked = true;
                  dest.hasLinkedRanges = true;
                } else if (!dest.firstNonLinked)
                  dest.firstNonLinked = range;
              }
              if (!dest.firstNonLinked)
                dest.hasLinkedRanges = false;
              if (dest === ts) {
                arg.push(dest);
                this.$openTabstops[index] = dest;
              }
              this.addTabstopMarkers(dest);
              dest.rangeList = dest.rangeList || new RangeList();
              dest.rangeList.$bias = 0;
              dest.rangeList.addList(dest);
            }, this);
            if (arg.length > 2) {
              if (this.tabstops.length)
                arg.push(arg.splice(2, 1)[0]);
              this.tabstops.splice.apply(this.tabstops, arg);
            }
          };
          TabstopManager2.prototype.addTabstopMarkers = function(ts) {
            var session = this.session;
            ts.forEach(function(range) {
              if (!range.markerId)
                range.markerId = session.addMarker(range, "ace_snippet-marker", "text");
            });
          };
          TabstopManager2.prototype.removeTabstopMarkers = function(ts) {
            var session = this.session;
            ts.forEach(function(range) {
              session.removeMarker(range.markerId);
              range.markerId = null;
            });
          };
          TabstopManager2.prototype.updateTabstopMarkers = function() {
            if (!this.selectedTabstop)
              return;
            var currentSnippetId = this.selectedTabstop.snippetId;
            if (this.selectedTabstop.index === 0) {
              currentSnippetId--;
            }
            this.tabstops.forEach(function(ts) {
              if (ts.snippetId === currentSnippetId)
                this.addTabstopMarkers(ts);
              else
                this.removeTabstopMarkers(ts);
            }, this);
          };
          TabstopManager2.prototype.removeRange = function(range) {
            var i2 = range.tabstop.indexOf(range);
            if (i2 != -1)
              range.tabstop.splice(i2, 1);
            i2 = this.ranges.indexOf(range);
            if (i2 != -1)
              this.ranges.splice(i2, 1);
            i2 = range.tabstop.rangeList.ranges.indexOf(range);
            if (i2 != -1)
              range.tabstop.splice(i2, 1);
            this.session.removeMarker(range.markerId);
            if (!range.tabstop.length) {
              i2 = this.tabstops.indexOf(range.tabstop);
              if (i2 != -1)
                this.tabstops.splice(i2, 1);
              if (!this.tabstops.length)
                this.detach();
            }
          };
          return TabstopManager2;
        })()
      );
      TabstopManager.prototype.keyboardHandler = new HashHandler();
      TabstopManager.prototype.keyboardHandler.bindKeys({
        "Tab": function(editor) {
          if (exports3.snippetManager && exports3.snippetManager.expandWithTab(editor))
            return;
          editor.tabstopManager.tabNext(1);
          editor.renderer.scrollCursorIntoView();
        },
        "Shift-Tab": function(editor) {
          editor.tabstopManager.tabNext(-1);
          editor.renderer.scrollCursorIntoView();
        },
        "Esc": function(editor) {
          editor.tabstopManager.detach();
        }
      });
      var movePoint = function(point, diff) {
        if (point.row == 0)
          point.column += diff.column;
        point.row += diff.row;
      };
      var moveRelative = function(point, start) {
        if (point.row == start.row)
          point.column -= start.column;
        point.row -= start.row;
      };
      dom.importCssString("\n.ace_snippet-marker {\n    -moz-box-sizing: border-box;\n    box-sizing: border-box;\n    background: rgba(194, 193, 208, 0.09);\n    border: 1px dotted rgba(211, 208, 235, 0.62);\n    position: absolute;\n}", "snippets.css", false);
      exports3.snippetManager = new SnippetManager();
      var Editor = require2("./editor").Editor;
      (function() {
        this.insertSnippet = function(content, options) {
          return exports3.snippetManager.insertSnippet(this, content, options);
        };
        this.expandSnippet = function(options) {
          return exports3.snippetManager.expandWithTab(this, options);
        };
      }).call(Editor.prototype);
    });
    ace.define("ace/autocomplete/popup", ["require", "exports", "module", "ace/virtual_renderer", "ace/editor", "ace/range", "ace/lib/event", "ace/lib/lang", "ace/lib/dom", "ace/config", "ace/lib/useragent"], function(require2, exports3, module3) {
      var Renderer = require2("../virtual_renderer").VirtualRenderer;
      var Editor = require2("../editor").Editor;
      var Range = require2("../range").Range;
      var event = require2("../lib/event");
      var lang = require2("../lib/lang");
      var dom = require2("../lib/dom");
      var nls = require2("../config").nls;
      var userAgent = require2("./../lib/useragent");
      var getAriaId = function(index) {
        return "suggest-aria-id:".concat(index);
      };
      var popupAriaRole = userAgent.isSafari ? "menu" : "listbox";
      var optionAriaRole = userAgent.isSafari ? "menuitem" : "option";
      var ariaActiveState = userAgent.isSafari ? "aria-current" : "aria-selected";
      var $singleLineEditor = function(el) {
        var renderer = new Renderer(el);
        renderer.$maxLines = 4;
        var editor = new Editor(renderer);
        editor.setHighlightActiveLine(false);
        editor.setShowPrintMargin(false);
        editor.renderer.setShowGutter(false);
        editor.renderer.setHighlightGutterLine(false);
        editor.$mouseHandler.$focusTimeout = 0;
        editor.$highlightTagPending = true;
        return editor;
      };
      var AcePopup = (
        /** @class */
        /* @__PURE__ */ (function() {
          function AcePopup2(parentNode) {
            var el = dom.createElement("div");
            var popup = $singleLineEditor(el);
            if (parentNode) {
              parentNode.appendChild(el);
            }
            el.style.display = "none";
            popup.renderer.content.style.cursor = "default";
            popup.renderer.setStyle("ace_autocomplete");
            popup.renderer.$textLayer.element.setAttribute("role", popupAriaRole);
            popup.renderer.$textLayer.element.setAttribute("aria-roledescription", nls("autocomplete.popup.aria-roledescription", "Autocomplete suggestions"));
            popup.renderer.$textLayer.element.setAttribute("aria-label", nls("autocomplete.popup.aria-label", "Autocomplete suggestions"));
            popup.renderer.textarea.setAttribute("aria-hidden", "true");
            popup.setOption("displayIndentGuides", false);
            popup.setOption("dragDelay", 150);
            var noop = function() {
            };
            popup.focus = noop;
            popup.$isFocused = true;
            popup.renderer.$cursorLayer.restartTimer = noop;
            popup.renderer.$cursorLayer.element.style.opacity = "0";
            popup.renderer.$maxLines = 8;
            popup.renderer.$keepTextAreaAtCursor = false;
            popup.setHighlightActiveLine(false);
            popup.session.highlight("");
            popup.session.$searchHighlight.clazz = "ace_highlight-marker";
            popup.on("mousedown", function(e2) {
              var pos = e2.getDocumentPosition();
              popup.selection.moveToPosition(pos);
              selectionMarker.start.row = selectionMarker.end.row = pos.row;
              e2.stop();
            });
            var lastMouseEvent;
            var hoverMarker = new Range(-1, 0, -1, Infinity);
            var selectionMarker = new Range(-1, 0, -1, Infinity);
            selectionMarker.id = popup.session.addMarker(selectionMarker, "ace_active-line", "fullLine");
            popup.setSelectOnHover = function(val) {
              if (!val) {
                hoverMarker.id = popup.session.addMarker(hoverMarker, "ace_line-hover", "fullLine");
              } else if (hoverMarker.id) {
                popup.session.removeMarker(hoverMarker.id);
                hoverMarker.id = null;
              }
            };
            popup.setSelectOnHover(false);
            popup.on("mousemove", function(e2) {
              if (!lastMouseEvent) {
                lastMouseEvent = e2;
                return;
              }
              if (lastMouseEvent.x == e2.x && lastMouseEvent.y == e2.y) {
                return;
              }
              lastMouseEvent = e2;
              lastMouseEvent.scrollTop = popup.renderer.scrollTop;
              popup.isMouseOver = true;
              var row = lastMouseEvent.getDocumentPosition().row;
              if (hoverMarker.start.row != row) {
                if (!hoverMarker.id)
                  popup.setRow(row);
                setHoverMarker(row);
              }
            });
            popup.renderer.on("beforeRender", function() {
              if (lastMouseEvent && hoverMarker.start.row != -1) {
                lastMouseEvent.$pos = null;
                var row = lastMouseEvent.getDocumentPosition().row;
                if (!hoverMarker.id)
                  popup.setRow(row);
                setHoverMarker(row, true);
              }
            });
            popup.renderer.on("afterRender", function() {
              var t2 = popup.renderer.$textLayer;
              for (var row = t2.config.firstRow, l = t2.config.lastRow; row <= l; row++) {
                var popupRowElement = (
                  /** @type {HTMLElement|null} */
                  t2.element.childNodes[row - t2.config.firstRow]
                );
                popupRowElement.setAttribute("role", optionAriaRole);
                popupRowElement.setAttribute("aria-roledescription", nls("autocomplete.popup.item.aria-roledescription", "item"));
                popupRowElement.setAttribute("aria-setsize", popup.data.length);
                popupRowElement.setAttribute("aria-describedby", "doc-tooltip");
                popupRowElement.setAttribute("aria-posinset", row + 1);
                var rowData = popup.getData(row);
                if (rowData) {
                  var ariaLabel = "".concat(rowData.caption || rowData.value).concat(rowData.meta ? ", ".concat(rowData.meta) : "");
                  popupRowElement.setAttribute("aria-label", ariaLabel);
                }
                var highlightedSpans = popupRowElement.querySelectorAll(".ace_completion-highlight");
                highlightedSpans.forEach(function(span) {
                  span.setAttribute("role", "mark");
                });
              }
            });
            popup.renderer.on("afterRender", function() {
              var row = popup.getRow();
              var t2 = popup.renderer.$textLayer;
              var selected = (
                /** @type {HTMLElement|null} */
                t2.element.childNodes[row - t2.config.firstRow]
              );
              var el2 = document.activeElement;
              if (selected !== popup.selectedNode && popup.selectedNode) {
                dom.removeCssClass(popup.selectedNode, "ace_selected");
                popup.selectedNode.removeAttribute(ariaActiveState);
                popup.selectedNode.removeAttribute("id");
              }
              el2.removeAttribute("aria-activedescendant");
              popup.selectedNode = selected;
              if (selected) {
                var ariaId = getAriaId(row);
                dom.addCssClass(selected, "ace_selected");
                selected.id = ariaId;
                t2.element.setAttribute("aria-activedescendant", ariaId);
                el2.setAttribute("aria-activedescendant", ariaId);
                selected.setAttribute(ariaActiveState, "true");
              }
            });
            var hideHoverMarker = function() {
              setHoverMarker(-1);
            };
            var setHoverMarker = function(row, suppressRedraw) {
              if (row !== hoverMarker.start.row) {
                hoverMarker.start.row = hoverMarker.end.row = row;
                if (!suppressRedraw)
                  popup.session._emit("changeBackMarker");
                popup._emit("changeHoverMarker");
              }
            };
            popup.getHoveredRow = function() {
              return hoverMarker.start.row;
            };
            event.addListener(popup.container, "mouseout", function() {
              popup.isMouseOver = false;
              hideHoverMarker();
            });
            popup.on("hide", hideHoverMarker);
            popup.on("changeSelection", hideHoverMarker);
            popup.session.doc.getLength = function() {
              return popup.data.length;
            };
            popup.session.doc.getLine = function(i2) {
              var data = popup.data[i2];
              if (typeof data == "string")
                return data;
              return data && data.value || "";
            };
            var bgTokenizer = popup.session.bgTokenizer;
            bgTokenizer.$tokenizeRow = function(row) {
              var data = popup.data[row];
              var tokens = [];
              if (!data)
                return tokens;
              if (typeof data == "string")
                data = { value: data };
              var caption = data.caption || data.value || data.name;
              function addToken(value, className) {
                value && tokens.push({
                  type: (data.className || "") + (className || ""),
                  value
                });
              }
              var lower = caption.toLowerCase();
              var filterText = (popup.filterText || "").toLowerCase();
              var lastIndex = 0;
              var lastI = 0;
              for (var i2 = 0; i2 <= filterText.length; i2++) {
                if (i2 != lastI && (data.matchMask & 1 << i2 || i2 == filterText.length)) {
                  var sub = filterText.slice(lastI, i2);
                  lastI = i2;
                  var index = lower.indexOf(sub, lastIndex);
                  if (index == -1)
                    continue;
                  addToken(caption.slice(lastIndex, index), "");
                  lastIndex = index + sub.length;
                  addToken(caption.slice(index, lastIndex), "completion-highlight");
                }
              }
              addToken(caption.slice(lastIndex, caption.length), "");
              tokens.push({ type: "completion-spacer", value: " " });
              if (data.meta)
                tokens.push({ type: "completion-meta", value: data.meta });
              if (data.message)
                tokens.push({ type: "completion-message", value: data.message });
              return tokens;
            };
            bgTokenizer.$updateOnChange = noop;
            bgTokenizer.start = noop;
            popup.session.$computeWidth = function() {
              return this.screenWidth = 0;
            };
            popup.isOpen = false;
            popup.isTopdown = false;
            popup.autoSelect = true;
            popup.filterText = "";
            popup.isMouseOver = false;
            popup.data = [];
            popup.setData = function(list, filterText) {
              popup.filterText = filterText || "";
              popup.setValue(lang.stringRepeat("\n", list.length), -1);
              popup.data = list || [];
              popup.setRow(0);
            };
            popup.getData = function(row) {
              return popup.data[row];
            };
            popup.getRow = function() {
              return selectionMarker.start.row;
            };
            popup.setRow = function(line) {
              line = Math.max(this.autoSelect ? 0 : -1, Math.min(this.data.length - 1, line));
              if (selectionMarker.start.row != line) {
                popup.selection.clearSelection();
                selectionMarker.start.row = selectionMarker.end.row = line || 0;
                popup.session._emit("changeBackMarker");
                popup.moveCursorTo(line || 0, 0);
                if (popup.isOpen)
                  popup._signal("select");
              }
            };
            popup.on("changeSelection", function() {
              if (popup.isOpen)
                popup.setRow(popup.selection.lead.row);
              popup.renderer.scrollCursorIntoView();
            });
            popup.hide = function() {
              this.container.style.display = "none";
              popup.anchorPos = null;
              popup.anchor = null;
              if (popup.isOpen) {
                popup.isOpen = false;
                this._signal("hide");
              }
            };
            popup.tryShow = function(pos, lineHeight, anchor, forceShow) {
              if (!forceShow && popup.isOpen && popup.anchorPos && popup.anchor && popup.anchorPos.top === pos.top && popup.anchorPos.left === pos.left && popup.anchor === anchor) {
                return true;
              }
              var el2 = this.container;
              var screenHeight = window.innerHeight;
              var screenWidth = window.innerWidth;
              var renderer = this.renderer;
              var maxH = renderer.$maxLines * lineHeight * 1.4;
              var dims = { top: 0, bottom: 0 };
              var spaceBelow = screenHeight - pos.top - 3 * this.$borderSize - lineHeight;
              var spaceAbove = pos.top - 3 * this.$borderSize;
              if (!anchor) {
                if (spaceAbove <= spaceBelow || spaceBelow >= maxH) {
                  anchor = "bottom";
                } else {
                  anchor = "top";
                }
              }
              if (anchor === "top") {
                dims.bottom = pos.top - this.$borderSize;
                dims.top = dims.bottom - maxH;
              } else if (anchor === "bottom") {
                dims.top = pos.top + lineHeight + this.$borderSize;
                dims.bottom = dims.top + maxH;
              }
              var fitsX = dims.top >= 0 && dims.bottom <= screenHeight;
              if (!forceShow && !fitsX) {
                return false;
              }
              if (!fitsX) {
                if (anchor === "top") {
                  renderer.$maxPixelHeight = spaceAbove;
                } else {
                  renderer.$maxPixelHeight = spaceBelow;
                }
              } else {
                renderer.$maxPixelHeight = null;
              }
              if (anchor === "top") {
                el2.style.top = "";
                el2.style.bottom = screenHeight - dims.bottom + "px";
                popup.isTopdown = false;
              } else {
                el2.style.top = dims.top + "px";
                el2.style.bottom = "";
                popup.isTopdown = true;
              }
              el2.style.display = "";
              var left = pos.left;
              if (left + el2.offsetWidth > screenWidth)
                left = screenWidth - el2.offsetWidth;
              el2.style.left = left + "px";
              el2.style.right = "";
              if (!popup.isOpen) {
                popup.isOpen = true;
                this._signal("show");
                lastMouseEvent = null;
              }
              popup.anchorPos = pos;
              popup.anchor = anchor;
              return true;
            };
            popup.show = function(pos, lineHeight, topdownOnly) {
              this.tryShow(pos, lineHeight, topdownOnly ? "bottom" : void 0, true);
            };
            popup.goTo = function(where) {
              var row = this.getRow();
              var max = this.session.getLength() - 1;
              switch (where) {
                case "up":
                  row = row <= 0 ? max : row - 1;
                  break;
                case "down":
                  row = row >= max ? -1 : row + 1;
                  break;
                case "start":
                  row = 0;
                  break;
                case "end":
                  row = max;
                  break;
              }
              this.setRow(row);
            };
            popup.getTextLeftOffset = function() {
              return this.$borderSize + this.renderer.$padding + this.$imageSize;
            };
            popup.$imageSize = 0;
            popup.$borderSize = 1;
            return popup;
          }
          return AcePopup2;
        })()
      );
      dom.importCssString('\n.ace_editor.ace_autocomplete .ace_marker-layer .ace_active-line {\n    background-color: #CAD6FA;\n    z-index: 1;\n}\n.ace_dark.ace_editor.ace_autocomplete .ace_marker-layer .ace_active-line {\n    background-color: #3a674e;\n}\n.ace_editor.ace_autocomplete .ace_line-hover {\n    border: 1px solid #abbffe;\n    margin-top: -1px;\n    background: rgba(233,233,253,0.4);\n    position: absolute;\n    z-index: 2;\n}\n.ace_dark.ace_editor.ace_autocomplete .ace_line-hover {\n    border: 1px solid rgba(109, 150, 13, 0.8);\n    background: rgba(58, 103, 78, 0.62);\n}\n.ace_completion-meta {\n    opacity: 0.5;\n    margin-left: 0.9em;\n}\n.ace_completion-message {\n    margin-left: 0.9em;\n    color: blue;\n}\n.ace_editor.ace_autocomplete .ace_completion-highlight{\n    color: #2d69c7;\n}\n.ace_dark.ace_editor.ace_autocomplete .ace_completion-highlight{\n    color: #93ca12;\n}\n.ace_editor.ace_autocomplete {\n    width: 300px;\n    z-index: 200000;\n    border: 1px lightgray solid;\n    position: fixed;\n    box-shadow: 2px 3px 5px rgba(0,0,0,.2);\n    line-height: 1.4;\n    background: #fefefe;\n    color: #111;\n}\n.ace_dark.ace_editor.ace_autocomplete {\n    border: 1px #484747 solid;\n    box-shadow: 2px 3px 5px rgba(0, 0, 0, 0.51);\n    line-height: 1.4;\n    background: #25282c;\n    color: #c1c1c1;\n}\n.ace_autocomplete .ace_text-layer  {\n    width: calc(100% - 8px);\n}\n.ace_autocomplete .ace_line {\n    display: flex;\n    align-items: center;\n}\n.ace_autocomplete .ace_line > * {\n    min-width: 0;\n    flex: 0 0 auto;\n}\n.ace_autocomplete .ace_line .ace_ {\n    flex: 0 1 auto;\n    overflow: hidden;\n    text-overflow: ellipsis;\n}\n.ace_autocomplete .ace_completion-spacer {\n    flex: 1;\n}\n.ace_autocomplete.ace_loading:after  {\n    content: "";\n    position: absolute;\n    top: 0px;\n    height: 2px;\n    width: 8%;\n    background: blue;\n    z-index: 100;\n    animation: ace_progress 3s infinite linear;\n    animation-delay: 300ms;\n    transform: translateX(-100%) scaleX(1);\n}\n@keyframes ace_progress {\n    0% { transform: translateX(-100%) scaleX(1) }\n    50% { transform: translateX(625%) scaleX(2) } \n    100% { transform: translateX(1500%) scaleX(3) } \n}\n@media (prefers-reduced-motion) {\n    .ace_autocomplete.ace_loading:after {\n        transform: translateX(625%) scaleX(2);\n        animation: none;\n     }\n}\n', "autocompletion.css", false);
      exports3.AcePopup = AcePopup;
      exports3.$singleLineEditor = $singleLineEditor;
      exports3.getAriaId = getAriaId;
    });
    ace.define("ace/autocomplete/inline_screenreader", ["require", "exports", "module"], function(require2, exports3, module3) {
      var AceInlineScreenReader = (
        /** @class */
        (function() {
          function AceInlineScreenReader2(editor) {
            this.editor = editor;
            this.screenReaderDiv = document.createElement("div");
            this.screenReaderDiv.classList.add("ace_screenreader-only");
            this.editor.container.appendChild(this.screenReaderDiv);
          }
          AceInlineScreenReader2.prototype.setScreenReaderContent = function(content) {
            if (!this.popup && this.editor.completer && /**@type{import("../autocomplete").Autocomplete}*/
            this.editor.completer.popup) {
              this.popup = /**@type{import("../autocomplete").Autocomplete}*/
              this.editor.completer.popup;
              this.popup.renderer.on("afterRender", (function() {
                var row = this.popup.getRow();
                var t2 = this.popup.renderer.$textLayer;
                var selected = t2.element.childNodes[row - t2.config.firstRow];
                if (selected) {
                  var idString = "doc-tooltip ";
                  for (var lineIndex = 0; lineIndex < this._lines.length; lineIndex++) {
                    idString += "ace-inline-screenreader-line-".concat(lineIndex, " ");
                  }
                  selected.setAttribute("aria-describedby", idString);
                }
              }).bind(this));
            }
            while (this.screenReaderDiv.firstChild) {
              this.screenReaderDiv.removeChild(this.screenReaderDiv.firstChild);
            }
            this._lines = content.split(/\r\n|\r|\n/);
            var codeElement = this.createCodeBlock();
            this.screenReaderDiv.appendChild(codeElement);
          };
          AceInlineScreenReader2.prototype.destroy = function() {
            this.screenReaderDiv.remove();
          };
          AceInlineScreenReader2.prototype.createCodeBlock = function() {
            var container = document.createElement("pre");
            container.setAttribute("id", "ace-inline-screenreader");
            for (var lineIndex = 0; lineIndex < this._lines.length; lineIndex++) {
              var codeElement = document.createElement("code");
              codeElement.setAttribute("id", "ace-inline-screenreader-line-".concat(lineIndex));
              var line = document.createTextNode(this._lines[lineIndex]);
              codeElement.appendChild(line);
              container.appendChild(codeElement);
            }
            return container;
          };
          return AceInlineScreenReader2;
        })()
      );
      exports3.AceInlineScreenReader = AceInlineScreenReader;
    });
    ace.define("ace/autocomplete/inline", ["require", "exports", "module", "ace/snippets", "ace/autocomplete/inline_screenreader"], function(require2, exports3, module3) {
      var snippetManager = require2("../snippets").snippetManager;
      var AceInlineScreenReader = require2("./inline_screenreader").AceInlineScreenReader;
      var AceInline = (
        /** @class */
        (function() {
          function AceInline2() {
            this.editor = null;
          }
          AceInline2.prototype.show = function(editor, completion, prefix) {
            prefix = prefix || "";
            if (editor && this.editor && this.editor !== editor) {
              this.hide();
              this.editor = null;
              this.inlineScreenReader = null;
            }
            if (!editor || !completion) {
              return false;
            }
            if (!this.inlineScreenReader) {
              this.inlineScreenReader = new AceInlineScreenReader(editor);
            }
            var displayText = completion.snippet ? snippetManager.getDisplayTextForSnippet(editor, completion.snippet) : completion.value;
            if (completion.hideInlinePreview || !displayText || !displayText.startsWith(prefix)) {
              return false;
            }
            this.editor = editor;
            this.inlineScreenReader.setScreenReaderContent(displayText);
            displayText = displayText.slice(prefix.length);
            if (displayText === "") {
              editor.removeGhostText();
            } else {
              editor.setGhostText(displayText);
            }
            return true;
          };
          AceInline2.prototype.isOpen = function() {
            if (!this.editor) {
              return false;
            }
            return !!this.editor.renderer.$ghostText;
          };
          AceInline2.prototype.hide = function() {
            if (!this.editor) {
              return false;
            }
            this.editor.removeGhostText();
            return true;
          };
          AceInline2.prototype.destroy = function() {
            this.hide();
            this.editor = null;
            if (this.inlineScreenReader) {
              this.inlineScreenReader.destroy();
              this.inlineScreenReader = null;
            }
          };
          return AceInline2;
        })()
      );
      exports3.AceInline = AceInline;
    });
    ace.define("ace/autocomplete/util", ["require", "exports", "module"], function(require2, exports3, module3) {
      exports3.parForEach = function(array, fn, callback) {
        var completed = 0;
        var arLength = array.length;
        if (arLength === 0)
          callback();
        for (var i2 = 0; i2 < arLength; i2++) {
          fn(array[i2], function(result, err) {
            completed++;
            if (completed === arLength)
              callback(result, err);
          });
        }
      };
      var ID_REGEX = /[a-zA-Z_0-9\$\-\u00A2-\u2000\u2070-\uFFFF]/;
      exports3.retrievePrecedingIdentifier = function(text, pos, regex) {
        regex = regex || ID_REGEX;
        var buf = [];
        for (var i2 = pos - 1; i2 >= 0; i2--) {
          if (regex.test(text[i2]))
            buf.push(text[i2]);
          else
            break;
        }
        return buf.reverse().join("");
      };
      exports3.retrieveFollowingIdentifier = function(text, pos, regex) {
        regex = regex || ID_REGEX;
        var buf = [];
        for (var i2 = pos; i2 < text.length; i2++) {
          if (regex.test(text[i2]))
            buf.push(text[i2]);
          else
            break;
        }
        return buf;
      };
      exports3.getCompletionPrefix = function(editor) {
        var pos = editor.getCursorPosition();
        var line = editor.session.getLine(pos.row);
        var prefix;
        editor.completers.forEach((function(completer) {
          if (completer.identifierRegexps) {
            completer.identifierRegexps.forEach((function(identifierRegex) {
              if (!prefix && identifierRegex)
                prefix = this.retrievePrecedingIdentifier(line, pos.column, identifierRegex);
            }).bind(this));
          }
        }).bind(this));
        return prefix || this.retrievePrecedingIdentifier(line, pos.column);
      };
      exports3.triggerAutocomplete = function(editor, previousChar) {
        var previousChar = previousChar == null ? editor.session.getPrecedingCharacter() : previousChar;
        return editor.completers.some(function(completer) {
          if (completer.triggerCharacters && Array.isArray(completer.triggerCharacters)) {
            return completer.triggerCharacters.includes(previousChar);
          }
        });
      };
    });
    ace.define("ace/autocomplete", ["require", "exports", "module", "ace/keyboard/hash_handler", "ace/autocomplete/popup", "ace/autocomplete/inline", "ace/autocomplete/popup", "ace/autocomplete/util", "ace/lib/lang", "ace/lib/dom", "ace/snippets", "ace/config", "ace/lib/event", "ace/lib/scroll"], function(require2, exports3, module3) {
      var HashHandler = require2("./keyboard/hash_handler").HashHandler;
      var AcePopup = require2("./autocomplete/popup").AcePopup;
      var AceInline = require2("./autocomplete/inline").AceInline;
      var getAriaId = require2("./autocomplete/popup").getAriaId;
      var util = require2("./autocomplete/util");
      var lang = require2("./lib/lang");
      var dom = require2("./lib/dom");
      var snippetManager = require2("./snippets").snippetManager;
      var config = require2("./config");
      var event = require2("./lib/event");
      var preventParentScroll = require2("./lib/scroll").preventParentScroll;
      var destroyCompleter = function(e2, editor) {
        editor.completer && editor.completer.destroy();
      };
      var Autocomplete = (
        /** @class */
        (function() {
          function Autocomplete2() {
            this.autoInsert = false;
            this.autoSelect = true;
            this.autoShown = false;
            this.exactMatch = false;
            this.inlineEnabled = false;
            this.keyboardHandler = new HashHandler();
            this.keyboardHandler.bindKeys(this.commands);
            this.parentNode = null;
            this.setSelectOnHover = false;
            this.hasSeen = /* @__PURE__ */ new Set();
            this.showLoadingState = false;
            this.stickySelectionDelay = 500;
            this.blurListener = this.blurListener.bind(this);
            this.changeListener = this.changeListener.bind(this);
            this.mousedownListener = this.mousedownListener.bind(this);
            this.mousewheelListener = this.mousewheelListener.bind(this);
            this.onLayoutChange = this.onLayoutChange.bind(this);
            this.changeTimer = lang.delayedCall((function() {
              this.updateCompletions(true);
            }).bind(this));
            this.tooltipTimer = lang.delayedCall(this.updateDocTooltip.bind(this), 50);
            this.popupTimer = lang.delayedCall(this.$updatePopupPosition.bind(this), 50);
            this.stickySelectionTimer = lang.delayedCall((function() {
              this.stickySelection = true;
            }).bind(this), this.stickySelectionDelay);
            this.$firstOpenTimer = lang.delayedCall(
              /**@this{Autocomplete}*/
              (function() {
                var initialPosition = this.completionProvider && this.completionProvider.initialPosition;
                if (this.autoShown || this.popup && this.popup.isOpen || !initialPosition || this.editor.completers.length === 0)
                  return;
                this.completions = new FilteredList(Autocomplete2.completionsForLoading);
                this.openPopup(this.editor, initialPosition.prefix, false);
                this.popup.renderer.setStyle("ace_loading", true);
              }).bind(this),
              this.stickySelectionDelay
            );
          }
          Object.defineProperty(Autocomplete2, "completionsForLoading", {
            get: function() {
              return [{
                caption: config.nls("autocomplete.loading", "Loading..."),
                value: ""
              }];
            },
            enumerable: false,
            configurable: true
          });
          Autocomplete2.prototype.$init = function() {
            this.popup = new AcePopup(this.parentNode || document.body || document.documentElement);
            this.popup.on("click", (function(e2) {
              this.insertMatch();
              e2.stop();
            }).bind(this));
            this.popup.focus = this.editor.focus.bind(this.editor);
            this.popup.on("show", this.$onPopupShow.bind(this));
            this.popup.on("hide", this.$onHidePopup.bind(this));
            this.popup.on("select", this.$onPopupChange.bind(this));
            event.addListener(this.popup.container, "mouseout", this.mouseOutListener.bind(this));
            this.popup.on("changeHoverMarker", this.tooltipTimer.bind(null, null));
            this.popup.renderer.on("afterRender", this.$onPopupRender.bind(this));
            return this.popup;
          };
          Autocomplete2.prototype.$initInline = function() {
            if (!this.inlineEnabled || this.inlineRenderer)
              return;
            this.inlineRenderer = new AceInline();
            return this.inlineRenderer;
          };
          Autocomplete2.prototype.getPopup = function() {
            return this.popup || this.$init();
          };
          Autocomplete2.prototype.$onHidePopup = function() {
            if (this.inlineRenderer) {
              this.inlineRenderer.hide();
            }
            this.hideDocTooltip();
            this.stickySelectionTimer.cancel();
            this.popupTimer.cancel();
            this.stickySelection = false;
          };
          Autocomplete2.prototype.$seen = function(completion) {
            if (!this.hasSeen.has(completion) && completion && completion.completer && completion.completer.onSeen && typeof completion.completer.onSeen === "function") {
              completion.completer.onSeen(this.editor, completion);
              this.hasSeen.add(completion);
            }
          };
          Autocomplete2.prototype.$onPopupChange = function(hide) {
            if (this.inlineRenderer && this.inlineEnabled) {
              var completion = hide ? null : this.popup.getData(this.popup.getRow());
              this.$updateGhostText(completion);
              if (this.popup.isMouseOver && this.setSelectOnHover) {
                this.tooltipTimer.call(null, null);
                return;
              }
              this.popupTimer.schedule();
              this.tooltipTimer.schedule();
            } else {
              this.popupTimer.call(null, null);
              this.tooltipTimer.call(null, null);
            }
          };
          Autocomplete2.prototype.$updateGhostText = function(completion) {
            var row = this.base.row;
            var column = this.base.column;
            var cursorColumn = this.editor.getCursorPosition().column;
            var prefix = this.editor.session.getLine(row).slice(column, cursorColumn);
            if (!this.inlineRenderer.show(this.editor, completion, prefix)) {
              this.inlineRenderer.hide();
            } else {
              this.$seen(completion);
            }
          };
          Autocomplete2.prototype.$onPopupRender = function() {
            var inlineEnabled = this.inlineRenderer && this.inlineEnabled;
            if (this.completions && this.completions.filtered && this.completions.filtered.length > 0) {
              for (var i2 = this.popup.getFirstVisibleRow(); i2 <= this.popup.getLastVisibleRow(); i2++) {
                var completion = this.popup.getData(i2);
                if (completion && (!inlineEnabled || completion.hideInlinePreview)) {
                  this.$seen(completion);
                }
              }
            }
          };
          Autocomplete2.prototype.$onPopupShow = function(hide) {
            this.$onPopupChange(hide);
            this.stickySelection = false;
            if (this.stickySelectionDelay >= 0)
              this.stickySelectionTimer.schedule(this.stickySelectionDelay);
          };
          Autocomplete2.prototype.observeLayoutChanges = function() {
            if (this.$elements || !this.editor)
              return;
            window.addEventListener("resize", this.onLayoutChange, { passive: true });
            window.addEventListener("wheel", this.mousewheelListener);
            var el = this.editor.container.parentNode;
            var elements = [];
            while (el) {
              elements.push(el);
              el.addEventListener("scroll", this.onLayoutChange, { passive: true });
              el = el.parentNode;
            }
            this.$elements = elements;
          };
          Autocomplete2.prototype.unObserveLayoutChanges = function() {
            var _this = this;
            window.removeEventListener("resize", this.onLayoutChange, { passive: true });
            window.removeEventListener("wheel", this.mousewheelListener);
            this.$elements && this.$elements.forEach(function(el) {
              el.removeEventListener("scroll", _this.onLayoutChange, { passive: true });
            });
            this.$elements = null;
          };
          Autocomplete2.prototype.onLayoutChange = function() {
            if (!this.popup.isOpen)
              return this.unObserveLayoutChanges();
            this.$updatePopupPosition();
            this.updateDocTooltip();
          };
          Autocomplete2.prototype.$updatePopupPosition = function() {
            var editor = this.editor;
            var renderer = editor.renderer;
            var lineHeight = renderer.layerConfig.lineHeight;
            var pos = renderer.$cursorLayer.getPixelPosition(this.base, true);
            pos.left -= this.popup.getTextLeftOffset();
            var rect = editor.container.getBoundingClientRect();
            pos.top += rect.top - renderer.layerConfig.offset;
            pos.left += rect.left - editor.renderer.scrollLeft;
            pos.left += renderer.gutterWidth;
            var posGhostText = {
              top: pos.top,
              left: pos.left
            };
            if (renderer.$ghostText && renderer.$ghostTextWidget) {
              if (this.base.row === renderer.$ghostText.position.row) {
                posGhostText.top += renderer.$ghostTextWidget.el.offsetHeight;
              }
            }
            var editorContainerBottom = editor.container.getBoundingClientRect().bottom - lineHeight;
            var lowestPosition = editorContainerBottom < posGhostText.top ? { top: editorContainerBottom, left: posGhostText.left } : posGhostText;
            if (this.popup.tryShow(lowestPosition, lineHeight, "bottom")) {
              return;
            }
            if (this.popup.tryShow(pos, lineHeight, "top")) {
              return;
            }
            this.popup.show(pos, lineHeight);
          };
          Autocomplete2.prototype.openPopup = function(editor, prefix, keepPopupPosition) {
            this.$firstOpenTimer.cancel();
            if (!this.popup)
              this.$init();
            if (this.inlineEnabled && !this.inlineRenderer)
              this.$initInline();
            this.popup.autoSelect = this.autoSelect;
            this.popup.setSelectOnHover(this.setSelectOnHover);
            var oldRow = this.popup.getRow();
            var previousSelectedItem = this.popup.data[oldRow];
            this.popup.setData(this.completions.filtered, this.completions.filterText);
            if (this.editor.textInput.setAriaOptions) {
              this.editor.textInput.setAriaOptions({
                activeDescendant: getAriaId(this.popup.getRow()),
                inline: this.inlineEnabled
              });
            }
            editor.keyBinding.addKeyboardHandler(this.keyboardHandler);
            var newRow;
            if (this.stickySelection)
              newRow = this.popup.data.indexOf(previousSelectedItem);
            if (!newRow || newRow === -1)
              newRow = 0;
            this.popup.setRow(this.autoSelect ? newRow : -1);
            if (newRow === oldRow && previousSelectedItem !== this.completions.filtered[newRow])
              this.$onPopupChange();
            var inlineEnabled = this.inlineRenderer && this.inlineEnabled;
            if (newRow === oldRow && inlineEnabled) {
              var completion = this.popup.getData(this.popup.getRow());
              this.$updateGhostText(completion);
            }
            if (!keepPopupPosition) {
              this.popup.setTheme(editor.getTheme());
              this.popup.setFontSize(editor.getFontSize());
              this.$updatePopupPosition();
              if (this.tooltipNode) {
                this.updateDocTooltip();
              }
            }
            this.changeTimer.cancel();
            this.observeLayoutChanges();
          };
          Autocomplete2.prototype.detach = function() {
            if (this.editor) {
              this.editor.keyBinding.removeKeyboardHandler(this.keyboardHandler);
              this.editor.off("changeSelection", this.changeListener);
              this.editor.off("blur", this.blurListener);
              this.editor.off("mousedown", this.mousedownListener);
              this.editor.off("mousewheel", this.mousewheelListener);
            }
            this.$firstOpenTimer.cancel();
            this.changeTimer.cancel();
            this.hideDocTooltip();
            if (this.completionProvider) {
              this.completionProvider.detach();
            }
            if (this.popup && this.popup.isOpen)
              this.popup.hide();
            if (this.popup && this.popup.renderer) {
              this.popup.renderer.off("afterRender", this.$onPopupRender);
            }
            if (this.base)
              this.base.detach();
            this.activated = false;
            this.completionProvider = this.completions = this.base = null;
            this.unObserveLayoutChanges();
          };
          Autocomplete2.prototype.changeListener = function(e2) {
            var cursor = this.editor.selection.lead;
            if (cursor.row != this.base.row || cursor.column < this.base.column) {
              this.detach();
            }
            if (this.activated)
              this.changeTimer.schedule();
            else
              this.detach();
          };
          Autocomplete2.prototype.blurListener = function(e2) {
            var el = document.activeElement;
            var text = this.editor.textInput.getElement();
            var fromTooltip = e2.relatedTarget && this.tooltipNode && this.tooltipNode.contains(e2.relatedTarget);
            var container = this.popup && this.popup.container;
            if (el != text && el.parentNode != container && !fromTooltip && el != this.tooltipNode && e2.relatedTarget != text) {
              this.detach();
            }
          };
          Autocomplete2.prototype.mousedownListener = function(e2) {
            this.detach();
          };
          Autocomplete2.prototype.mousewheelListener = function(e2) {
            if (this.popup && !this.popup.isMouseOver)
              this.detach();
          };
          Autocomplete2.prototype.mouseOutListener = function(e2) {
            if (this.popup.isOpen)
              this.$updatePopupPosition();
          };
          Autocomplete2.prototype.goTo = function(where) {
            this.popup.goTo(where);
          };
          Autocomplete2.prototype.insertMatch = function(data, options) {
            if (!data)
              data = this.popup.getData(this.popup.getRow());
            if (!data)
              return false;
            if (data.value === "")
              return this.detach();
            var completions = this.completions;
            var result = this.getCompletionProvider().insertMatch(this.editor, data, completions.filterText, options);
            if (this.completions == completions)
              this.detach();
            return result;
          };
          Autocomplete2.prototype.showPopup = function(editor, options) {
            if (this.editor)
              this.detach();
            this.activated = true;
            this.editor = editor;
            if (editor.completer != this) {
              if (editor.completer)
                editor.completer.detach();
              editor.completer = this;
            }
            editor.on("changeSelection", this.changeListener);
            editor.on("blur", this.blurListener);
            editor.on("mousedown", this.mousedownListener);
            editor.on("mousewheel", this.mousewheelListener);
            this.updateCompletions(false, options);
          };
          Autocomplete2.prototype.getCompletionProvider = function(initialPosition) {
            if (!this.completionProvider)
              this.completionProvider = new CompletionProvider(initialPosition);
            return this.completionProvider;
          };
          Autocomplete2.prototype.gatherCompletions = function(editor, callback) {
            return this.getCompletionProvider().gatherCompletions(editor, callback);
          };
          Autocomplete2.prototype.updateCompletions = function(keepPopupPosition, options) {
            if (keepPopupPosition && this.base && this.completions) {
              var pos = this.editor.getCursorPosition();
              var prefix = this.editor.session.getTextRange({ start: this.base, end: pos });
              if (prefix == this.completions.filterText)
                return;
              this.completions.setFilter(prefix);
              if (!this.completions.filtered.length)
                return this.detach();
              if (this.completions.filtered.length == 1 && this.completions.filtered[0].value == prefix && !this.completions.filtered[0].snippet)
                return this.detach();
              this.openPopup(this.editor, prefix, keepPopupPosition);
              return;
            }
            if (options && options.matches) {
              var pos = this.editor.getSelectionRange().start;
              this.base = this.editor.session.doc.createAnchor(pos.row, pos.column);
              this.base.$insertRight = true;
              this.completions = new FilteredList(options.matches);
              this.getCompletionProvider().completions = this.completions;
              return this.openPopup(this.editor, "", keepPopupPosition);
            }
            var session = this.editor.getSession();
            var pos = this.editor.getCursorPosition();
            var prefix = util.getCompletionPrefix(this.editor);
            this.base = session.doc.createAnchor(pos.row, pos.column - prefix.length);
            this.base.$insertRight = true;
            var completionOptions = {
              exactMatch: this.exactMatch,
              ignoreCaption: this.ignoreCaption
            };
            this.getCompletionProvider({
              prefix,
              pos
            }).provideCompletions(
              this.editor,
              completionOptions,
              (function(err, completions, finished) {
                var filtered = completions.filtered;
                var prefix2 = util.getCompletionPrefix(this.editor);
                this.$firstOpenTimer.cancel();
                if (finished) {
                  if (!filtered.length) {
                    var emptyMessage = !this.autoShown && this.emptyMessage;
                    if (typeof emptyMessage == "function")
                      emptyMessage = this.emptyMessage(prefix2);
                    if (emptyMessage) {
                      var completionsForEmpty = [
                        {
                          caption: emptyMessage,
                          value: ""
                        }
                      ];
                      this.completions = new FilteredList(completionsForEmpty);
                      this.openPopup(this.editor, prefix2, keepPopupPosition);
                      this.popup.renderer.setStyle("ace_loading", false);
                      this.popup.renderer.setStyle("ace_empty-message", true);
                      return;
                    }
                    return this.detach();
                  }
                  if (filtered.length == 1 && filtered[0].value == prefix2 && !filtered[0].snippet)
                    return this.detach();
                  if (this.autoInsert && !this.autoShown && filtered.length == 1)
                    return this.insertMatch(filtered[0]);
                }
                this.completions = !finished && this.showLoadingState ? new FilteredList(Autocomplete2.completionsForLoading.concat(filtered), completions.filterText) : completions;
                this.openPopup(this.editor, prefix2, keepPopupPosition);
                this.popup.renderer.setStyle("ace_empty-message", false);
                this.popup.renderer.setStyle("ace_loading", !finished);
              }).bind(this)
            );
            if (this.showLoadingState && !this.autoShown && !(this.popup && this.popup.isOpen)) {
              this.$firstOpenTimer.delay(this.stickySelectionDelay / 2);
            }
          };
          Autocomplete2.prototype.cancelContextMenu = function() {
            this.editor.$mouseHandler.cancelContextMenu();
          };
          Autocomplete2.prototype.updateDocTooltip = function() {
            var popup = this.popup;
            var all = this.completions.filtered;
            var selected = all && (all[popup.getHoveredRow()] || all[popup.getRow()]);
            var doc = null;
            if (!selected || !this.editor || !this.popup.isOpen)
              return this.hideDocTooltip();
            var completersLength = this.editor.completers.length;
            for (var i2 = 0; i2 < completersLength; i2++) {
              var completer = this.editor.completers[i2];
              if (completer.getDocTooltip && selected.completerId === completer.id) {
                doc = completer.getDocTooltip(selected);
                break;
              }
            }
            if (!doc && typeof selected != "string")
              doc = selected;
            if (typeof doc == "string")
              doc = { docText: doc };
            if (!doc || !(doc.docHTML || doc.docText))
              return this.hideDocTooltip();
            this.showDocTooltip(doc);
          };
          Autocomplete2.prototype.showDocTooltip = function(item2) {
            if (!this.tooltipNode) {
              this.tooltipNode = dom.createElement("div");
              this.tooltipNode.style.margin = "0";
              this.tooltipNode.style.pointerEvents = "auto";
              this.tooltipNode.style.overscrollBehavior = "contain";
              this.tooltipNode.tabIndex = -1;
              this.tooltipNode.onblur = this.blurListener.bind(this);
              this.tooltipNode.onclick = this.onTooltipClick.bind(this);
              this.tooltipNode.id = "doc-tooltip";
              this.tooltipNode.setAttribute("role", "tooltip");
              this.tooltipNode.addEventListener("wheel", preventParentScroll);
            }
            var theme = this.editor.renderer.theme;
            this.tooltipNode.className = "ace_tooltip ace_doc-tooltip " + (theme.isDark ? "ace_dark " : "") + (theme.cssClass || "");
            var tooltipNode = this.tooltipNode;
            if (item2.docHTML) {
              tooltipNode.innerHTML = item2.docHTML;
            } else if (item2.docText) {
              tooltipNode.textContent = item2.docText;
            }
            if (!tooltipNode.parentNode)
              this.popup.container.appendChild(this.tooltipNode);
            var popup = this.popup;
            var rect = popup.container.getBoundingClientRect();
            tooltipNode.style.top = popup.container.style.top;
            tooltipNode.style.bottom = popup.container.style.bottom;
            tooltipNode.style.display = "block";
            if (window.innerWidth - rect.right < 320) {
              if (rect.left < 320) {
                if (popup.isTopdown) {
                  tooltipNode.style.top = rect.bottom + "px";
                  tooltipNode.style.left = rect.left + "px";
                  tooltipNode.style.right = "";
                  tooltipNode.style.bottom = "";
                } else {
                  tooltipNode.style.top = popup.container.offsetTop - tooltipNode.offsetHeight + "px";
                  tooltipNode.style.left = rect.left + "px";
                  tooltipNode.style.right = "";
                  tooltipNode.style.bottom = "";
                }
              } else {
                tooltipNode.style.right = window.innerWidth - rect.left + "px";
                tooltipNode.style.left = "";
              }
            } else {
              tooltipNode.style.left = rect.right + 1 + "px";
              tooltipNode.style.right = "";
            }
          };
          Autocomplete2.prototype.hideDocTooltip = function() {
            this.tooltipTimer.cancel();
            if (!this.tooltipNode)
              return;
            var el = this.tooltipNode;
            if (!this.editor.isFocused() && document.activeElement == el)
              this.editor.focus();
            this.tooltipNode = null;
            if (el.parentNode)
              el.parentNode.removeChild(el);
          };
          Autocomplete2.prototype.onTooltipClick = function(e2) {
            var a3 = e2.target;
            while (a3 && a3 != this.tooltipNode) {
              if (a3.nodeName == "A" && a3.href) {
                a3.rel = "noreferrer";
                a3.target = "_blank";
                break;
              }
              a3 = a3.parentNode;
            }
          };
          Autocomplete2.prototype.destroy = function() {
            this.detach();
            if (this.popup) {
              this.popup.destroy();
              var el = this.popup.container;
              if (el && el.parentNode)
                el.parentNode.removeChild(el);
            }
            if (this.editor && this.editor.completer == this) {
              this.editor.off("destroy", destroyCompleter);
              this.editor.completer = null;
            }
            this.inlineRenderer = this.popup = this.editor = null;
          };
          Autocomplete2.for = function(editor) {
            if (editor.completer instanceof Autocomplete2) {
              return editor.completer;
            }
            if (editor.completer) {
              editor.completer.destroy();
              editor.completer = null;
            }
            if (config.get("sharedPopups")) {
              if (!Autocomplete2["$sharedInstance"])
                Autocomplete2["$sharedInstance"] = new Autocomplete2();
              editor.completer = Autocomplete2["$sharedInstance"];
            } else {
              editor.completer = new Autocomplete2();
              editor.once("destroy", destroyCompleter);
            }
            return editor.completer;
          };
          return Autocomplete2;
        })()
      );
      Autocomplete.prototype.commands = {
        "Up": function(editor) {
          editor.completer.goTo("up");
        },
        "Down": function(editor) {
          editor.completer.goTo("down");
        },
        "Ctrl-Up|Ctrl-Home": function(editor) {
          editor.completer.goTo("start");
        },
        "Ctrl-Down|Ctrl-End": function(editor) {
          editor.completer.goTo("end");
        },
        "Esc": function(editor) {
          editor.completer.detach();
        },
        "Return": function(editor) {
          return editor.completer.insertMatch();
        },
        "Shift-Return": function(editor) {
          editor.completer.insertMatch(null, { deleteSuffix: true });
        },
        "Tab": function(editor) {
          var result = editor.completer.insertMatch();
          if (!result && !editor.tabstopManager)
            editor.completer.goTo("down");
          else
            return result;
        },
        "Backspace": function(editor) {
          editor.execCommand("backspace");
          var prefix = util.getCompletionPrefix(editor);
          if (!prefix && editor.completer)
            editor.completer.detach();
        },
        "PageUp": function(editor) {
          editor.completer.popup.gotoPageUp();
        },
        "PageDown": function(editor) {
          editor.completer.popup.gotoPageDown();
        }
      };
      Autocomplete.startCommand = {
        name: "startAutocomplete",
        exec: function(editor, options) {
          var completer = Autocomplete.for(editor);
          completer.autoInsert = false;
          completer.autoSelect = true;
          completer.autoShown = false;
          completer.showPopup(editor, options);
          completer.cancelContextMenu();
        },
        bindKey: "Ctrl-Space|Ctrl-Shift-Space|Alt-Space"
      };
      var CompletionProvider = (
        /** @class */
        (function() {
          function CompletionProvider2(initialPosition) {
            this.initialPosition = initialPosition;
            this.active = true;
          }
          CompletionProvider2.prototype.insertByIndex = function(editor, index, options) {
            if (!this.completions || !this.completions.filtered) {
              return false;
            }
            return this.insertMatch(editor, this.completions.filtered[index], options);
          };
          CompletionProvider2.prototype.insertMatch = function(editor, data, options) {
            if (!data)
              return false;
            editor.startOperation({ command: { name: "insertMatch" } });
            if (data.completer && data.completer.insertMatch) {
              data.completer.insertMatch(editor, data);
            } else {
              if (!this.completions)
                return false;
              var replaceBefore = this.completions.filterText.length;
              var replaceAfter = 0;
              if (data.range && data.range.start.row === data.range.end.row) {
                replaceBefore -= this.initialPosition.prefix.length;
                replaceBefore += this.initialPosition.pos.column - data.range.start.column;
                replaceAfter += data.range.end.column - this.initialPosition.pos.column;
              }
              if (replaceBefore || replaceAfter) {
                var ranges;
                if (editor.selection.getAllRanges) {
                  ranges = editor.selection.getAllRanges();
                } else {
                  ranges = [editor.getSelectionRange()];
                }
                for (var i2 = 0, range; range = ranges[i2]; i2++) {
                  range.start.column -= replaceBefore;
                  range.end.column += replaceAfter;
                  editor.session.remove(range);
                }
              }
              if (data.snippet) {
                snippetManager.insertSnippet(editor, data.snippet);
              } else {
                this.$insertString(editor, data);
              }
              if (data.completer && data.completer.onInsert && typeof data.completer.onInsert == "function") {
                data.completer.onInsert(editor, data);
              }
              if (data.command && data.command === "startAutocomplete") {
                editor.execCommand(data.command);
              }
            }
            editor.endOperation();
            return true;
          };
          CompletionProvider2.prototype.$insertString = function(editor, data) {
            var text = data.value || data;
            editor.execCommand("insertstring", text);
          };
          CompletionProvider2.prototype.gatherCompletions = function(editor, callback) {
            var session = editor.getSession();
            var pos = editor.getCursorPosition();
            var prefix = util.getCompletionPrefix(editor);
            var matches2 = [];
            this.completers = editor.completers;
            var total = editor.completers.length;
            editor.completers.forEach(function(completer, i2) {
              completer.getCompletions(editor, session, pos, prefix, function(err, results) {
                if (completer.hideInlinePreview)
                  results = results.map(function(result) {
                    return Object.assign(result, { hideInlinePreview: completer.hideInlinePreview });
                  });
                if (!err && results)
                  matches2 = matches2.concat(results);
                callback(null, {
                  prefix: util.getCompletionPrefix(editor),
                  matches: matches2,
                  finished: --total === 0
                });
              });
            });
            return true;
          };
          CompletionProvider2.prototype.provideCompletions = function(editor, options, callback) {
            var processResults = (function(results2) {
              var prefix = results2.prefix;
              var matches2 = results2.matches;
              this.completions = new FilteredList(matches2);
              if (options.exactMatch)
                this.completions.exactMatch = true;
              if (options.ignoreCaption)
                this.completions.ignoreCaption = true;
              this.completions.setFilter(prefix);
              if (results2.finished || this.completions.filtered.length)
                callback(null, this.completions, results2.finished);
            }).bind(this);
            var isImmediate = true;
            var immediateResults = null;
            this.gatherCompletions(editor, (function(err, results2) {
              if (!this.active) {
                return;
              }
              if (err) {
                callback(err, [], true);
                this.detach();
              }
              var prefix = results2.prefix;
              if (prefix.indexOf(results2.prefix) !== 0)
                return;
              if (isImmediate) {
                immediateResults = results2;
                return;
              }
              processResults(results2);
            }).bind(this));
            isImmediate = false;
            if (immediateResults) {
              var results = immediateResults;
              immediateResults = null;
              processResults(results);
            }
          };
          CompletionProvider2.prototype.detach = function() {
            this.active = false;
            this.completers && this.completers.forEach(function(completer) {
              if (typeof completer.cancel === "function") {
                completer.cancel();
              }
            });
          };
          return CompletionProvider2;
        })()
      );
      var FilteredList = (
        /** @class */
        (function() {
          function FilteredList2(array, filterText) {
            this.all = array;
            this.filtered = array;
            this.filterText = filterText || "";
            this.exactMatch = false;
            this.ignoreCaption = false;
          }
          FilteredList2.prototype.setFilter = function(str) {
            if (str.length > this.filterText && str.lastIndexOf(this.filterText, 0) === 0)
              var matches2 = this.filtered;
            else
              var matches2 = this.all;
            this.filterText = str;
            matches2 = this.filterCompletions(matches2, this.filterText);
            matches2 = matches2.sort(function(a3, b2) {
              return b2.exactMatch - a3.exactMatch || b2.$score - a3.$score || (a3.caption || a3.value).localeCompare(b2.caption || b2.value);
            });
            var prev = null;
            matches2 = matches2.filter(function(item2) {
              var caption = item2.snippet || item2.caption || item2.value;
              if (caption === prev)
                return false;
              prev = caption;
              return true;
            });
            this.filtered = matches2;
          };
          FilteredList2.prototype.filterCompletions = function(items, needle) {
            var results = [];
            var upper2 = needle.toUpperCase();
            var lower = needle.toLowerCase();
            loop: for (var i2 = 0, item2; item2 = items[i2]; i2++) {
              if (item2.skipFilter) {
                item2.$score = item2.score;
                results.push(item2);
                continue;
              }
              var caption = !this.ignoreCaption && item2.caption || item2.value || item2.snippet;
              if (!caption)
                continue;
              var lastIndex = -1;
              var matchMask = 0;
              var penalty = 0;
              var index, distance;
              if (this.exactMatch) {
                if (needle !== caption.substr(0, needle.length))
                  continue loop;
              } else {
                var fullMatchIndex = caption.toLowerCase().indexOf(lower);
                if (fullMatchIndex > -1) {
                  penalty = fullMatchIndex;
                } else {
                  for (var j = 0; j < needle.length; j++) {
                    var i1 = caption.indexOf(lower[j], lastIndex + 1);
                    var i22 = caption.indexOf(upper2[j], lastIndex + 1);
                    index = i1 >= 0 ? i22 < 0 || i1 < i22 ? i1 : i22 : i22;
                    if (index < 0)
                      continue loop;
                    distance = index - lastIndex - 1;
                    if (distance > 0) {
                      if (lastIndex === -1)
                        penalty += 10;
                      penalty += distance;
                      matchMask = matchMask | 1 << j;
                    }
                    lastIndex = index;
                  }
                }
              }
              item2.matchMask = matchMask;
              item2.exactMatch = penalty ? 0 : 1;
              item2.$score = (item2.score || 0) - penalty;
              results.push(item2);
            }
            return results;
          };
          return FilteredList2;
        })()
      );
      exports3.Autocomplete = Autocomplete;
      exports3.CompletionProvider = CompletionProvider;
      exports3.FilteredList = FilteredList;
    });
    ace.define("ace/autocomplete/text_completer", ["require", "exports", "module", "ace/range"], function(require2, exports3, module3) {
      var Range = require2("../range").Range;
      var splitRegex = /[^a-zA-Z_0-9\$\-\u00C0-\u1FFF\u2C00-\uD7FF\w]+/;
      function getWordIndex(doc, pos) {
        var textBefore = doc.getTextRange(Range.fromPoints({
          row: 0,
          column: 0
        }, pos));
        return textBefore.split(splitRegex).length - 1;
      }
      function wordDistance(doc, pos) {
        var prefixPos = getWordIndex(doc, pos);
        var words = doc.getValue().split(splitRegex);
        var wordScores = /* @__PURE__ */ Object.create(null);
        var currentWord = words[prefixPos];
        words.forEach(function(word, idx) {
          if (!word || word === currentWord)
            return;
          var distance = Math.abs(prefixPos - idx);
          var score = words.length - distance;
          if (wordScores[word]) {
            wordScores[word] = Math.max(score, wordScores[word]);
          } else {
            wordScores[word] = score;
          }
        });
        return wordScores;
      }
      exports3.getCompletions = function(editor, session, pos, prefix, callback) {
        var wordScore = wordDistance(session, pos);
        var wordList = Object.keys(wordScore);
        callback(null, wordList.map(function(word) {
          return {
            caption: word,
            value: word,
            score: wordScore[word],
            meta: "local"
          };
        }));
      };
    });
    ace.define("ace/ext/language_tools", ["require", "exports", "module", "ace/snippets", "ace/autocomplete", "ace/config", "ace/lib/lang", "ace/autocomplete/util", "ace/autocomplete/text_completer", "ace/editor", "ace/config"], function(require2, exports3, module3) {
      var snippetManager = require2("../snippets").snippetManager;
      var Autocomplete = require2("../autocomplete").Autocomplete;
      var config = require2("../config");
      var lang = require2("../lib/lang");
      var util = require2("../autocomplete/util");
      var textCompleter = require2("../autocomplete/text_completer");
      var keyWordCompleter = {
        getCompletions: function(editor, session, pos, prefix, callback) {
          if (session.$mode.completer) {
            return session.$mode.completer.getCompletions(editor, session, pos, prefix, callback);
          }
          var state = editor.session.getState(pos.row);
          var completions = session.$mode.getCompletions(state, session, pos, prefix);
          completions = completions.map(function(el) {
            el.completerId = keyWordCompleter.id;
            return el;
          });
          callback(null, completions);
        },
        id: "keywordCompleter"
      };
      var transformSnippetTooltip = function(str) {
        var record = {};
        return str.replace(/\${(\d+)(:(.*?))?}/g, function(_, p1, p2, p3) {
          return record[p1] = p3 || "";
        }).replace(/\$(\d+?)/g, function(_, p1) {
          return record[p1];
        });
      };
      var snippetCompleter = {
        getCompletions: function(editor, session, pos, prefix, callback) {
          var scopes = [];
          var token = session.getTokenAt(pos.row, pos.column);
          if (token && token.type.match(/(tag-name|tag-open|tag-whitespace|attribute-name|attribute-value)\.xml$/))
            scopes.push("html-tag");
          else
            scopes = snippetManager.getActiveScopes(editor);
          var snippetMap = snippetManager.snippetMap;
          var completions = [];
          scopes.forEach(function(scope) {
            var snippets = snippetMap[scope] || [];
            for (var i2 = snippets.length; i2--; ) {
              var s3 = snippets[i2];
              var caption = s3.name || s3.tabTrigger;
              if (!caption)
                continue;
              completions.push({
                caption,
                snippet: s3.content,
                meta: s3.tabTrigger && !s3.name ? s3.tabTrigger + " " : "snippet",
                completerId: snippetCompleter.id
              });
            }
          }, this);
          callback(null, completions);
        },
        getDocTooltip: function(item2) {
          if (item2.snippet && !item2.docHTML) {
            item2.docHTML = [
              "<b>",
              lang.escapeHTML(item2.caption),
              "</b>",
              "<hr></hr>",
              lang.escapeHTML(transformSnippetTooltip(item2.snippet))
            ].join("");
          }
        },
        id: "snippetCompleter"
      };
      var completers = [snippetCompleter, textCompleter, keyWordCompleter];
      exports3.setCompleters = function(val) {
        completers.length = 0;
        if (val)
          completers.push.apply(completers, val);
      };
      exports3.addCompleter = function(completer) {
        completers.push(completer);
      };
      exports3.textCompleter = textCompleter;
      exports3.keyWordCompleter = keyWordCompleter;
      exports3.snippetCompleter = snippetCompleter;
      var expandSnippet = {
        name: "expandSnippet",
        exec: function(editor) {
          return snippetManager.expandWithTab(editor);
        },
        bindKey: "Tab"
      };
      var onChangeMode = function(e2, editor) {
        loadSnippetsForMode(editor.session.$mode);
      };
      var loadSnippetsForMode = function(mode) {
        if (typeof mode == "string")
          mode = config.$modes[mode];
        if (!mode)
          return;
        if (!snippetManager.files)
          snippetManager.files = {};
        loadSnippetFile(mode.$id, mode.snippetFileId);
        if (mode.modes)
          mode.modes.forEach(loadSnippetsForMode);
      };
      var loadSnippetFile = function(id, snippetFilePath) {
        if (!snippetFilePath || !id || snippetManager.files[id])
          return;
        snippetManager.files[id] = {};
        config.loadModule(snippetFilePath, function(m3) {
          if (!m3)
            return;
          snippetManager.files[id] = m3;
          if (!m3.snippets && m3.snippetText)
            m3.snippets = snippetManager.parseSnippetFile(m3.snippetText);
          snippetManager.register(m3.snippets || [], m3.scope);
          if (m3.includeScopes) {
            snippetManager.snippetMap[m3.scope].includeScopes = m3.includeScopes;
            m3.includeScopes.forEach(function(x2) {
              loadSnippetsForMode("ace/mode/" + x2);
            });
          }
        });
      };
      var doLiveAutocomplete = function(e2) {
        var editor = e2.editor;
        var hasCompleter = editor.completer && editor.completer.activated;
        if (e2.command.name === "backspace") {
          if (hasCompleter && !util.getCompletionPrefix(editor))
            editor.completer.detach();
        } else if (e2.command.name === "insertstring" && !hasCompleter) {
          lastExecEvent = e2;
          var delay = e2.editor.$liveAutocompletionDelay;
          if (delay) {
            liveAutocompleteTimer.delay(delay);
          } else {
            showLiveAutocomplete(e2);
          }
        }
      };
      var lastExecEvent;
      var liveAutocompleteTimer = lang.delayedCall(function() {
        showLiveAutocomplete(lastExecEvent);
      }, 0);
      var showLiveAutocomplete = function(e2) {
        var editor = e2.editor;
        var prefix = util.getCompletionPrefix(editor);
        var previousChar = e2.args;
        var triggerAutocomplete = util.triggerAutocomplete(editor, previousChar);
        if (prefix && prefix.length >= editor.$liveAutocompletionThreshold || triggerAutocomplete) {
          var completer = Autocomplete.for(editor);
          completer.autoShown = true;
          completer.showPopup(editor);
        }
      };
      var Editor = require2("../editor").Editor;
      require2("../config").defineOptions(Editor.prototype, "editor", {
        enableBasicAutocompletion: {
          set: function(val) {
            if (val) {
              if (!this.completers)
                this.completers = Array.isArray(val) ? val : completers;
              this.commands.addCommand(Autocomplete.startCommand);
            } else {
              this.commands.removeCommand(Autocomplete.startCommand);
            }
          },
          value: false
        },
        enableLiveAutocompletion: {
          set: function(val) {
            if (val) {
              if (!this.completers)
                this.completers = Array.isArray(val) ? val : completers;
              this.commands.on("afterExec", doLiveAutocomplete);
            } else {
              this.commands.off("afterExec", doLiveAutocomplete);
            }
          },
          value: false
        },
        liveAutocompletionDelay: {
          initialValue: 0
        },
        liveAutocompletionThreshold: {
          initialValue: 0
        },
        enableSnippets: {
          set: function(val) {
            if (val) {
              this.commands.addCommand(expandSnippet);
              this.on("changeMode", onChangeMode);
              onChangeMode(null, this);
            } else {
              this.commands.removeCommand(expandSnippet);
              this.off("changeMode", onChangeMode);
            }
          },
          value: false
        }
      });
    });
    (function() {
      ace.require(["ace/ext/language_tools"], function(m3) {
        if (module2) {
          module2.exports = m3;
        }
      });
    })();
  })(extLanguage_tools$2);
  return extLanguage_tools$2.exports;
}
var extLanguage_toolsExports = requireExtLanguage_tools();
const extLanguage_tools = /* @__PURE__ */ getDefaultExportFromCjs(extLanguage_toolsExports);
const extLanguage_tools$1 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: extLanguage_tools
}, [extLanguage_toolsExports]);
const contentStyles = css`

  /*ace_scrollbar.css*/
  .ace_editor > .ace_sb-v div, .ace_editor > .ace_sb-h div {
    position: absolute;
    background: rgba(128, 128, 128, 0.6);
    -moz-box-sizing: border-box;
    box-sizing: border-box;
    border: 1px solid #bbb;
    border-radius: 2px;
    z-index: 8;
  }

  .ace_editor > .ace_sb-v, .ace_editor > .ace_sb-h {
    position: absolute;
    z-index: 6;
    background: none;
    overflow: hidden !important;
  }

  .ace_editor > .ace_sb-v {
    z-index: 6;
    right: 0;
    top: 0;
    width: 12px;
  }

  .ace_editor > .ace_sb-v div {
    z-index: 8;
    right: 0;
    width: 100%;
  }

  .ace_editor > .ace_sb-h {
    bottom: 0;
    left: 0;
    height: 12px;
  }

  .ace_editor > .ace_sb-h div {
    bottom: 0;
    height: 100%;
  }

  .ace_editor > .ace_sb_grabbed {
    z-index: 8;
    background: #000;
  }

  /*ace_editor.css*/

  .ace_br1 {
    border-top-left-radius: 3px;
  }

  .ace_br2 {
    border-top-right-radius: 3px;
  }

  .ace_br3 {
    border-top-left-radius: 3px;
    border-top-right-radius: 3px;
  }

  .ace_br4 {
    border-bottom-right-radius: 3px;
  }

  .ace_br5 {
    border-top-left-radius: 3px;
    border-bottom-right-radius: 3px;
  }

  .ace_br6 {
    border-top-right-radius: 3px;
    border-bottom-right-radius: 3px;
  }

  .ace_br7 {
    border-top-left-radius: 3px;
    border-top-right-radius: 3px;
    border-bottom-right-radius: 3px;
  }

  .ace_br8 {
    border-bottom-left-radius: 3px;
  }

  .ace_br9 {
    border-top-left-radius: 3px;
    border-bottom-left-radius: 3px;
  }

  .ace_br10 {
    border-top-right-radius: 3px;
    border-bottom-left-radius: 3px;
  }

  .ace_br11 {
    border-top-left-radius: 3px;
    border-top-right-radius: 3px;
    border-bottom-left-radius: 3px;
  }

  .ace_br12 {
    border-bottom-right-radius: 3px;
    border-bottom-left-radius: 3px;
  }

  .ace_br13 {
    border-top-left-radius: 3px;
    border-bottom-right-radius: 3px;
    border-bottom-left-radius: 3px;
  }

  .ace_br14 {
    border-top-right-radius: 3px;
    border-bottom-right-radius: 3px;
    border-bottom-left-radius: 3px;
  }

  .ace_br15 {
    border-top-left-radius: 3px;
    border-top-right-radius: 3px;
    border-bottom-right-radius: 3px;
    border-bottom-left-radius: 3px;
  }

  .ace_editor {
    height: 100%;
    width: 100%;
    position: relative;
    overflow: hidden;
    padding:  0;
    font: 12px/normal 'Monaco', 'Menlo', 'Ubuntu Mono', 'Consolas', 'Source Code Pro', 'source-code-pro', monospace;
    direction: ltr;
    text-align: left;
    -webkit-tap-highlight-color: rgba(0, 0, 0, 0);
    border: 1px solid;
    border-radius: var(--lumo-border-radius-l);
    border-color: var(--lumo-contrast-20pct);
  }

  .ace_scroller {
    position: absolute;
    overflow: hidden;
    top: 0;
    bottom: 0;
    background-color: inherit;
    -ms-user-select: none;
    -moz-user-select: none;
    -webkit-user-select: none;
    user-select: none;
    cursor: text;
  }

  .ace_content {
    position: absolute;
    box-sizing: border-box;
    min-width: 100%;
    contain: style size layout;
    font-variant-ligatures: no-common-ligatures;
  }

  .ace_dragging .ace_scroller:before {
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    content: '';
    background: rgba(250, 250, 250, 0.01);
    z-index: 1000;
  }

  .ace_dragging.ace_dark .ace_scroller:before {
    background: rgba(0, 0, 0, 0.01);
  }

  .ace_gutter {
    position: absolute;
    overflow: hidden;
    width: auto;
    top: 0;
    bottom: 0;
    left: 0;
    cursor: default;
    z-index: 1;
    -ms-user-select: none;
    -moz-user-select: none;
    -webkit-user-select: none;
    user-select: none;
    contain: style size layout;
  }

  .ace_gutter-active-line {
    position: absolute;
    left: 0;
    right: 0;
  }

  .ace_scroller.ace_scroll-left:after {
    content: "";
    position: absolute;
    top: 0;
    right: 0;
    bottom: 0;
    left: 0;
    box-shadow: 17px 0 16px -16px rgba(0, 0, 0, 0.4) inset;
    pointer-events: none;
  }

  .ace_gutter-cell {
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    padding-left: 19px;
    padding-right: 6px;
    background-repeat: no-repeat;
  }

  .ace_gutter-cell.ace_error {
    background-image: url("./style/main-1.png");
    background-repeat: no-repeat;
    background-position: 2px center;
  }

  .ace_gutter-cell.ace_warning {
    background-image: url("./style/main-2.png");
    background-position: 2px center;
  }

  .ace_gutter-cell.ace_info {
    background-image: url("./style/main-3.png");
    background-position: 2px center;
  }

  .ace_dark .ace_gutter-cell.ace_info {
    background-image: url("./style/main-4.png");
  }

  .ace_scrollbar {
    contain: strict;
    position: absolute;
    right: 0;
    bottom: 0;
    z-index: 6;
  }

  .ace_scrollbar-inner {
    position: absolute;
    cursor: text;
    left: 0;
    top: 0;
  }

  .ace_scrollbar-v {
    overflow-x: hidden;
    overflow-y: scroll;
    top: 0;
  }

  .ace_scrollbar-h {
    overflow-x: scroll;
    overflow-y: hidden;
    left: 0;
  }

  .ace_print-margin {
    position: absolute;
    height: 100%;
  }

  .ace_text-input {
    position: absolute;
    z-index: 0;
    width: 0.5em;
    height: 1em;
    opacity: 0;
    background: transparent;
    -moz-appearance: none;
    appearance: none;
    border: none;
    resize: none;
    outline: none;
    overflow: hidden;
    font: inherit;
    padding: 0 1px;
    margin: 0 -1px;
    contain: strict;
    -ms-user-select: text;
    -moz-user-select: text;
    -webkit-user-select: text;
    user-select: text;
    /*with \`pre-line\` chrome inserts &nbsp; instead of space*/
    white-space: pre !important;
  }

  .ace_text-input.ace_composition {
    background: transparent;
    color: inherit;
    z-index: 1000;
    opacity: 1;
  }

  .ace_composition_placeholder {
    color: transparent
  }

  .ace_composition_marker {
    border-bottom: 1px solid;
    position: absolute;
    border-radius: 0;
    margin-top: 1px;
  }

  [ace_nocontext=true] {
    transform: none !important;
    filter: none !important;
    clip-path: none !important;
    mask: none !important;
    contain: none !important;
    perspective: none !important;
    mix-blend-mode: initial !important;
    z-index: auto;
  }

  .ace_layer {
    z-index: 1;
    position: absolute;
    overflow: hidden;
    /* workaround for chrome bug https://github.com/ajaxorg/ace/issues/2312*/
    word-wrap: normal;
    white-space: pre;
    height: 100%;
    width: 100%;
    box-sizing: border-box;
    /* setting pointer-events: auto; on node under the mouse, which changes
    during scroll, will break mouse wheel scrolling in Safari */
    pointer-events: none;
  }

  .ace_gutter-layer {
    position: relative;
    width: auto;
    text-align: right;
    pointer-events: auto;
    height: 1000000px;
    contain: style size layout;
  }

  .ace_text-layer {
    font: inherit !important;
    position: absolute;
    height: 1000000px;
    width: 1000000px;
    contain: style size layout;
  }

  .ace_text-layer > .ace_line, .ace_text-layer > .ace_line_group {
    contain: style size layout;
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
  }

  .ace_hidpi .ace_text-layer,
  .ace_hidpi .ace_gutter-layer,
  .ace_hidpi .ace_content,
  .ace_hidpi .ace_gutter {
    contain: strict;
    will-change: transform;
  }

  .ace_hidpi .ace_text-layer > .ace_line,
  .ace_hidpi .ace_text-layer > .ace_line_group {
    contain: strict;
  }

  .ace_cjk {
    display: inline-block;
    text-align: center;
  }

  .ace_cursor-layer {
    z-index: 4;
  }

  .ace_cursor {
    z-index: 4;
    position: absolute;
    box-sizing: border-box;
    border-left: 2px solid;
    /* workaround for smooth cursor repaintng whole screen in chrome */
    transform: translatez(0);
  }

  .ace_multiselect .ace_cursor {
    border-left-width: 1px;
  }

  .ace_slim-cursors .ace_cursor {
    border-left-width: 1px;
  }

  .ace_overwrite-cursors .ace_cursor {
    border-left-width: 0;
    border-bottom: 1px solid;
  }

  .ace_hidden-cursors .ace_cursor {
    opacity: 0.2;
  }

  .ace_hasPlaceholder .ace_hidden-cursors .ace_cursor {
    opacity: 0;
  }

  .ace_smooth-blinking .ace_cursor {
    transition: opacity 0.18s;
  }

  .ace_animate-blinking .ace_cursor {
    animation-duration: 1000ms;
    animation-timing-function: step-end;
    animation-name: blink-ace-animate;
    animation-iteration-count: infinite;
  }

  .ace_animate-blinking.ace_smooth-blinking .ace_cursor {
    animation-duration: 1000ms;
    animation-timing-function: ease-in-out;
    animation-name: blink-ace-animate-smooth;
  }

  @keyframes blink-ace-animate {
    from, to {
      opacity: 1;
    }
    60% {
      opacity: 0;
    }
  }

  @keyframes blink-ace-animate-smooth {
    from, to {
      opacity: 1;
    }
    45% {
      opacity: 1;
    }
    60% {
      opacity: 0;
    }
    85% {
      opacity: 0;
    }
  }

  .ace_marker-layer .ace_step, .ace_marker-layer .ace_stack {
    position: absolute;
    z-index: 3;
  }

  .ace_marker-layer .ace_selection {
    position: absolute;
    z-index: 5;
  }

  .ace_marker-layer .ace_bracket {
    position: absolute;
    z-index: 6;
  }

  .ace_marker-layer .ace_error_bracket {
    position: absolute;
    border-bottom: 1px solid #DE5555;
    border-radius: 0;
  }

  .ace_marker-layer .ace_active-line {
    position: absolute;
    z-index: 2;
  }

  .ace_marker-layer .ace_selected-word {
    position: absolute;
    z-index: 4;
    box-sizing: border-box;
  }

  .ace_line .ace_fold {
    box-sizing: border-box;
    display: inline-block;
    height: 11px;
    margin-top: -2px;
    vertical-align: middle;
    background-image: url("./style/main-5.png"),
    url("./style/main-6.png");
    background-repeat: no-repeat, repeat-x;
    background-position: center center, top left;
    color: transparent;
    border: 1px solid black;
    border-radius: 2px;
    cursor: pointer;
    pointer-events: auto;
  }

  .ace_dark .ace_fold {
  }

  .ace_fold:hover {
    background-image: url("./style/main-7.png"),
    url("./style/main-8.png");
  }

  .ace_tooltip {
    background-color: #f5f5f5;
    border: 1px solid gray;
    border-radius: 1px;
    box-shadow: 0 1px 2px rgba(0, 0, 0, 0.3);
    color: black;
    max-width: 100%;
    padding: 3px 4px;
    position: fixed;
    z-index: 999999;
    box-sizing: border-box;
    cursor: default;
    white-space: pre;
    word-wrap: break-word;
    line-height: normal;
    font-style: normal;
    font-weight: normal;
    letter-spacing: normal;
    pointer-events: none;
  }

  .ace_tooltip:focus {
    outline: 1px solid black;
  }

  .ace_folding-enabled > .ace_gutter-cell {
    padding-right: 13px;
  }

  .ace_fold-widget {
    box-sizing: border-box;
    margin: 0 -12px 0 1px;
    display: none;
    width: 11px;
    vertical-align: top;
    background-image: url("./style/main-9.png");
    background-repeat: no-repeat;
    background-position: center;
    border-radius: 3px;
    border: 1px solid transparent;
    cursor: pointer;
  }

  .ace_folding-enabled .ace_fold-widget {
    display: inline-block;
  }

  .ace_fold-widget.ace_end {
    background-image: url("./style/main-10.png");
  }

  .ace_fold-widget.ace_closed {
    background-image: url("./style/main-11.png");
  }

  .ace_fold-widget:hover {
    border: 1px solid rgba(0, 0, 0, 0.3);
    background-color: rgba(255, 255, 255, 0.2);
    box-shadow: 0 1px 1px rgba(255, 255, 255, 0.7);
  }

  .ace_fold-widget:active {
    border: 1px solid rgba(0, 0, 0, 0.4);
    background-color: rgba(0, 0, 0, 0.05);
    box-shadow: 0 1px 1px rgba(255, 255, 255, 0.8);
  }

  /**
  * Dark version for fold widgets
  */

  .ace_dark .ace_fold-widget {
    background-image: url("./style/main-12.png");
  }

  .ace_dark .ace_fold-widget.ace_end {
    background-image: url("./style/main-13.png");
  }

  .ace_dark .ace_fold-widget.ace_closed {
    background-image: url("./style/main-14.png");
  }

  .ace_dark .ace_fold-widget:hover {
    box-shadow: 0 1px 1px rgba(255, 255, 255, 0.2);
    background-color: rgba(255, 255, 255, 0.1);
  }

  .ace_dark .ace_fold-widget:active {
    box-shadow: 0 1px 1px rgba(255, 255, 255, 0.2);
  }

  .ace_inline_button {
    border: 1px solid lightgray;
    display: inline-block;
    margin: -1px 8px;
    padding: 0 5px;
    pointer-events: auto;
    cursor: pointer;
  }

  .ace_inline_button:hover {
    border-color: gray;
    background: rgba(200, 200, 200, 0.2);
    display: inline-block;
    pointer-events: auto;
  }

  .ace_fold-widget.ace_invalid {
    background-color: #FFB4B4;
    border-color: #DE5555;
  }

  .ace_fade-fold-widgets .ace_fold-widget {
    transition: opacity 0.4s ease 0.05s;
    opacity: 0;
  }

  .ace_fade-fold-widgets:hover .ace_fold-widget {
    transition: opacity 0.05s ease 0.05s;
    opacity: 1;
  }

  .ace_underline {
    text-decoration: underline;
  }

  .ace_bold {
    font-weight: bold;
  }

  .ace_nobold .ace_bold {
    font-weight: normal;
  }

  .ace_italic {
    font-style: italic;
  }

  .ace_error-marker {
    background-color: rgba(255, 0, 0, 0.2);
    position: absolute;
    z-index: 9;
  }

  .ace_highlight-marker {
    background-color: rgba(255, 255, 0, 0.2);
    position: absolute;
    z-index: 8;
  }

  .ace_mobile-menu {
    position: absolute;
    line-height: 1.5;
    border-radius: 4px;
    -ms-user-select: none;
    -moz-user-select: none;
    -webkit-user-select: none;
    user-select: none;
    background: white;
    box-shadow: 1px 3px 2px grey;
    border: 1px solid #dcdcdc;
    color: black;
  }

  .ace_dark > .ace_mobile-menu {
    background: #333;
    color: #ccc;
    box-shadow: 1px 3px 2px grey;
    border: 1px solid #444;
  }

  .ace_mobile-button {
    padding: 2px;
    cursor: pointer;
    overflow: hidden;
  }

  .ace_mobile-button:hover {
    background-color: #eee;
    opacity: 1;
  }

  .ace_mobile-button:active {
    background-color: #ddd;
  }

  .ace_placeholder {
    font-family: arial;
    transform: scale(0.9);
    transform-origin: left;
    white-space: pre;
    opacity: 0.7;
    margin: 0 10px;
  }

  .ace_ghost_text {
    opacity: 0.5;
    font-style: italic;
    white-space: pre;
  }

  /*ace-tm*/

  .ace-tm .ace_gutter {
    background: #f0f0f0;
    color: #333;
  }

  .ace-tm .ace_print-margin {
    width: 1px;
    background: #e8e8e8;
  }

  .ace-tm .ace_fold {
    background-color: #6B72E6;
  }

  .ace-tm {
    background-color: #FFFFFF;
    color: black;
  }

  .ace-tm .ace_cursor {
    color: black;
  }

  .ace-tm .ace_invisible {
    color: rgb(191, 191, 191);
  }

  .ace-tm .ace_storage,
  .ace-tm .ace_keyword {
    color: blue;
  }

  .ace-tm .ace_constant {
    color: rgb(197, 6, 11);
  }

  .ace-tm .ace_constant.ace_buildin {
    color: rgb(88, 72, 246);
  }

  .ace-tm .ace_constant.ace_language {
    color: rgb(88, 92, 246);
  }

  .ace-tm .ace_constant.ace_library {
    color: rgb(6, 150, 14);
  }

  .ace-tm .ace_invalid {
    background-color: rgba(255, 0, 0, 0.1);
    color: red;
  }

  .ace-tm .ace_support.ace_function {
    color: rgb(60, 76, 114);
  }

  .ace-tm .ace_support.ace_constant {
    color: rgb(6, 150, 14);
  }

  .ace-tm .ace_support.ace_type,
  .ace-tm .ace_support.ace_class {
    color: rgb(109, 121, 222);
  }

  .ace-tm .ace_keyword.ace_operator {
    color: rgb(104, 118, 135);
  }

  .ace-tm .ace_string {
    color: rgb(3, 106, 7);
  }

  .ace-tm .ace_comment {
    color: rgb(76, 136, 107);
  }

  .ace-tm .ace_comment.ace_doc {
    color: rgb(0, 102, 255);
  }

  .ace-tm .ace_comment.ace_doc.ace_tag {
    color: rgb(128, 159, 191);
  }

  .ace-tm .ace_constant.ace_numeric {
    color: rgb(0, 0, 205);
  }

  .ace-tm .ace_variable {
    color: rgb(49, 132, 149);
  }

  .ace-tm .ace_xml-pe {
    color: rgb(104, 104, 91);
  }

  .ace-tm .ace_entity.ace_name.ace_function {
    color: #0000A2;
  }

  .ace-tm .ace_heading {
    color: rgb(12, 7, 255);
  }

  .ace-tm .ace_list {
    color: rgb(185, 6, 144);
  }

  .ace-tm .ace_meta.ace_tag {
    color: rgb(0, 22, 142);
  }

  .ace-tm .ace_string.ace_regex {
    color: rgb(255, 0, 0)
  }

  .ace-tm .ace_marker-layer .ace_selection {
    background: rgb(181, 213, 255);
  }

  .ace-tm.ace_multiselect .ace_selection.ace_start {
    box-shadow: 0 0 3px 0px white;
  }

  .ace-tm .ace_marker-layer .ace_step {
    background: rgb(252, 255, 0);
  }

  .ace-tm .ace_marker-layer .ace_stack {
    background: rgb(164, 229, 101);
  }

  .ace-tm .ace_marker-layer .ace_bracket {
    margin: -1px 0 0 -1px;
    border: 1px solid rgb(192, 192, 192);
  }

  .ace-tm .ace_marker-layer .ace_active-line {
    background: rgba(0, 0, 0, 0.07);
  }

  .ace-tm .ace_gutter-active-line {
    background-color: #dcdcdc;
  }

  .ace-tm .ace_marker-layer .ace_selected-word {
    background: rgb(250, 250, 255);
    border: 1px solid rgb(200, 200, 250);
  }

  .ace-tm .ace_indent-guide {
    background: url("./style/main-15.png") right repeat-y;
  }

  .ace-tm .ace_indent-guide-active {
    background: url("./style/main-16.png") right repeat-y;
  }

  /*error_marker.css*/

  .error_widget_wrapper {
    background: inherit;
    color: inherit;
    border: none
  }

  .error_widget {
    border-top: solid 2px;
    border-bottom: solid 2px;
    margin: 5px 0;
    padding: 10px 40px;
    white-space: pre-wrap;
  }

  .error_widget.ace_error, .error_widget_arrow.ace_error {
    border-color: #ff5a5a
  }

  .error_widget.ace_warning, .error_widget_arrow.ace_warning {
    border-color: #F1D817
  }

  .error_widget.ace_info, .error_widget_arrow.ace_info {
    border-color: #5a5a5a
  }

  .error_widget.ace_ok, .error_widget_arrow.ace_ok {
    border-color: #5aaa5a
  }

  .error_widget_arrow {
    position: absolute;
    border: solid 5px;
    border-top-color: transparent !important;
    border-right-color: transparent !important;
    border-left-color: transparent !important;
    top: -5px;
  }

  /*codelense.css*/

  .ace_codeLens {
    position: absolute;
    color: #aaa;
    font-size: 88%;
    background: inherit;
    width: 100%;
    display: flex;
    align-items: flex-end;
    pointer-events: none;
  }

  .ace_codeLens > a {
    cursor: pointer;
    pointer-events: auto;
  }

  .ace_codeLens > a:hover {
    color: #0000ff;
    text-decoration: underline;
  }

  .ace_dark > .ace_codeLens > a:hover {
    color: #4e94ce;
  }

  /*snippets.css*/

  .ace_snippet-marker {
    -moz-box-sizing: border-box;
    box-sizing: border-box;
    background: rgba(194, 193, 208, 0.09);
    border: 1px dotted rgba(211, 208, 235, 0.62);
    position: absolute;
  }

  /*autocompletion.css*/

  .ace_editor.ace_autocomplete .ace_marker-layer .ace_active-line {
    background-color: #CAD6FA;
    z-index: 1;
  }

  .ace_dark.ace_editor.ace_autocomplete .ace_marker-layer .ace_active-line {
    background-color: #3a674e;
  }

  .ace_editor.ace_autocomplete .ace_line-hover {
    border: 1px solid #abbffe;
    margin-top: -1px;
    background: rgba(233, 233, 253, 0.4);
    position: absolute;
    z-index: 2;
  }

  .ace_dark.ace_editor.ace_autocomplete .ace_line-hover {
    border: 1px solid rgba(109, 150, 13, 0.8);
    background: rgba(58, 103, 78, 0.62);
  }

  .ace_completion-meta {
    opacity: 0.5;
    margin: 0 0.9em;
  }

  .ace_completion-message {
    color: blue;
  }

  .ace_editor.ace_autocomplete .ace_completion-highlight {
    color: #2d69c7;
  }

  .ace_dark.ace_editor.ace_autocomplete .ace_completion-highlight {
    color: #93ca12;
  }

  .ace_editor.ace_autocomplete {
    width: 300px;
    z-index: 200000;
    border: 1px lightgray solid;
    position: fixed;
    box-shadow: 2px 3px 5px rgba(0, 0, 0, .2);
    line-height: 1.4;
    background: #fefefe;
    color: #111;
  }

  .ace_dark.ace_editor.ace_autocomplete {
    border: 1px #484747 solid;
    box-shadow: 2px 3px 5px rgba(0, 0, 0, 0.51);
    line-height: 1.4;
    background: #25282c;
    color: #c1c1c1;
  }

  .ace_autocomplete_right .ace_text-layer {
    width: calc(100% - 8px);
  }

  .ace_autocomplete_right .ace_line {
    display: flex;
  }

  .ace_autocomplete_right .ace_completion-meta {
    flex: 1;
    text-align: right;
  }

  /*inlinetooltip.css*/

  .ace_inline_autocomplete_tooltip {
    display: inline-block;
  }

  .inline_autocomplete_tooltip_entry {
    display: inline-block;
    padding: 0 5px;
  }

  .inline_autocomplete_tooltip_button {
    display: inline-block;
    cursor: pointer;
    padding: 5px;
  }

  .inline_autocomplete_tooltip_button:hover {
    background-color: rgba(0, 0, 0, 0.1);
  }

  div.inline_autocomplete_tooltip_button_disabled {
    display: inline-block;
    padding: 5px;
    cursor: default;
    color: #777;
  }

  /*settings_menu.css*/

  #ace_settingsmenu, #kbshortcutmenu {
    background-color: #F7F7F7;
    color: black;
    box-shadow: -5px 4px 5px rgba(126, 126, 126, 0.55);
    padding: 1em 0.5em 2em 1em;
    overflow: auto;
    position: absolute;
    margin: 0;
    bottom: 0;
    right: 0;
    top: 0;
    z-index: 9991;
    cursor: default;
  }

  .ace_dark #ace_settingsmenu, .ace_dark #kbshortcutmenu {
    box-shadow: -20px 10px 25px rgba(126, 126, 126, 0.25);
    background-color: rgba(255, 255, 255, 0.6);
    color: black;
  }

  .ace_optionsMenuEntry:hover {
    background-color: rgba(100, 100, 100, 0.1);
    transition: all 0.3s
  }

  .ace_closeButton {
    background: rgba(245, 146, 146, 0.5);
    border: 1px solid #F48A8A;
    border-radius: 50%;
    padding: 7px;
    position: absolute;
    right: -8px;
    top: -8px;
    z-index: 100000;
  }

  .ace_closeButton {
    background: rgba(245, 146, 146, 0.9);
  }

  .ace_optionsMenuKey {
    color: darkslateblue;
    font-weight: bold;
  }

  .ace_optionsMenuCommand {
    color: darkcyan;
    font-weight: normal;
  }

  .ace_optionsMenuEntry input, .ace_optionsMenuEntry button {
    vertical-align: middle;
  }

  .ace_optionsMenuEntry button[ace_selected_button=true] {
    background: #e7e7e7;
    box-shadow: 1px 0px 2px 0px #adadad inset;
    border-color: #adadad;
  }

  .ace_optionsMenuEntry button {
    background: white;
    border: 1px solid lightgray;
    margin: 0px;
  }

  .ace_optionsMenuEntry button:hover {
    background: #f0f0f0;
  }

  /*promtp.css*/

  .ace_prompt_container {
    max-width: 603px;
    width: 100%;
    margin: 20px auto;
    padding: 3px;
    background: white;
    border-radius: 2px;
    box-shadow: 0px 2px 3px 0px #555;
  }

  /*ace_searchbox*/
  /* ------------------------------------------------------------------------------------------
  * Editor Search Form
  * --------------------------------------------------------------------------------------- */

  .ace_search {
    background-color: #ddd;
    color: #666;
    border: 1px solid #cbcbcb;
    border-top: 0 none;
    overflow: hidden;
    margin: 0;
    padding: 4px 6px 0 4px;
    position: absolute;
    top: 0;
    z-index: 99;
    white-space: normal;
  }

  .ace_search.left {
    border-left: 0 none;
    border-radius: 0px 0px 5px 0px;
    left: 0;
  }

  .ace_search.right {
    border-radius: 0px 0px 0px 5px;
    border-right: 0 none;
    right: 0;
  }

  .ace_search_form, .ace_replace_form {
    margin: 0 20px 4px 0;
    overflow: hidden;
    line-height: 1.9;
  }

  .ace_replace_form {
    margin-right: 0;
  }

  .ace_search_form.ace_nomatch {
    outline: 1px solid red;
  }

  .ace_search_field {
    border-radius: 3px 0 0 3px;
    background-color: white;
    color: black;
    border: 1px solid #cbcbcb;
    border-right: 0 none;
    outline: 0;
    padding: 0;
    font-size: inherit;
    margin: 0;
    line-height: inherit;
    padding: 0 6px;
    min-width: 17em;
    vertical-align: top;
    min-height: 1.8em;
    box-sizing: content-box;
  }

  .ace_searchbtn {
    border: 1px solid #cbcbcb;
    line-height: inherit;
    display: inline-block;
    padding: 0 6px;
    background: #fff;
    border-right: 0 none;
    border-left: 1px solid #dcdcdc;
    cursor: pointer;
    margin: 0;
    position: relative;
    color: #666;
  }

  .ace_searchbtn:last-child {
    border-radius: 0 3px 3px 0;
    border-right: 1px solid #cbcbcb;
  }

  .ace_searchbtn:disabled {
    background: none;
    cursor: default;
  }

  .ace_searchbtn:hover {
    background-color: #eef1f6;
  }

  .ace_searchbtn.prev, .ace_searchbtn.next {
    padding: 0px 0.7em
  }

  .ace_searchbtn.prev:after, .ace_searchbtn.next:after {
    content: "";
    border: solid 2px #888;
    width: 0.5em;
    height: 0.5em;
    border-width: 2px 0 0 2px;
    display: inline-block;
    transform: rotate(-45deg);
  }

  .ace_searchbtn.next:after {
    border-width: 0 2px 2px 0;
  }

  .ace_searchbtn_close {
    background: url("./style/main-17.png") no-repeat 50% 0;
    border-radius: 50%;
    border: 0 none;
    color: #656565;
    cursor: pointer;
    font: 16px/16px Arial;
    padding: 0;
    height: 14px;
    width: 14px;
    top: 9px;
    right: 7px;
    position: absolute;
  }

  .ace_searchbtn_close:hover {
    background-color: #656565;
    background-position: 50% 100%;
    color: white;
  }

  .ace_button {
    margin-left: 2px;
    cursor: pointer;
    -webkit-user-select: none;
    -moz-user-select: none;
    -o-user-select: none;
    -ms-user-select: none;
    user-select: none;
    overflow: hidden;
    opacity: 0.7;
    border: 1px solid rgba(100, 100, 100, 0.23);
    padding: 1px;
    box-sizing: border-box !important;
    color: black;
  }

  .ace_button:hover {
    background-color: #eee;
    opacity: 1;
  }

  .ace_button:active {
    background-color: #ddd;
  }

  .ace_button.checked {
    border-color: #3399ff;
    opacity: 1;
  }

  .ace_search_options {
    margin-bottom: 3px;
    text-align: right;
    -webkit-user-select: none;
    -moz-user-select: none;
    -o-user-select: none;
    -ms-user-select: none;
    user-select: none;
    clear: both;
  }

  .ace_search_counter {
    float: left;
    font-family: arial;
    padding: 0 8px;
  }

  /*incremental-occur-highlighting*/

  .ace_occur-highlight {
    border-radius: 4px;
    background-color: rgba(87, 255, 8, 0.25);
    position: absolute;
    z-index: 4;
    box-sizing: border-box;
    box-shadow: 0 0 4px rgb(91, 255, 50);
  }

  .ace_dark .ace_occur-highlight {
    background-color: rgb(80, 140, 85);
    box-shadow: 0 0 4px rgb(60, 120, 70);
  }

  /*incremental-search-highlighting*/

  .ace_marker-layer .ace_isearch-result {
    position: absolute;
    z-index: 6;
    box-sizing: border-box;
  }

  div.ace_isearch-result {
    border-radius: 4px;
    background-color: rgba(255, 200, 0, 0.5);
    box-shadow: 0 0 4px rgb(255, 200, 0);
  }

  .ace_dark div.ace_isearch-result {
    background-color: rgb(100, 110, 160);
    box-shadow: 0 0 4px rgb(80, 90, 140);
  }

  /*emacsMode*/

  .emacs-mode .ace_cursor {
    border: 1px rgba(50, 250, 50, 0.8) solid !important;
    box-sizing: border-box !important;
    background-color: rgba(0, 250, 0, 0.9);
    opacity: 0.5;
  }

  .emacs-mode .ace_hidden-cursors .ace_cursor {
    opacity: 1;
    background-color: transparent;
  }

  .emacs-mode .ace_overwrite-cursors .ace_cursor {
    opacity: 1;
    background-color: transparent;
    border-width: 0 0 2px 2px !important;
  }

  .emacs-mode .ace_text-layer {
    z-index: 4
  }

  .emacs-mode .ace_cursor-layer {
    z-index: 2
  }

  /*vimMode*/

  .normal-mode .ace_cursor {
    border: none;
    background-color: rgba(255, 0, 0, 0.5);
  }

  .normal-mode .ace_hidden-cursors .ace_cursor {
    background-color: transparent;
    border: 1px solid red;
    opacity: 0.7
  }

  .ace_dialog {
    position: absolute;
    left: 0;
    right: 0;
    background: inherit;
    z-index: 15;
    padding: .1em .8em;
    overflow: hidden;
    color: inherit;
  }

  .ace_dialog-top {
    border-bottom: 1px solid #444;
    top: 0;
  }

  .ace_dialog-bottom {
    border-top: 1px solid #444;
    bottom: 0;
  }

  .ace_dialog input {
    border: none;
    outline: none;
    background: transparent;
    width: 20em;
    color: inherit;
    font-family: monospace;
  }
`;
registerStyles$1("", contentStyles, { moduleId: "jmix-code-editor-content-styles" });
const statesStyles = css`

  :host {
    width: 50em;
    height: 20em;
  }

  .jmix-code-editor-container {
    height: 100%;
  }
`;
const jmixCodeEditorStyles = [contentStyles, statesStyles];
registerStyles$1("jmix-code-editor", [inputFieldShared, jmixCodeEditorStyles], { moduleId: "jmix-code-editor-styles" });
class JmixCodeEditor extends ResizeMixin(InputFieldMixin(ThemableMixin(ElementMixin(PolymerElement)))) {
  static get is() {
    return "jmix-code-editor";
  }
  static get template() {
    return html`
            <div class="jmix-code-editor-container">
                <div part="label">
                    <slot name="label"></slot>
                    <span part="required-indicator" aria-hidden="true"></span>
                </div>

                <div part="input-field"
                     readonly="[[readonly]]"
                     disabled="[[disabled]]"
                     invalid="[[invalid]]"></div>

                <div part="helper-text">
                    <slot name="helper"></slot>
                </div>

                <div part="error-message">
                    <slot name="error-message"></slot>
                </div>
            </div>

            <slot name="tooltip"></slot>
        `;
  }
  static get properties() {
    return {
      theme: {
        type: String,
        observer: "_onThemeChange",
        notify: true
      },
      mode: {
        type: String,
        value: "plain_text",
        observer: "_onModeChange"
      },
      highlightActiveLine: {
        type: Boolean,
        value: true,
        observer: "_onHighlightActiveLineChange"
      },
      highlightGutterLine: {
        type: Boolean,
        value: true,
        observer: "_onHighlightGutterLineChange"
      },
      showGutter: {
        type: Boolean,
        value: true,
        observer: "_onShowGutterChange"
      },
      showLineNumbers: {
        type: Boolean,
        value: true,
        observer: "_onShowLineNumbersChange"
      },
      showPrintMargin: {
        type: Boolean,
        value: true,
        observer: "_onShowPrintMarginChange"
      },
      printMarginColumn: {
        type: Number,
        value: 80,
        observer: "_onPrintMarginColumnChange"
      },
      value: {
        type: String,
        observer: "_onValueChange"
      },
      fontSize: {
        type: String,
        value: "1rem",
        observer: "_onFontSizeChange"
      },
      textWrap: {
        type: Boolean,
        value: false,
        observer: "_onTextWrapChange"
      },
      useSoftTabs: {
        type: Boolean,
        value: true,
        observer: "_onUseSoftTabsChange"
      },
      defaultSuggestionsEnabled: {
        type: Boolean,
        value: false,
        observer: "_onDefaultSuggestionsEnabledChange"
      },
      liveSuggestionsEnabled: {
        type: Boolean,
        value: false,
        observer: "_onLiveSuggestionsEnabledChange"
      },
      /**
       * Regular expression pattern for suggesting from server.
       */
      suggestOn: String,
      /**
       * Regular expression dependent on #suggestOn property.
       */
      suggestOnRegExp: {
        type: Object,
        computed: "_computeSuggestOnRegExp(suggestOn)"
      },
      /**
       * Flag for tracking the presence of a suggester on the server side.
       * Required to avoid unnecessary client-server interaction.
       */
      serverSuggesterSet: {
        type: Boolean,
        value: false,
        observer: "_onServerSuggesterSetChange"
      },
      /** @private */
      _editor: Object
    };
  }
  static get observers() {
    return ["_disabledChanged(disabled, readonly, _editor)"];
  }
  /** @protected */
  ready() {
    super.ready();
    const editor = this.shadowRoot.querySelector('[part="input-field"]');
    if (this.theme === void 0) {
      this.initApplicationThemeObserver();
    }
    this._editor = ace.edit(editor, {
      theme: "ace/theme/" + this.theme,
      mode: "ace/mode/" + this.mode,
      highlightActiveLine: this.highlightActiveLine,
      highlightGutterLine: this.highlightGutterLine,
      showGutter: this.showGutter,
      showLineNumbers: this.showLineNumbers,
      showPrintMargin: this.showPrintMargin,
      printMarginColumn: this.printMarginColumn,
      value: this.value,
      fontSize: this.fontSize,
      wrap: this.textWrap,
      useSoftTabs: this.useSoftTabs,
      enableBasicAutocompletion: true,
      enableLiveAutocompletion: this.liveSuggestionsEnabled,
      useWorker: false
    });
    this._tooltipController = new TooltipController(this);
    this._tooltipController.setPosition("top");
    this._tooltipController.setAriaTarget(this._editor);
    this.addController(this._tooltipController);
    this._editor.on("blur", () => {
      this.value = this._editor.getValue();
      const customEvent = new CustomEvent("value-changed", { detail: { value: this._editor.getValue() } });
      this.dispatchEvent(customEvent);
      this._setFocused(false);
    });
    this.addEventListener("focus", (e2) => {
      this._setFocused(true);
    });
    this._setFocusElement(this._editor.textInput.getElement());
    this.initSuggestionListeners();
    this.updateSuggestions();
  }
  initApplicationThemeObserver() {
    this._applyTheme();
    this._applicationThemeObserver = new MutationObserver((mutations) => {
      if (mutations.filter((mutation) => mutation.type === "attributes" && mutation.attributeName === "theme").length !== 0) {
        this._applyTheme();
      }
    });
    this._applicationThemeObserver.observe(document.documentElement, {
      attributes: true
    });
  }
  /**
   * Initializes the required listeners and values for suggestion mechanism to work.
   */
  initSuggestionListeners() {
    this._cursorPosition = 0;
    this._editor.session.selection.on("changeCursor", (e2) => {
      this._internalValue = this._editor.getValue();
      const cursor = this._editor.selection.getCursor();
      this._cursorPosition = this._calculateAbsoluteCursorPosition(this._internalValue, cursor);
      if (this._autocompleteRequested) {
        this._autocompleteRequested = false;
        this._editor.execCommand("startAutocomplete");
      }
    });
    this._editor.session.on("change", (e2) => {
      if (this.suggestOnRegExp && this._editor.getValue() && this.suggestOnRegExp.test(this._editor.getValue().substring(0, this._cursorPosition + 1))) {
        this._autocompleteRequested = true;
      }
    });
  }
  /**
   * Updates the list of auto-completions depending on the current state of the editor.
   */
  updateSuggestions() {
    const suggesters = this.defaultSuggestionsEnabled ? [extLanguage_toolsExports.textCompleter, extLanguage_toolsExports.keyWordCompleter, extLanguage_toolsExports.snippetCompleter] : [];
    if (this.serverSuggesterSet) {
      suggesters.push(this._getServerSuggester());
    }
    this._editor.completers = suggesters;
  }
  /**
   * @returns suggester object that requests autocompletes from the server-side
   * @private
   */
  _getServerSuggester() {
    return {
      $server: this.$server,
      getValue: () => this._internalValue,
      getCursorPosition: () => this._cursorPosition,
      getCompletions: function(editor, session, pos, prefix, callback) {
        this.$server.getSuggestions(this.getValue() ?? "", this.getCursorPosition(), prefix).then((suggestions) => {
          suggestions = suggestions.map(this.suggestionMapper);
          callback(null, suggestions);
        });
      },
      suggestionMapper: function(suggestion) {
        return {
          caption: suggestion.displayText,
          value: suggestion.suggestionText,
          meta: suggestion.descriptionText
        };
      }
    };
  }
  /**
   * @protected
   */
  _applyTheme() {
    const currentTheme = this._getCurrentApplicationTheme();
    this.theme = currentTheme === "dark" ? "nord_dark" : "textmate";
  }
  /**
   * @protected
   */
  _getCurrentApplicationTheme() {
    return document.documentElement.getAttribute("theme");
  }
  /**
   * @protected
   */
  _disabledChanged(disabled, readonly, editor) {
    if (disabled === void 0 || readonly === void 0 || editor === void 0) {
      return;
    }
    editor.setReadOnly(disabled || readonly);
    if (!disabled && !readonly) {
      editor.textInput.getElement().removeAttribute("disabled");
    }
    this._editor.setHighlightActiveLine(this.highlightActiveLine && !readonly);
    this._editor.setHighlightGutterLine(this.highlightGutterLine && !readonly);
    this._editor.renderer.$cursorLayer.element.style.opacity = readonly ? 0 : 1;
  }
  /**
   * @protected
   * @override
   */
  _onResize() {
    this._editor.resize();
  }
  /**
   * @protected
   */
  _onModeChange(mode) {
    if (this._editor === void 0) {
      return;
    }
    this._editor.session.setMode("ace/mode/" + mode);
  }
  /**
   * @protected
   */
  _onThemeChange(theme) {
    if (this._editor === void 0) {
      return;
    }
    this._editor.setTheme("ace/theme/" + theme);
  }
  /**
   * @protected
   */
  _onHighlightActiveLineChange(showActiveLine) {
    if (this._editor === void 0) {
      return;
    }
    this._editor.setHighlightActiveLine(showActiveLine);
  }
  /**
   * @protected
   */
  _onHighlightGutterLineChange(showGutterLine) {
    if (this._editor === void 0) {
      return;
    }
    this._editor.setHighlightGutterLine(showGutterLine);
  }
  /**
   * @protected
   */
  _onShowGutterChange(showGutter) {
    if (this._editor === void 0) {
      return;
    }
    this._editor.setOption("showGutter", showGutter);
  }
  /**
   * @protected
   */
  _onShowLineNumbersChange(showLineNumbers) {
    if (this._editor === void 0) {
      return;
    }
    this._editor.setOption("showLineNumbers", showLineNumbers);
  }
  /**
   * @protected
   */
  _onShowPrintMarginChange(showPrintMargin) {
    if (this._editor === void 0) {
      return;
    }
    this._editor.setShowPrintMargin(showPrintMargin);
  }
  /**
   * @protected
   */
  _onValueChange(value) {
    if (this._editor === void 0) {
      return;
    }
    this._editor.session.setValue(value);
  }
  /**
   * @protected
   */
  _onFontSizeChange(fontSize) {
    if (this._editor === void 0) {
      return;
    }
    this._editor.setFontSize(fontSize);
  }
  /**
   * @private
   */
  _onTextWrapChange(textWrap) {
    if (this._editor === void 0) {
      return;
    }
    this._editor.session.setUseWrapMode(textWrap);
  }
  /**
   * @private
   */
  _onUseSoftTabsChange(useSoftTabs) {
    if (this._editor === void 0) {
      return;
    }
    this._editor.session.setUseSoftTabs(useSoftTabs);
  }
  /**
   * @private
   */
  _onDefaultSuggestionsEnabledChange() {
    if (this._editor === void 0) {
      return;
    }
    this.updateSuggestions();
  }
  /**
   * @private
   */
  _onLiveSuggestionsEnabledChange(liveSuggestionsEnabled) {
    if (this._editor === void 0) {
      return;
    }
    this._editor.setOption("enableLiveAutocompletion", liveSuggestionsEnabled);
  }
  /**
   * @private
   */
  _computeSuggestOnRegExp(suggestOn) {
    return new RegExp(suggestOn + "$");
  }
  /**
   * @private
   */
  _onServerSuggesterSetChange(serverSuggesterSet) {
    if (this._editor === void 0) {
      return;
    }
    this.updateSuggestions();
  }
  /**
   * @protected
   */
  _onPrintMarginColumnChange(printMarginColumn) {
    if (this._editor === void 0) {
      return;
    }
    this._editor.setPrintMarginColumn(printMarginColumn);
  }
  /**
   * Calculates the absolute value of the cursor position, taking into account all entered rows and columns.
   *
   * @return absolute cursor position index
   * @private
   */
  _calculateAbsoluteCursorPosition(value, cursor) {
    const lines = value.split("\n", -1);
    let currentLine = 0;
    let pos = 0;
    while (currentLine < cursor.row) {
      pos += lines[currentLine].length + 1;
      ++currentLine;
    }
    pos += cursor.column;
    return pos;
  }
  get clearElement() {
    return null;
  }
}
defineCustomElement(JmixCodeEditor);
const entityComboBox = css`
  [part="action-part"] ::slotted(*) {
    gap: var(--lumo-space-xs);
    margin-left: var(--lumo-space-xs);
  }
  
  :host([has-actions]) [part="input-field"] {
    padding-right: var(--lumo-space-xs);
  }
`;
registerStyles$1("jmix-combo-box-picker", entityComboBox, {
  moduleId: "lumo-combo-box-picker-styles"
});
registerStyles$1("jmix-combo-box-picker", [], {
  moduleId: "jmix-combo-box-picker-styles"
});
class JmixComboBoxPicker extends ComboBox {
  static get is() {
    return "jmix-combo-box-picker";
  }
  static get template() {
    return html`
            <style>
                [part="action-part"] ::slotted(*) {
                    display: flex;
                }

                :host([readonly]) [part="action-part"] {
                    display: none;
                }

                :host([opened]) {
                    pointer-events: auto;
                }
            </style>

            <div class="value-picker-container">
                <div part="label">
                    <slot name="label"></slot>
                    <span part="required-indicator" aria-hidden="true" on-click="focus"></span>
                </div>

                <vaadin-input-container
                        part="input-field"
                        readonly="[[readonly]]"
                        disabled="[[disabled]]"
                        invalid="[[invalid]]"
                        theme$="[[_theme]]"
                >
                    <slot name="prefix" slot="prefix"></slot>
                    <slot name="input"></slot>
                    <div id="toggleButton" part="toggle-button" slot="suffix" aria-hidden="true"></div>
                    <!-- Jmix API -->
                    <div id="pickerAction" part="action-part" slot="suffix">
                        <slot name="actions"></slot>
                    </div>
                </vaadin-input-container>

                <div part="helper-text">
                    <slot name="helper"></slot>
                </div>

                <div part="error-message">
                    <slot name="error-message"></slot>
                </div>
            </div>

            <vaadin-combo-box-overlay
                    id="overlay"
                    opened="[[_overlayOpened]]"
                    loading$="[[loading]]"
                    theme$="[[_theme]]"
                    position-target="[[_positionTarget]]"
                    no-vertical-overlap
            ></vaadin-combo-box-overlay>

            <slot name="tooltip"></slot>
        `;
  }
  /**
   * Used by `ClearButtonMixin` as a reference to the clear button element.
   * @protected
   * @return {!HTMLElement}
   */
  get clearElement() {
    return null;
  }
}
defineCustomElement(JmixComboBoxPicker);
const loginForm = css`
  .jmix-login-form-additional-fields-container {
    display: flex;
    gap: var(--lumo-space-s);
    justify-content: end;
    padding-top: var(--lumo-space-m);
  }
  
  .jmix-login-form-remember-me {
    align-self: center;
    flex-grow: 1;
  }
  
  .jmix-login-form-locales-select {
    width: var(--jmix-login-form-locales-select-width, 8em);
  }
  
  vaadin-select.jmix-login-form-locales-select vaadin-select-value-button {
    width: 0;
  }
`;
registerStyles$1("jmix-login-form", [loginForm], {
  moduleId: "lumo-jmix-login-form-styles"
});
class JmixLoginForm extends LoginForm {
  static get template() {
    return html`
            <style>
                vaadin-login-form-wrapper > form > * {
                    width: 100%;
                }
            </style>
            <vaadin-login-form-wrapper
              id="vaadinLoginFormWrapper"
              theme$="[[_theme]]"
              error="[[error]]"
              i18n="[[i18n]]"
              heading-level="[[headingLevel]]"
            >
                <form method="POST" action$="[[action]]" on-formdata="_onFormData" slot="form">
                    <input id="csrf" type="hidden"/>
                    <vaadin-text-field
                            name="username"
                            label="[[i18n.form.username]]"
                            error-message="[[i18n.errorMessage.username]]"
                            id="vaadinLoginUsername"
                            required
                            on-keydown="_handleInputKeydown"
                            autocapitalize="none"
                            autocorrect="off"
                            spellcheck="false"
                            autocomplete="username"
                            value="[[username]]"
                            manual-validation
                    >
                        <input type="text" slot="input" on-keyup="_handleInputKeyup"/>
                    </vaadin-text-field>

                    <vaadin-password-field
                            name="password"
                            label="[[i18n.form.password]]"
                            error-message="[[i18n.errorMessage.password]]"
                            id="vaadinLoginPassword"
                            required
                            on-keydown="_handleInputKeydown"
                            spellcheck="false"
                            autocomplete="current-password"
                            value="[[password]]"
                            manual-validation
                    >
                        <input type="password" slot="input" on-keyup="_handleInputKeyup"/>
                    </vaadin-password-field>

                    <div id="additionalFields" class="jmix-login-form-additional-fields-container">
                        <vaadin-checkbox id="rememberMeCheckbox"
                                         label="[[i18n.form.rememberMe]]"
                                         class="jmix-login-form-remember-me"></vaadin-checkbox>
                        <vaadin-select id="localesSelect"
                                       class="jmix-login-form-locales-select">
                        </vaadin-select>
                    </div>
                </form>

                <vaadin-button slot="submit" theme="primary contained submit" on-click="submit" disabled$="[[disabled]]">
                    [[i18n.form.submit]]
                </vaadin-button>

                <vaadin-button
                        slot="forgot-password"
                        theme="tertiary small"
                        on-click="_onForgotPasswordClick"
                        hidden$="[[noForgotPassword]]"
                >
                    [[i18n.form.forgotPassword]]
                </vaadin-button>
            </vaadin-login-form-wrapper>
        `;
  }
  static get is() {
    return "jmix-login-form";
  }
  static get properties() {
    return {
      username: {
        type: String,
        value: null,
        notify: true
      },
      password: {
        type: String,
        value: null,
        notify: true
      },
      rememberMeVisibility: {
        type: Boolean,
        value: true
      },
      localesVisibility: {
        type: Boolean,
        notify: true
      },
      locales: {
        type: Object,
        value: []
      },
      /* CAUTION! Copied from LoginMixin */
      i18n: {
        type: Object,
        value: function() {
          return {
            form: {
              title: "Log in",
              username: "Username",
              password: "Password",
              submit: "Log in",
              forgotPassword: "Forgot password",
              rememberMe: "Remember me"
            },
            errorMessage: {
              title: "Incorrect username or password",
              message: "Check that you have entered the correct username and password and try again.",
              username: "Username is required",
              password: "Password is required"
            }
          };
        },
        notify: true
      }
    };
  }
  static get observers() {
    return [
      "_onVisibilityPropertiesChanged(rememberMeVisibility, localesVisibility)",
      `_onLocalesPropertyChanged(locales)`
    ];
  }
  ready() {
    super.ready();
    this.$.localesSelect.addEventListener("value-changed", (e2) => this._localeValueChanged(e2));
    this.$.rememberMeCheckbox.addEventListener("checked-changed", (e2) => this._onRememberMeValueChange(e2));
    this.$.localesSelect.jmixUserOriginated = true;
    this.$.rememberMeCheckbox.jmixUserOriginated = true;
  }
  _onVisibilityPropertiesChanged(rememberMeVisibility, localesVisibility) {
    this.$.additionalFields.hidden = !rememberMeVisibility && !localesVisibility;
    this.$.rememberMeCheckbox.hidden = !rememberMeVisibility;
    this.$.localesSelect.hidden = !localesVisibility;
  }
  _onLocalesPropertyChanged(items) {
    this.$.localesSelect.items = items;
  }
  selectLocale(localeString) {
    const currentValue = this.$.localesSelect.value;
    if (localeString && currentValue !== localeString) {
      this.$.localesSelect.jmixUserOriginated = false;
      this.$.localesSelect.value = localeString;
    }
  }
  setRememberMe(rememberMe) {
    if (this.$.rememberMeCheckbox.checked !== rememberMe) {
      this.$.rememberMeCheckbox.jmixUserOriginated = false;
      this.$.rememberMeCheckbox.checked = rememberMe;
    }
  }
  _onRememberMeValueChange(e2) {
    if (this.$.rememberMeCheckbox.jmixUserOriginated) {
      const customEvent = new CustomEvent("remember-me-changed", { detail: { checked: e2.detail.value } });
      this.dispatchEvent(customEvent);
    }
    this.$.rememberMeCheckbox.jmixUserOriginated = true;
  }
  _localeValueChanged(e2) {
    const localeString = e2.detail.value;
    if (this.$.localesSelect.jmixUserOriginated) {
      const customEvent = new CustomEvent("locale-selection-changed", { detail: { localeString } });
      this.dispatchEvent(customEvent);
    }
    this.$.localesSelect.jmixUserOriginated = true;
  }
}
defineCustomElement(JmixLoginForm);
const multiSelectComboBoxPicker = css`
  [part="action-part"] ::slotted(*) {
    gap: var(--lumo-space-xs);
    margin-left: var(--lumo-space-xs);
  }
  
  :host([has-actions]) [part="input-field"] {
    padding-right: var(--lumo-space-xs);
  }
`;
registerStyles$1("jmix-multi-select-combo-box-picker", multiSelectComboBoxPicker, {
  moduleId: "lumo-multi-select-combo-box-picker-styles"
});
class JmixMultiSelectComboBoxInternal extends ComboBoxDataProviderMixin(ComboBoxMixin(ThemableMixin(PolymerElement))) {
  static get is() {
    return "jmix-multi-select-combo-box-internal";
  }
  static get template() {
    return html`
      <style>
        :host([opened]) {
          pointer-events: auto;
        }
      </style>

      <slot></slot>

      <vaadin-multi-select-combo-box-overlay
        id="overlay"
        opened="[[_overlayOpened]]"
        loading$="[[loading]]"
        theme$="[[_theme]]"
        position-target="[[_target]]"
        no-vertical-overlap
        restore-focus-node="[[inputElement]]"
      ></vaadin-multi-select-combo-box-overlay>
    `;
  }
  static get properties() {
    return {
      /**
       * A subset of items, filtered based on the user input.
       */
      filteredItems: {
        type: Array,
        notify: true
      },
      /**
       * When true, filter string isn't cleared after selecting an item.
       */
      keepFilter: {
        type: Boolean,
        value: false
      },
      /**
       * When set to `true`, "loading" attribute is set
       * on the host and the overlay element.
       * @type {boolean}
       */
      loading: {
        type: Boolean,
        notify: true
      },
      /**
       * Total number of items.
       * @type {number | undefined}
       */
      size: {
        type: Number,
        notify: true
      },
      /**
       * Selected items to render in the dropdown
       * when the component is read-only.
       */
      selectedItems: {
        type: Array,
        value: () => []
      },
      /**
       * Set to true to group selected items at the top of the overlay.
       * @attr {boolean} selected-items-on-top
       */
      selectedItemsOnTop: {
        type: Boolean,
        value: false
      },
      /**
       * Last input value entered by the user before value is updated.
       * Used to store `filter` property value before clearing it.
       */
      lastFilter: {
        type: String,
        notify: true
      },
      /**
       * A subset of items to be shown at the top of the overlay.
       */
      topGroup: {
        type: Array,
        observer: "_topGroupChanged"
      },
      _target: {
        type: Object
      }
    };
  }
  static get observers() {
    return ["_readonlyChanged(readonly)"];
  }
  /**
   * Reference to the clear button element.
   * @protected
   * @return {!HTMLElement}
   */
  get clearElement() {
    return this.querySelector('[part="clear-button"]');
  }
  /**
   * Tag name prefix used by scroller and items.
   * @protected
   * @return {string}
   */
  get _tagNamePrefix() {
    return "vaadin-multi-select-combo-box";
  }
  constructor() {
    super();
    this.addEventListener("custom-value-set", this.__onCustomValueSet.bind(this));
  }
  /**
   * Override method inherited from the combo-box
   * to allow opening dropdown when readonly.
   * @override
   */
  open() {
    if (!this.disabled && !(this.readonly && this.selectedItems.length === 0)) {
      this.opened = true;
    }
  }
  /** @protected */
  ready() {
    super.ready();
    this._target = this;
    this._toggleElement = this.querySelector(".toggle-button");
  }
  /** @private */
  _readonlyChanged() {
    this._setDropdownItems(this.filteredItems);
  }
  /**
   * Override combo-box method to group selected
   * items at the top of the overlay.
   *
   * @protected
   * @override
   */
  _setDropdownItems(items) {
    if (this.readonly) {
      super._setDropdownItems(this.selectedItems);
      return;
    }
    if (this.filter || !this.selectedItemsOnTop) {
      super._setDropdownItems(items);
      return;
    }
    if (items && items.length && this.topGroup && this.topGroup.length) {
      const filteredItems = items.filter(
        (item2) => this._comboBox._findIndex(item2, this.topGroup, this.itemIdPath) === -1
      );
      super._setDropdownItems(this.topGroup.concat(filteredItems));
      return;
    }
    super._setDropdownItems(items);
  }
  /** @private */
  _topGroupChanged(topGroup) {
    if (topGroup) {
      this._setDropdownItems(this.filteredItems);
    }
  }
  /**
   * Override combo-box method to set correct owner for using by item renderers.
   * This needs to be done before the scroller gets added to the DOM to ensure
   * Lit directive works in case when combo-box is opened using attribute.
   *
   * @protected
   * @override
   */
  _initScroller() {
    const comboBox2 = this.getRootNode().host;
    this._comboBox = comboBox2;
    super._initScroller(comboBox2);
  }
  /**
   * Override Enter handler to keep overlay open
   * when item is selected or unselected.
   * @param {!Event} event
   * @protected
   * @override
   */
  _onEnter(event) {
    if (this.opened) {
      event.preventDefault();
      event.stopPropagation();
      if (this.readonly) {
        this.close();
      } else if (this._hasValidInputValue()) {
        const focusedItem = this._dropdownItems[this._focusedIndex];
        this._commitValue();
        this._focusedIndex = this._dropdownItems.indexOf(focusedItem);
      }
      return;
    }
    super._onEnter(event);
  }
  /**
   * Override Escape handler to not clear
   * selected items when readonly.
   * @param {!Event} event
   * @protected
   * @override
   */
  _onEscape(event) {
    if (this.readonly) {
      event.stopPropagation();
      if (this.opened) {
        this.close();
      }
      return;
    }
    super._onEscape(event);
  }
  /**
   * Override from combo-box to ignore requests to clear the filter if the
   * keepFilter option is enabled. Exceptions are when the dropdown is closed,
   * so the filter is still cleared on cancel and focus out.
   * @protected
   * @override
   */
  _clearFilter() {
    if (!this.keepFilter || !this.opened) {
      super._clearFilter();
    }
  }
  /**
   * Override method from combo-box to always clear the filter when reverting
   * the input value, regardless of the keepFilter option.
   * @override
   * @protected
   */
  _revertInputValueToValue() {
    super._revertInputValueToValue();
    this.filter = "";
  }
  /**
   * @protected
   * @override
   */
  _commitValue() {
    this.lastFilter = this.filter;
    super._commitValue();
  }
  /**
   * Override method inherited from the combo-box
   * to not update focused item when readonly.
   * @protected
   * @override
   */
  _onArrowDown() {
    if (!this.readonly) {
      super._onArrowDown();
    } else if (!this.opened) {
      this.open();
    }
  }
  /**
   * Override method inherited from the combo-box
   * to not update focused item when readonly.
   * @protected
   * @override
   */
  _onArrowUp() {
    if (!this.readonly) {
      super._onArrowUp();
    } else if (!this.opened) {
      this.open();
    }
  }
  /**
   * Override method inherited from the combo-box
   * to close dropdown on blur when readonly.
   * @param {boolean} focused
   * @protected
   * @override
   */
  _setFocused(focused) {
    if (!focused) {
      this._ignoreCommitValue = true;
    }
    super._setFocused(focused);
    if (!focused && this.readonly && !this._closeOnBlurIsPrevented) {
      this.close();
    }
  }
  /**
   * Override method inherited from the combo-box
   * to not commit an already selected item again
   * after closing overlay on outside click.
   * @protected
   * @override
   */
  _onClosed() {
    this._ignoreCommitValue = true;
    super._onClosed();
  }
  /**
   * Override method inherited from the combo-box
   * to not commit an already selected item again
   * on blur, which would result in un-selecting.
   * @protected
   * @override
   */
  _detectAndDispatchChange() {
    if (this._ignoreCommitValue) {
      this._ignoreCommitValue = false;
      this.clear();
      this._inputElementValue = "";
      return;
    }
    super._detectAndDispatchChange();
  }
  /**
   * @param {CustomEvent} event
   * @protected
   * @override
   */
  _overlaySelectedItemChanged(event) {
    event.stopPropagation();
    if (this.readonly) {
      return;
    }
    if (event.detail.item instanceof ComboBoxPlaceholder) {
      return;
    }
    if (this.opened) {
      this.lastFilter = this.filter;
      this.dispatchEvent(
        new CustomEvent("combo-box-item-selected", {
          detail: {
            item: event.detail.item
          }
        })
      );
    }
  }
  /**
   * Override method inherited from the combo-box
   * to not request data provider when read-only.
   *
   * @protected
   * @override
   */
  _shouldFetchData() {
    if (this.readonly) {
      return false;
    }
    return super._shouldFetchData();
  }
  /**
   * Override method inherited from the combo-box
   * to not clear the data provider cache when read-only.
   *
   * @protected
   * @override
   */
  clearCache() {
    if (this.readonly) {
      return;
    }
    super.clearCache();
  }
  /** @private */
  __onCustomValueSet(event) {
    if (this._ignoreCommitValue) {
      event.stopImmediatePropagation();
    }
  }
  /**
   * Jmix API
   *
   * @param {Event} event
   * @protected
   * @override
   */
  _onHostClick(event) {
    const path = event.composedPath();
    if (!path.includes(this._actionsBox)) {
      super._onHostClick(event);
    }
  }
}
defineCustomElement(JmixMultiSelectComboBoxInternal);
registerStyles$1("jmix-multi-select-combo-box-picker", [], {
  moduleId: "jmix-multi-select-combo-box-picker-styles"
});
class JmixMultiSelectComboBoxPicker extends MultiSelectComboBox {
  static get is() {
    return "jmix-multi-select-combo-box-picker";
  }
  static get template() {
    return html`
            <style>
                [part="action-part"] ::slotted(*) {
                    display: flex;
                }

                :host([readonly]) [part="action-part"] {
                    display: none;
                }
            </style>
            
            <div class="vaadin-multi-select-combo-box-container">
                <div part="label">
                    <slot name="label"></slot>
                    <span part="required-indicator" aria-hidden="true" on-click="focus"></span>
                </div>

                <vaadin-multi-select-combo-box-internal
                        id="comboBox"
                        items="[[items]]"
                        item-id-path="[[itemIdPath]]"
                        item-label-path="[[itemLabelPath]]"
                        item-value-path="[[itemValuePath]]"
                        disabled="[[disabled]]"
                        readonly="[[readonly]]"
                        auto-open-disabled="[[autoOpenDisabled]]"
                        allow-custom-value="[[allowCustomValue]]"
                        overlay-class="[[overlayClass]]"
                        data-provider="[[dataProvider]]"
                        filter="{{filter}}"
                        last-filter="{{_lastFilter}}"
                        loading="{{loading}}"
                        size="{{size}}"
                        filtered-items="[[filteredItems]]"
                        selected-items="[[selectedItems]]"
                        selected-items-on-top="[[selectedItemsOnTop]]"
                        item-class-name-generator="[[itemClassNameGenerator]]"
                        top-group="[[_topGroup]]"
                        opened="{{opened}}"
                        renderer="[[renderer]]"
                        keep-filter="[[keepFilter]]"
                        theme$="[[_theme]]"
                        on-combo-box-item-selected="_onComboBoxItemSelected"
                        on-change="_onComboBoxChange"
                        on-custom-value-set="_onCustomValueSet"
                        on-filtered-items-changed="_onFilteredItemsChanged"
                >
                    <vaadin-multi-select-combo-box-container
                            part="input-field"
                            auto-expand-vertically="[[autoExpandVertically]]"
                            readonly="[[readonly]]"
                            disabled="[[disabled]]"
                            invalid="[[invalid]]"
                            theme$="[[_theme]]"
                    >
                        <slot name="overflow" slot="prefix"></slot>
                        <div id="chips" part="chips" slot="prefix">
                            <slot name="chip"></slot>
                        </div>
                        <slot name="input"></slot>
                        <div id="toggleButton" class="toggle-button" part="toggle-button" slot="suffix"
                             aria-hidden="true"></div>
                        <!-- Jmix API -->
                        <div id="pickerAction" part="action-part" slot="suffix">
                            <slot name="actions"></slot>
                        </div>
                    </vaadin-multi-select-combo-box-container>
                </jmix-multi-select-combo-box-internal>

                <div part="helper-text">
                    <slot name="helper"></slot>
                </div>

                <div part="error-message">
                    <slot name="error-message"></slot>
                </div>
            </div>

            <slot name="tooltip"></slot>
        `;
  }
  /**
   * Used by `ClearButtonMixin` as a reference to the clear button element.
   * @protected
   * @return {!HTMLElement}
   */
  get clearElement() {
    return null;
  }
}
defineCustomElement(JmixMultiSelectComboBoxPicker);
/*!
 * Quill Editor v1.3.7
 * https://quilljs.com/
 * Copyright (c) 2014, Jason Chen
 * Copyright (c) 2013, salesforce.com
 */
!(function(t2, e2) {
  "object" == typeof exports && "object" == typeof module ? module.exports = e2() : "function" == typeof define && define.amd ? define([], e2) : "object" == typeof exports ? exports.Quill = e2() : t2.Quill = e2();
})("undefined" != typeof self ? self : void 0, function() {
  return (function(t2) {
    function e2(r) {
      if (n[r]) return n[r].exports;
      var o = n[r] = { i: r, l: false, exports: {} };
      return t2[r].call(o.exports, o, o.exports, e2), o.l = true, o.exports;
    }
    var n = {};
    return e2.m = t2, e2.c = n, e2.d = function(t3, n2, r) {
      e2.o(t3, n2) || Object.defineProperty(t3, n2, { configurable: false, enumerable: true, get: r });
    }, e2.n = function(t3) {
      var n2 = t3 && t3.__esModule ? function() {
        return t3.default;
      } : function() {
        return t3;
      };
      return e2.d(n2, "a", n2), n2;
    }, e2.o = function(t3, e3) {
      return Object.prototype.hasOwnProperty.call(t3, e3);
    }, e2.p = "", e2(e2.s = 45);
  })([function(t2, e2, n) {
    Object.defineProperty(e2, "__esModule", { value: true });
    var r = n(17), o = n(18), i2 = n(19), l = n(48), a3 = n(49), s3 = n(50), u2 = n(51), c2 = n(52), f = n(11), h3 = n(29), p = n(30), d3 = n(28), y3 = n(1), v = { Scope: y3.Scope, create: y3.create, find: y3.find, query: y3.query, register: y3.register, Container: r.default, Format: o.default, Leaf: i2.default, Embed: u2.default, Scroll: l.default, Block: s3.default, Inline: a3.default, Text: c2.default, Attributor: { Attribute: f.default, Class: h3.default, Style: p.default, Store: d3.default } };
    e2.default = v;
  }, function(t2, e2, n) {
    function r(t3, e3) {
      var n2 = i2(t3);
      if (null == n2) throw new s3("Unable to create " + t3 + " blot");
      var r2 = n2;
      return new r2(t3 instanceof Node || t3.nodeType === Node.TEXT_NODE ? t3 : r2.create(e3), e3);
    }
    function o(t3, n2) {
      return void 0 === n2 && (n2 = false), null == t3 ? null : null != t3[e2.DATA_KEY] ? t3[e2.DATA_KEY].blot : n2 ? o(t3.parentNode, n2) : null;
    }
    function i2(t3, e3) {
      void 0 === e3 && (e3 = p.ANY);
      var n2;
      if ("string" == typeof t3) n2 = h3[t3] || u2[t3];
      else if (t3 instanceof Text || t3.nodeType === Node.TEXT_NODE) n2 = h3.text;
      else if ("number" == typeof t3) t3 & p.LEVEL & p.BLOCK ? n2 = h3.block : t3 & p.LEVEL & p.INLINE && (n2 = h3.inline);
      else if (t3 instanceof HTMLElement) {
        var r2 = (t3.getAttribute("class") || "").split(/\s+/);
        for (var o2 in r2) if (n2 = c2[r2[o2]]) break;
        n2 = n2 || f[t3.tagName];
      }
      return null == n2 ? null : e3 & p.LEVEL & n2.scope && e3 & p.TYPE & n2.scope ? n2 : null;
    }
    function l() {
      for (var t3 = [], e3 = 0; e3 < arguments.length; e3++) t3[e3] = arguments[e3];
      if (t3.length > 1) return t3.map(function(t4) {
        return l(t4);
      });
      var n2 = t3[0];
      if ("string" != typeof n2.blotName && "string" != typeof n2.attrName) throw new s3("Invalid definition");
      if ("abstract" === n2.blotName) throw new s3("Cannot register abstract class");
      if (h3[n2.blotName || n2.attrName] = n2, "string" == typeof n2.keyName) u2[n2.keyName] = n2;
      else if (null != n2.className && (c2[n2.className] = n2), null != n2.tagName) {
        Array.isArray(n2.tagName) ? n2.tagName = n2.tagName.map(function(t4) {
          return t4.toUpperCase();
        }) : n2.tagName = n2.tagName.toUpperCase();
        var r2 = Array.isArray(n2.tagName) ? n2.tagName : [n2.tagName];
        r2.forEach(function(t4) {
          null != f[t4] && null != n2.className || (f[t4] = n2);
        });
      }
      return n2;
    }
    var a3 = this && this.__extends || (function() {
      var t3 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t4, e3) {
        t4.__proto__ = e3;
      } || function(t4, e3) {
        for (var n2 in e3) e3.hasOwnProperty(n2) && (t4[n2] = e3[n2]);
      };
      return function(e3, n2) {
        function r2() {
          this.constructor = e3;
        }
        t3(e3, n2), e3.prototype = null === n2 ? Object.create(n2) : (r2.prototype = n2.prototype, new r2());
      };
    })();
    Object.defineProperty(e2, "__esModule", { value: true });
    var s3 = (function(t3) {
      function e3(e4) {
        var n2 = this;
        return e4 = "[Parchment] " + e4, n2 = t3.call(this, e4) || this, n2.message = e4, n2.name = n2.constructor.name, n2;
      }
      return a3(e3, t3), e3;
    })(Error);
    e2.ParchmentError = s3;
    var u2 = {}, c2 = {}, f = {}, h3 = {};
    e2.DATA_KEY = "__blot";
    var p;
    !(function(t3) {
      t3[t3.TYPE = 3] = "TYPE", t3[t3.LEVEL = 12] = "LEVEL", t3[t3.ATTRIBUTE = 13] = "ATTRIBUTE", t3[t3.BLOT = 14] = "BLOT", t3[t3.INLINE = 7] = "INLINE", t3[t3.BLOCK = 11] = "BLOCK", t3[t3.BLOCK_BLOT = 10] = "BLOCK_BLOT", t3[t3.INLINE_BLOT = 6] = "INLINE_BLOT", t3[t3.BLOCK_ATTRIBUTE = 9] = "BLOCK_ATTRIBUTE", t3[t3.INLINE_ATTRIBUTE = 5] = "INLINE_ATTRIBUTE", t3[t3.ANY = 15] = "ANY";
    })(p = e2.Scope || (e2.Scope = {})), e2.create = r, e2.find = o, e2.query = i2, e2.register = l;
  }, function(t2, e2) {
    var n = Object.prototype.hasOwnProperty, r = Object.prototype.toString, o = Object.defineProperty, i2 = Object.getOwnPropertyDescriptor, l = function(t3) {
      return "function" == typeof Array.isArray ? Array.isArray(t3) : "[object Array]" === r.call(t3);
    }, a3 = function(t3) {
      if (!t3 || "[object Object]" !== r.call(t3)) return false;
      var e3 = n.call(t3, "constructor"), o2 = t3.constructor && t3.constructor.prototype && n.call(t3.constructor.prototype, "isPrototypeOf");
      if (t3.constructor && !e3 && !o2) return false;
      var i3;
      for (i3 in t3) ;
      return void 0 === i3 || n.call(t3, i3);
    }, s3 = function(t3, e3) {
      o && "__proto__" === e3.name ? o(t3, e3.name, { enumerable: true, configurable: true, value: e3.newValue, writable: true }) : t3[e3.name] = e3.newValue;
    }, u2 = function(t3, e3) {
      if ("__proto__" === e3) {
        if (!n.call(t3, e3)) return;
        if (i2) return i2(t3, e3).value;
      }
      return t3[e3];
    };
    t2.exports = function t3() {
      var e3, n2, r2, o2, i3, c2, f = arguments[0], h3 = 1, p = arguments.length, d3 = false;
      for ("boolean" == typeof f && (d3 = f, f = arguments[1] || {}, h3 = 2), (null == f || "object" != typeof f && "function" != typeof f) && (f = {}); h3 < p; ++h3) if (null != (e3 = arguments[h3])) for (n2 in e3) r2 = u2(f, n2), o2 = u2(e3, n2), f !== o2 && (d3 && o2 && (a3(o2) || (i3 = l(o2))) ? (i3 ? (i3 = false, c2 = r2 && l(r2) ? r2 : []) : c2 = r2 && a3(r2) ? r2 : {}, s3(f, { name: n2, newValue: t3(d3, c2, o2) })) : void 0 !== o2 && s3(f, { name: n2, newValue: o2 }));
      return f;
    };
  }, function(t2, e2, n) {
    function r(t3) {
      return t3 && t3.__esModule ? t3 : { default: t3 };
    }
    function o(t3, e3) {
      if (!(t3 instanceof e3)) throw new TypeError("Cannot call a class as a function");
    }
    function i2(t3, e3) {
      if (!t3) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      return !e3 || "object" != typeof e3 && "function" != typeof e3 ? t3 : e3;
    }
    function l(t3, e3) {
      if ("function" != typeof e3 && null !== e3) throw new TypeError("Super expression must either be null or a function, not " + typeof e3);
      t3.prototype = Object.create(e3 && e3.prototype, { constructor: { value: t3, enumerable: false, writable: true, configurable: true } }), e3 && (Object.setPrototypeOf ? Object.setPrototypeOf(t3, e3) : t3.__proto__ = e3);
    }
    function a3(t3) {
      var e3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
      return null == t3 ? e3 : ("function" == typeof t3.formats && (e3 = (0, f.default)(e3, t3.formats())), null == t3.parent || "scroll" == t3.parent.blotName || t3.parent.statics.scope !== t3.statics.scope ? e3 : a3(t3.parent, e3));
    }
    Object.defineProperty(e2, "__esModule", { value: true }), e2.default = e2.BlockEmbed = e2.bubbleFormats = void 0;
    var s3 = /* @__PURE__ */ (function() {
      function t3(t4, e3) {
        for (var n2 = 0; n2 < e3.length; n2++) {
          var r2 = e3[n2];
          r2.enumerable = r2.enumerable || false, r2.configurable = true, "value" in r2 && (r2.writable = true), Object.defineProperty(t4, r2.key, r2);
        }
      }
      return function(e3, n2, r2) {
        return n2 && t3(e3.prototype, n2), r2 && t3(e3, r2), e3;
      };
    })(), u2 = function t3(e3, n2, r2) {
      null === e3 && (e3 = Function.prototype);
      var o2 = Object.getOwnPropertyDescriptor(e3, n2);
      if (void 0 === o2) {
        var i3 = Object.getPrototypeOf(e3);
        return null === i3 ? void 0 : t3(i3, n2, r2);
      }
      if ("value" in o2) return o2.value;
      var l2 = o2.get;
      if (void 0 !== l2) return l2.call(r2);
    }, c2 = n(2), f = r(c2), h3 = n(4), p = r(h3), d3 = n(0), y3 = r(d3), v = n(14), b2 = r(v), g = n(5), m3 = r(g), _ = n(8), O2 = r(_), w2 = (function(t3) {
      function e3() {
        return o(this, e3), i2(this, (e3.__proto__ || Object.getPrototypeOf(e3)).apply(this, arguments));
      }
      return l(e3, t3), s3(e3, [{ key: "attach", value: function() {
        u2(e3.prototype.__proto__ || Object.getPrototypeOf(e3.prototype), "attach", this).call(this), this.attributes = new y3.default.Attributor.Store(this.domNode);
      } }, { key: "delta", value: function() {
        return new p.default().insert(this.value(), (0, f.default)(this.formats(), this.attributes.values()));
      } }, { key: "format", value: function(t4, e4) {
        var n2 = y3.default.query(t4, y3.default.Scope.BLOCK_ATTRIBUTE);
        null != n2 && this.attributes.attribute(n2, e4);
      } }, { key: "formatAt", value: function(t4, e4, n2, r2) {
        this.format(n2, r2);
      } }, { key: "insertAt", value: function(t4, n2, r2) {
        if ("string" == typeof n2 && n2.endsWith("\n")) {
          var o2 = y3.default.create(x2.blotName);
          this.parent.insertBefore(o2, 0 === t4 ? this : this.next), o2.insertAt(0, n2.slice(0, -1));
        } else u2(e3.prototype.__proto__ || Object.getPrototypeOf(e3.prototype), "insertAt", this).call(this, t4, n2, r2);
      } }]), e3;
    })(y3.default.Embed);
    w2.scope = y3.default.Scope.BLOCK_BLOT;
    var x2 = (function(t3) {
      function e3(t4) {
        o(this, e3);
        var n2 = i2(this, (e3.__proto__ || Object.getPrototypeOf(e3)).call(this, t4));
        return n2.cache = {}, n2;
      }
      return l(e3, t3), s3(e3, [{ key: "delta", value: function() {
        return null == this.cache.delta && (this.cache.delta = this.descendants(y3.default.Leaf).reduce(function(t4, e4) {
          return 0 === e4.length() ? t4 : t4.insert(e4.value(), a3(e4));
        }, new p.default()).insert("\n", a3(this))), this.cache.delta;
      } }, { key: "deleteAt", value: function(t4, n2) {
        u2(e3.prototype.__proto__ || Object.getPrototypeOf(e3.prototype), "deleteAt", this).call(this, t4, n2), this.cache = {};
      } }, { key: "formatAt", value: function(t4, n2, r2, o2) {
        n2 <= 0 || (y3.default.query(r2, y3.default.Scope.BLOCK) ? t4 + n2 === this.length() && this.format(r2, o2) : u2(e3.prototype.__proto__ || Object.getPrototypeOf(e3.prototype), "formatAt", this).call(this, t4, Math.min(n2, this.length() - t4 - 1), r2, o2), this.cache = {});
      } }, { key: "insertAt", value: function(t4, n2, r2) {
        if (null != r2) return u2(e3.prototype.__proto__ || Object.getPrototypeOf(e3.prototype), "insertAt", this).call(this, t4, n2, r2);
        if (0 !== n2.length) {
          var o2 = n2.split("\n"), i3 = o2.shift();
          i3.length > 0 && (t4 < this.length() - 1 || null == this.children.tail ? u2(e3.prototype.__proto__ || Object.getPrototypeOf(e3.prototype), "insertAt", this).call(this, Math.min(t4, this.length() - 1), i3) : this.children.tail.insertAt(this.children.tail.length(), i3), this.cache = {});
          var l2 = this;
          o2.reduce(function(t5, e4) {
            return l2 = l2.split(t5, true), l2.insertAt(0, e4), e4.length;
          }, t4 + i3.length);
        }
      } }, { key: "insertBefore", value: function(t4, n2) {
        var r2 = this.children.head;
        u2(e3.prototype.__proto__ || Object.getPrototypeOf(e3.prototype), "insertBefore", this).call(this, t4, n2), r2 instanceof b2.default && r2.remove(), this.cache = {};
      } }, { key: "length", value: function() {
        return null == this.cache.length && (this.cache.length = u2(e3.prototype.__proto__ || Object.getPrototypeOf(e3.prototype), "length", this).call(this) + 1), this.cache.length;
      } }, { key: "moveChildren", value: function(t4, n2) {
        u2(e3.prototype.__proto__ || Object.getPrototypeOf(e3.prototype), "moveChildren", this).call(this, t4, n2), this.cache = {};
      } }, { key: "optimize", value: function(t4) {
        u2(e3.prototype.__proto__ || Object.getPrototypeOf(e3.prototype), "optimize", this).call(this, t4), this.cache = {};
      } }, { key: "path", value: function(t4) {
        return u2(e3.prototype.__proto__ || Object.getPrototypeOf(e3.prototype), "path", this).call(this, t4, true);
      } }, { key: "removeChild", value: function(t4) {
        u2(e3.prototype.__proto__ || Object.getPrototypeOf(e3.prototype), "removeChild", this).call(this, t4), this.cache = {};
      } }, { key: "split", value: function(t4) {
        var n2 = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
        if (n2 && (0 === t4 || t4 >= this.length() - 1)) {
          var r2 = this.clone();
          return 0 === t4 ? (this.parent.insertBefore(r2, this), this) : (this.parent.insertBefore(r2, this.next), r2);
        }
        var o2 = u2(e3.prototype.__proto__ || Object.getPrototypeOf(e3.prototype), "split", this).call(this, t4, n2);
        return this.cache = {}, o2;
      } }]), e3;
    })(y3.default.Block);
    x2.blotName = "block", x2.tagName = "P", x2.defaultChild = "break", x2.allowedChildren = [m3.default, y3.default.Embed, O2.default], e2.bubbleFormats = a3, e2.BlockEmbed = w2, e2.default = x2;
  }, function(t2, e2, n) {
    var r = n(54), o = n(12), i2 = n(2), l = n(20), a3 = String.fromCharCode(0), s3 = function(t3) {
      Array.isArray(t3) ? this.ops = t3 : null != t3 && Array.isArray(t3.ops) ? this.ops = t3.ops : this.ops = [];
    };
    s3.prototype.insert = function(t3, e3) {
      var n2 = {};
      return 0 === t3.length ? this : (n2.insert = t3, null != e3 && "object" == typeof e3 && Object.keys(e3).length > 0 && (n2.attributes = e3), this.push(n2));
    }, s3.prototype.delete = function(t3) {
      return t3 <= 0 ? this : this.push({ delete: t3 });
    }, s3.prototype.retain = function(t3, e3) {
      if (t3 <= 0) return this;
      var n2 = { retain: t3 };
      return null != e3 && "object" == typeof e3 && Object.keys(e3).length > 0 && (n2.attributes = e3), this.push(n2);
    }, s3.prototype.push = function(t3) {
      var e3 = this.ops.length, n2 = this.ops[e3 - 1];
      if (t3 = i2(true, {}, t3), "object" == typeof n2) {
        if ("number" == typeof t3.delete && "number" == typeof n2.delete) return this.ops[e3 - 1] = { delete: n2.delete + t3.delete }, this;
        if ("number" == typeof n2.delete && null != t3.insert && (e3 -= 1, "object" != typeof (n2 = this.ops[e3 - 1]))) return this.ops.unshift(t3), this;
        if (o(t3.attributes, n2.attributes)) {
          if ("string" == typeof t3.insert && "string" == typeof n2.insert) return this.ops[e3 - 1] = { insert: n2.insert + t3.insert }, "object" == typeof t3.attributes && (this.ops[e3 - 1].attributes = t3.attributes), this;
          if ("number" == typeof t3.retain && "number" == typeof n2.retain) return this.ops[e3 - 1] = { retain: n2.retain + t3.retain }, "object" == typeof t3.attributes && (this.ops[e3 - 1].attributes = t3.attributes), this;
        }
      }
      return e3 === this.ops.length ? this.ops.push(t3) : this.ops.splice(e3, 0, t3), this;
    }, s3.prototype.chop = function() {
      var t3 = this.ops[this.ops.length - 1];
      return t3 && t3.retain && !t3.attributes && this.ops.pop(), this;
    }, s3.prototype.filter = function(t3) {
      return this.ops.filter(t3);
    }, s3.prototype.forEach = function(t3) {
      this.ops.forEach(t3);
    }, s3.prototype.map = function(t3) {
      return this.ops.map(t3);
    }, s3.prototype.partition = function(t3) {
      var e3 = [], n2 = [];
      return this.forEach(function(r2) {
        (t3(r2) ? e3 : n2).push(r2);
      }), [e3, n2];
    }, s3.prototype.reduce = function(t3, e3) {
      return this.ops.reduce(t3, e3);
    }, s3.prototype.changeLength = function() {
      return this.reduce(function(t3, e3) {
        return e3.insert ? t3 + l.length(e3) : e3.delete ? t3 - e3.delete : t3;
      }, 0);
    }, s3.prototype.length = function() {
      return this.reduce(function(t3, e3) {
        return t3 + l.length(e3);
      }, 0);
    }, s3.prototype.slice = function(t3, e3) {
      t3 = t3 || 0, "number" != typeof e3 && (e3 = 1 / 0);
      for (var n2 = [], r2 = l.iterator(this.ops), o2 = 0; o2 < e3 && r2.hasNext(); ) {
        var i3;
        o2 < t3 ? i3 = r2.next(t3 - o2) : (i3 = r2.next(e3 - o2), n2.push(i3)), o2 += l.length(i3);
      }
      return new s3(n2);
    }, s3.prototype.compose = function(t3) {
      var e3 = l.iterator(this.ops), n2 = l.iterator(t3.ops), r2 = [], i3 = n2.peek();
      if (null != i3 && "number" == typeof i3.retain && null == i3.attributes) {
        for (var a4 = i3.retain; "insert" === e3.peekType() && e3.peekLength() <= a4; ) a4 -= e3.peekLength(), r2.push(e3.next());
        i3.retain - a4 > 0 && n2.next(i3.retain - a4);
      }
      for (var u2 = new s3(r2); e3.hasNext() || n2.hasNext(); ) if ("insert" === n2.peekType()) u2.push(n2.next());
      else if ("delete" === e3.peekType()) u2.push(e3.next());
      else {
        var c2 = Math.min(e3.peekLength(), n2.peekLength()), f = e3.next(c2), h3 = n2.next(c2);
        if ("number" == typeof h3.retain) {
          var p = {};
          "number" == typeof f.retain ? p.retain = c2 : p.insert = f.insert;
          var d3 = l.attributes.compose(f.attributes, h3.attributes, "number" == typeof f.retain);
          if (d3 && (p.attributes = d3), u2.push(p), !n2.hasNext() && o(u2.ops[u2.ops.length - 1], p)) {
            var y3 = new s3(e3.rest());
            return u2.concat(y3).chop();
          }
        } else "number" == typeof h3.delete && "number" == typeof f.retain && u2.push(h3);
      }
      return u2.chop();
    }, s3.prototype.concat = function(t3) {
      var e3 = new s3(this.ops.slice());
      return t3.ops.length > 0 && (e3.push(t3.ops[0]), e3.ops = e3.ops.concat(t3.ops.slice(1))), e3;
    }, s3.prototype.diff = function(t3, e3) {
      if (this.ops === t3.ops) return new s3();
      var n2 = [this, t3].map(function(e4) {
        return e4.map(function(n3) {
          if (null != n3.insert) return "string" == typeof n3.insert ? n3.insert : a3;
          var r2 = e4 === t3 ? "on" : "with";
          throw new Error("diff() called " + r2 + " non-document");
        }).join("");
      }), i3 = new s3(), u2 = r(n2[0], n2[1], e3), c2 = l.iterator(this.ops), f = l.iterator(t3.ops);
      return u2.forEach(function(t4) {
        for (var e4 = t4[1].length; e4 > 0; ) {
          var n3 = 0;
          switch (t4[0]) {
            case r.INSERT:
              n3 = Math.min(f.peekLength(), e4), i3.push(f.next(n3));
              break;
            case r.DELETE:
              n3 = Math.min(e4, c2.peekLength()), c2.next(n3), i3.delete(n3);
              break;
            case r.EQUAL:
              n3 = Math.min(c2.peekLength(), f.peekLength(), e4);
              var a4 = c2.next(n3), s4 = f.next(n3);
              o(a4.insert, s4.insert) ? i3.retain(n3, l.attributes.diff(a4.attributes, s4.attributes)) : i3.push(s4).delete(n3);
          }
          e4 -= n3;
        }
      }), i3.chop();
    }, s3.prototype.eachLine = function(t3, e3) {
      e3 = e3 || "\n";
      for (var n2 = l.iterator(this.ops), r2 = new s3(), o2 = 0; n2.hasNext(); ) {
        if ("insert" !== n2.peekType()) return;
        var i3 = n2.peek(), a4 = l.length(i3) - n2.peekLength(), u2 = "string" == typeof i3.insert ? i3.insert.indexOf(e3, a4) - a4 : -1;
        if (u2 < 0) r2.push(n2.next());
        else if (u2 > 0) r2.push(n2.next(u2));
        else {
          if (false === t3(r2, n2.next(1).attributes || {}, o2)) return;
          o2 += 1, r2 = new s3();
        }
      }
      r2.length() > 0 && t3(r2, {}, o2);
    }, s3.prototype.transform = function(t3, e3) {
      if (e3 = !!e3, "number" == typeof t3) return this.transformPosition(t3, e3);
      for (var n2 = l.iterator(this.ops), r2 = l.iterator(t3.ops), o2 = new s3(); n2.hasNext() || r2.hasNext(); ) if ("insert" !== n2.peekType() || !e3 && "insert" === r2.peekType()) if ("insert" === r2.peekType()) o2.push(r2.next());
      else {
        var i3 = Math.min(n2.peekLength(), r2.peekLength()), a4 = n2.next(i3), u2 = r2.next(i3);
        if (a4.delete) continue;
        u2.delete ? o2.push(u2) : o2.retain(i3, l.attributes.transform(a4.attributes, u2.attributes, e3));
      }
      else o2.retain(l.length(n2.next()));
      return o2.chop();
    }, s3.prototype.transformPosition = function(t3, e3) {
      e3 = !!e3;
      for (var n2 = l.iterator(this.ops), r2 = 0; n2.hasNext() && r2 <= t3; ) {
        var o2 = n2.peekLength(), i3 = n2.peekType();
        n2.next(), "delete" !== i3 ? ("insert" === i3 && (r2 < t3 || !e3) && (t3 += o2), r2 += o2) : t3 -= Math.min(o2, t3 - r2);
      }
      return t3;
    }, t2.exports = s3;
  }, function(t2, e2, n) {
    function r(t3) {
      return t3 && t3.__esModule ? t3 : { default: t3 };
    }
    function o(t3, e3) {
      if (!(t3 instanceof e3)) throw new TypeError("Cannot call a class as a function");
    }
    function i2(t3, e3) {
      if (!t3) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      return !e3 || "object" != typeof e3 && "function" != typeof e3 ? t3 : e3;
    }
    function l(t3, e3) {
      if ("function" != typeof e3 && null !== e3) throw new TypeError("Super expression must either be null or a function, not " + typeof e3);
      t3.prototype = Object.create(e3 && e3.prototype, { constructor: { value: t3, enumerable: false, writable: true, configurable: true } }), e3 && (Object.setPrototypeOf ? Object.setPrototypeOf(t3, e3) : t3.__proto__ = e3);
    }
    Object.defineProperty(e2, "__esModule", { value: true });
    var a3 = /* @__PURE__ */ (function() {
      function t3(t4, e3) {
        for (var n2 = 0; n2 < e3.length; n2++) {
          var r2 = e3[n2];
          r2.enumerable = r2.enumerable || false, r2.configurable = true, "value" in r2 && (r2.writable = true), Object.defineProperty(t4, r2.key, r2);
        }
      }
      return function(e3, n2, r2) {
        return n2 && t3(e3.prototype, n2), r2 && t3(e3, r2), e3;
      };
    })(), s3 = function t3(e3, n2, r2) {
      null === e3 && (e3 = Function.prototype);
      var o2 = Object.getOwnPropertyDescriptor(e3, n2);
      if (void 0 === o2) {
        var i3 = Object.getPrototypeOf(e3);
        return null === i3 ? void 0 : t3(i3, n2, r2);
      }
      if ("value" in o2) return o2.value;
      var l2 = o2.get;
      if (void 0 !== l2) return l2.call(r2);
    }, u2 = n(8), c2 = r(u2), f = n(0), h3 = r(f), p = (function(t3) {
      function e3() {
        return o(this, e3), i2(this, (e3.__proto__ || Object.getPrototypeOf(e3)).apply(this, arguments));
      }
      return l(e3, t3), a3(e3, [{ key: "formatAt", value: function(t4, n2, r2, o2) {
        if (e3.compare(this.statics.blotName, r2) < 0 && h3.default.query(r2, h3.default.Scope.BLOT)) {
          var i3 = this.isolate(t4, n2);
          o2 && i3.wrap(r2, o2);
        } else s3(e3.prototype.__proto__ || Object.getPrototypeOf(e3.prototype), "formatAt", this).call(this, t4, n2, r2, o2);
      } }, { key: "optimize", value: function(t4) {
        if (s3(e3.prototype.__proto__ || Object.getPrototypeOf(e3.prototype), "optimize", this).call(this, t4), this.parent instanceof e3 && e3.compare(this.statics.blotName, this.parent.statics.blotName) > 0) {
          var n2 = this.parent.isolate(this.offset(), this.length());
          this.moveChildren(n2), n2.wrap(this);
        }
      } }], [{ key: "compare", value: function(t4, n2) {
        var r2 = e3.order.indexOf(t4), o2 = e3.order.indexOf(n2);
        return r2 >= 0 || o2 >= 0 ? r2 - o2 : t4 === n2 ? 0 : t4 < n2 ? -1 : 1;
      } }]), e3;
    })(h3.default.Inline);
    p.allowedChildren = [p, h3.default.Embed, c2.default], p.order = ["cursor", "inline", "underline", "strike", "italic", "bold", "script", "link", "code"], e2.default = p;
  }, function(t2, e2, n) {
    function r(t3) {
      return t3 && t3.__esModule ? t3 : { default: t3 };
    }
    function o(t3, e3, n2) {
      return e3 in t3 ? Object.defineProperty(t3, e3, { value: n2, enumerable: true, configurable: true, writable: true }) : t3[e3] = n2, t3;
    }
    function i2(t3, e3) {
      if (!(t3 instanceof e3)) throw new TypeError("Cannot call a class as a function");
    }
    function l(t3, e3) {
      if (e3 = (0, N.default)(true, { container: t3, modules: { clipboard: true, keyboard: true, history: true } }, e3), e3.theme && e3.theme !== S3.DEFAULTS.theme) {
        if (e3.theme = S3.import("themes/" + e3.theme), null == e3.theme) throw new Error("Invalid theme " + e3.theme + ". Did you register it?");
      } else e3.theme = T2.default;
      var n2 = (0, N.default)(true, {}, e3.theme.DEFAULTS);
      [n2, e3].forEach(function(t4) {
        t4.modules = t4.modules || {}, Object.keys(t4.modules).forEach(function(e4) {
          true === t4.modules[e4] && (t4.modules[e4] = {});
        });
      });
      var r2 = Object.keys(n2.modules).concat(Object.keys(e3.modules)), o2 = r2.reduce(function(t4, e4) {
        var n3 = S3.import("modules/" + e4);
        return null == n3 ? P.error("Cannot load " + e4 + " module. Are you sure you registered it?") : t4[e4] = n3.DEFAULTS || {}, t4;
      }, {});
      return null != e3.modules && e3.modules.toolbar && e3.modules.toolbar.constructor !== Object && (e3.modules.toolbar = { container: e3.modules.toolbar }), e3 = (0, N.default)(true, {}, S3.DEFAULTS, { modules: o2 }, n2, e3), ["bounds", "container", "scrollingContainer"].forEach(function(t4) {
        "string" == typeof e3[t4] && (e3[t4] = document.querySelector(e3[t4]));
      }), e3.modules = Object.keys(e3.modules).reduce(function(t4, n3) {
        return e3.modules[n3] && (t4[n3] = e3.modules[n3]), t4;
      }, {}), e3;
    }
    function a3(t3, e3, n2, r2) {
      if (this.options.strict && !this.isEnabled() && e3 === g.default.sources.USER) return new d3.default();
      var o2 = null == n2 ? null : this.getSelection(), i3 = this.editor.delta, l2 = t3();
      if (null != o2 && (true === n2 && (n2 = o2.index), null == r2 ? o2 = u2(o2, l2, e3) : 0 !== r2 && (o2 = u2(o2, n2, r2, e3)), this.setSelection(o2, g.default.sources.SILENT)), l2.length() > 0) {
        var a4, s4 = [g.default.events.TEXT_CHANGE, l2, i3, e3];
        if ((a4 = this.emitter).emit.apply(a4, [g.default.events.EDITOR_CHANGE].concat(s4)), e3 !== g.default.sources.SILENT) {
          var c3;
          (c3 = this.emitter).emit.apply(c3, s4);
        }
      }
      return l2;
    }
    function s3(t3, e3, n2, r2, o2) {
      var i3 = {};
      return "number" == typeof t3.index && "number" == typeof t3.length ? "number" != typeof e3 ? (o2 = r2, r2 = n2, n2 = e3, e3 = t3.length, t3 = t3.index) : (e3 = t3.length, t3 = t3.index) : "number" != typeof e3 && (o2 = r2, r2 = n2, n2 = e3, e3 = 0), "object" === (void 0 === n2 ? "undefined" : c2(n2)) ? (i3 = n2, o2 = r2) : "string" == typeof n2 && (null != r2 ? i3[n2] = r2 : o2 = n2), o2 = o2 || g.default.sources.API, [t3, e3, i3, o2];
    }
    function u2(t3, e3, n2, r2) {
      if (null == t3) return null;
      var o2 = void 0, i3 = void 0;
      if (e3 instanceof d3.default) {
        var l2 = [t3.index, t3.index + t3.length].map(function(t4) {
          return e3.transformPosition(t4, r2 !== g.default.sources.USER);
        }), a4 = f(l2, 2);
        o2 = a4[0], i3 = a4[1];
      } else {
        var s4 = [t3.index, t3.index + t3.length].map(function(t4) {
          return t4 < e3 || t4 === e3 && r2 === g.default.sources.USER ? t4 : n2 >= 0 ? t4 + n2 : Math.max(e3, t4 + n2);
        }), u3 = f(s4, 2);
        o2 = u3[0], i3 = u3[1];
      }
      return new x2.Range(o2, i3 - o2);
    }
    Object.defineProperty(e2, "__esModule", { value: true }), e2.default = e2.overload = e2.expandConfig = void 0;
    var c2 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t3) {
      return typeof t3;
    } : function(t3) {
      return t3 && "function" == typeof Symbol && t3.constructor === Symbol && t3 !== Symbol.prototype ? "symbol" : typeof t3;
    }, f = /* @__PURE__ */ (function() {
      function t3(t4, e3) {
        var n2 = [], r2 = true, o2 = false, i3 = void 0;
        try {
          for (var l2, a4 = t4[Symbol.iterator](); !(r2 = (l2 = a4.next()).done) && (n2.push(l2.value), !e3 || n2.length !== e3); r2 = true) ;
        } catch (t5) {
          o2 = true, i3 = t5;
        } finally {
          try {
            !r2 && a4.return && a4.return();
          } finally {
            if (o2) throw i3;
          }
        }
        return n2;
      }
      return function(e3, n2) {
        if (Array.isArray(e3)) return e3;
        if (Symbol.iterator in Object(e3)) return t3(e3, n2);
        throw new TypeError("Invalid attempt to destructure non-iterable instance");
      };
    })(), h3 = /* @__PURE__ */ (function() {
      function t3(t4, e3) {
        for (var n2 = 0; n2 < e3.length; n2++) {
          var r2 = e3[n2];
          r2.enumerable = r2.enumerable || false, r2.configurable = true, "value" in r2 && (r2.writable = true), Object.defineProperty(t4, r2.key, r2);
        }
      }
      return function(e3, n2, r2) {
        return n2 && t3(e3.prototype, n2), r2 && t3(e3, r2), e3;
      };
    })();
    n(53);
    var p = n(4), d3 = r(p), y3 = n(57), v = r(y3), b2 = n(9), g = r(b2), m3 = n(7), _ = r(m3), O2 = n(0), w2 = r(O2), x2 = n(22), k2 = r(x2), E2 = n(2), N = r(E2), j = n(10), A = r(j), q2 = n(32), T2 = r(q2), P = (0, A.default)("quill"), S3 = (function() {
      function t3(e3) {
        var n2 = this, r2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
        if (i2(this, t3), this.options = l(e3, r2), this.container = this.options.container, null == this.container) return P.error("Invalid Quill container", e3);
        this.options.debug && t3.debug(this.options.debug);
        var o2 = this.container.innerHTML.trim();
        this.container.classList.add("ql-container"), this.container.innerHTML = "", this.container.__quill = this, this.root = this.addContainer("ql-editor"), this.root.classList.add("ql-blank"), this.root.setAttribute("data-gramm", false), this.scrollingContainer = this.options.scrollingContainer || this.root, this.emitter = new g.default(), this.scroll = w2.default.create(this.root, { emitter: this.emitter, whitelist: this.options.formats }), this.editor = new v.default(this.scroll), this.selection = new k2.default(this.scroll, this.emitter), this.theme = new this.options.theme(this, this.options), this.keyboard = this.theme.addModule("keyboard"), this.clipboard = this.theme.addModule("clipboard"), this.history = this.theme.addModule("history"), this.theme.init(), this.emitter.on(g.default.events.EDITOR_CHANGE, function(t4) {
          t4 === g.default.events.TEXT_CHANGE && n2.root.classList.toggle("ql-blank", n2.editor.isBlank());
        }), this.emitter.on(g.default.events.SCROLL_UPDATE, function(t4, e4) {
          var r3 = n2.selection.lastRange, o3 = r3 && 0 === r3.length ? r3.index : void 0;
          a3.call(n2, function() {
            return n2.editor.update(null, e4, o3);
          }, t4);
        });
        var s4 = this.clipboard.convert(`<div class='ql-editor' style="white-space: normal;">` + o2 + "<p><br></p></div>");
        this.setContents(s4), this.history.clear(), this.options.placeholder && this.root.setAttribute("data-placeholder", this.options.placeholder), this.options.readOnly && this.disable();
      }
      return h3(t3, null, [{ key: "debug", value: function(t4) {
        true === t4 && (t4 = "log"), A.default.level(t4);
      } }, { key: "find", value: function(t4) {
        return t4.__quill || w2.default.find(t4);
      } }, { key: "import", value: function(t4) {
        return null == this.imports[t4] && P.error("Cannot import " + t4 + ". Are you sure it was registered?"), this.imports[t4];
      } }, { key: "register", value: function(t4, e3) {
        var n2 = this, r2 = arguments.length > 2 && void 0 !== arguments[2] && arguments[2];
        if ("string" != typeof t4) {
          var o2 = t4.attrName || t4.blotName;
          "string" == typeof o2 ? this.register("formats/" + o2, t4, e3) : Object.keys(t4).forEach(function(r3) {
            n2.register(r3, t4[r3], e3);
          });
        } else null == this.imports[t4] || r2 || P.warn("Overwriting " + t4 + " with", e3), this.imports[t4] = e3, (t4.startsWith("blots/") || t4.startsWith("formats/")) && "abstract" !== e3.blotName ? w2.default.register(e3) : t4.startsWith("modules") && "function" == typeof e3.register && e3.register();
      } }]), h3(t3, [{ key: "addContainer", value: function(t4) {
        var e3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null;
        if ("string" == typeof t4) {
          var n2 = t4;
          t4 = document.createElement("div"), t4.classList.add(n2);
        }
        return this.container.insertBefore(t4, e3), t4;
      } }, { key: "blur", value: function() {
        this.selection.setRange(null);
      } }, { key: "deleteText", value: function(t4, e3, n2) {
        var r2 = this, o2 = s3(t4, e3, n2), i3 = f(o2, 4);
        return t4 = i3[0], e3 = i3[1], n2 = i3[3], a3.call(this, function() {
          return r2.editor.deleteText(t4, e3);
        }, n2, t4, -1 * e3);
      } }, { key: "disable", value: function() {
        this.enable(false);
      } }, { key: "enable", value: function() {
        var t4 = !(arguments.length > 0 && void 0 !== arguments[0]) || arguments[0];
        this.scroll.enable(t4), this.container.classList.toggle("ql-disabled", !t4);
      } }, { key: "focus", value: function() {
        var t4 = this.scrollingContainer.scrollTop;
        this.selection.focus(), this.scrollingContainer.scrollTop = t4, this.scrollIntoView();
      } }, { key: "format", value: function(t4, e3) {
        var n2 = this, r2 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : g.default.sources.API;
        return a3.call(this, function() {
          var r3 = n2.getSelection(true), i3 = new d3.default();
          if (null == r3) return i3;
          if (w2.default.query(t4, w2.default.Scope.BLOCK)) i3 = n2.editor.formatLine(r3.index, r3.length, o({}, t4, e3));
          else {
            if (0 === r3.length) return n2.selection.format(t4, e3), i3;
            i3 = n2.editor.formatText(r3.index, r3.length, o({}, t4, e3));
          }
          return n2.setSelection(r3, g.default.sources.SILENT), i3;
        }, r2);
      } }, { key: "formatLine", value: function(t4, e3, n2, r2, o2) {
        var i3 = this, l2 = void 0, u3 = s3(t4, e3, n2, r2, o2), c3 = f(u3, 4);
        return t4 = c3[0], e3 = c3[1], l2 = c3[2], o2 = c3[3], a3.call(this, function() {
          return i3.editor.formatLine(t4, e3, l2);
        }, o2, t4, 0);
      } }, { key: "formatText", value: function(t4, e3, n2, r2, o2) {
        var i3 = this, l2 = void 0, u3 = s3(t4, e3, n2, r2, o2), c3 = f(u3, 4);
        return t4 = c3[0], e3 = c3[1], l2 = c3[2], o2 = c3[3], a3.call(this, function() {
          return i3.editor.formatText(t4, e3, l2);
        }, o2, t4, 0);
      } }, { key: "getBounds", value: function(t4) {
        var e3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0, n2 = void 0;
        n2 = "number" == typeof t4 ? this.selection.getBounds(t4, e3) : this.selection.getBounds(t4.index, t4.length);
        var r2 = this.container.getBoundingClientRect();
        return { bottom: n2.bottom - r2.top, height: n2.height, left: n2.left - r2.left, right: n2.right - r2.left, top: n2.top - r2.top, width: n2.width };
      } }, { key: "getContents", value: function() {
        var t4 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0, e3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : this.getLength() - t4, n2 = s3(t4, e3), r2 = f(n2, 2);
        return t4 = r2[0], e3 = r2[1], this.editor.getContents(t4, e3);
      } }, { key: "getFormat", value: function() {
        var t4 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : this.getSelection(true), e3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
        return "number" == typeof t4 ? this.editor.getFormat(t4, e3) : this.editor.getFormat(t4.index, t4.length);
      } }, { key: "getIndex", value: function(t4) {
        return t4.offset(this.scroll);
      } }, { key: "getLength", value: function() {
        return this.scroll.length();
      } }, { key: "getLeaf", value: function(t4) {
        return this.scroll.leaf(t4);
      } }, { key: "getLine", value: function(t4) {
        return this.scroll.line(t4);
      } }, { key: "getLines", value: function() {
        var t4 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0, e3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : Number.MAX_VALUE;
        return "number" != typeof t4 ? this.scroll.lines(t4.index, t4.length) : this.scroll.lines(t4, e3);
      } }, { key: "getModule", value: function(t4) {
        return this.theme.modules[t4];
      } }, { key: "getSelection", value: function() {
        return arguments.length > 0 && void 0 !== arguments[0] && arguments[0] && this.focus(), this.update(), this.selection.getRange()[0];
      } }, { key: "getText", value: function() {
        var t4 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0, e3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : this.getLength() - t4, n2 = s3(t4, e3), r2 = f(n2, 2);
        return t4 = r2[0], e3 = r2[1], this.editor.getText(t4, e3);
      } }, { key: "hasFocus", value: function() {
        return this.selection.hasFocus();
      } }, { key: "insertEmbed", value: function(e3, n2, r2) {
        var o2 = this, i3 = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : t3.sources.API;
        return a3.call(this, function() {
          return o2.editor.insertEmbed(e3, n2, r2);
        }, i3, e3);
      } }, { key: "insertText", value: function(t4, e3, n2, r2, o2) {
        var i3 = this, l2 = void 0, u3 = s3(t4, 0, n2, r2, o2), c3 = f(u3, 4);
        return t4 = c3[0], l2 = c3[2], o2 = c3[3], a3.call(this, function() {
          return i3.editor.insertText(t4, e3, l2);
        }, o2, t4, e3.length);
      } }, { key: "isEnabled", value: function() {
        return !this.container.classList.contains("ql-disabled");
      } }, { key: "off", value: function() {
        return this.emitter.off.apply(this.emitter, arguments);
      } }, { key: "on", value: function() {
        return this.emitter.on.apply(this.emitter, arguments);
      } }, { key: "once", value: function() {
        return this.emitter.once.apply(this.emitter, arguments);
      } }, { key: "pasteHTML", value: function(t4, e3, n2) {
        this.clipboard.dangerouslyPasteHTML(t4, e3, n2);
      } }, { key: "removeFormat", value: function(t4, e3, n2) {
        var r2 = this, o2 = s3(t4, e3, n2), i3 = f(o2, 4);
        return t4 = i3[0], e3 = i3[1], n2 = i3[3], a3.call(this, function() {
          return r2.editor.removeFormat(t4, e3);
        }, n2, t4);
      } }, { key: "scrollIntoView", value: function() {
        this.selection.scrollIntoView(this.scrollingContainer);
      } }, { key: "setContents", value: function(t4) {
        var e3 = this, n2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : g.default.sources.API;
        return a3.call(this, function() {
          t4 = new d3.default(t4);
          var n3 = e3.getLength(), r2 = e3.editor.deleteText(0, n3), o2 = e3.editor.applyDelta(t4), i3 = o2.ops[o2.ops.length - 1];
          return null != i3 && "string" == typeof i3.insert && "\n" === i3.insert[i3.insert.length - 1] && (e3.editor.deleteText(e3.getLength() - 1, 1), o2.delete(1)), r2.compose(o2);
        }, n2);
      } }, { key: "setSelection", value: function(e3, n2, r2) {
        if (null == e3) this.selection.setRange(null, n2 || t3.sources.API);
        else {
          var o2 = s3(e3, n2, r2), i3 = f(o2, 4);
          e3 = i3[0], n2 = i3[1], r2 = i3[3], this.selection.setRange(new x2.Range(e3, n2), r2), r2 !== g.default.sources.SILENT && this.selection.scrollIntoView(this.scrollingContainer);
        }
      } }, { key: "setText", value: function(t4) {
        var e3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : g.default.sources.API, n2 = new d3.default().insert(t4);
        return this.setContents(n2, e3);
      } }, { key: "update", value: function() {
        var t4 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : g.default.sources.USER, e3 = this.scroll.update(t4);
        return this.selection.update(t4), e3;
      } }, { key: "updateContents", value: function(t4) {
        var e3 = this, n2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : g.default.sources.API;
        return a3.call(this, function() {
          return t4 = new d3.default(t4), e3.editor.applyDelta(t4, n2);
        }, n2, true);
      } }]), t3;
    })();
    S3.DEFAULTS = { bounds: null, formats: null, modules: {}, placeholder: "", readOnly: false, scrollingContainer: null, strict: true, theme: "default" }, S3.events = g.default.events, S3.sources = g.default.sources, S3.version = "1.3.7", S3.imports = { delta: d3.default, parchment: w2.default, "core/module": _.default, "core/theme": T2.default }, e2.expandConfig = l, e2.overload = s3, e2.default = S3;
  }, function(t2, e2, n) {
    function r(t3, e3) {
      if (!(t3 instanceof e3)) throw new TypeError("Cannot call a class as a function");
    }
    Object.defineProperty(e2, "__esModule", { value: true });
    var o = function t3(e3) {
      var n2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
      r(this, t3), this.quill = e3, this.options = n2;
    };
    o.DEFAULTS = {}, e2.default = o;
  }, function(t2, e2, n) {
    function r(t3, e3) {
      if (!(t3 instanceof e3)) throw new TypeError("Cannot call a class as a function");
    }
    function o(t3, e3) {
      if (!t3) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      return !e3 || "object" != typeof e3 && "function" != typeof e3 ? t3 : e3;
    }
    function i2(t3, e3) {
      if ("function" != typeof e3 && null !== e3) throw new TypeError("Super expression must either be null or a function, not " + typeof e3);
      t3.prototype = Object.create(e3 && e3.prototype, { constructor: { value: t3, enumerable: false, writable: true, configurable: true } }), e3 && (Object.setPrototypeOf ? Object.setPrototypeOf(t3, e3) : t3.__proto__ = e3);
    }
    Object.defineProperty(e2, "__esModule", { value: true });
    var l = n(0), a3 = (function(t3) {
      return t3 && t3.__esModule ? t3 : { default: t3 };
    })(l), s3 = (function(t3) {
      function e3() {
        return r(this, e3), o(this, (e3.__proto__ || Object.getPrototypeOf(e3)).apply(this, arguments));
      }
      return i2(e3, t3), e3;
    })(a3.default.Text);
    e2.default = s3;
  }, function(t2, e2, n) {
    function r(t3) {
      return t3 && t3.__esModule ? t3 : { default: t3 };
    }
    function o(t3, e3) {
      if (!(t3 instanceof e3)) throw new TypeError("Cannot call a class as a function");
    }
    function i2(t3, e3) {
      if (!t3) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      return !e3 || "object" != typeof e3 && "function" != typeof e3 ? t3 : e3;
    }
    function l(t3, e3) {
      if ("function" != typeof e3 && null !== e3) throw new TypeError("Super expression must either be null or a function, not " + typeof e3);
      t3.prototype = Object.create(e3 && e3.prototype, { constructor: { value: t3, enumerable: false, writable: true, configurable: true } }), e3 && (Object.setPrototypeOf ? Object.setPrototypeOf(t3, e3) : t3.__proto__ = e3);
    }
    Object.defineProperty(e2, "__esModule", { value: true });
    var a3 = /* @__PURE__ */ (function() {
      function t3(t4, e3) {
        for (var n2 = 0; n2 < e3.length; n2++) {
          var r2 = e3[n2];
          r2.enumerable = r2.enumerable || false, r2.configurable = true, "value" in r2 && (r2.writable = true), Object.defineProperty(t4, r2.key, r2);
        }
      }
      return function(e3, n2, r2) {
        return n2 && t3(e3.prototype, n2), r2 && t3(e3, r2), e3;
      };
    })(), s3 = function t3(e3, n2, r2) {
      null === e3 && (e3 = Function.prototype);
      var o2 = Object.getOwnPropertyDescriptor(e3, n2);
      if (void 0 === o2) {
        var i3 = Object.getPrototypeOf(e3);
        return null === i3 ? void 0 : t3(i3, n2, r2);
      }
      if ("value" in o2) return o2.value;
      var l2 = o2.get;
      if (void 0 !== l2) return l2.call(r2);
    }, u2 = n(58), c2 = r(u2), f = n(10), h3 = r(f), p = (0, h3.default)("quill:events");
    ["selectionchange", "mousedown", "mouseup", "click"].forEach(function(t3) {
      document.addEventListener(t3, function() {
        for (var t4 = arguments.length, e3 = Array(t4), n2 = 0; n2 < t4; n2++) e3[n2] = arguments[n2];
        [].slice.call(document.querySelectorAll(".ql-container")).forEach(function(t5) {
          if (t5.__quill && t5.__quill.emitter) {
            var n3;
            (n3 = t5.__quill.emitter).handleDOM.apply(n3, e3);
          }
        });
      });
    });
    var d3 = (function(t3) {
      function e3() {
        o(this, e3);
        var t4 = i2(this, (e3.__proto__ || Object.getPrototypeOf(e3)).call(this));
        return t4.listeners = {}, t4.on("error", p.error), t4;
      }
      return l(e3, t3), a3(e3, [{ key: "emit", value: function() {
        p.log.apply(p, arguments), s3(e3.prototype.__proto__ || Object.getPrototypeOf(e3.prototype), "emit", this).apply(this, arguments);
      } }, { key: "handleDOM", value: function(t4) {
        for (var e4 = arguments.length, n2 = Array(e4 > 1 ? e4 - 1 : 0), r2 = 1; r2 < e4; r2++) n2[r2 - 1] = arguments[r2];
        (this.listeners[t4.type] || []).forEach(function(e5) {
          var r3 = e5.node, o2 = e5.handler;
          (t4.target === r3 || r3.contains(t4.target)) && o2.apply(void 0, [t4].concat(n2));
        });
      } }, { key: "listenDOM", value: function(t4, e4, n2) {
        this.listeners[t4] || (this.listeners[t4] = []), this.listeners[t4].push({ node: e4, handler: n2 });
      } }]), e3;
    })(c2.default);
    d3.events = { EDITOR_CHANGE: "editor-change", SCROLL_BEFORE_UPDATE: "scroll-before-update", SCROLL_OPTIMIZE: "scroll-optimize", SCROLL_UPDATE: "scroll-update", SELECTION_CHANGE: "selection-change", TEXT_CHANGE: "text-change" }, d3.sources = { API: "api", SILENT: "silent", USER: "user" }, e2.default = d3;
  }, function(t2, e2, n) {
    function r(t3) {
      if (i2.indexOf(t3) <= i2.indexOf(l)) {
        for (var e3, n2 = arguments.length, r2 = Array(n2 > 1 ? n2 - 1 : 0), o2 = 1; o2 < n2; o2++) r2[o2 - 1] = arguments[o2];
        (e3 = console)[t3].apply(e3, r2);
      }
    }
    function o(t3) {
      return i2.reduce(function(e3, n2) {
        return e3[n2] = r.bind(console, n2, t3), e3;
      }, {});
    }
    Object.defineProperty(e2, "__esModule", { value: true });
    var i2 = ["error", "warn", "log", "info"], l = "warn";
    r.level = o.level = function(t3) {
      l = t3;
    }, e2.default = o;
  }, function(t2, e2, n) {
    Object.defineProperty(e2, "__esModule", { value: true });
    var r = n(1), o = (function() {
      function t3(t4, e3, n2) {
        void 0 === n2 && (n2 = {}), this.attrName = t4, this.keyName = e3;
        var o2 = r.Scope.TYPE & r.Scope.ATTRIBUTE;
        null != n2.scope ? this.scope = n2.scope & r.Scope.LEVEL | o2 : this.scope = r.Scope.ATTRIBUTE, null != n2.whitelist && (this.whitelist = n2.whitelist);
      }
      return t3.keys = function(t4) {
        return [].map.call(t4.attributes, function(t5) {
          return t5.name;
        });
      }, t3.prototype.add = function(t4, e3) {
        return !!this.canAdd(t4, e3) && (t4.setAttribute(this.keyName, e3), true);
      }, t3.prototype.canAdd = function(t4, e3) {
        return null != r.query(t4, r.Scope.BLOT & (this.scope | r.Scope.TYPE)) && (null == this.whitelist || ("string" == typeof e3 ? this.whitelist.indexOf(e3.replace(/["']/g, "")) > -1 : this.whitelist.indexOf(e3) > -1));
      }, t3.prototype.remove = function(t4) {
        t4.removeAttribute(this.keyName);
      }, t3.prototype.value = function(t4) {
        var e3 = t4.getAttribute(this.keyName);
        return this.canAdd(t4, e3) && e3 ? e3 : "";
      }, t3;
    })();
    e2.default = o;
  }, function(t2, e2, n) {
    function r(t3) {
      return null === t3 || void 0 === t3;
    }
    function o(t3) {
      return !(!t3 || "object" != typeof t3 || "number" != typeof t3.length) && ("function" == typeof t3.copy && "function" == typeof t3.slice && !(t3.length > 0 && "number" != typeof t3[0]));
    }
    function i2(t3, e3, n2) {
      var i3, c2;
      if (r(t3) || r(e3)) return false;
      if (t3.prototype !== e3.prototype) return false;
      if (s3(t3)) return !!s3(e3) && (t3 = l.call(t3), e3 = l.call(e3), u2(t3, e3, n2));
      if (o(t3)) {
        if (!o(e3)) return false;
        if (t3.length !== e3.length) return false;
        for (i3 = 0; i3 < t3.length; i3++) if (t3[i3] !== e3[i3]) return false;
        return true;
      }
      try {
        var f = a3(t3), h3 = a3(e3);
      } catch (t4) {
        return false;
      }
      if (f.length != h3.length) return false;
      for (f.sort(), h3.sort(), i3 = f.length - 1; i3 >= 0; i3--) if (f[i3] != h3[i3]) return false;
      for (i3 = f.length - 1; i3 >= 0; i3--) if (c2 = f[i3], !u2(t3[c2], e3[c2], n2)) return false;
      return typeof t3 == typeof e3;
    }
    var l = Array.prototype.slice, a3 = n(55), s3 = n(56), u2 = t2.exports = function(t3, e3, n2) {
      return n2 || (n2 = {}), t3 === e3 || (t3 instanceof Date && e3 instanceof Date ? t3.getTime() === e3.getTime() : !t3 || !e3 || "object" != typeof t3 && "object" != typeof e3 ? n2.strict ? t3 === e3 : t3 == e3 : i2(t3, e3, n2));
    };
  }, function(t2, e2, n) {
    function r(t3) {
      return t3 && t3.__esModule ? t3 : { default: t3 };
    }
    function o(t3, e3) {
      if (!(t3 instanceof e3)) throw new TypeError("Cannot call a class as a function");
    }
    function i2(t3, e3) {
      if (!t3) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      return !e3 || "object" != typeof e3 && "function" != typeof e3 ? t3 : e3;
    }
    function l(t3, e3) {
      if ("function" != typeof e3 && null !== e3) throw new TypeError("Super expression must either be null or a function, not " + typeof e3);
      t3.prototype = Object.create(e3 && e3.prototype, { constructor: { value: t3, enumerable: false, writable: true, configurable: true } }), e3 && (Object.setPrototypeOf ? Object.setPrototypeOf(t3, e3) : t3.__proto__ = e3);
    }
    Object.defineProperty(e2, "__esModule", { value: true }), e2.default = e2.Code = void 0;
    var a3 = /* @__PURE__ */ (function() {
      function t3(t4, e3) {
        var n2 = [], r2 = true, o2 = false, i3 = void 0;
        try {
          for (var l2, a4 = t4[Symbol.iterator](); !(r2 = (l2 = a4.next()).done) && (n2.push(l2.value), !e3 || n2.length !== e3); r2 = true) ;
        } catch (t5) {
          o2 = true, i3 = t5;
        } finally {
          try {
            !r2 && a4.return && a4.return();
          } finally {
            if (o2) throw i3;
          }
        }
        return n2;
      }
      return function(e3, n2) {
        if (Array.isArray(e3)) return e3;
        if (Symbol.iterator in Object(e3)) return t3(e3, n2);
        throw new TypeError("Invalid attempt to destructure non-iterable instance");
      };
    })(), s3 = /* @__PURE__ */ (function() {
      function t3(t4, e3) {
        for (var n2 = 0; n2 < e3.length; n2++) {
          var r2 = e3[n2];
          r2.enumerable = r2.enumerable || false, r2.configurable = true, "value" in r2 && (r2.writable = true), Object.defineProperty(t4, r2.key, r2);
        }
      }
      return function(e3, n2, r2) {
        return n2 && t3(e3.prototype, n2), r2 && t3(e3, r2), e3;
      };
    })(), u2 = function t3(e3, n2, r2) {
      null === e3 && (e3 = Function.prototype);
      var o2 = Object.getOwnPropertyDescriptor(e3, n2);
      if (void 0 === o2) {
        var i3 = Object.getPrototypeOf(e3);
        return null === i3 ? void 0 : t3(i3, n2, r2);
      }
      if ("value" in o2) return o2.value;
      var l2 = o2.get;
      if (void 0 !== l2) return l2.call(r2);
    }, c2 = n(4), f = r(c2), h3 = n(0), p = r(h3), d3 = n(3), y3 = r(d3), v = n(5), b2 = r(v), g = n(8), m3 = r(g), _ = (function(t3) {
      function e3() {
        return o(this, e3), i2(this, (e3.__proto__ || Object.getPrototypeOf(e3)).apply(this, arguments));
      }
      return l(e3, t3), e3;
    })(b2.default);
    _.blotName = "code", _.tagName = "CODE";
    var O2 = (function(t3) {
      function e3() {
        return o(this, e3), i2(this, (e3.__proto__ || Object.getPrototypeOf(e3)).apply(this, arguments));
      }
      return l(e3, t3), s3(e3, [{ key: "delta", value: function() {
        var t4 = this, e4 = this.domNode.textContent;
        return e4.endsWith("\n") && (e4 = e4.slice(0, -1)), e4.split("\n").reduce(function(e5, n2) {
          return e5.insert(n2).insert("\n", t4.formats());
        }, new f.default());
      } }, { key: "format", value: function(t4, n2) {
        if (t4 !== this.statics.blotName || !n2) {
          var r2 = this.descendant(m3.default, this.length() - 1), o2 = a3(r2, 1), i3 = o2[0];
          null != i3 && i3.deleteAt(i3.length() - 1, 1), u2(e3.prototype.__proto__ || Object.getPrototypeOf(e3.prototype), "format", this).call(this, t4, n2);
        }
      } }, { key: "formatAt", value: function(t4, n2, r2, o2) {
        if (0 !== n2 && null != p.default.query(r2, p.default.Scope.BLOCK) && (r2 !== this.statics.blotName || o2 !== this.statics.formats(this.domNode))) {
          var i3 = this.newlineIndex(t4);
          if (!(i3 < 0 || i3 >= t4 + n2)) {
            var l2 = this.newlineIndex(t4, true) + 1, a4 = i3 - l2 + 1, s4 = this.isolate(l2, a4), u3 = s4.next;
            s4.format(r2, o2), u3 instanceof e3 && u3.formatAt(0, t4 - l2 + n2 - a4, r2, o2);
          }
        }
      } }, { key: "insertAt", value: function(t4, e4, n2) {
        if (null == n2) {
          var r2 = this.descendant(m3.default, t4), o2 = a3(r2, 2), i3 = o2[0], l2 = o2[1];
          i3.insertAt(l2, e4);
        }
      } }, { key: "length", value: function() {
        var t4 = this.domNode.textContent.length;
        return this.domNode.textContent.endsWith("\n") ? t4 : t4 + 1;
      } }, { key: "newlineIndex", value: function(t4) {
        if (arguments.length > 1 && void 0 !== arguments[1] && arguments[1]) return this.domNode.textContent.slice(0, t4).lastIndexOf("\n");
        var e4 = this.domNode.textContent.slice(t4).indexOf("\n");
        return e4 > -1 ? t4 + e4 : -1;
      } }, { key: "optimize", value: function(t4) {
        this.domNode.textContent.endsWith("\n") || this.appendChild(p.default.create("text", "\n")), u2(e3.prototype.__proto__ || Object.getPrototypeOf(e3.prototype), "optimize", this).call(this, t4);
        var n2 = this.next;
        null != n2 && n2.prev === this && n2.statics.blotName === this.statics.blotName && this.statics.formats(this.domNode) === n2.statics.formats(n2.domNode) && (n2.optimize(t4), n2.moveChildren(this), n2.remove());
      } }, { key: "replace", value: function(t4) {
        u2(e3.prototype.__proto__ || Object.getPrototypeOf(e3.prototype), "replace", this).call(this, t4), [].slice.call(this.domNode.querySelectorAll("*")).forEach(function(t5) {
          var e4 = p.default.find(t5);
          null == e4 ? t5.parentNode.removeChild(t5) : e4 instanceof p.default.Embed ? e4.remove() : e4.unwrap();
        });
      } }], [{ key: "create", value: function(t4) {
        var n2 = u2(e3.__proto__ || Object.getPrototypeOf(e3), "create", this).call(this, t4);
        return n2.setAttribute("spellcheck", false), n2;
      } }, { key: "formats", value: function() {
        return true;
      } }]), e3;
    })(y3.default);
    O2.blotName = "code-block", O2.tagName = "PRE", O2.TAB = "  ", e2.Code = _, e2.default = O2;
  }, function(t2, e2, n) {
    function r(t3, e3) {
      if (!(t3 instanceof e3)) throw new TypeError("Cannot call a class as a function");
    }
    function o(t3, e3) {
      if (!t3) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      return !e3 || "object" != typeof e3 && "function" != typeof e3 ? t3 : e3;
    }
    function i2(t3, e3) {
      if ("function" != typeof e3 && null !== e3) throw new TypeError("Super expression must either be null or a function, not " + typeof e3);
      t3.prototype = Object.create(e3 && e3.prototype, { constructor: { value: t3, enumerable: false, writable: true, configurable: true } }), e3 && (Object.setPrototypeOf ? Object.setPrototypeOf(t3, e3) : t3.__proto__ = e3);
    }
    Object.defineProperty(e2, "__esModule", { value: true });
    var l = /* @__PURE__ */ (function() {
      function t3(t4, e3) {
        for (var n2 = 0; n2 < e3.length; n2++) {
          var r2 = e3[n2];
          r2.enumerable = r2.enumerable || false, r2.configurable = true, "value" in r2 && (r2.writable = true), Object.defineProperty(t4, r2.key, r2);
        }
      }
      return function(e3, n2, r2) {
        return n2 && t3(e3.prototype, n2), r2 && t3(e3, r2), e3;
      };
    })(), a3 = function t3(e3, n2, r2) {
      null === e3 && (e3 = Function.prototype);
      var o2 = Object.getOwnPropertyDescriptor(e3, n2);
      if (void 0 === o2) {
        var i3 = Object.getPrototypeOf(e3);
        return null === i3 ? void 0 : t3(i3, n2, r2);
      }
      if ("value" in o2) return o2.value;
      var l2 = o2.get;
      if (void 0 !== l2) return l2.call(r2);
    }, s3 = n(0), u2 = (function(t3) {
      return t3 && t3.__esModule ? t3 : { default: t3 };
    })(s3), c2 = (function(t3) {
      function e3() {
        return r(this, e3), o(this, (e3.__proto__ || Object.getPrototypeOf(e3)).apply(this, arguments));
      }
      return i2(e3, t3), l(e3, [{ key: "insertInto", value: function(t4, n2) {
        0 === t4.children.length ? a3(e3.prototype.__proto__ || Object.getPrototypeOf(e3.prototype), "insertInto", this).call(this, t4, n2) : this.remove();
      } }, { key: "length", value: function() {
        return 0;
      } }, { key: "value", value: function() {
        return "";
      } }], [{ key: "value", value: function() {
      } }]), e3;
    })(u2.default.Embed);
    c2.blotName = "break", c2.tagName = "BR", e2.default = c2;
  }, function(t2, e2, n) {
    function r(t3, e3) {
      if (!(t3 instanceof e3)) throw new TypeError("Cannot call a class as a function");
    }
    function o(t3, e3) {
      if (!t3) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      return !e3 || "object" != typeof e3 && "function" != typeof e3 ? t3 : e3;
    }
    function i2(t3, e3) {
      if ("function" != typeof e3 && null !== e3) throw new TypeError("Super expression must either be null or a function, not " + typeof e3);
      t3.prototype = Object.create(e3 && e3.prototype, { constructor: { value: t3, enumerable: false, writable: true, configurable: true } }), e3 && (Object.setPrototypeOf ? Object.setPrototypeOf(t3, e3) : t3.__proto__ = e3);
    }
    function l(t3, e3) {
      var n2 = document.createElement("a");
      n2.href = t3;
      var r2 = n2.href.slice(0, n2.href.indexOf(":"));
      return e3.indexOf(r2) > -1;
    }
    Object.defineProperty(e2, "__esModule", { value: true }), e2.sanitize = e2.default = void 0;
    var a3 = /* @__PURE__ */ (function() {
      function t3(t4, e3) {
        for (var n2 = 0; n2 < e3.length; n2++) {
          var r2 = e3[n2];
          r2.enumerable = r2.enumerable || false, r2.configurable = true, "value" in r2 && (r2.writable = true), Object.defineProperty(t4, r2.key, r2);
        }
      }
      return function(e3, n2, r2) {
        return n2 && t3(e3.prototype, n2), r2 && t3(e3, r2), e3;
      };
    })(), s3 = function t3(e3, n2, r2) {
      null === e3 && (e3 = Function.prototype);
      var o2 = Object.getOwnPropertyDescriptor(e3, n2);
      if (void 0 === o2) {
        var i3 = Object.getPrototypeOf(e3);
        return null === i3 ? void 0 : t3(i3, n2, r2);
      }
      if ("value" in o2) return o2.value;
      var l2 = o2.get;
      if (void 0 !== l2) return l2.call(r2);
    }, u2 = n(5), c2 = (function(t3) {
      return t3 && t3.__esModule ? t3 : { default: t3 };
    })(u2), f = (function(t3) {
      function e3() {
        return r(this, e3), o(this, (e3.__proto__ || Object.getPrototypeOf(e3)).apply(this, arguments));
      }
      return i2(e3, t3), a3(e3, [{ key: "format", value: function(t4, n2) {
        if (t4 !== this.statics.blotName || !n2) return s3(e3.prototype.__proto__ || Object.getPrototypeOf(e3.prototype), "format", this).call(this, t4, n2);
        n2 = this.constructor.sanitize(n2), this.domNode.setAttribute("href", n2);
      } }], [{ key: "create", value: function(t4) {
        var n2 = s3(e3.__proto__ || Object.getPrototypeOf(e3), "create", this).call(this, t4);
        return t4 = this.sanitize(t4), n2.setAttribute("href", t4), n2.setAttribute("rel", "noopener noreferrer"), n2.setAttribute("target", "_blank"), n2;
      } }, { key: "formats", value: function(t4) {
        return t4.getAttribute("href");
      } }, { key: "sanitize", value: function(t4) {
        return l(t4, this.PROTOCOL_WHITELIST) ? t4 : this.SANITIZED_URL;
      } }]), e3;
    })(c2.default);
    f.blotName = "link", f.tagName = "A", f.SANITIZED_URL = "about:blank", f.PROTOCOL_WHITELIST = ["http", "https", "mailto", "tel"], e2.default = f, e2.sanitize = l;
  }, function(t2, e2, n) {
    function r(t3) {
      return t3 && t3.__esModule ? t3 : { default: t3 };
    }
    function o(t3, e3) {
      if (!(t3 instanceof e3)) throw new TypeError("Cannot call a class as a function");
    }
    function i2(t3, e3) {
      t3.setAttribute(e3, !("true" === t3.getAttribute(e3)));
    }
    Object.defineProperty(e2, "__esModule", { value: true });
    var l = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t3) {
      return typeof t3;
    } : function(t3) {
      return t3 && "function" == typeof Symbol && t3.constructor === Symbol && t3 !== Symbol.prototype ? "symbol" : typeof t3;
    }, a3 = /* @__PURE__ */ (function() {
      function t3(t4, e3) {
        for (var n2 = 0; n2 < e3.length; n2++) {
          var r2 = e3[n2];
          r2.enumerable = r2.enumerable || false, r2.configurable = true, "value" in r2 && (r2.writable = true), Object.defineProperty(t4, r2.key, r2);
        }
      }
      return function(e3, n2, r2) {
        return n2 && t3(e3.prototype, n2), r2 && t3(e3, r2), e3;
      };
    })(), s3 = n(25), u2 = r(s3), c2 = n(106), f = r(c2), h3 = 0, p = (function() {
      function t3(e3) {
        var n2 = this;
        o(this, t3), this.select = e3, this.container = document.createElement("span"), this.buildPicker(), this.select.style.display = "none", this.select.parentNode.insertBefore(this.container, this.select), this.label.addEventListener("mousedown", function() {
          n2.togglePicker();
        }), this.label.addEventListener("keydown", function(t4) {
          switch (t4.keyCode) {
            case u2.default.keys.ENTER:
              n2.togglePicker();
              break;
            case u2.default.keys.ESCAPE:
              n2.escape(), t4.preventDefault();
          }
        }), this.select.addEventListener("change", this.update.bind(this));
      }
      return a3(t3, [{ key: "togglePicker", value: function() {
        this.container.classList.toggle("ql-expanded"), i2(this.label, "aria-expanded"), i2(this.options, "aria-hidden");
      } }, { key: "buildItem", value: function(t4) {
        var e3 = this, n2 = document.createElement("span");
        return n2.tabIndex = "0", n2.setAttribute("role", "button"), n2.classList.add("ql-picker-item"), t4.hasAttribute("value") && n2.setAttribute("data-value", t4.getAttribute("value")), t4.textContent && n2.setAttribute("data-label", t4.textContent), n2.addEventListener("click", function() {
          e3.selectItem(n2, true);
        }), n2.addEventListener("keydown", function(t5) {
          switch (t5.keyCode) {
            case u2.default.keys.ENTER:
              e3.selectItem(n2, true), t5.preventDefault();
              break;
            case u2.default.keys.ESCAPE:
              e3.escape(), t5.preventDefault();
          }
        }), n2;
      } }, { key: "buildLabel", value: function() {
        var t4 = document.createElement("span");
        return t4.classList.add("ql-picker-label"), t4.innerHTML = f.default, t4.tabIndex = "0", t4.setAttribute("role", "button"), t4.setAttribute("aria-expanded", "false"), this.container.appendChild(t4), t4;
      } }, { key: "buildOptions", value: function() {
        var t4 = this, e3 = document.createElement("span");
        e3.classList.add("ql-picker-options"), e3.setAttribute("aria-hidden", "true"), e3.tabIndex = "-1", e3.id = "ql-picker-options-" + h3, h3 += 1, this.label.setAttribute("aria-controls", e3.id), this.options = e3, [].slice.call(this.select.options).forEach(function(n2) {
          var r2 = t4.buildItem(n2);
          e3.appendChild(r2), true === n2.selected && t4.selectItem(r2);
        }), this.container.appendChild(e3);
      } }, { key: "buildPicker", value: function() {
        var t4 = this;
        [].slice.call(this.select.attributes).forEach(function(e3) {
          t4.container.setAttribute(e3.name, e3.value);
        }), this.container.classList.add("ql-picker"), this.label = this.buildLabel(), this.buildOptions();
      } }, { key: "escape", value: function() {
        var t4 = this;
        this.close(), setTimeout(function() {
          return t4.label.focus();
        }, 1);
      } }, { key: "close", value: function() {
        this.container.classList.remove("ql-expanded"), this.label.setAttribute("aria-expanded", "false"), this.options.setAttribute("aria-hidden", "true");
      } }, { key: "selectItem", value: function(t4) {
        var e3 = arguments.length > 1 && void 0 !== arguments[1] && arguments[1], n2 = this.container.querySelector(".ql-selected");
        if (t4 !== n2 && (null != n2 && n2.classList.remove("ql-selected"), null != t4 && (t4.classList.add("ql-selected"), this.select.selectedIndex = [].indexOf.call(t4.parentNode.children, t4), t4.hasAttribute("data-value") ? this.label.setAttribute("data-value", t4.getAttribute("data-value")) : this.label.removeAttribute("data-value"), t4.hasAttribute("data-label") ? this.label.setAttribute("data-label", t4.getAttribute("data-label")) : this.label.removeAttribute("data-label"), e3))) {
          if ("function" == typeof Event) this.select.dispatchEvent(new Event("change"));
          else if ("object" === ("undefined" == typeof Event ? "undefined" : l(Event))) {
            var r2 = document.createEvent("Event");
            r2.initEvent("change", true, true), this.select.dispatchEvent(r2);
          }
          this.close();
        }
      } }, { key: "update", value: function() {
        var t4 = void 0;
        if (this.select.selectedIndex > -1) {
          var e3 = this.container.querySelector(".ql-picker-options").children[this.select.selectedIndex];
          t4 = this.select.options[this.select.selectedIndex], this.selectItem(e3);
        } else this.selectItem(null);
        var n2 = null != t4 && t4 !== this.select.querySelector("option[selected]");
        this.label.classList.toggle("ql-active", n2);
      } }]), t3;
    })();
    e2.default = p;
  }, function(t2, e2, n) {
    function r(t3) {
      var e3 = a3.find(t3);
      if (null == e3) try {
        e3 = a3.create(t3);
      } catch (n2) {
        e3 = a3.create(a3.Scope.INLINE), [].slice.call(t3.childNodes).forEach(function(t4) {
          e3.domNode.appendChild(t4);
        }), t3.parentNode && t3.parentNode.replaceChild(e3.domNode, t3), e3.attach();
      }
      return e3;
    }
    var o = this && this.__extends || (function() {
      var t3 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t4, e3) {
        t4.__proto__ = e3;
      } || function(t4, e3) {
        for (var n2 in e3) e3.hasOwnProperty(n2) && (t4[n2] = e3[n2]);
      };
      return function(e3, n2) {
        function r2() {
          this.constructor = e3;
        }
        t3(e3, n2), e3.prototype = null === n2 ? Object.create(n2) : (r2.prototype = n2.prototype, new r2());
      };
    })();
    Object.defineProperty(e2, "__esModule", { value: true });
    var i2 = n(47), l = n(27), a3 = n(1), s3 = (function(t3) {
      function e3(e4) {
        var n2 = t3.call(this, e4) || this;
        return n2.build(), n2;
      }
      return o(e3, t3), e3.prototype.appendChild = function(t4) {
        this.insertBefore(t4);
      }, e3.prototype.attach = function() {
        t3.prototype.attach.call(this), this.children.forEach(function(t4) {
          t4.attach();
        });
      }, e3.prototype.build = function() {
        var t4 = this;
        this.children = new i2.default(), [].slice.call(this.domNode.childNodes).reverse().forEach(function(e4) {
          try {
            var n2 = r(e4);
            t4.insertBefore(n2, t4.children.head || void 0);
          } catch (t5) {
            if (t5 instanceof a3.ParchmentError) return;
            throw t5;
          }
        });
      }, e3.prototype.deleteAt = function(t4, e4) {
        if (0 === t4 && e4 === this.length()) return this.remove();
        this.children.forEachAt(t4, e4, function(t5, e5, n2) {
          t5.deleteAt(e5, n2);
        });
      }, e3.prototype.descendant = function(t4, n2) {
        var r2 = this.children.find(n2), o2 = r2[0], i3 = r2[1];
        return null == t4.blotName && t4(o2) || null != t4.blotName && o2 instanceof t4 ? [o2, i3] : o2 instanceof e3 ? o2.descendant(t4, i3) : [null, -1];
      }, e3.prototype.descendants = function(t4, n2, r2) {
        void 0 === n2 && (n2 = 0), void 0 === r2 && (r2 = Number.MAX_VALUE);
        var o2 = [], i3 = r2;
        return this.children.forEachAt(n2, r2, function(n3, r3, l2) {
          (null == t4.blotName && t4(n3) || null != t4.blotName && n3 instanceof t4) && o2.push(n3), n3 instanceof e3 && (o2 = o2.concat(n3.descendants(t4, r3, i3))), i3 -= l2;
        }), o2;
      }, e3.prototype.detach = function() {
        this.children.forEach(function(t4) {
          t4.detach();
        }), t3.prototype.detach.call(this);
      }, e3.prototype.formatAt = function(t4, e4, n2, r2) {
        this.children.forEachAt(t4, e4, function(t5, e5, o2) {
          t5.formatAt(e5, o2, n2, r2);
        });
      }, e3.prototype.insertAt = function(t4, e4, n2) {
        var r2 = this.children.find(t4), o2 = r2[0], i3 = r2[1];
        if (o2) o2.insertAt(i3, e4, n2);
        else {
          var l2 = null == n2 ? a3.create("text", e4) : a3.create(e4, n2);
          this.appendChild(l2);
        }
      }, e3.prototype.insertBefore = function(t4, e4) {
        if (null != this.statics.allowedChildren && !this.statics.allowedChildren.some(function(e5) {
          return t4 instanceof e5;
        })) throw new a3.ParchmentError("Cannot insert " + t4.statics.blotName + " into " + this.statics.blotName);
        t4.insertInto(this, e4);
      }, e3.prototype.length = function() {
        return this.children.reduce(function(t4, e4) {
          return t4 + e4.length();
        }, 0);
      }, e3.prototype.moveChildren = function(t4, e4) {
        this.children.forEach(function(n2) {
          t4.insertBefore(n2, e4);
        });
      }, e3.prototype.optimize = function(e4) {
        if (t3.prototype.optimize.call(this, e4), 0 === this.children.length) if (null != this.statics.defaultChild) {
          var n2 = a3.create(this.statics.defaultChild);
          this.appendChild(n2), n2.optimize(e4);
        } else this.remove();
      }, e3.prototype.path = function(t4, n2) {
        void 0 === n2 && (n2 = false);
        var r2 = this.children.find(t4, n2), o2 = r2[0], i3 = r2[1], l2 = [[this, t4]];
        return o2 instanceof e3 ? l2.concat(o2.path(i3, n2)) : (null != o2 && l2.push([o2, i3]), l2);
      }, e3.prototype.removeChild = function(t4) {
        this.children.remove(t4);
      }, e3.prototype.replace = function(n2) {
        n2 instanceof e3 && n2.moveChildren(this), t3.prototype.replace.call(this, n2);
      }, e3.prototype.split = function(t4, e4) {
        if (void 0 === e4 && (e4 = false), !e4) {
          if (0 === t4) return this;
          if (t4 === this.length()) return this.next;
        }
        var n2 = this.clone();
        return this.parent.insertBefore(n2, this.next), this.children.forEachAt(t4, this.length(), function(t5, r2, o2) {
          t5 = t5.split(r2, e4), n2.appendChild(t5);
        }), n2;
      }, e3.prototype.unwrap = function() {
        this.moveChildren(this.parent, this.next), this.remove();
      }, e3.prototype.update = function(t4, e4) {
        var n2 = this, o2 = [], i3 = [];
        t4.forEach(function(t5) {
          t5.target === n2.domNode && "childList" === t5.type && (o2.push.apply(o2, t5.addedNodes), i3.push.apply(i3, t5.removedNodes));
        }), i3.forEach(function(t5) {
          if (!(null != t5.parentNode && "IFRAME" !== t5.tagName && document.body.compareDocumentPosition(t5) & Node.DOCUMENT_POSITION_CONTAINED_BY)) {
            var e5 = a3.find(t5);
            null != e5 && (null != e5.domNode.parentNode && e5.domNode.parentNode !== n2.domNode || e5.detach());
          }
        }), o2.filter(function(t5) {
          return t5.parentNode == n2.domNode;
        }).sort(function(t5, e5) {
          return t5 === e5 ? 0 : t5.compareDocumentPosition(e5) & Node.DOCUMENT_POSITION_FOLLOWING ? 1 : -1;
        }).forEach(function(t5) {
          var e5 = null;
          null != t5.nextSibling && (e5 = a3.find(t5.nextSibling));
          var o3 = r(t5);
          o3.next == e5 && null != o3.next || (null != o3.parent && o3.parent.removeChild(n2), n2.insertBefore(o3, e5 || void 0));
        });
      }, e3;
    })(l.default);
    e2.default = s3;
  }, function(t2, e2, n) {
    var r = this && this.__extends || (function() {
      var t3 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t4, e3) {
        t4.__proto__ = e3;
      } || function(t4, e3) {
        for (var n2 in e3) e3.hasOwnProperty(n2) && (t4[n2] = e3[n2]);
      };
      return function(e3, n2) {
        function r2() {
          this.constructor = e3;
        }
        t3(e3, n2), e3.prototype = null === n2 ? Object.create(n2) : (r2.prototype = n2.prototype, new r2());
      };
    })();
    Object.defineProperty(e2, "__esModule", { value: true });
    var o = n(11), i2 = n(28), l = n(17), a3 = n(1), s3 = (function(t3) {
      function e3(e4) {
        var n2 = t3.call(this, e4) || this;
        return n2.attributes = new i2.default(n2.domNode), n2;
      }
      return r(e3, t3), e3.formats = function(t4) {
        return "string" == typeof this.tagName || (Array.isArray(this.tagName) ? t4.tagName.toLowerCase() : void 0);
      }, e3.prototype.format = function(t4, e4) {
        var n2 = a3.query(t4);
        n2 instanceof o.default ? this.attributes.attribute(n2, e4) : e4 && (null == n2 || t4 === this.statics.blotName && this.formats()[t4] === e4 || this.replaceWith(t4, e4));
      }, e3.prototype.formats = function() {
        var t4 = this.attributes.values(), e4 = this.statics.formats(this.domNode);
        return null != e4 && (t4[this.statics.blotName] = e4), t4;
      }, e3.prototype.replaceWith = function(e4, n2) {
        var r2 = t3.prototype.replaceWith.call(this, e4, n2);
        return this.attributes.copy(r2), r2;
      }, e3.prototype.update = function(e4, n2) {
        var r2 = this;
        t3.prototype.update.call(this, e4, n2), e4.some(function(t4) {
          return t4.target === r2.domNode && "attributes" === t4.type;
        }) && this.attributes.build();
      }, e3.prototype.wrap = function(n2, r2) {
        var o2 = t3.prototype.wrap.call(this, n2, r2);
        return o2 instanceof e3 && o2.statics.scope === this.statics.scope && this.attributes.move(o2), o2;
      }, e3;
    })(l.default);
    e2.default = s3;
  }, function(t2, e2, n) {
    var r = this && this.__extends || (function() {
      var t3 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t4, e3) {
        t4.__proto__ = e3;
      } || function(t4, e3) {
        for (var n2 in e3) e3.hasOwnProperty(n2) && (t4[n2] = e3[n2]);
      };
      return function(e3, n2) {
        function r2() {
          this.constructor = e3;
        }
        t3(e3, n2), e3.prototype = null === n2 ? Object.create(n2) : (r2.prototype = n2.prototype, new r2());
      };
    })();
    Object.defineProperty(e2, "__esModule", { value: true });
    var o = n(27), i2 = n(1), l = (function(t3) {
      function e3() {
        return null !== t3 && t3.apply(this, arguments) || this;
      }
      return r(e3, t3), e3.value = function(t4) {
        return true;
      }, e3.prototype.index = function(t4, e4) {
        return this.domNode === t4 || this.domNode.compareDocumentPosition(t4) & Node.DOCUMENT_POSITION_CONTAINED_BY ? Math.min(e4, 1) : -1;
      }, e3.prototype.position = function(t4, e4) {
        var n2 = [].indexOf.call(this.parent.domNode.childNodes, this.domNode);
        return t4 > 0 && (n2 += 1), [this.parent.domNode, n2];
      }, e3.prototype.value = function() {
        var t4;
        return t4 = {}, t4[this.statics.blotName] = this.statics.value(this.domNode) || true, t4;
      }, e3.scope = i2.Scope.INLINE_BLOT, e3;
    })(o.default);
    e2.default = l;
  }, function(t2, e2, n) {
    function r(t3) {
      this.ops = t3, this.index = 0, this.offset = 0;
    }
    var o = n(12), i2 = n(2), l = { attributes: { compose: function(t3, e3, n2) {
      "object" != typeof t3 && (t3 = {}), "object" != typeof e3 && (e3 = {});
      var r2 = i2(true, {}, e3);
      n2 || (r2 = Object.keys(r2).reduce(function(t4, e4) {
        return null != r2[e4] && (t4[e4] = r2[e4]), t4;
      }, {}));
      for (var o2 in t3) void 0 !== t3[o2] && void 0 === e3[o2] && (r2[o2] = t3[o2]);
      return Object.keys(r2).length > 0 ? r2 : void 0;
    }, diff: function(t3, e3) {
      "object" != typeof t3 && (t3 = {}), "object" != typeof e3 && (e3 = {});
      var n2 = Object.keys(t3).concat(Object.keys(e3)).reduce(function(n3, r2) {
        return o(t3[r2], e3[r2]) || (n3[r2] = void 0 === e3[r2] ? null : e3[r2]), n3;
      }, {});
      return Object.keys(n2).length > 0 ? n2 : void 0;
    }, transform: function(t3, e3, n2) {
      if ("object" != typeof t3) return e3;
      if ("object" == typeof e3) {
        if (!n2) return e3;
        var r2 = Object.keys(e3).reduce(function(n3, r3) {
          return void 0 === t3[r3] && (n3[r3] = e3[r3]), n3;
        }, {});
        return Object.keys(r2).length > 0 ? r2 : void 0;
      }
    } }, iterator: function(t3) {
      return new r(t3);
    }, length: function(t3) {
      return "number" == typeof t3.delete ? t3.delete : "number" == typeof t3.retain ? t3.retain : "string" == typeof t3.insert ? t3.insert.length : 1;
    } };
    r.prototype.hasNext = function() {
      return this.peekLength() < 1 / 0;
    }, r.prototype.next = function(t3) {
      t3 || (t3 = 1 / 0);
      var e3 = this.ops[this.index];
      if (e3) {
        var n2 = this.offset, r2 = l.length(e3);
        if (t3 >= r2 - n2 ? (t3 = r2 - n2, this.index += 1, this.offset = 0) : this.offset += t3, "number" == typeof e3.delete) return { delete: t3 };
        var o2 = {};
        return e3.attributes && (o2.attributes = e3.attributes), "number" == typeof e3.retain ? o2.retain = t3 : "string" == typeof e3.insert ? o2.insert = e3.insert.substr(n2, t3) : o2.insert = e3.insert, o2;
      }
      return { retain: 1 / 0 };
    }, r.prototype.peek = function() {
      return this.ops[this.index];
    }, r.prototype.peekLength = function() {
      return this.ops[this.index] ? l.length(this.ops[this.index]) - this.offset : 1 / 0;
    }, r.prototype.peekType = function() {
      return this.ops[this.index] ? "number" == typeof this.ops[this.index].delete ? "delete" : "number" == typeof this.ops[this.index].retain ? "retain" : "insert" : "retain";
    }, r.prototype.rest = function() {
      if (this.hasNext()) {
        if (0 === this.offset) return this.ops.slice(this.index);
        var t3 = this.offset, e3 = this.index, n2 = this.next(), r2 = this.ops.slice(this.index);
        return this.offset = t3, this.index = e3, [n2].concat(r2);
      }
      return [];
    }, t2.exports = l;
  }, function(t2, e2) {
    var n = (function() {
      function t3(t4, e4) {
        return null != e4 && t4 instanceof e4;
      }
      function e3(n3, r2, o2, i3, c2) {
        function f(n4, o3) {
          if (null === n4) return null;
          if (0 === o3) return n4;
          var y3, v;
          if ("object" != typeof n4) return n4;
          if (t3(n4, a3)) y3 = new a3();
          else if (t3(n4, s3)) y3 = new s3();
          else if (t3(n4, u2)) y3 = new u2(function(t4, e4) {
            n4.then(function(e5) {
              t4(f(e5, o3 - 1));
            }, function(t5) {
              e4(f(t5, o3 - 1));
            });
          });
          else if (e3.__isArray(n4)) y3 = [];
          else if (e3.__isRegExp(n4)) y3 = new RegExp(n4.source, l(n4)), n4.lastIndex && (y3.lastIndex = n4.lastIndex);
          else if (e3.__isDate(n4)) y3 = new Date(n4.getTime());
          else {
            if (d3 && Buffer.isBuffer(n4)) return y3 = Buffer.allocUnsafe ? Buffer.allocUnsafe(n4.length) : new Buffer(n4.length), n4.copy(y3), y3;
            t3(n4, Error) ? y3 = Object.create(n4) : void 0 === i3 ? (v = Object.getPrototypeOf(n4), y3 = Object.create(v)) : (y3 = Object.create(i3), v = i3);
          }
          if (r2) {
            var b2 = h3.indexOf(n4);
            if (-1 != b2) return p[b2];
            h3.push(n4), p.push(y3);
          }
          t3(n4, a3) && n4.forEach(function(t4, e4) {
            var n5 = f(e4, o3 - 1), r3 = f(t4, o3 - 1);
            y3.set(n5, r3);
          }), t3(n4, s3) && n4.forEach(function(t4) {
            var e4 = f(t4, o3 - 1);
            y3.add(e4);
          });
          for (var g in n4) {
            var m3;
            v && (m3 = Object.getOwnPropertyDescriptor(v, g)), m3 && null == m3.set || (y3[g] = f(n4[g], o3 - 1));
          }
          if (Object.getOwnPropertySymbols) for (var _ = Object.getOwnPropertySymbols(n4), g = 0; g < _.length; g++) {
            var O2 = _[g], w2 = Object.getOwnPropertyDescriptor(n4, O2);
            (!w2 || w2.enumerable || c2) && (y3[O2] = f(n4[O2], o3 - 1), w2.enumerable || Object.defineProperty(y3, O2, { enumerable: false }));
          }
          if (c2) for (var x2 = Object.getOwnPropertyNames(n4), g = 0; g < x2.length; g++) {
            var k2 = x2[g], w2 = Object.getOwnPropertyDescriptor(n4, k2);
            w2 && w2.enumerable || (y3[k2] = f(n4[k2], o3 - 1), Object.defineProperty(y3, k2, { enumerable: false }));
          }
          return y3;
        }
        "object" == typeof r2 && (o2 = r2.depth, i3 = r2.prototype, c2 = r2.includeNonEnumerable, r2 = r2.circular);
        var h3 = [], p = [], d3 = "undefined" != typeof Buffer;
        return void 0 === r2 && (r2 = true), void 0 === o2 && (o2 = 1 / 0), f(n3, o2);
      }
      function n2(t4) {
        return Object.prototype.toString.call(t4);
      }
      function r(t4) {
        return "object" == typeof t4 && "[object Date]" === n2(t4);
      }
      function o(t4) {
        return "object" == typeof t4 && "[object Array]" === n2(t4);
      }
      function i2(t4) {
        return "object" == typeof t4 && "[object RegExp]" === n2(t4);
      }
      function l(t4) {
        var e4 = "";
        return t4.global && (e4 += "g"), t4.ignoreCase && (e4 += "i"), t4.multiline && (e4 += "m"), e4;
      }
      var a3;
      try {
        a3 = Map;
      } catch (t4) {
        a3 = function() {
        };
      }
      var s3;
      try {
        s3 = Set;
      } catch (t4) {
        s3 = function() {
        };
      }
      var u2;
      try {
        u2 = Promise;
      } catch (t4) {
        u2 = function() {
        };
      }
      return e3.clonePrototype = function(t4) {
        if (null === t4) return null;
        var e4 = function() {
        };
        return e4.prototype = t4, new e4();
      }, e3.__objToStr = n2, e3.__isDate = r, e3.__isArray = o, e3.__isRegExp = i2, e3.__getRegExpFlags = l, e3;
    })();
    "object" == typeof t2 && t2.exports && (t2.exports = n);
  }, function(t2, e2, n) {
    function r(t3) {
      return t3 && t3.__esModule ? t3 : { default: t3 };
    }
    function o(t3) {
      if (Array.isArray(t3)) {
        for (var e3 = 0, n2 = Array(t3.length); e3 < t3.length; e3++) n2[e3] = t3[e3];
        return n2;
      }
      return Array.from(t3);
    }
    function i2(t3, e3) {
      if (!(t3 instanceof e3)) throw new TypeError("Cannot call a class as a function");
    }
    function l(t3, e3) {
      try {
        e3.parentNode;
      } catch (t4) {
        return false;
      }
      return e3 instanceof Text && (e3 = e3.parentNode), t3.contains(e3);
    }
    Object.defineProperty(e2, "__esModule", { value: true }), e2.default = e2.Range = void 0;
    var a3 = /* @__PURE__ */ (function() {
      function t3(t4, e3) {
        var n2 = [], r2 = true, o2 = false, i3 = void 0;
        try {
          for (var l2, a4 = t4[Symbol.iterator](); !(r2 = (l2 = a4.next()).done) && (n2.push(l2.value), !e3 || n2.length !== e3); r2 = true) ;
        } catch (t5) {
          o2 = true, i3 = t5;
        } finally {
          try {
            !r2 && a4.return && a4.return();
          } finally {
            if (o2) throw i3;
          }
        }
        return n2;
      }
      return function(e3, n2) {
        if (Array.isArray(e3)) return e3;
        if (Symbol.iterator in Object(e3)) return t3(e3, n2);
        throw new TypeError("Invalid attempt to destructure non-iterable instance");
      };
    })(), s3 = /* @__PURE__ */ (function() {
      function t3(t4, e3) {
        for (var n2 = 0; n2 < e3.length; n2++) {
          var r2 = e3[n2];
          r2.enumerable = r2.enumerable || false, r2.configurable = true, "value" in r2 && (r2.writable = true), Object.defineProperty(t4, r2.key, r2);
        }
      }
      return function(e3, n2, r2) {
        return n2 && t3(e3.prototype, n2), r2 && t3(e3, r2), e3;
      };
    })(), u2 = n(0), c2 = r(u2), f = n(21), h3 = r(f), p = n(12), d3 = r(p), y3 = n(9), v = r(y3), b2 = n(10), g = r(b2), m3 = (0, g.default)("quill:selection"), _ = function t3(e3) {
      var n2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0;
      i2(this, t3), this.index = e3, this.length = n2;
    }, O2 = (function() {
      function t3(e3, n2) {
        var r2 = this;
        i2(this, t3), this.emitter = n2, this.scroll = e3, this.composing = false, this.mouseDown = false, this.root = this.scroll.domNode, this.cursor = c2.default.create("cursor", this), this.lastRange = this.savedRange = new _(0, 0), this.handleComposition(), this.handleDragging(), this.emitter.listenDOM("selectionchange", document, function() {
          r2.mouseDown || setTimeout(r2.update.bind(r2, v.default.sources.USER), 1);
        }), this.emitter.on(v.default.events.EDITOR_CHANGE, function(t4, e4) {
          t4 === v.default.events.TEXT_CHANGE && e4.length() > 0 && r2.update(v.default.sources.SILENT);
        }), this.emitter.on(v.default.events.SCROLL_BEFORE_UPDATE, function() {
          if (r2.hasFocus()) {
            var t4 = r2.getNativeRange();
            null != t4 && t4.start.node !== r2.cursor.textNode && r2.emitter.once(v.default.events.SCROLL_UPDATE, function() {
              try {
                r2.setNativeRange(t4.start.node, t4.start.offset, t4.end.node, t4.end.offset);
              } catch (t5) {
              }
            });
          }
        }), this.emitter.on(v.default.events.SCROLL_OPTIMIZE, function(t4, e4) {
          if (e4.range) {
            var n3 = e4.range, o2 = n3.startNode, i3 = n3.startOffset, l2 = n3.endNode, a4 = n3.endOffset;
            r2.setNativeRange(o2, i3, l2, a4);
          }
        }), this.update(v.default.sources.SILENT);
      }
      return s3(t3, [{ key: "handleComposition", value: function() {
        var t4 = this;
        this.root.addEventListener("compositionstart", function() {
          t4.composing = true;
        }), this.root.addEventListener("compositionend", function() {
          if (t4.composing = false, t4.cursor.parent) {
            var e3 = t4.cursor.restore();
            if (!e3) return;
            setTimeout(function() {
              t4.setNativeRange(e3.startNode, e3.startOffset, e3.endNode, e3.endOffset);
            }, 1);
          }
        });
      } }, { key: "handleDragging", value: function() {
        var t4 = this;
        this.emitter.listenDOM("mousedown", document.body, function() {
          t4.mouseDown = true;
        }), this.emitter.listenDOM("mouseup", document.body, function() {
          t4.mouseDown = false, t4.update(v.default.sources.USER);
        });
      } }, { key: "focus", value: function() {
        this.hasFocus() || (this.root.focus(), this.setRange(this.savedRange));
      } }, { key: "format", value: function(t4, e3) {
        if (null == this.scroll.whitelist || this.scroll.whitelist[t4]) {
          this.scroll.update();
          var n2 = this.getNativeRange();
          if (null != n2 && n2.native.collapsed && !c2.default.query(t4, c2.default.Scope.BLOCK)) {
            if (n2.start.node !== this.cursor.textNode) {
              var r2 = c2.default.find(n2.start.node, false);
              if (null == r2) return;
              if (r2 instanceof c2.default.Leaf) {
                var o2 = r2.split(n2.start.offset);
                r2.parent.insertBefore(this.cursor, o2);
              } else r2.insertBefore(this.cursor, n2.start.node);
              this.cursor.attach();
            }
            this.cursor.format(t4, e3), this.scroll.optimize(), this.setNativeRange(this.cursor.textNode, this.cursor.textNode.data.length), this.update();
          }
        }
      } }, { key: "getBounds", value: function(t4) {
        var e3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0, n2 = this.scroll.length();
        t4 = Math.min(t4, n2 - 1), e3 = Math.min(t4 + e3, n2 - 1) - t4;
        var r2 = void 0, o2 = this.scroll.leaf(t4), i3 = a3(o2, 2), l2 = i3[0], s4 = i3[1];
        if (null == l2) return null;
        var u3 = l2.position(s4, true), c3 = a3(u3, 2);
        r2 = c3[0], s4 = c3[1];
        var f2 = document.createRange();
        if (e3 > 0) {
          f2.setStart(r2, s4);
          var h4 = this.scroll.leaf(t4 + e3), p2 = a3(h4, 2);
          if (l2 = p2[0], s4 = p2[1], null == l2) return null;
          var d4 = l2.position(s4, true), y4 = a3(d4, 2);
          return r2 = y4[0], s4 = y4[1], f2.setEnd(r2, s4), f2.getBoundingClientRect();
        }
        var v2 = "left", b3 = void 0;
        return r2 instanceof Text ? (s4 < r2.data.length ? (f2.setStart(r2, s4), f2.setEnd(r2, s4 + 1)) : (f2.setStart(r2, s4 - 1), f2.setEnd(r2, s4), v2 = "right"), b3 = f2.getBoundingClientRect()) : (b3 = l2.domNode.getBoundingClientRect(), s4 > 0 && (v2 = "right")), { bottom: b3.top + b3.height, height: b3.height, left: b3[v2], right: b3[v2], top: b3.top, width: 0 };
      } }, { key: "getNativeRange", value: function() {
        var t4 = document.getSelection();
        if (null == t4 || t4.rangeCount <= 0) return null;
        var e3 = t4.getRangeAt(0);
        if (null == e3) return null;
        var n2 = this.normalizeNative(e3);
        return m3.info("getNativeRange", n2), n2;
      } }, { key: "getRange", value: function() {
        var t4 = this.getNativeRange();
        return null == t4 ? [null, null] : [this.normalizedToRange(t4), t4];
      } }, { key: "hasFocus", value: function() {
        return document.activeElement === this.root;
      } }, { key: "normalizedToRange", value: function(t4) {
        var e3 = this, n2 = [[t4.start.node, t4.start.offset]];
        t4.native.collapsed || n2.push([t4.end.node, t4.end.offset]);
        var r2 = n2.map(function(t5) {
          var n3 = a3(t5, 2), r3 = n3[0], o2 = n3[1], i4 = c2.default.find(r3, true), l3 = i4.offset(e3.scroll);
          return 0 === o2 ? l3 : i4 instanceof c2.default.Container ? l3 + i4.length() : l3 + i4.index(r3, o2);
        }), i3 = Math.min(Math.max.apply(Math, o(r2)), this.scroll.length() - 1), l2 = Math.min.apply(Math, [i3].concat(o(r2)));
        return new _(l2, i3 - l2);
      } }, { key: "normalizeNative", value: function(t4) {
        if (!l(this.root, t4.startContainer) || !t4.collapsed && !l(this.root, t4.endContainer)) return null;
        var e3 = { start: { node: t4.startContainer, offset: t4.startOffset }, end: { node: t4.endContainer, offset: t4.endOffset }, native: t4 };
        return [e3.start, e3.end].forEach(function(t5) {
          for (var e4 = t5.node, n2 = t5.offset; !(e4 instanceof Text) && e4.childNodes.length > 0; ) if (e4.childNodes.length > n2) e4 = e4.childNodes[n2], n2 = 0;
          else {
            if (e4.childNodes.length !== n2) break;
            e4 = e4.lastChild, n2 = e4 instanceof Text ? e4.data.length : e4.childNodes.length + 1;
          }
          t5.node = e4, t5.offset = n2;
        }), e3;
      } }, { key: "rangeToNative", value: function(t4) {
        var e3 = this, n2 = t4.collapsed ? [t4.index] : [t4.index, t4.index + t4.length], r2 = [], o2 = this.scroll.length();
        return n2.forEach(function(t5, n3) {
          t5 = Math.min(o2 - 1, t5);
          var i3 = void 0, l2 = e3.scroll.leaf(t5), s4 = a3(l2, 2), u3 = s4[0], c3 = s4[1], f2 = u3.position(c3, 0 !== n3), h4 = a3(f2, 2);
          i3 = h4[0], c3 = h4[1], r2.push(i3, c3);
        }), r2.length < 2 && (r2 = r2.concat(r2)), r2;
      } }, { key: "scrollIntoView", value: function(t4) {
        var e3 = this.lastRange;
        if (null != e3) {
          var n2 = this.getBounds(e3.index, e3.length);
          if (null != n2) {
            var r2 = this.scroll.length() - 1, o2 = this.scroll.line(Math.min(e3.index, r2)), i3 = a3(o2, 1), l2 = i3[0], s4 = l2;
            if (e3.length > 0) {
              var u3 = this.scroll.line(Math.min(e3.index + e3.length, r2));
              s4 = a3(u3, 1)[0];
            }
            if (null != l2 && null != s4) {
              var c3 = t4.getBoundingClientRect();
              n2.top < c3.top ? t4.scrollTop -= c3.top - n2.top : n2.bottom > c3.bottom && (t4.scrollTop += n2.bottom - c3.bottom);
            }
          }
        }
      } }, { key: "setNativeRange", value: function(t4, e3) {
        var n2 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : t4, r2 = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : e3, o2 = arguments.length > 4 && void 0 !== arguments[4] && arguments[4];
        if (m3.info("setNativeRange", t4, e3, n2, r2), null == t4 || null != this.root.parentNode && null != t4.parentNode && null != n2.parentNode) {
          var i3 = document.getSelection();
          if (null != i3) if (null != t4) {
            this.hasFocus() || this.root.focus();
            var l2 = (this.getNativeRange() || {}).native;
            if (null == l2 || o2 || t4 !== l2.startContainer || e3 !== l2.startOffset || n2 !== l2.endContainer || r2 !== l2.endOffset) {
              "BR" == t4.tagName && (e3 = [].indexOf.call(t4.parentNode.childNodes, t4), t4 = t4.parentNode), "BR" == n2.tagName && (r2 = [].indexOf.call(n2.parentNode.childNodes, n2), n2 = n2.parentNode);
              var a4 = document.createRange();
              a4.setStart(t4, e3), a4.setEnd(n2, r2), i3.removeAllRanges(), i3.addRange(a4);
            }
          } else i3.removeAllRanges(), this.root.blur(), document.body.focus();
        }
      } }, { key: "setRange", value: function(t4) {
        var e3 = arguments.length > 1 && void 0 !== arguments[1] && arguments[1], n2 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : v.default.sources.API;
        if ("string" == typeof e3 && (n2 = e3, e3 = false), m3.info("setRange", t4), null != t4) {
          var r2 = this.rangeToNative(t4);
          this.setNativeRange.apply(this, o(r2).concat([e3]));
        } else this.setNativeRange(null);
        this.update(n2);
      } }, { key: "update", value: function() {
        var t4 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : v.default.sources.USER, e3 = this.lastRange, n2 = this.getRange(), r2 = a3(n2, 2), o2 = r2[0], i3 = r2[1];
        if (this.lastRange = o2, null != this.lastRange && (this.savedRange = this.lastRange), !(0, d3.default)(e3, this.lastRange)) {
          var l2;
          !this.composing && null != i3 && i3.native.collapsed && i3.start.node !== this.cursor.textNode && this.cursor.restore();
          var s4 = [v.default.events.SELECTION_CHANGE, (0, h3.default)(this.lastRange), (0, h3.default)(e3), t4];
          if ((l2 = this.emitter).emit.apply(l2, [v.default.events.EDITOR_CHANGE].concat(s4)), t4 !== v.default.sources.SILENT) {
            var u3;
            (u3 = this.emitter).emit.apply(u3, s4);
          }
        }
      } }]), t3;
    })();
    e2.Range = _, e2.default = O2;
  }, function(t2, e2, n) {
    function r(t3) {
      return t3 && t3.__esModule ? t3 : { default: t3 };
    }
    function o(t3, e3) {
      if (!(t3 instanceof e3)) throw new TypeError("Cannot call a class as a function");
    }
    function i2(t3, e3) {
      if (!t3) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      return !e3 || "object" != typeof e3 && "function" != typeof e3 ? t3 : e3;
    }
    function l(t3, e3) {
      if ("function" != typeof e3 && null !== e3) throw new TypeError("Super expression must either be null or a function, not " + typeof e3);
      t3.prototype = Object.create(e3 && e3.prototype, { constructor: { value: t3, enumerable: false, writable: true, configurable: true } }), e3 && (Object.setPrototypeOf ? Object.setPrototypeOf(t3, e3) : t3.__proto__ = e3);
    }
    Object.defineProperty(e2, "__esModule", { value: true });
    var a3 = n(0), s3 = r(a3), u2 = n(3), c2 = r(u2), f = (function(t3) {
      function e3() {
        return o(this, e3), i2(this, (e3.__proto__ || Object.getPrototypeOf(e3)).apply(this, arguments));
      }
      return l(e3, t3), e3;
    })(s3.default.Container);
    f.allowedChildren = [c2.default, u2.BlockEmbed, f], e2.default = f;
  }, function(t2, e2, n) {
    function r(t3, e3) {
      if (!(t3 instanceof e3)) throw new TypeError("Cannot call a class as a function");
    }
    function o(t3, e3) {
      if (!t3) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      return !e3 || "object" != typeof e3 && "function" != typeof e3 ? t3 : e3;
    }
    function i2(t3, e3) {
      if ("function" != typeof e3 && null !== e3) throw new TypeError("Super expression must either be null or a function, not " + typeof e3);
      t3.prototype = Object.create(e3 && e3.prototype, { constructor: { value: t3, enumerable: false, writable: true, configurable: true } }), e3 && (Object.setPrototypeOf ? Object.setPrototypeOf(t3, e3) : t3.__proto__ = e3);
    }
    Object.defineProperty(e2, "__esModule", { value: true }), e2.ColorStyle = e2.ColorClass = e2.ColorAttributor = void 0;
    var l = /* @__PURE__ */ (function() {
      function t3(t4, e3) {
        for (var n2 = 0; n2 < e3.length; n2++) {
          var r2 = e3[n2];
          r2.enumerable = r2.enumerable || false, r2.configurable = true, "value" in r2 && (r2.writable = true), Object.defineProperty(t4, r2.key, r2);
        }
      }
      return function(e3, n2, r2) {
        return n2 && t3(e3.prototype, n2), r2 && t3(e3, r2), e3;
      };
    })(), a3 = function t3(e3, n2, r2) {
      null === e3 && (e3 = Function.prototype);
      var o2 = Object.getOwnPropertyDescriptor(e3, n2);
      if (void 0 === o2) {
        var i3 = Object.getPrototypeOf(e3);
        return null === i3 ? void 0 : t3(i3, n2, r2);
      }
      if ("value" in o2) return o2.value;
      var l2 = o2.get;
      if (void 0 !== l2) return l2.call(r2);
    }, s3 = n(0), u2 = (function(t3) {
      return t3 && t3.__esModule ? t3 : { default: t3 };
    })(s3), c2 = (function(t3) {
      function e3() {
        return r(this, e3), o(this, (e3.__proto__ || Object.getPrototypeOf(e3)).apply(this, arguments));
      }
      return i2(e3, t3), l(e3, [{ key: "value", value: function(t4) {
        var n2 = a3(e3.prototype.__proto__ || Object.getPrototypeOf(e3.prototype), "value", this).call(this, t4);
        return n2.startsWith("rgb(") ? (n2 = n2.replace(/^[^\d]+/, "").replace(/[^\d]+$/, ""), "#" + n2.split(",").map(function(t5) {
          return ("00" + parseInt(t5).toString(16)).slice(-2);
        }).join("")) : n2;
      } }]), e3;
    })(u2.default.Attributor.Style), f = new u2.default.Attributor.Class("color", "ql-color", { scope: u2.default.Scope.INLINE }), h3 = new c2("color", "color", { scope: u2.default.Scope.INLINE });
    e2.ColorAttributor = c2, e2.ColorClass = f, e2.ColorStyle = h3;
  }, function(t2, e2, n) {
    function r(t3) {
      return t3 && t3.__esModule ? t3 : { default: t3 };
    }
    function o(t3, e3, n2) {
      return e3 in t3 ? Object.defineProperty(t3, e3, { value: n2, enumerable: true, configurable: true, writable: true }) : t3[e3] = n2, t3;
    }
    function i2(t3, e3) {
      if (!(t3 instanceof e3)) throw new TypeError("Cannot call a class as a function");
    }
    function l(t3, e3) {
      if (!t3) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      return !e3 || "object" != typeof e3 && "function" != typeof e3 ? t3 : e3;
    }
    function a3(t3, e3) {
      if ("function" != typeof e3 && null !== e3) throw new TypeError("Super expression must either be null or a function, not " + typeof e3);
      t3.prototype = Object.create(e3 && e3.prototype, { constructor: { value: t3, enumerable: false, writable: true, configurable: true } }), e3 && (Object.setPrototypeOf ? Object.setPrototypeOf(t3, e3) : t3.__proto__ = e3);
    }
    function s3(t3, e3) {
      var n2, r2 = t3 === D2.keys.LEFT ? "prefix" : "suffix";
      return n2 = { key: t3, shiftKey: e3, altKey: null }, o(n2, r2, /^$/), o(n2, "handler", function(n3) {
        var r3 = n3.index;
        t3 === D2.keys.RIGHT && (r3 += n3.length + 1);
        var o2 = this.quill.getLeaf(r3);
        return !(b2(o2, 1)[0] instanceof T2.default.Embed) || (t3 === D2.keys.LEFT ? e3 ? this.quill.setSelection(n3.index - 1, n3.length + 1, S3.default.sources.USER) : this.quill.setSelection(n3.index - 1, S3.default.sources.USER) : e3 ? this.quill.setSelection(n3.index, n3.length + 1, S3.default.sources.USER) : this.quill.setSelection(n3.index + n3.length + 1, S3.default.sources.USER), false);
      }), n2;
    }
    function u2(t3, e3) {
      if (!(0 === t3.index || this.quill.getLength() <= 1)) {
        var n2 = this.quill.getLine(t3.index), r2 = b2(n2, 1), o2 = r2[0], i3 = {};
        if (0 === e3.offset) {
          var l2 = this.quill.getLine(t3.index - 1), a4 = b2(l2, 1), s4 = a4[0];
          if (null != s4 && s4.length() > 1) {
            var u3 = o2.formats(), c3 = this.quill.getFormat(t3.index - 1, 1);
            i3 = A.default.attributes.diff(u3, c3) || {};
          }
        }
        var f2 = /[\uD800-\uDBFF][\uDC00-\uDFFF]$/.test(e3.prefix) ? 2 : 1;
        this.quill.deleteText(t3.index - f2, f2, S3.default.sources.USER), Object.keys(i3).length > 0 && this.quill.formatLine(t3.index - f2, f2, i3, S3.default.sources.USER), this.quill.focus();
      }
    }
    function c2(t3, e3) {
      var n2 = /^[\uD800-\uDBFF][\uDC00-\uDFFF]/.test(e3.suffix) ? 2 : 1;
      if (!(t3.index >= this.quill.getLength() - n2)) {
        var r2 = {}, o2 = 0, i3 = this.quill.getLine(t3.index), l2 = b2(i3, 1), a4 = l2[0];
        if (e3.offset >= a4.length() - 1) {
          var s4 = this.quill.getLine(t3.index + 1), u3 = b2(s4, 1), c3 = u3[0];
          if (c3) {
            var f2 = a4.formats(), h4 = this.quill.getFormat(t3.index, 1);
            r2 = A.default.attributes.diff(f2, h4) || {}, o2 = c3.length();
          }
        }
        this.quill.deleteText(t3.index, n2, S3.default.sources.USER), Object.keys(r2).length > 0 && this.quill.formatLine(t3.index + o2 - 1, n2, r2, S3.default.sources.USER);
      }
    }
    function f(t3) {
      var e3 = this.quill.getLines(t3), n2 = {};
      if (e3.length > 1) {
        var r2 = e3[0].formats(), o2 = e3[e3.length - 1].formats();
        n2 = A.default.attributes.diff(o2, r2) || {};
      }
      this.quill.deleteText(t3, S3.default.sources.USER), Object.keys(n2).length > 0 && this.quill.formatLine(t3.index, 1, n2, S3.default.sources.USER), this.quill.setSelection(t3.index, S3.default.sources.SILENT), this.quill.focus();
    }
    function h3(t3, e3) {
      var n2 = this;
      t3.length > 0 && this.quill.scroll.deleteAt(t3.index, t3.length);
      var r2 = Object.keys(e3.format).reduce(function(t4, n3) {
        return T2.default.query(n3, T2.default.Scope.BLOCK) && !Array.isArray(e3.format[n3]) && (t4[n3] = e3.format[n3]), t4;
      }, {});
      this.quill.insertText(t3.index, "\n", r2, S3.default.sources.USER), this.quill.setSelection(t3.index + 1, S3.default.sources.SILENT), this.quill.focus(), Object.keys(e3.format).forEach(function(t4) {
        null == r2[t4] && (Array.isArray(e3.format[t4]) || "link" !== t4 && n2.quill.format(t4, e3.format[t4], S3.default.sources.USER));
      });
    }
    function p(t3) {
      return { key: D2.keys.TAB, shiftKey: !t3, format: { "code-block": true }, handler: function(e3) {
        var n2 = T2.default.query("code-block"), r2 = e3.index, o2 = e3.length, i3 = this.quill.scroll.descendant(n2, r2), l2 = b2(i3, 2), a4 = l2[0], s4 = l2[1];
        if (null != a4) {
          var u3 = this.quill.getIndex(a4), c3 = a4.newlineIndex(s4, true) + 1, f2 = a4.newlineIndex(u3 + s4 + o2), h4 = a4.domNode.textContent.slice(c3, f2).split("\n");
          s4 = 0, h4.forEach(function(e4, i4) {
            t3 ? (a4.insertAt(c3 + s4, n2.TAB), s4 += n2.TAB.length, 0 === i4 ? r2 += n2.TAB.length : o2 += n2.TAB.length) : e4.startsWith(n2.TAB) && (a4.deleteAt(c3 + s4, n2.TAB.length), s4 -= n2.TAB.length, 0 === i4 ? r2 -= n2.TAB.length : o2 -= n2.TAB.length), s4 += e4.length + 1;
          }), this.quill.update(S3.default.sources.USER), this.quill.setSelection(r2, o2, S3.default.sources.SILENT);
        }
      } };
    }
    function d3(t3) {
      return { key: t3[0].toUpperCase(), shortKey: true, handler: function(e3, n2) {
        this.quill.format(t3, !n2.format[t3], S3.default.sources.USER);
      } };
    }
    function y3(t3) {
      if ("string" == typeof t3 || "number" == typeof t3) return y3({ key: t3 });
      if ("object" === (void 0 === t3 ? "undefined" : v(t3)) && (t3 = (0, _.default)(t3, false)), "string" == typeof t3.key) if (null != D2.keys[t3.key.toUpperCase()]) t3.key = D2.keys[t3.key.toUpperCase()];
      else {
        if (1 !== t3.key.length) return null;
        t3.key = t3.key.toUpperCase().charCodeAt(0);
      }
      return t3.shortKey && (t3[B2] = t3.shortKey, delete t3.shortKey), t3;
    }
    Object.defineProperty(e2, "__esModule", { value: true }), e2.SHORTKEY = e2.default = void 0;
    var v = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t3) {
      return typeof t3;
    } : function(t3) {
      return t3 && "function" == typeof Symbol && t3.constructor === Symbol && t3 !== Symbol.prototype ? "symbol" : typeof t3;
    }, b2 = /* @__PURE__ */ (function() {
      function t3(t4, e3) {
        var n2 = [], r2 = true, o2 = false, i3 = void 0;
        try {
          for (var l2, a4 = t4[Symbol.iterator](); !(r2 = (l2 = a4.next()).done) && (n2.push(l2.value), !e3 || n2.length !== e3); r2 = true) ;
        } catch (t5) {
          o2 = true, i3 = t5;
        } finally {
          try {
            !r2 && a4.return && a4.return();
          } finally {
            if (o2) throw i3;
          }
        }
        return n2;
      }
      return function(e3, n2) {
        if (Array.isArray(e3)) return e3;
        if (Symbol.iterator in Object(e3)) return t3(e3, n2);
        throw new TypeError("Invalid attempt to destructure non-iterable instance");
      };
    })(), g = /* @__PURE__ */ (function() {
      function t3(t4, e3) {
        for (var n2 = 0; n2 < e3.length; n2++) {
          var r2 = e3[n2];
          r2.enumerable = r2.enumerable || false, r2.configurable = true, "value" in r2 && (r2.writable = true), Object.defineProperty(t4, r2.key, r2);
        }
      }
      return function(e3, n2, r2) {
        return n2 && t3(e3.prototype, n2), r2 && t3(e3, r2), e3;
      };
    })(), m3 = n(21), _ = r(m3), O2 = n(12), w2 = r(O2), x2 = n(2), k2 = r(x2), E2 = n(4), N = r(E2), j = n(20), A = r(j), q2 = n(0), T2 = r(q2), P = n(6), S3 = r(P), C = n(10), L2 = r(C), M3 = n(7), R2 = r(M3), I2 = (0, L2.default)("quill:keyboard"), B2 = /Mac/i.test(navigator.platform) ? "metaKey" : "ctrlKey", D2 = (function(t3) {
      function e3(t4, n2) {
        i2(this, e3);
        var r2 = l(this, (e3.__proto__ || Object.getPrototypeOf(e3)).call(this, t4, n2));
        return r2.bindings = {}, Object.keys(r2.options.bindings).forEach(function(e4) {
          ("list autofill" !== e4 || null == t4.scroll.whitelist || t4.scroll.whitelist.list) && r2.options.bindings[e4] && r2.addBinding(r2.options.bindings[e4]);
        }), r2.addBinding({ key: e3.keys.ENTER, shiftKey: null }, h3), r2.addBinding({ key: e3.keys.ENTER, metaKey: null, ctrlKey: null, altKey: null }, function() {
        }), /Firefox/i.test(navigator.userAgent) ? (r2.addBinding({ key: e3.keys.BACKSPACE }, { collapsed: true }, u2), r2.addBinding({ key: e3.keys.DELETE }, { collapsed: true }, c2)) : (r2.addBinding({ key: e3.keys.BACKSPACE }, { collapsed: true, prefix: /^.?$/ }, u2), r2.addBinding({ key: e3.keys.DELETE }, { collapsed: true, suffix: /^.?$/ }, c2)), r2.addBinding({ key: e3.keys.BACKSPACE }, { collapsed: false }, f), r2.addBinding({ key: e3.keys.DELETE }, { collapsed: false }, f), r2.addBinding({ key: e3.keys.BACKSPACE, altKey: null, ctrlKey: null, metaKey: null, shiftKey: null }, { collapsed: true, offset: 0 }, u2), r2.listen(), r2;
      }
      return a3(e3, t3), g(e3, null, [{ key: "match", value: function(t4, e4) {
        return e4 = y3(e4), !["altKey", "ctrlKey", "metaKey", "shiftKey"].some(function(n2) {
          return !!e4[n2] !== t4[n2] && null !== e4[n2];
        }) && e4.key === (t4.which || t4.keyCode);
      } }]), g(e3, [{ key: "addBinding", value: function(t4) {
        var e4 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {}, n2 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {}, r2 = y3(t4);
        if (null == r2 || null == r2.key) return I2.warn("Attempted to add invalid keyboard binding", r2);
        "function" == typeof e4 && (e4 = { handler: e4 }), "function" == typeof n2 && (n2 = { handler: n2 }), r2 = (0, k2.default)(r2, e4, n2), this.bindings[r2.key] = this.bindings[r2.key] || [], this.bindings[r2.key].push(r2);
      } }, { key: "listen", value: function() {
        var t4 = this;
        this.quill.root.addEventListener("keydown", function(n2) {
          if (!n2.defaultPrevented) {
            var r2 = n2.which || n2.keyCode, o2 = (t4.bindings[r2] || []).filter(function(t5) {
              return e3.match(n2, t5);
            });
            if (0 !== o2.length) {
              var i3 = t4.quill.getSelection();
              if (null != i3 && t4.quill.hasFocus()) {
                var l2 = t4.quill.getLine(i3.index), a4 = b2(l2, 2), s4 = a4[0], u3 = a4[1], c3 = t4.quill.getLeaf(i3.index), f2 = b2(c3, 2), h4 = f2[0], p2 = f2[1], d4 = 0 === i3.length ? [h4, p2] : t4.quill.getLeaf(i3.index + i3.length), y4 = b2(d4, 2), g2 = y4[0], m4 = y4[1], _2 = h4 instanceof T2.default.Text ? h4.value().slice(0, p2) : "", O3 = g2 instanceof T2.default.Text ? g2.value().slice(m4) : "", x3 = { collapsed: 0 === i3.length, empty: 0 === i3.length && s4.length() <= 1, format: t4.quill.getFormat(i3), offset: u3, prefix: _2, suffix: O3 };
                o2.some(function(e4) {
                  if (null != e4.collapsed && e4.collapsed !== x3.collapsed) return false;
                  if (null != e4.empty && e4.empty !== x3.empty) return false;
                  if (null != e4.offset && e4.offset !== x3.offset) return false;
                  if (Array.isArray(e4.format)) {
                    if (e4.format.every(function(t5) {
                      return null == x3.format[t5];
                    })) return false;
                  } else if ("object" === v(e4.format) && !Object.keys(e4.format).every(function(t5) {
                    return true === e4.format[t5] ? null != x3.format[t5] : false === e4.format[t5] ? null == x3.format[t5] : (0, w2.default)(e4.format[t5], x3.format[t5]);
                  })) return false;
                  return !(null != e4.prefix && !e4.prefix.test(x3.prefix)) && (!(null != e4.suffix && !e4.suffix.test(x3.suffix)) && true !== e4.handler.call(t4, i3, x3));
                }) && n2.preventDefault();
              }
            }
          }
        });
      } }]), e3;
    })(R2.default);
    D2.keys = { BACKSPACE: 8, TAB: 9, ENTER: 13, ESCAPE: 27, LEFT: 37, UP: 38, RIGHT: 39, DOWN: 40, DELETE: 46 }, D2.DEFAULTS = { bindings: { bold: d3("bold"), italic: d3("italic"), underline: d3("underline"), indent: { key: D2.keys.TAB, format: ["blockquote", "indent", "list"], handler: function(t3, e3) {
      if (e3.collapsed && 0 !== e3.offset) return true;
      this.quill.format("indent", "+1", S3.default.sources.USER);
    } }, outdent: { key: D2.keys.TAB, shiftKey: true, format: ["blockquote", "indent", "list"], handler: function(t3, e3) {
      if (e3.collapsed && 0 !== e3.offset) return true;
      this.quill.format("indent", "-1", S3.default.sources.USER);
    } }, "outdent backspace": { key: D2.keys.BACKSPACE, collapsed: true, shiftKey: null, metaKey: null, ctrlKey: null, altKey: null, format: ["indent", "list"], offset: 0, handler: function(t3, e3) {
      null != e3.format.indent ? this.quill.format("indent", "-1", S3.default.sources.USER) : null != e3.format.list && this.quill.format("list", false, S3.default.sources.USER);
    } }, "indent code-block": p(true), "outdent code-block": p(false), "remove tab": { key: D2.keys.TAB, shiftKey: true, collapsed: true, prefix: /\t$/, handler: function(t3) {
      this.quill.deleteText(t3.index - 1, 1, S3.default.sources.USER);
    } }, tab: { key: D2.keys.TAB, handler: function(t3) {
      this.quill.history.cutoff();
      var e3 = new N.default().retain(t3.index).delete(t3.length).insert("	");
      this.quill.updateContents(e3, S3.default.sources.USER), this.quill.history.cutoff(), this.quill.setSelection(t3.index + 1, S3.default.sources.SILENT);
    } }, "list empty enter": { key: D2.keys.ENTER, collapsed: true, format: ["list"], empty: true, handler: function(t3, e3) {
      this.quill.format("list", false, S3.default.sources.USER), e3.format.indent && this.quill.format("indent", false, S3.default.sources.USER);
    } }, "checklist enter": { key: D2.keys.ENTER, collapsed: true, format: { list: "checked" }, handler: function(t3) {
      var e3 = this.quill.getLine(t3.index), n2 = b2(e3, 2), r2 = n2[0], o2 = n2[1], i3 = (0, k2.default)({}, r2.formats(), { list: "checked" }), l2 = new N.default().retain(t3.index).insert("\n", i3).retain(r2.length() - o2 - 1).retain(1, { list: "unchecked" });
      this.quill.updateContents(l2, S3.default.sources.USER), this.quill.setSelection(t3.index + 1, S3.default.sources.SILENT), this.quill.scrollIntoView();
    } }, "header enter": { key: D2.keys.ENTER, collapsed: true, format: ["header"], suffix: /^$/, handler: function(t3, e3) {
      var n2 = this.quill.getLine(t3.index), r2 = b2(n2, 2), o2 = r2[0], i3 = r2[1], l2 = new N.default().retain(t3.index).insert("\n", e3.format).retain(o2.length() - i3 - 1).retain(1, { header: null });
      this.quill.updateContents(l2, S3.default.sources.USER), this.quill.setSelection(t3.index + 1, S3.default.sources.SILENT), this.quill.scrollIntoView();
    } }, "list autofill": { key: " ", collapsed: true, format: { list: false }, prefix: /^\s*?(\d+\.|-|\*|\[ ?\]|\[x\])$/, handler: function(t3, e3) {
      var n2 = e3.prefix.length, r2 = this.quill.getLine(t3.index), o2 = b2(r2, 2), i3 = o2[0], l2 = o2[1];
      if (l2 > n2) return true;
      var a4 = void 0;
      switch (e3.prefix.trim()) {
        case "[]":
        case "[ ]":
          a4 = "unchecked";
          break;
        case "[x]":
          a4 = "checked";
          break;
        case "-":
        case "*":
          a4 = "bullet";
          break;
        default:
          a4 = "ordered";
      }
      this.quill.insertText(t3.index, " ", S3.default.sources.USER), this.quill.history.cutoff();
      var s4 = new N.default().retain(t3.index - l2).delete(n2 + 1).retain(i3.length() - 2 - l2).retain(1, { list: a4 });
      this.quill.updateContents(s4, S3.default.sources.USER), this.quill.history.cutoff(), this.quill.setSelection(t3.index - n2, S3.default.sources.SILENT);
    } }, "code exit": { key: D2.keys.ENTER, collapsed: true, format: ["code-block"], prefix: /\n\n$/, suffix: /^\s+$/, handler: function(t3) {
      var e3 = this.quill.getLine(t3.index), n2 = b2(e3, 2), r2 = n2[0], o2 = n2[1], i3 = new N.default().retain(t3.index + r2.length() - o2 - 2).retain(1, { "code-block": null }).delete(1);
      this.quill.updateContents(i3, S3.default.sources.USER);
    } }, "embed left": s3(D2.keys.LEFT, false), "embed left shift": s3(D2.keys.LEFT, true), "embed right": s3(D2.keys.RIGHT, false), "embed right shift": s3(D2.keys.RIGHT, true) } }, e2.default = D2, e2.SHORTKEY = B2;
  }, function(t2, e2, n) {
    t2.exports = { align: { "": n(75), center: n(76), right: n(77), justify: n(78) }, background: n(79), blockquote: n(80), bold: n(81), clean: n(82), code: n(40), "code-block": n(40), color: n(83), direction: { "": n(84), rtl: n(85) }, float: { center: n(86), full: n(87), left: n(88), right: n(89) }, formula: n(90), header: { 1: n(91), 2: n(92) }, italic: n(93), image: n(94), indent: { "+1": n(95), "-1": n(96) }, link: n(97), list: { ordered: n(98), bullet: n(99), check: n(100) }, script: { sub: n(101), super: n(102) }, strike: n(103), underline: n(104), video: n(105) };
  }, function(t2, e2, n) {
    Object.defineProperty(e2, "__esModule", { value: true });
    var r = n(1), o = (function() {
      function t3(t4) {
        this.domNode = t4, this.domNode[r.DATA_KEY] = { blot: this };
      }
      return Object.defineProperty(t3.prototype, "statics", { get: function() {
        return this.constructor;
      }, enumerable: true, configurable: true }), t3.create = function(t4) {
        if (null == this.tagName) throw new r.ParchmentError("Blot definition missing tagName");
        var e3;
        return Array.isArray(this.tagName) ? ("string" == typeof t4 && (t4 = t4.toUpperCase(), parseInt(t4).toString() === t4 && (t4 = parseInt(t4))), e3 = "number" == typeof t4 ? document.createElement(this.tagName[t4 - 1]) : this.tagName.indexOf(t4) > -1 ? document.createElement(t4) : document.createElement(this.tagName[0])) : e3 = document.createElement(this.tagName), this.className && e3.classList.add(this.className), e3;
      }, t3.prototype.attach = function() {
        null != this.parent && (this.scroll = this.parent.scroll);
      }, t3.prototype.clone = function() {
        var t4 = this.domNode.cloneNode(false);
        return r.create(t4);
      }, t3.prototype.detach = function() {
        null != this.parent && this.parent.removeChild(this), delete this.domNode[r.DATA_KEY];
      }, t3.prototype.deleteAt = function(t4, e3) {
        this.isolate(t4, e3).remove();
      }, t3.prototype.formatAt = function(t4, e3, n2, o2) {
        var i2 = this.isolate(t4, e3);
        if (null != r.query(n2, r.Scope.BLOT) && o2) i2.wrap(n2, o2);
        else if (null != r.query(n2, r.Scope.ATTRIBUTE)) {
          var l = r.create(this.statics.scope);
          i2.wrap(l), l.format(n2, o2);
        }
      }, t3.prototype.insertAt = function(t4, e3, n2) {
        var o2 = null == n2 ? r.create("text", e3) : r.create(e3, n2), i2 = this.split(t4);
        this.parent.insertBefore(o2, i2);
      }, t3.prototype.insertInto = function(t4, e3) {
        void 0 === e3 && (e3 = null), null != this.parent && this.parent.children.remove(this);
        var n2 = null;
        t4.children.insertBefore(this, e3), null != e3 && (n2 = e3.domNode), this.domNode.parentNode == t4.domNode && this.domNode.nextSibling == n2 || t4.domNode.insertBefore(this.domNode, n2), this.parent = t4, this.attach();
      }, t3.prototype.isolate = function(t4, e3) {
        var n2 = this.split(t4);
        return n2.split(e3), n2;
      }, t3.prototype.length = function() {
        return 1;
      }, t3.prototype.offset = function(t4) {
        return void 0 === t4 && (t4 = this.parent), null == this.parent || this == t4 ? 0 : this.parent.children.offset(this) + this.parent.offset(t4);
      }, t3.prototype.optimize = function(t4) {
        null != this.domNode[r.DATA_KEY] && delete this.domNode[r.DATA_KEY].mutations;
      }, t3.prototype.remove = function() {
        null != this.domNode.parentNode && this.domNode.parentNode.removeChild(this.domNode), this.detach();
      }, t3.prototype.replace = function(t4) {
        null != t4.parent && (t4.parent.insertBefore(this, t4.next), t4.remove());
      }, t3.prototype.replaceWith = function(t4, e3) {
        var n2 = "string" == typeof t4 ? r.create(t4, e3) : t4;
        return n2.replace(this), n2;
      }, t3.prototype.split = function(t4, e3) {
        return 0 === t4 ? this : this.next;
      }, t3.prototype.update = function(t4, e3) {
      }, t3.prototype.wrap = function(t4, e3) {
        var n2 = "string" == typeof t4 ? r.create(t4, e3) : t4;
        return null != this.parent && this.parent.insertBefore(n2, this.next), n2.appendChild(this), n2;
      }, t3.blotName = "abstract", t3;
    })();
    e2.default = o;
  }, function(t2, e2, n) {
    Object.defineProperty(e2, "__esModule", { value: true });
    var r = n(11), o = n(29), i2 = n(30), l = n(1), a3 = (function() {
      function t3(t4) {
        this.attributes = {}, this.domNode = t4, this.build();
      }
      return t3.prototype.attribute = function(t4, e3) {
        e3 ? t4.add(this.domNode, e3) && (null != t4.value(this.domNode) ? this.attributes[t4.attrName] = t4 : delete this.attributes[t4.attrName]) : (t4.remove(this.domNode), delete this.attributes[t4.attrName]);
      }, t3.prototype.build = function() {
        var t4 = this;
        this.attributes = {};
        var e3 = r.default.keys(this.domNode), n2 = o.default.keys(this.domNode), a4 = i2.default.keys(this.domNode);
        e3.concat(n2).concat(a4).forEach(function(e4) {
          var n3 = l.query(e4, l.Scope.ATTRIBUTE);
          n3 instanceof r.default && (t4.attributes[n3.attrName] = n3);
        });
      }, t3.prototype.copy = function(t4) {
        var e3 = this;
        Object.keys(this.attributes).forEach(function(n2) {
          var r2 = e3.attributes[n2].value(e3.domNode);
          t4.format(n2, r2);
        });
      }, t3.prototype.move = function(t4) {
        var e3 = this;
        this.copy(t4), Object.keys(this.attributes).forEach(function(t5) {
          e3.attributes[t5].remove(e3.domNode);
        }), this.attributes = {};
      }, t3.prototype.values = function() {
        var t4 = this;
        return Object.keys(this.attributes).reduce(function(e3, n2) {
          return e3[n2] = t4.attributes[n2].value(t4.domNode), e3;
        }, {});
      }, t3;
    })();
    e2.default = a3;
  }, function(t2, e2, n) {
    function r(t3, e3) {
      return (t3.getAttribute("class") || "").split(/\s+/).filter(function(t4) {
        return 0 === t4.indexOf(e3 + "-");
      });
    }
    var o = this && this.__extends || (function() {
      var t3 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t4, e3) {
        t4.__proto__ = e3;
      } || function(t4, e3) {
        for (var n2 in e3) e3.hasOwnProperty(n2) && (t4[n2] = e3[n2]);
      };
      return function(e3, n2) {
        function r2() {
          this.constructor = e3;
        }
        t3(e3, n2), e3.prototype = null === n2 ? Object.create(n2) : (r2.prototype = n2.prototype, new r2());
      };
    })();
    Object.defineProperty(e2, "__esModule", { value: true });
    var i2 = n(11), l = (function(t3) {
      function e3() {
        return null !== t3 && t3.apply(this, arguments) || this;
      }
      return o(e3, t3), e3.keys = function(t4) {
        return (t4.getAttribute("class") || "").split(/\s+/).map(function(t5) {
          return t5.split("-").slice(0, -1).join("-");
        });
      }, e3.prototype.add = function(t4, e4) {
        return !!this.canAdd(t4, e4) && (this.remove(t4), t4.classList.add(this.keyName + "-" + e4), true);
      }, e3.prototype.remove = function(t4) {
        r(t4, this.keyName).forEach(function(e4) {
          t4.classList.remove(e4);
        }), 0 === t4.classList.length && t4.removeAttribute("class");
      }, e3.prototype.value = function(t4) {
        var e4 = r(t4, this.keyName)[0] || "", n2 = e4.slice(this.keyName.length + 1);
        return this.canAdd(t4, n2) ? n2 : "";
      }, e3;
    })(i2.default);
    e2.default = l;
  }, function(t2, e2, n) {
    function r(t3) {
      var e3 = t3.split("-"), n2 = e3.slice(1).map(function(t4) {
        return t4[0].toUpperCase() + t4.slice(1);
      }).join("");
      return e3[0] + n2;
    }
    var o = this && this.__extends || (function() {
      var t3 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t4, e3) {
        t4.__proto__ = e3;
      } || function(t4, e3) {
        for (var n2 in e3) e3.hasOwnProperty(n2) && (t4[n2] = e3[n2]);
      };
      return function(e3, n2) {
        function r2() {
          this.constructor = e3;
        }
        t3(e3, n2), e3.prototype = null === n2 ? Object.create(n2) : (r2.prototype = n2.prototype, new r2());
      };
    })();
    Object.defineProperty(e2, "__esModule", { value: true });
    var i2 = n(11), l = (function(t3) {
      function e3() {
        return null !== t3 && t3.apply(this, arguments) || this;
      }
      return o(e3, t3), e3.keys = function(t4) {
        return (t4.getAttribute("style") || "").split(";").map(function(t5) {
          return t5.split(":")[0].trim();
        });
      }, e3.prototype.add = function(t4, e4) {
        return !!this.canAdd(t4, e4) && (t4.style[r(this.keyName)] = e4, true);
      }, e3.prototype.remove = function(t4) {
        t4.style[r(this.keyName)] = "", t4.getAttribute("style") || t4.removeAttribute("style");
      }, e3.prototype.value = function(t4) {
        var e4 = t4.style[r(this.keyName)];
        return this.canAdd(t4, e4) ? e4 : "";
      }, e3;
    })(i2.default);
    e2.default = l;
  }, function(t2, e2, n) {
    function r(t3) {
      return t3 && t3.__esModule ? t3 : { default: t3 };
    }
    function o(t3, e3) {
      if (!(t3 instanceof e3)) throw new TypeError("Cannot call a class as a function");
    }
    function i2(t3, e3) {
      if (!t3) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      return !e3 || "object" != typeof e3 && "function" != typeof e3 ? t3 : e3;
    }
    function l(t3, e3) {
      if ("function" != typeof e3 && null !== e3) throw new TypeError("Super expression must either be null or a function, not " + typeof e3);
      t3.prototype = Object.create(e3 && e3.prototype, { constructor: { value: t3, enumerable: false, writable: true, configurable: true } }), e3 && (Object.setPrototypeOf ? Object.setPrototypeOf(t3, e3) : t3.__proto__ = e3);
    }
    Object.defineProperty(e2, "__esModule", { value: true });
    var a3 = /* @__PURE__ */ (function() {
      function t3(t4, e3) {
        var n2 = [], r2 = true, o2 = false, i3 = void 0;
        try {
          for (var l2, a4 = t4[Symbol.iterator](); !(r2 = (l2 = a4.next()).done) && (n2.push(l2.value), !e3 || n2.length !== e3); r2 = true) ;
        } catch (t5) {
          o2 = true, i3 = t5;
        } finally {
          try {
            !r2 && a4.return && a4.return();
          } finally {
            if (o2) throw i3;
          }
        }
        return n2;
      }
      return function(e3, n2) {
        if (Array.isArray(e3)) return e3;
        if (Symbol.iterator in Object(e3)) return t3(e3, n2);
        throw new TypeError("Invalid attempt to destructure non-iterable instance");
      };
    })(), s3 = function t3(e3, n2, r2) {
      null === e3 && (e3 = Function.prototype);
      var o2 = Object.getOwnPropertyDescriptor(e3, n2);
      if (void 0 === o2) {
        var i3 = Object.getPrototypeOf(e3);
        return null === i3 ? void 0 : t3(i3, n2, r2);
      }
      if ("value" in o2) return o2.value;
      var l2 = o2.get;
      if (void 0 !== l2) return l2.call(r2);
    }, u2 = /* @__PURE__ */ (function() {
      function t3(t4, e3) {
        for (var n2 = 0; n2 < e3.length; n2++) {
          var r2 = e3[n2];
          r2.enumerable = r2.enumerable || false, r2.configurable = true, "value" in r2 && (r2.writable = true), Object.defineProperty(t4, r2.key, r2);
        }
      }
      return function(e3, n2, r2) {
        return n2 && t3(e3.prototype, n2), r2 && t3(e3, r2), e3;
      };
    })(), c2 = n(0), f = r(c2), h3 = n(8), p = r(h3), d3 = (function(t3) {
      function e3(t4, n2) {
        o(this, e3);
        var r2 = i2(this, (e3.__proto__ || Object.getPrototypeOf(e3)).call(this, t4));
        return r2.selection = n2, r2.textNode = document.createTextNode(e3.CONTENTS), r2.domNode.appendChild(r2.textNode), r2._length = 0, r2;
      }
      return l(e3, t3), u2(e3, null, [{ key: "value", value: function() {
      } }]), u2(e3, [{ key: "detach", value: function() {
        null != this.parent && this.parent.removeChild(this);
      } }, { key: "format", value: function(t4, n2) {
        if (0 !== this._length) return s3(e3.prototype.__proto__ || Object.getPrototypeOf(e3.prototype), "format", this).call(this, t4, n2);
        for (var r2 = this, o2 = 0; null != r2 && r2.statics.scope !== f.default.Scope.BLOCK_BLOT; ) o2 += r2.offset(r2.parent), r2 = r2.parent;
        null != r2 && (this._length = e3.CONTENTS.length, r2.optimize(), r2.formatAt(o2, e3.CONTENTS.length, t4, n2), this._length = 0);
      } }, { key: "index", value: function(t4, n2) {
        return t4 === this.textNode ? 0 : s3(e3.prototype.__proto__ || Object.getPrototypeOf(e3.prototype), "index", this).call(this, t4, n2);
      } }, { key: "length", value: function() {
        return this._length;
      } }, { key: "position", value: function() {
        return [this.textNode, this.textNode.data.length];
      } }, { key: "remove", value: function() {
        s3(e3.prototype.__proto__ || Object.getPrototypeOf(e3.prototype), "remove", this).call(this), this.parent = null;
      } }, { key: "restore", value: function() {
        if (!this.selection.composing && null != this.parent) {
          var t4 = this.textNode, n2 = this.selection.getNativeRange(), r2 = void 0, o2 = void 0, i3 = void 0;
          if (null != n2 && n2.start.node === t4 && n2.end.node === t4) {
            var l2 = [t4, n2.start.offset, n2.end.offset];
            r2 = l2[0], o2 = l2[1], i3 = l2[2];
          }
          for (; null != this.domNode.lastChild && this.domNode.lastChild !== this.textNode; ) this.domNode.parentNode.insertBefore(this.domNode.lastChild, this.domNode);
          if (this.textNode.data !== e3.CONTENTS) {
            var s4 = this.textNode.data.split(e3.CONTENTS).join("");
            this.next instanceof p.default ? (r2 = this.next.domNode, this.next.insertAt(0, s4), this.textNode.data = e3.CONTENTS) : (this.textNode.data = s4, this.parent.insertBefore(f.default.create(this.textNode), this), this.textNode = document.createTextNode(e3.CONTENTS), this.domNode.appendChild(this.textNode));
          }
          if (this.remove(), null != o2) {
            var u3 = [o2, i3].map(function(t5) {
              return Math.max(0, Math.min(r2.data.length, t5 - 1));
            }), c3 = a3(u3, 2);
            return o2 = c3[0], i3 = c3[1], { startNode: r2, startOffset: o2, endNode: r2, endOffset: i3 };
          }
        }
      } }, { key: "update", value: function(t4, e4) {
        var n2 = this;
        if (t4.some(function(t5) {
          return "characterData" === t5.type && t5.target === n2.textNode;
        })) {
          var r2 = this.restore();
          r2 && (e4.range = r2);
        }
      } }, { key: "value", value: function() {
        return "";
      } }]), e3;
    })(f.default.Embed);
    d3.blotName = "cursor", d3.className = "ql-cursor", d3.tagName = "span", d3.CONTENTS = "\uFEFF", e2.default = d3;
  }, function(t2, e2, n) {
    function r(t3, e3) {
      if (!(t3 instanceof e3)) throw new TypeError("Cannot call a class as a function");
    }
    Object.defineProperty(e2, "__esModule", { value: true });
    var o = /* @__PURE__ */ (function() {
      function t3(t4, e3) {
        for (var n2 = 0; n2 < e3.length; n2++) {
          var r2 = e3[n2];
          r2.enumerable = r2.enumerable || false, r2.configurable = true, "value" in r2 && (r2.writable = true), Object.defineProperty(t4, r2.key, r2);
        }
      }
      return function(e3, n2, r2) {
        return n2 && t3(e3.prototype, n2), r2 && t3(e3, r2), e3;
      };
    })(), i2 = (function() {
      function t3(e3, n2) {
        r(this, t3), this.quill = e3, this.options = n2, this.modules = {};
      }
      return o(t3, [{ key: "init", value: function() {
        var t4 = this;
        Object.keys(this.options.modules).forEach(function(e3) {
          null == t4.modules[e3] && t4.addModule(e3);
        });
      } }, { key: "addModule", value: function(t4) {
        var e3 = this.quill.constructor.import("modules/" + t4);
        return this.modules[t4] = new e3(this.quill, this.options.modules[t4] || {}), this.modules[t4];
      } }]), t3;
    })();
    i2.DEFAULTS = { modules: {} }, i2.themes = { default: i2 }, e2.default = i2;
  }, function(t2, e2, n) {
    function r(t3) {
      return t3 && t3.__esModule ? t3 : { default: t3 };
    }
    function o(t3, e3) {
      if (!(t3 instanceof e3)) throw new TypeError("Cannot call a class as a function");
    }
    function i2(t3, e3) {
      if (!t3) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      return !e3 || "object" != typeof e3 && "function" != typeof e3 ? t3 : e3;
    }
    function l(t3, e3) {
      if ("function" != typeof e3 && null !== e3) throw new TypeError("Super expression must either be null or a function, not " + typeof e3);
      t3.prototype = Object.create(e3 && e3.prototype, { constructor: { value: t3, enumerable: false, writable: true, configurable: true } }), e3 && (Object.setPrototypeOf ? Object.setPrototypeOf(t3, e3) : t3.__proto__ = e3);
    }
    Object.defineProperty(e2, "__esModule", { value: true });
    var a3 = /* @__PURE__ */ (function() {
      function t3(t4, e3) {
        for (var n2 = 0; n2 < e3.length; n2++) {
          var r2 = e3[n2];
          r2.enumerable = r2.enumerable || false, r2.configurable = true, "value" in r2 && (r2.writable = true), Object.defineProperty(t4, r2.key, r2);
        }
      }
      return function(e3, n2, r2) {
        return n2 && t3(e3.prototype, n2), r2 && t3(e3, r2), e3;
      };
    })(), s3 = function t3(e3, n2, r2) {
      null === e3 && (e3 = Function.prototype);
      var o2 = Object.getOwnPropertyDescriptor(e3, n2);
      if (void 0 === o2) {
        var i3 = Object.getPrototypeOf(e3);
        return null === i3 ? void 0 : t3(i3, n2, r2);
      }
      if ("value" in o2) return o2.value;
      var l2 = o2.get;
      if (void 0 !== l2) return l2.call(r2);
    }, u2 = n(0), c2 = r(u2), f = n(8), h3 = r(f), p = "\uFEFF", d3 = (function(t3) {
      function e3(t4) {
        o(this, e3);
        var n2 = i2(this, (e3.__proto__ || Object.getPrototypeOf(e3)).call(this, t4));
        return n2.contentNode = document.createElement("span"), n2.contentNode.setAttribute("contenteditable", false), [].slice.call(n2.domNode.childNodes).forEach(function(t5) {
          n2.contentNode.appendChild(t5);
        }), n2.leftGuard = document.createTextNode(p), n2.rightGuard = document.createTextNode(p), n2.domNode.appendChild(n2.leftGuard), n2.domNode.appendChild(n2.contentNode), n2.domNode.appendChild(n2.rightGuard), n2;
      }
      return l(e3, t3), a3(e3, [{ key: "index", value: function(t4, n2) {
        return t4 === this.leftGuard ? 0 : t4 === this.rightGuard ? 1 : s3(e3.prototype.__proto__ || Object.getPrototypeOf(e3.prototype), "index", this).call(this, t4, n2);
      } }, { key: "restore", value: function(t4) {
        var e4 = void 0, n2 = void 0, r2 = t4.data.split(p).join("");
        if (t4 === this.leftGuard) if (this.prev instanceof h3.default) {
          var o2 = this.prev.length();
          this.prev.insertAt(o2, r2), e4 = { startNode: this.prev.domNode, startOffset: o2 + r2.length };
        } else n2 = document.createTextNode(r2), this.parent.insertBefore(c2.default.create(n2), this), e4 = { startNode: n2, startOffset: r2.length };
        else t4 === this.rightGuard && (this.next instanceof h3.default ? (this.next.insertAt(0, r2), e4 = { startNode: this.next.domNode, startOffset: r2.length }) : (n2 = document.createTextNode(r2), this.parent.insertBefore(c2.default.create(n2), this.next), e4 = { startNode: n2, startOffset: r2.length }));
        return t4.data = p, e4;
      } }, { key: "update", value: function(t4, e4) {
        var n2 = this;
        t4.forEach(function(t5) {
          if ("characterData" === t5.type && (t5.target === n2.leftGuard || t5.target === n2.rightGuard)) {
            var r2 = n2.restore(t5.target);
            r2 && (e4.range = r2);
          }
        });
      } }]), e3;
    })(c2.default.Embed);
    e2.default = d3;
  }, function(t2, e2, n) {
    Object.defineProperty(e2, "__esModule", { value: true }), e2.AlignStyle = e2.AlignClass = e2.AlignAttribute = void 0;
    var r = n(0), o = (function(t3) {
      return t3 && t3.__esModule ? t3 : { default: t3 };
    })(r), i2 = { scope: o.default.Scope.BLOCK, whitelist: ["right", "center", "justify"] }, l = new o.default.Attributor.Attribute("align", "align", i2), a3 = new o.default.Attributor.Class("align", "ql-align", i2), s3 = new o.default.Attributor.Style("align", "text-align", i2);
    e2.AlignAttribute = l, e2.AlignClass = a3, e2.AlignStyle = s3;
  }, function(t2, e2, n) {
    Object.defineProperty(e2, "__esModule", { value: true }), e2.BackgroundStyle = e2.BackgroundClass = void 0;
    var r = n(0), o = (function(t3) {
      return t3 && t3.__esModule ? t3 : { default: t3 };
    })(r), i2 = n(24), l = new o.default.Attributor.Class("background", "ql-bg", { scope: o.default.Scope.INLINE }), a3 = new i2.ColorAttributor("background", "background-color", { scope: o.default.Scope.INLINE });
    e2.BackgroundClass = l, e2.BackgroundStyle = a3;
  }, function(t2, e2, n) {
    Object.defineProperty(e2, "__esModule", { value: true }), e2.DirectionStyle = e2.DirectionClass = e2.DirectionAttribute = void 0;
    var r = n(0), o = (function(t3) {
      return t3 && t3.__esModule ? t3 : { default: t3 };
    })(r), i2 = { scope: o.default.Scope.BLOCK, whitelist: ["rtl"] }, l = new o.default.Attributor.Attribute("direction", "dir", i2), a3 = new o.default.Attributor.Class("direction", "ql-direction", i2), s3 = new o.default.Attributor.Style("direction", "direction", i2);
    e2.DirectionAttribute = l, e2.DirectionClass = a3, e2.DirectionStyle = s3;
  }, function(t2, e2, n) {
    function r(t3, e3) {
      if (!(t3 instanceof e3)) throw new TypeError("Cannot call a class as a function");
    }
    function o(t3, e3) {
      if (!t3) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      return !e3 || "object" != typeof e3 && "function" != typeof e3 ? t3 : e3;
    }
    function i2(t3, e3) {
      if ("function" != typeof e3 && null !== e3) throw new TypeError("Super expression must either be null or a function, not " + typeof e3);
      t3.prototype = Object.create(e3 && e3.prototype, { constructor: { value: t3, enumerable: false, writable: true, configurable: true } }), e3 && (Object.setPrototypeOf ? Object.setPrototypeOf(t3, e3) : t3.__proto__ = e3);
    }
    Object.defineProperty(e2, "__esModule", { value: true }), e2.FontClass = e2.FontStyle = void 0;
    var l = /* @__PURE__ */ (function() {
      function t3(t4, e3) {
        for (var n2 = 0; n2 < e3.length; n2++) {
          var r2 = e3[n2];
          r2.enumerable = r2.enumerable || false, r2.configurable = true, "value" in r2 && (r2.writable = true), Object.defineProperty(t4, r2.key, r2);
        }
      }
      return function(e3, n2, r2) {
        return n2 && t3(e3.prototype, n2), r2 && t3(e3, r2), e3;
      };
    })(), a3 = function t3(e3, n2, r2) {
      null === e3 && (e3 = Function.prototype);
      var o2 = Object.getOwnPropertyDescriptor(e3, n2);
      if (void 0 === o2) {
        var i3 = Object.getPrototypeOf(e3);
        return null === i3 ? void 0 : t3(i3, n2, r2);
      }
      if ("value" in o2) return o2.value;
      var l2 = o2.get;
      if (void 0 !== l2) return l2.call(r2);
    }, s3 = n(0), u2 = (function(t3) {
      return t3 && t3.__esModule ? t3 : { default: t3 };
    })(s3), c2 = { scope: u2.default.Scope.INLINE, whitelist: ["serif", "monospace"] }, f = new u2.default.Attributor.Class("font", "ql-font", c2), h3 = (function(t3) {
      function e3() {
        return r(this, e3), o(this, (e3.__proto__ || Object.getPrototypeOf(e3)).apply(this, arguments));
      }
      return i2(e3, t3), l(e3, [{ key: "value", value: function(t4) {
        return a3(e3.prototype.__proto__ || Object.getPrototypeOf(e3.prototype), "value", this).call(this, t4).replace(/["']/g, "");
      } }]), e3;
    })(u2.default.Attributor.Style), p = new h3("font", "font-family", c2);
    e2.FontStyle = p, e2.FontClass = f;
  }, function(t2, e2, n) {
    Object.defineProperty(e2, "__esModule", { value: true }), e2.SizeStyle = e2.SizeClass = void 0;
    var r = n(0), o = (function(t3) {
      return t3 && t3.__esModule ? t3 : { default: t3 };
    })(r), i2 = new o.default.Attributor.Class("size", "ql-size", { scope: o.default.Scope.INLINE, whitelist: ["small", "large", "huge"] }), l = new o.default.Attributor.Style("size", "font-size", { scope: o.default.Scope.INLINE, whitelist: ["10px", "18px", "32px"] });
    e2.SizeClass = i2, e2.SizeStyle = l;
  }, function(t2, e2, n) {
    function r(t3, e3) {
      if (!(t3 instanceof e3)) throw new TypeError("Cannot call a class as a function");
    }
    function o(t3, e3) {
      if (!t3) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      return !e3 || "object" != typeof e3 && "function" != typeof e3 ? t3 : e3;
    }
    function i2(t3, e3) {
      if ("function" != typeof e3 && null !== e3) throw new TypeError("Super expression must either be null or a function, not " + typeof e3);
      t3.prototype = Object.create(e3 && e3.prototype, { constructor: { value: t3, enumerable: false, writable: true, configurable: true } }), e3 && (Object.setPrototypeOf ? Object.setPrototypeOf(t3, e3) : t3.__proto__ = e3);
    }
    Object.defineProperty(e2, "__esModule", { value: true });
    var l = /* @__PURE__ */ (function() {
      function t3(t4, e3) {
        for (var n2 = 0; n2 < e3.length; n2++) {
          var r2 = e3[n2];
          r2.enumerable = r2.enumerable || false, r2.configurable = true, "value" in r2 && (r2.writable = true), Object.defineProperty(t4, r2.key, r2);
        }
      }
      return function(e3, n2, r2) {
        return n2 && t3(e3.prototype, n2), r2 && t3(e3, r2), e3;
      };
    })(), a3 = function t3(e3, n2, r2) {
      null === e3 && (e3 = Function.prototype);
      var o2 = Object.getOwnPropertyDescriptor(e3, n2);
      if (void 0 === o2) {
        var i3 = Object.getPrototypeOf(e3);
        return null === i3 ? void 0 : t3(i3, n2, r2);
      }
      if ("value" in o2) return o2.value;
      var l2 = o2.get;
      if (void 0 !== l2) return l2.call(r2);
    }, s3 = n(5), u2 = (function(t3) {
      return t3 && t3.__esModule ? t3 : { default: t3 };
    })(s3), c2 = (function(t3) {
      function e3() {
        return r(this, e3), o(this, (e3.__proto__ || Object.getPrototypeOf(e3)).apply(this, arguments));
      }
      return i2(e3, t3), l(e3, [{ key: "optimize", value: function(t4) {
        a3(e3.prototype.__proto__ || Object.getPrototypeOf(e3.prototype), "optimize", this).call(this, t4), this.domNode.tagName !== this.statics.tagName[0] && this.replaceWith(this.statics.blotName);
      } }], [{ key: "create", value: function() {
        return a3(e3.__proto__ || Object.getPrototypeOf(e3), "create", this).call(this);
      } }, { key: "formats", value: function() {
        return true;
      } }]), e3;
    })(u2.default);
    c2.blotName = "bold", c2.tagName = ["STRONG", "B"], e2.default = c2;
  }, function(t2, e2) {
    t2.exports = '<svg viewbox="0 0 18 18"> <polyline class="ql-even ql-stroke" points="5 7 3 9 5 11"></polyline> <polyline class="ql-even ql-stroke" points="13 7 15 9 13 11"></polyline> <line class=ql-stroke x1=10 x2=8 y1=5 y2=13></line> </svg>';
  }, function(t2, e2, n) {
    function r(t3, e3) {
      if (!(t3 instanceof e3)) throw new TypeError("Cannot call a class as a function");
    }
    function o(t3, e3) {
      if (!t3) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      return !e3 || "object" != typeof e3 && "function" != typeof e3 ? t3 : e3;
    }
    function i2(t3, e3) {
      if ("function" != typeof e3 && null !== e3) throw new TypeError("Super expression must either be null or a function, not " + typeof e3);
      t3.prototype = Object.create(e3 && e3.prototype, { constructor: { value: t3, enumerable: false, writable: true, configurable: true } }), e3 && (Object.setPrototypeOf ? Object.setPrototypeOf(t3, e3) : t3.__proto__ = e3);
    }
    Object.defineProperty(e2, "__esModule", { value: true });
    var l = /* @__PURE__ */ (function() {
      function t3(t4, e3) {
        for (var n2 = 0; n2 < e3.length; n2++) {
          var r2 = e3[n2];
          r2.enumerable = r2.enumerable || false, r2.configurable = true, "value" in r2 && (r2.writable = true), Object.defineProperty(t4, r2.key, r2);
        }
      }
      return function(e3, n2, r2) {
        return n2 && t3(e3.prototype, n2), r2 && t3(e3, r2), e3;
      };
    })(), a3 = function t3(e3, n2, r2) {
      null === e3 && (e3 = Function.prototype);
      var o2 = Object.getOwnPropertyDescriptor(e3, n2);
      if (void 0 === o2) {
        var i3 = Object.getPrototypeOf(e3);
        return null === i3 ? void 0 : t3(i3, n2, r2);
      }
      if ("value" in o2) return o2.value;
      var l2 = o2.get;
      if (void 0 !== l2) return l2.call(r2);
    }, s3 = n(16), u2 = (function(t3) {
      return t3 && t3.__esModule ? t3 : { default: t3 };
    })(s3), c2 = (function(t3) {
      function e3(t4, n2) {
        r(this, e3);
        var i3 = o(this, (e3.__proto__ || Object.getPrototypeOf(e3)).call(this, t4));
        return i3.label.innerHTML = n2, i3.container.classList.add("ql-color-picker"), [].slice.call(i3.container.querySelectorAll(".ql-picker-item"), 0, 7).forEach(function(t5) {
          t5.classList.add("ql-primary");
        }), i3;
      }
      return i2(e3, t3), l(e3, [{ key: "buildItem", value: function(t4) {
        var n2 = a3(e3.prototype.__proto__ || Object.getPrototypeOf(e3.prototype), "buildItem", this).call(this, t4);
        return n2.style.backgroundColor = t4.getAttribute("value") || "", n2;
      } }, { key: "selectItem", value: function(t4, n2) {
        a3(e3.prototype.__proto__ || Object.getPrototypeOf(e3.prototype), "selectItem", this).call(this, t4, n2);
        var r2 = this.label.querySelector(".ql-color-label"), o2 = t4 ? t4.getAttribute("data-value") || "" : "";
        r2 && ("line" === r2.tagName ? r2.style.stroke = o2 : r2.style.fill = o2);
      } }]), e3;
    })(u2.default);
    e2.default = c2;
  }, function(t2, e2, n) {
    function r(t3, e3) {
      if (!(t3 instanceof e3)) throw new TypeError("Cannot call a class as a function");
    }
    function o(t3, e3) {
      if (!t3) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      return !e3 || "object" != typeof e3 && "function" != typeof e3 ? t3 : e3;
    }
    function i2(t3, e3) {
      if ("function" != typeof e3 && null !== e3) throw new TypeError("Super expression must either be null or a function, not " + typeof e3);
      t3.prototype = Object.create(e3 && e3.prototype, { constructor: { value: t3, enumerable: false, writable: true, configurable: true } }), e3 && (Object.setPrototypeOf ? Object.setPrototypeOf(t3, e3) : t3.__proto__ = e3);
    }
    Object.defineProperty(e2, "__esModule", { value: true });
    var l = /* @__PURE__ */ (function() {
      function t3(t4, e3) {
        for (var n2 = 0; n2 < e3.length; n2++) {
          var r2 = e3[n2];
          r2.enumerable = r2.enumerable || false, r2.configurable = true, "value" in r2 && (r2.writable = true), Object.defineProperty(t4, r2.key, r2);
        }
      }
      return function(e3, n2, r2) {
        return n2 && t3(e3.prototype, n2), r2 && t3(e3, r2), e3;
      };
    })(), a3 = function t3(e3, n2, r2) {
      null === e3 && (e3 = Function.prototype);
      var o2 = Object.getOwnPropertyDescriptor(e3, n2);
      if (void 0 === o2) {
        var i3 = Object.getPrototypeOf(e3);
        return null === i3 ? void 0 : t3(i3, n2, r2);
      }
      if ("value" in o2) return o2.value;
      var l2 = o2.get;
      if (void 0 !== l2) return l2.call(r2);
    }, s3 = n(16), u2 = (function(t3) {
      return t3 && t3.__esModule ? t3 : { default: t3 };
    })(s3), c2 = (function(t3) {
      function e3(t4, n2) {
        r(this, e3);
        var i3 = o(this, (e3.__proto__ || Object.getPrototypeOf(e3)).call(this, t4));
        return i3.container.classList.add("ql-icon-picker"), [].forEach.call(i3.container.querySelectorAll(".ql-picker-item"), function(t5) {
          t5.innerHTML = n2[t5.getAttribute("data-value") || ""];
        }), i3.defaultItem = i3.container.querySelector(".ql-selected"), i3.selectItem(i3.defaultItem), i3;
      }
      return i2(e3, t3), l(e3, [{ key: "selectItem", value: function(t4, n2) {
        a3(e3.prototype.__proto__ || Object.getPrototypeOf(e3.prototype), "selectItem", this).call(this, t4, n2), t4 = t4 || this.defaultItem, this.label.innerHTML = t4.innerHTML;
      } }]), e3;
    })(u2.default);
    e2.default = c2;
  }, function(t2, e2, n) {
    function r(t3, e3) {
      if (!(t3 instanceof e3)) throw new TypeError("Cannot call a class as a function");
    }
    Object.defineProperty(e2, "__esModule", { value: true });
    var o = /* @__PURE__ */ (function() {
      function t3(t4, e3) {
        for (var n2 = 0; n2 < e3.length; n2++) {
          var r2 = e3[n2];
          r2.enumerable = r2.enumerable || false, r2.configurable = true, "value" in r2 && (r2.writable = true), Object.defineProperty(t4, r2.key, r2);
        }
      }
      return function(e3, n2, r2) {
        return n2 && t3(e3.prototype, n2), r2 && t3(e3, r2), e3;
      };
    })(), i2 = (function() {
      function t3(e3, n2) {
        var o2 = this;
        r(this, t3), this.quill = e3, this.boundsContainer = n2 || document.body, this.root = e3.addContainer("ql-tooltip"), this.root.innerHTML = this.constructor.TEMPLATE, this.quill.root === this.quill.scrollingContainer && this.quill.root.addEventListener("scroll", function() {
          o2.root.style.marginTop = -1 * o2.quill.root.scrollTop + "px";
        }), this.hide();
      }
      return o(t3, [{ key: "hide", value: function() {
        this.root.classList.add("ql-hidden");
      } }, { key: "position", value: function(t4) {
        var e3 = t4.left + t4.width / 2 - this.root.offsetWidth / 2, n2 = t4.bottom + this.quill.root.scrollTop;
        this.root.style.left = e3 + "px", this.root.style.top = n2 + "px", this.root.classList.remove("ql-flip");
        var r2 = this.boundsContainer.getBoundingClientRect(), o2 = this.root.getBoundingClientRect(), i3 = 0;
        if (o2.right > r2.right && (i3 = r2.right - o2.right, this.root.style.left = e3 + i3 + "px"), o2.left < r2.left && (i3 = r2.left - o2.left, this.root.style.left = e3 + i3 + "px"), o2.bottom > r2.bottom) {
          var l = o2.bottom - o2.top, a3 = t4.bottom - t4.top + l;
          this.root.style.top = n2 - a3 + "px", this.root.classList.add("ql-flip");
        }
        return i3;
      } }, { key: "show", value: function() {
        this.root.classList.remove("ql-editing"), this.root.classList.remove("ql-hidden");
      } }]), t3;
    })();
    e2.default = i2;
  }, function(t2, e2, n) {
    function r(t3) {
      return t3 && t3.__esModule ? t3 : { default: t3 };
    }
    function o(t3, e3) {
      if (!(t3 instanceof e3)) throw new TypeError("Cannot call a class as a function");
    }
    function i2(t3, e3) {
      if (!t3) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      return !e3 || "object" != typeof e3 && "function" != typeof e3 ? t3 : e3;
    }
    function l(t3, e3) {
      if ("function" != typeof e3 && null !== e3) throw new TypeError("Super expression must either be null or a function, not " + typeof e3);
      t3.prototype = Object.create(e3 && e3.prototype, { constructor: { value: t3, enumerable: false, writable: true, configurable: true } }), e3 && (Object.setPrototypeOf ? Object.setPrototypeOf(t3, e3) : t3.__proto__ = e3);
    }
    function a3(t3) {
      var e3 = t3.match(/^(?:(https?):\/\/)?(?:(?:www|m)\.)?youtube\.com\/watch.*v=([a-zA-Z0-9_-]+)/) || t3.match(/^(?:(https?):\/\/)?(?:(?:www|m)\.)?youtu\.be\/([a-zA-Z0-9_-]+)/);
      return e3 ? (e3[1] || "https") + "://www.youtube.com/embed/" + e3[2] + "?showinfo=0" : (e3 = t3.match(/^(?:(https?):\/\/)?(?:www\.)?vimeo\.com\/(\d+)/)) ? (e3[1] || "https") + "://player.vimeo.com/video/" + e3[2] + "/" : t3;
    }
    function s3(t3, e3) {
      var n2 = arguments.length > 2 && void 0 !== arguments[2] && arguments[2];
      e3.forEach(function(e4) {
        var r2 = document.createElement("option");
        e4 === n2 ? r2.setAttribute("selected", "selected") : r2.setAttribute("value", e4), t3.appendChild(r2);
      });
    }
    Object.defineProperty(e2, "__esModule", { value: true }), e2.default = e2.BaseTooltip = void 0;
    var u2 = /* @__PURE__ */ (function() {
      function t3(t4, e3) {
        for (var n2 = 0; n2 < e3.length; n2++) {
          var r2 = e3[n2];
          r2.enumerable = r2.enumerable || false, r2.configurable = true, "value" in r2 && (r2.writable = true), Object.defineProperty(t4, r2.key, r2);
        }
      }
      return function(e3, n2, r2) {
        return n2 && t3(e3.prototype, n2), r2 && t3(e3, r2), e3;
      };
    })(), c2 = function t3(e3, n2, r2) {
      null === e3 && (e3 = Function.prototype);
      var o2 = Object.getOwnPropertyDescriptor(e3, n2);
      if (void 0 === o2) {
        var i3 = Object.getPrototypeOf(e3);
        return null === i3 ? void 0 : t3(i3, n2, r2);
      }
      if ("value" in o2) return o2.value;
      var l2 = o2.get;
      if (void 0 !== l2) return l2.call(r2);
    }, f = n(2), h3 = r(f), p = n(4), d3 = r(p), y3 = n(9), v = r(y3), b2 = n(25), g = r(b2), m3 = n(32), _ = r(m3), O2 = n(41), w2 = r(O2), x2 = n(42), k2 = r(x2), E2 = n(16), N = r(E2), j = n(43), A = r(j), q2 = [false, "center", "right", "justify"], T2 = ["#000000", "#e60000", "#ff9900", "#ffff00", "#008a00", "#0066cc", "#9933ff", "#ffffff", "#facccc", "#ffebcc", "#ffffcc", "#cce8cc", "#cce0f5", "#ebd6ff", "#bbbbbb", "#f06666", "#ffc266", "#ffff66", "#66b966", "#66a3e0", "#c285ff", "#888888", "#a10000", "#b26b00", "#b2b200", "#006100", "#0047b2", "#6b24b2", "#444444", "#5c0000", "#663d00", "#666600", "#003700", "#002966", "#3d1466"], P = [false, "serif", "monospace"], S3 = ["1", "2", "3", false], C = ["small", false, "large", "huge"], L2 = (function(t3) {
      function e3(t4, n2) {
        o(this, e3);
        var r2 = i2(this, (e3.__proto__ || Object.getPrototypeOf(e3)).call(this, t4, n2)), l2 = function e4(n3) {
          if (!document.body.contains(t4.root)) return document.body.removeEventListener("click", e4);
          null == r2.tooltip || r2.tooltip.root.contains(n3.target) || document.activeElement === r2.tooltip.textbox || r2.quill.hasFocus() || r2.tooltip.hide(), null != r2.pickers && r2.pickers.forEach(function(t5) {
            t5.container.contains(n3.target) || t5.close();
          });
        };
        return t4.emitter.listenDOM("click", document.body, l2), r2;
      }
      return l(e3, t3), u2(e3, [{ key: "addModule", value: function(t4) {
        var n2 = c2(e3.prototype.__proto__ || Object.getPrototypeOf(e3.prototype), "addModule", this).call(this, t4);
        return "toolbar" === t4 && this.extendToolbar(n2), n2;
      } }, { key: "buildButtons", value: function(t4, e4) {
        t4.forEach(function(t5) {
          (t5.getAttribute("class") || "").split(/\s+/).forEach(function(n2) {
            if (n2.startsWith("ql-") && (n2 = n2.slice("ql-".length), null != e4[n2])) if ("direction" === n2) t5.innerHTML = e4[n2][""] + e4[n2].rtl;
            else if ("string" == typeof e4[n2]) t5.innerHTML = e4[n2];
            else {
              var r2 = t5.value || "";
              null != r2 && e4[n2][r2] && (t5.innerHTML = e4[n2][r2]);
            }
          });
        });
      } }, { key: "buildPickers", value: function(t4, e4) {
        var n2 = this;
        this.pickers = t4.map(function(t5) {
          if (t5.classList.contains("ql-align")) return null == t5.querySelector("option") && s3(t5, q2), new k2.default(t5, e4.align);
          if (t5.classList.contains("ql-background") || t5.classList.contains("ql-color")) {
            var n3 = t5.classList.contains("ql-background") ? "background" : "color";
            return null == t5.querySelector("option") && s3(t5, T2, "background" === n3 ? "#ffffff" : "#000000"), new w2.default(t5, e4[n3]);
          }
          return null == t5.querySelector("option") && (t5.classList.contains("ql-font") ? s3(t5, P) : t5.classList.contains("ql-header") ? s3(t5, S3) : t5.classList.contains("ql-size") && s3(t5, C)), new N.default(t5);
        });
        var r2 = function() {
          n2.pickers.forEach(function(t5) {
            t5.update();
          });
        };
        this.quill.on(v.default.events.EDITOR_CHANGE, r2);
      } }]), e3;
    })(_.default);
    L2.DEFAULTS = (0, h3.default)(true, {}, _.default.DEFAULTS, { modules: { toolbar: { handlers: { formula: function() {
      this.quill.theme.tooltip.edit("formula");
    }, image: function() {
      var t3 = this, e3 = this.container.querySelector("input.ql-image[type=file]");
      null == e3 && (e3 = document.createElement("input"), e3.setAttribute("type", "file"), e3.setAttribute("accept", "image/png, image/gif, image/jpeg, image/bmp, image/x-icon"), e3.classList.add("ql-image"), e3.addEventListener("change", function() {
        if (null != e3.files && null != e3.files[0]) {
          var n2 = new FileReader();
          n2.onload = function(n3) {
            var r2 = t3.quill.getSelection(true);
            t3.quill.updateContents(new d3.default().retain(r2.index).delete(r2.length).insert({ image: n3.target.result }), v.default.sources.USER), t3.quill.setSelection(r2.index + 1, v.default.sources.SILENT), e3.value = "";
          }, n2.readAsDataURL(e3.files[0]);
        }
      }), this.container.appendChild(e3)), e3.click();
    }, video: function() {
      this.quill.theme.tooltip.edit("video");
    } } } } });
    var M3 = (function(t3) {
      function e3(t4, n2) {
        o(this, e3);
        var r2 = i2(this, (e3.__proto__ || Object.getPrototypeOf(e3)).call(this, t4, n2));
        return r2.textbox = r2.root.querySelector('input[type="text"]'), r2.listen(), r2;
      }
      return l(e3, t3), u2(e3, [{ key: "listen", value: function() {
        var t4 = this;
        this.textbox.addEventListener("keydown", function(e4) {
          g.default.match(e4, "enter") ? (t4.save(), e4.preventDefault()) : g.default.match(e4, "escape") && (t4.cancel(), e4.preventDefault());
        });
      } }, { key: "cancel", value: function() {
        this.hide();
      } }, { key: "edit", value: function() {
        var t4 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "link", e4 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null;
        this.root.classList.remove("ql-hidden"), this.root.classList.add("ql-editing"), null != e4 ? this.textbox.value = e4 : t4 !== this.root.getAttribute("data-mode") && (this.textbox.value = ""), this.position(this.quill.getBounds(this.quill.selection.savedRange)), this.textbox.select(), this.textbox.setAttribute("placeholder", this.textbox.getAttribute("data-" + t4) || ""), this.root.setAttribute("data-mode", t4);
      } }, { key: "restoreFocus", value: function() {
        var t4 = this.quill.scrollingContainer.scrollTop;
        this.quill.focus(), this.quill.scrollingContainer.scrollTop = t4;
      } }, { key: "save", value: function() {
        var t4 = this.textbox.value;
        switch (this.root.getAttribute("data-mode")) {
          case "link":
            var e4 = this.quill.root.scrollTop;
            this.linkRange ? (this.quill.formatText(this.linkRange, "link", t4, v.default.sources.USER), delete this.linkRange) : (this.restoreFocus(), this.quill.format("link", t4, v.default.sources.USER)), this.quill.root.scrollTop = e4;
            break;
          case "video":
            t4 = a3(t4);
          case "formula":
            if (!t4) break;
            var n2 = this.quill.getSelection(true);
            if (null != n2) {
              var r2 = n2.index + n2.length;
              this.quill.insertEmbed(r2, this.root.getAttribute("data-mode"), t4, v.default.sources.USER), "formula" === this.root.getAttribute("data-mode") && this.quill.insertText(r2 + 1, " ", v.default.sources.USER), this.quill.setSelection(r2 + 2, v.default.sources.USER);
            }
        }
        this.textbox.value = "", this.hide();
      } }]), e3;
    })(A.default);
    e2.BaseTooltip = M3, e2.default = L2;
  }, function(t2, e2, n) {
    function r(t3) {
      return t3 && t3.__esModule ? t3 : { default: t3 };
    }
    Object.defineProperty(e2, "__esModule", { value: true });
    var o = n(46), i2 = r(o), l = n(34), a3 = n(36), s3 = n(62), u2 = n(63), c2 = r(u2), f = n(64), h3 = r(f), p = n(65), d3 = r(p), y3 = n(35), v = n(24), b2 = n(37), g = n(38), m3 = n(39), _ = r(m3), O2 = n(66), w2 = r(O2), x2 = n(15), k2 = r(x2), E2 = n(67), N = r(E2), j = n(68), A = r(j), q2 = n(69), T2 = r(q2), P = n(70), S3 = r(P), C = n(71), L2 = r(C), M3 = n(13), R2 = r(M3), I2 = n(72), B2 = r(I2), D2 = n(73), U = r(D2), F = n(74), H3 = r(F), K2 = n(26), z2 = r(K2), V = n(16), Z = r(V), W = n(41), G2 = r(W), Y2 = n(42), X2 = r(Y2), $ = n(43), Q2 = r($), J = n(107), tt = r(J), et = n(108), nt = r(et);
    i2.default.register({ "attributors/attribute/direction": a3.DirectionAttribute, "attributors/class/align": l.AlignClass, "attributors/class/background": y3.BackgroundClass, "attributors/class/color": v.ColorClass, "attributors/class/direction": a3.DirectionClass, "attributors/class/font": b2.FontClass, "attributors/class/size": g.SizeClass, "attributors/style/align": l.AlignStyle, "attributors/style/background": y3.BackgroundStyle, "attributors/style/color": v.ColorStyle, "attributors/style/direction": a3.DirectionStyle, "attributors/style/font": b2.FontStyle, "attributors/style/size": g.SizeStyle }, true), i2.default.register({ "formats/align": l.AlignClass, "formats/direction": a3.DirectionClass, "formats/indent": s3.IndentClass, "formats/background": y3.BackgroundStyle, "formats/color": v.ColorStyle, "formats/font": b2.FontClass, "formats/size": g.SizeClass, "formats/blockquote": c2.default, "formats/code-block": R2.default, "formats/header": h3.default, "formats/list": d3.default, "formats/bold": _.default, "formats/code": M3.Code, "formats/italic": w2.default, "formats/link": k2.default, "formats/script": N.default, "formats/strike": A.default, "formats/underline": T2.default, "formats/image": S3.default, "formats/video": L2.default, "formats/list/item": p.ListItem, "modules/formula": B2.default, "modules/syntax": U.default, "modules/toolbar": H3.default, "themes/bubble": tt.default, "themes/snow": nt.default, "ui/icons": z2.default, "ui/picker": Z.default, "ui/icon-picker": X2.default, "ui/color-picker": G2.default, "ui/tooltip": Q2.default }, true), e2.default = i2.default;
  }, function(t2, e2, n) {
    function r(t3) {
      return t3 && t3.__esModule ? t3 : { default: t3 };
    }
    Object.defineProperty(e2, "__esModule", { value: true });
    var o = n(0), i2 = r(o), l = n(6), a3 = r(l), s3 = n(3), u2 = r(s3), c2 = n(14), f = r(c2), h3 = n(23), p = r(h3), d3 = n(31), y3 = r(d3), v = n(33), b2 = r(v), g = n(5), m3 = r(g), _ = n(59), O2 = r(_), w2 = n(8), x2 = r(w2), k2 = n(60), E2 = r(k2), N = n(61), j = r(N), A = n(25), q2 = r(A);
    a3.default.register({ "blots/block": u2.default, "blots/block/embed": s3.BlockEmbed, "blots/break": f.default, "blots/container": p.default, "blots/cursor": y3.default, "blots/embed": b2.default, "blots/inline": m3.default, "blots/scroll": O2.default, "blots/text": x2.default, "modules/clipboard": E2.default, "modules/history": j.default, "modules/keyboard": q2.default }), i2.default.register(u2.default, f.default, y3.default, m3.default, O2.default, x2.default), e2.default = a3.default;
  }, function(t2, e2, n) {
    Object.defineProperty(e2, "__esModule", { value: true });
    var r = (function() {
      function t3() {
        this.head = this.tail = null, this.length = 0;
      }
      return t3.prototype.append = function() {
        for (var t4 = [], e3 = 0; e3 < arguments.length; e3++) t4[e3] = arguments[e3];
        this.insertBefore(t4[0], null), t4.length > 1 && this.append.apply(this, t4.slice(1));
      }, t3.prototype.contains = function(t4) {
        for (var e3, n2 = this.iterator(); e3 = n2(); ) if (e3 === t4) return true;
        return false;
      }, t3.prototype.insertBefore = function(t4, e3) {
        t4 && (t4.next = e3, null != e3 ? (t4.prev = e3.prev, null != e3.prev && (e3.prev.next = t4), e3.prev = t4, e3 === this.head && (this.head = t4)) : null != this.tail ? (this.tail.next = t4, t4.prev = this.tail, this.tail = t4) : (t4.prev = null, this.head = this.tail = t4), this.length += 1);
      }, t3.prototype.offset = function(t4) {
        for (var e3 = 0, n2 = this.head; null != n2; ) {
          if (n2 === t4) return e3;
          e3 += n2.length(), n2 = n2.next;
        }
        return -1;
      }, t3.prototype.remove = function(t4) {
        this.contains(t4) && (null != t4.prev && (t4.prev.next = t4.next), null != t4.next && (t4.next.prev = t4.prev), t4 === this.head && (this.head = t4.next), t4 === this.tail && (this.tail = t4.prev), this.length -= 1);
      }, t3.prototype.iterator = function(t4) {
        return void 0 === t4 && (t4 = this.head), function() {
          var e3 = t4;
          return null != t4 && (t4 = t4.next), e3;
        };
      }, t3.prototype.find = function(t4, e3) {
        void 0 === e3 && (e3 = false);
        for (var n2, r2 = this.iterator(); n2 = r2(); ) {
          var o = n2.length();
          if (t4 < o || e3 && t4 === o && (null == n2.next || 0 !== n2.next.length())) return [n2, t4];
          t4 -= o;
        }
        return [null, 0];
      }, t3.prototype.forEach = function(t4) {
        for (var e3, n2 = this.iterator(); e3 = n2(); ) t4(e3);
      }, t3.prototype.forEachAt = function(t4, e3, n2) {
        if (!(e3 <= 0)) for (var r2, o = this.find(t4), i2 = o[0], l = o[1], a3 = t4 - l, s3 = this.iterator(i2); (r2 = s3()) && a3 < t4 + e3; ) {
          var u2 = r2.length();
          t4 > a3 ? n2(r2, t4 - a3, Math.min(e3, a3 + u2 - t4)) : n2(r2, 0, Math.min(u2, t4 + e3 - a3)), a3 += u2;
        }
      }, t3.prototype.map = function(t4) {
        return this.reduce(function(e3, n2) {
          return e3.push(t4(n2)), e3;
        }, []);
      }, t3.prototype.reduce = function(t4, e3) {
        for (var n2, r2 = this.iterator(); n2 = r2(); ) e3 = t4(e3, n2);
        return e3;
      }, t3;
    })();
    e2.default = r;
  }, function(t2, e2, n) {
    var r = this && this.__extends || (function() {
      var t3 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t4, e3) {
        t4.__proto__ = e3;
      } || function(t4, e3) {
        for (var n2 in e3) e3.hasOwnProperty(n2) && (t4[n2] = e3[n2]);
      };
      return function(e3, n2) {
        function r2() {
          this.constructor = e3;
        }
        t3(e3, n2), e3.prototype = null === n2 ? Object.create(n2) : (r2.prototype = n2.prototype, new r2());
      };
    })();
    Object.defineProperty(e2, "__esModule", { value: true });
    var o = n(17), i2 = n(1), l = { attributes: true, characterData: true, characterDataOldValue: true, childList: true, subtree: true }, a3 = (function(t3) {
      function e3(e4) {
        var n2 = t3.call(this, e4) || this;
        return n2.scroll = n2, n2.observer = new MutationObserver(function(t4) {
          n2.update(t4);
        }), n2.observer.observe(n2.domNode, l), n2.attach(), n2;
      }
      return r(e3, t3), e3.prototype.detach = function() {
        t3.prototype.detach.call(this), this.observer.disconnect();
      }, e3.prototype.deleteAt = function(e4, n2) {
        this.update(), 0 === e4 && n2 === this.length() ? this.children.forEach(function(t4) {
          t4.remove();
        }) : t3.prototype.deleteAt.call(this, e4, n2);
      }, e3.prototype.formatAt = function(e4, n2, r2, o2) {
        this.update(), t3.prototype.formatAt.call(this, e4, n2, r2, o2);
      }, e3.prototype.insertAt = function(e4, n2, r2) {
        this.update(), t3.prototype.insertAt.call(this, e4, n2, r2);
      }, e3.prototype.optimize = function(e4, n2) {
        var r2 = this;
        void 0 === e4 && (e4 = []), void 0 === n2 && (n2 = {}), t3.prototype.optimize.call(this, n2);
        for (var l2 = [].slice.call(this.observer.takeRecords()); l2.length > 0; ) e4.push(l2.pop());
        for (var a4 = function(t4, e5) {
          void 0 === e5 && (e5 = true), null != t4 && t4 !== r2 && null != t4.domNode.parentNode && (null == t4.domNode[i2.DATA_KEY].mutations && (t4.domNode[i2.DATA_KEY].mutations = []), e5 && a4(t4.parent));
        }, s3 = function(t4) {
          null != t4.domNode[i2.DATA_KEY] && null != t4.domNode[i2.DATA_KEY].mutations && (t4 instanceof o.default && t4.children.forEach(s3), t4.optimize(n2));
        }, u2 = e4, c2 = 0; u2.length > 0; c2 += 1) {
          if (c2 >= 100) throw new Error("[Parchment] Maximum optimize iterations reached");
          for (u2.forEach(function(t4) {
            var e5 = i2.find(t4.target, true);
            null != e5 && (e5.domNode === t4.target && ("childList" === t4.type ? (a4(i2.find(t4.previousSibling, false)), [].forEach.call(t4.addedNodes, function(t5) {
              var e6 = i2.find(t5, false);
              a4(e6, false), e6 instanceof o.default && e6.children.forEach(function(t6) {
                a4(t6, false);
              });
            })) : "attributes" === t4.type && a4(e5.prev)), a4(e5));
          }), this.children.forEach(s3), u2 = [].slice.call(this.observer.takeRecords()), l2 = u2.slice(); l2.length > 0; ) e4.push(l2.pop());
        }
      }, e3.prototype.update = function(e4, n2) {
        var r2 = this;
        void 0 === n2 && (n2 = {}), e4 = e4 || this.observer.takeRecords(), e4.map(function(t4) {
          var e5 = i2.find(t4.target, true);
          return null == e5 ? null : null == e5.domNode[i2.DATA_KEY].mutations ? (e5.domNode[i2.DATA_KEY].mutations = [t4], e5) : (e5.domNode[i2.DATA_KEY].mutations.push(t4), null);
        }).forEach(function(t4) {
          null != t4 && t4 !== r2 && null != t4.domNode[i2.DATA_KEY] && t4.update(t4.domNode[i2.DATA_KEY].mutations || [], n2);
        }), null != this.domNode[i2.DATA_KEY].mutations && t3.prototype.update.call(this, this.domNode[i2.DATA_KEY].mutations, n2), this.optimize(e4, n2);
      }, e3.blotName = "scroll", e3.defaultChild = "block", e3.scope = i2.Scope.BLOCK_BLOT, e3.tagName = "DIV", e3;
    })(o.default);
    e2.default = a3;
  }, function(t2, e2, n) {
    function r(t3, e3) {
      if (Object.keys(t3).length !== Object.keys(e3).length) return false;
      for (var n2 in t3) if (t3[n2] !== e3[n2]) return false;
      return true;
    }
    var o = this && this.__extends || (function() {
      var t3 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t4, e3) {
        t4.__proto__ = e3;
      } || function(t4, e3) {
        for (var n2 in e3) e3.hasOwnProperty(n2) && (t4[n2] = e3[n2]);
      };
      return function(e3, n2) {
        function r2() {
          this.constructor = e3;
        }
        t3(e3, n2), e3.prototype = null === n2 ? Object.create(n2) : (r2.prototype = n2.prototype, new r2());
      };
    })();
    Object.defineProperty(e2, "__esModule", { value: true });
    var i2 = n(18), l = n(1), a3 = (function(t3) {
      function e3() {
        return null !== t3 && t3.apply(this, arguments) || this;
      }
      return o(e3, t3), e3.formats = function(n2) {
        if (n2.tagName !== e3.tagName) return t3.formats.call(this, n2);
      }, e3.prototype.format = function(n2, r2) {
        var o2 = this;
        n2 !== this.statics.blotName || r2 ? t3.prototype.format.call(this, n2, r2) : (this.children.forEach(function(t4) {
          t4 instanceof i2.default || (t4 = t4.wrap(e3.blotName, true)), o2.attributes.copy(t4);
        }), this.unwrap());
      }, e3.prototype.formatAt = function(e4, n2, r2, o2) {
        if (null != this.formats()[r2] || l.query(r2, l.Scope.ATTRIBUTE)) {
          this.isolate(e4, n2).format(r2, o2);
        } else t3.prototype.formatAt.call(this, e4, n2, r2, o2);
      }, e3.prototype.optimize = function(n2) {
        t3.prototype.optimize.call(this, n2);
        var o2 = this.formats();
        if (0 === Object.keys(o2).length) return this.unwrap();
        var i3 = this.next;
        i3 instanceof e3 && i3.prev === this && r(o2, i3.formats()) && (i3.moveChildren(this), i3.remove());
      }, e3.blotName = "inline", e3.scope = l.Scope.INLINE_BLOT, e3.tagName = "SPAN", e3;
    })(i2.default);
    e2.default = a3;
  }, function(t2, e2, n) {
    var r = this && this.__extends || (function() {
      var t3 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t4, e3) {
        t4.__proto__ = e3;
      } || function(t4, e3) {
        for (var n2 in e3) e3.hasOwnProperty(n2) && (t4[n2] = e3[n2]);
      };
      return function(e3, n2) {
        function r2() {
          this.constructor = e3;
        }
        t3(e3, n2), e3.prototype = null === n2 ? Object.create(n2) : (r2.prototype = n2.prototype, new r2());
      };
    })();
    Object.defineProperty(e2, "__esModule", { value: true });
    var o = n(18), i2 = n(1), l = (function(t3) {
      function e3() {
        return null !== t3 && t3.apply(this, arguments) || this;
      }
      return r(e3, t3), e3.formats = function(n2) {
        var r2 = i2.query(e3.blotName).tagName;
        if (n2.tagName !== r2) return t3.formats.call(this, n2);
      }, e3.prototype.format = function(n2, r2) {
        null != i2.query(n2, i2.Scope.BLOCK) && (n2 !== this.statics.blotName || r2 ? t3.prototype.format.call(this, n2, r2) : this.replaceWith(e3.blotName));
      }, e3.prototype.formatAt = function(e4, n2, r2, o2) {
        null != i2.query(r2, i2.Scope.BLOCK) ? this.format(r2, o2) : t3.prototype.formatAt.call(this, e4, n2, r2, o2);
      }, e3.prototype.insertAt = function(e4, n2, r2) {
        if (null == r2 || null != i2.query(n2, i2.Scope.INLINE)) t3.prototype.insertAt.call(this, e4, n2, r2);
        else {
          var o2 = this.split(e4), l2 = i2.create(n2, r2);
          o2.parent.insertBefore(l2, o2);
        }
      }, e3.prototype.update = function(e4, n2) {
        navigator.userAgent.match(/Trident/) ? this.build() : t3.prototype.update.call(this, e4, n2);
      }, e3.blotName = "block", e3.scope = i2.Scope.BLOCK_BLOT, e3.tagName = "P", e3;
    })(o.default);
    e2.default = l;
  }, function(t2, e2, n) {
    var r = this && this.__extends || (function() {
      var t3 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t4, e3) {
        t4.__proto__ = e3;
      } || function(t4, e3) {
        for (var n2 in e3) e3.hasOwnProperty(n2) && (t4[n2] = e3[n2]);
      };
      return function(e3, n2) {
        function r2() {
          this.constructor = e3;
        }
        t3(e3, n2), e3.prototype = null === n2 ? Object.create(n2) : (r2.prototype = n2.prototype, new r2());
      };
    })();
    Object.defineProperty(e2, "__esModule", { value: true });
    var o = n(19), i2 = (function(t3) {
      function e3() {
        return null !== t3 && t3.apply(this, arguments) || this;
      }
      return r(e3, t3), e3.formats = function(t4) {
      }, e3.prototype.format = function(e4, n2) {
        t3.prototype.formatAt.call(this, 0, this.length(), e4, n2);
      }, e3.prototype.formatAt = function(e4, n2, r2, o2) {
        0 === e4 && n2 === this.length() ? this.format(r2, o2) : t3.prototype.formatAt.call(this, e4, n2, r2, o2);
      }, e3.prototype.formats = function() {
        return this.statics.formats(this.domNode);
      }, e3;
    })(o.default);
    e2.default = i2;
  }, function(t2, e2, n) {
    var r = this && this.__extends || (function() {
      var t3 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(t4, e3) {
        t4.__proto__ = e3;
      } || function(t4, e3) {
        for (var n2 in e3) e3.hasOwnProperty(n2) && (t4[n2] = e3[n2]);
      };
      return function(e3, n2) {
        function r2() {
          this.constructor = e3;
        }
        t3(e3, n2), e3.prototype = null === n2 ? Object.create(n2) : (r2.prototype = n2.prototype, new r2());
      };
    })();
    Object.defineProperty(e2, "__esModule", { value: true });
    var o = n(19), i2 = n(1), l = (function(t3) {
      function e3(e4) {
        var n2 = t3.call(this, e4) || this;
        return n2.text = n2.statics.value(n2.domNode), n2;
      }
      return r(e3, t3), e3.create = function(t4) {
        return document.createTextNode(t4);
      }, e3.value = function(t4) {
        var e4 = t4.data;
        return e4.normalize && (e4 = e4.normalize()), e4;
      }, e3.prototype.deleteAt = function(t4, e4) {
        this.domNode.data = this.text = this.text.slice(0, t4) + this.text.slice(t4 + e4);
      }, e3.prototype.index = function(t4, e4) {
        return this.domNode === t4 ? e4 : -1;
      }, e3.prototype.insertAt = function(e4, n2, r2) {
        null == r2 ? (this.text = this.text.slice(0, e4) + n2 + this.text.slice(e4), this.domNode.data = this.text) : t3.prototype.insertAt.call(this, e4, n2, r2);
      }, e3.prototype.length = function() {
        return this.text.length;
      }, e3.prototype.optimize = function(n2) {
        t3.prototype.optimize.call(this, n2), this.text = this.statics.value(this.domNode), 0 === this.text.length ? this.remove() : this.next instanceof e3 && this.next.prev === this && (this.insertAt(this.length(), this.next.value()), this.next.remove());
      }, e3.prototype.position = function(t4, e4) {
        return [this.domNode, t4];
      }, e3.prototype.split = function(t4, e4) {
        if (void 0 === e4 && (e4 = false), !e4) {
          if (0 === t4) return this;
          if (t4 === this.length()) return this.next;
        }
        var n2 = i2.create(this.domNode.splitText(t4));
        return this.parent.insertBefore(n2, this.next), this.text = this.statics.value(this.domNode), n2;
      }, e3.prototype.update = function(t4, e4) {
        var n2 = this;
        t4.some(function(t5) {
          return "characterData" === t5.type && t5.target === n2.domNode;
        }) && (this.text = this.statics.value(this.domNode));
      }, e3.prototype.value = function() {
        return this.text;
      }, e3.blotName = "text", e3.scope = i2.Scope.INLINE_BLOT, e3;
    })(o.default);
    e2.default = l;
  }, function(t2, e2, n) {
    var r = document.createElement("div");
    if (r.classList.toggle("test-class", false), r.classList.contains("test-class")) {
      var o = DOMTokenList.prototype.toggle;
      DOMTokenList.prototype.toggle = function(t3, e3) {
        return arguments.length > 1 && !this.contains(t3) == !e3 ? e3 : o.call(this, t3);
      };
    }
    String.prototype.startsWith || (String.prototype.startsWith = function(t3, e3) {
      return e3 = e3 || 0, this.substr(e3, t3.length) === t3;
    }), String.prototype.endsWith || (String.prototype.endsWith = function(t3, e3) {
      var n2 = this.toString();
      ("number" != typeof e3 || !isFinite(e3) || Math.floor(e3) !== e3 || e3 > n2.length) && (e3 = n2.length), e3 -= t3.length;
      var r2 = n2.indexOf(t3, e3);
      return -1 !== r2 && r2 === e3;
    }), Array.prototype.find || Object.defineProperty(Array.prototype, "find", { value: function(t3) {
      if (null === this) throw new TypeError("Array.prototype.find called on null or undefined");
      if ("function" != typeof t3) throw new TypeError("predicate must be a function");
      for (var e3, n2 = Object(this), r2 = n2.length >>> 0, o2 = arguments[1], i2 = 0; i2 < r2; i2++) if (e3 = n2[i2], t3.call(o2, e3, i2, n2)) return e3;
    } }), document.addEventListener("DOMContentLoaded", function() {
      document.execCommand("enableObjectResizing", false, false), document.execCommand("autoUrlDetect", false, false);
    });
  }, function(t2, e2) {
    function n(t3, e3, n2) {
      if (t3 == e3) return t3 ? [[v, t3]] : [];
      (n2 < 0 || t3.length < n2) && (n2 = null);
      var o2 = l(t3, e3), i3 = t3.substring(0, o2);
      t3 = t3.substring(o2), e3 = e3.substring(o2), o2 = a3(t3, e3);
      var s4 = t3.substring(t3.length - o2);
      t3 = t3.substring(0, t3.length - o2), e3 = e3.substring(0, e3.length - o2);
      var c3 = r(t3, e3);
      return i3 && c3.unshift([v, i3]), s4 && c3.push([v, s4]), u2(c3), null != n2 && (c3 = f(c3, n2)), c3 = h3(c3);
    }
    function r(t3, e3) {
      var r2;
      if (!t3) return [[y3, e3]];
      if (!e3) return [[d3, t3]];
      var i3 = t3.length > e3.length ? t3 : e3, l2 = t3.length > e3.length ? e3 : t3, a4 = i3.indexOf(l2);
      if (-1 != a4) return r2 = [[y3, i3.substring(0, a4)], [v, l2], [y3, i3.substring(a4 + l2.length)]], t3.length > e3.length && (r2[0][0] = r2[2][0] = d3), r2;
      if (1 == l2.length) return [[d3, t3], [y3, e3]];
      var u3 = s3(t3, e3);
      if (u3) {
        var c3 = u3[0], f2 = u3[1], h4 = u3[2], p2 = u3[3], b3 = u3[4], g = n(c3, h4), m3 = n(f2, p2);
        return g.concat([[v, b3]], m3);
      }
      return o(t3, e3);
    }
    function o(t3, e3) {
      for (var n2 = t3.length, r2 = e3.length, o2 = Math.ceil((n2 + r2) / 2), l2 = o2, a4 = 2 * o2, s4 = new Array(a4), u3 = new Array(a4), c3 = 0; c3 < a4; c3++) s4[c3] = -1, u3[c3] = -1;
      s4[l2 + 1] = 0, u3[l2 + 1] = 0;
      for (var f2 = n2 - r2, h4 = f2 % 2 != 0, p2 = 0, v2 = 0, b3 = 0, g = 0, m3 = 0; m3 < o2; m3++) {
        for (var _ = -m3 + p2; _ <= m3 - v2; _ += 2) {
          var O2, w2 = l2 + _;
          O2 = _ == -m3 || _ != m3 && s4[w2 - 1] < s4[w2 + 1] ? s4[w2 + 1] : s4[w2 - 1] + 1;
          for (var x2 = O2 - _; O2 < n2 && x2 < r2 && t3.charAt(O2) == e3.charAt(x2); ) O2++, x2++;
          if (s4[w2] = O2, O2 > n2) v2 += 2;
          else if (x2 > r2) p2 += 2;
          else if (h4) {
            var k2 = l2 + f2 - _;
            if (k2 >= 0 && k2 < a4 && -1 != u3[k2]) {
              var E2 = n2 - u3[k2];
              if (O2 >= E2) return i2(t3, e3, O2, x2);
            }
          }
        }
        for (var N = -m3 + b3; N <= m3 - g; N += 2) {
          var E2, k2 = l2 + N;
          E2 = N == -m3 || N != m3 && u3[k2 - 1] < u3[k2 + 1] ? u3[k2 + 1] : u3[k2 - 1] + 1;
          for (var j = E2 - N; E2 < n2 && j < r2 && t3.charAt(n2 - E2 - 1) == e3.charAt(r2 - j - 1); ) E2++, j++;
          if (u3[k2] = E2, E2 > n2) g += 2;
          else if (j > r2) b3 += 2;
          else if (!h4) {
            var w2 = l2 + f2 - N;
            if (w2 >= 0 && w2 < a4 && -1 != s4[w2]) {
              var O2 = s4[w2], x2 = l2 + O2 - w2;
              if (E2 = n2 - E2, O2 >= E2) return i2(t3, e3, O2, x2);
            }
          }
        }
      }
      return [[d3, t3], [y3, e3]];
    }
    function i2(t3, e3, r2, o2) {
      var i3 = t3.substring(0, r2), l2 = e3.substring(0, o2), a4 = t3.substring(r2), s4 = e3.substring(o2), u3 = n(i3, l2), c3 = n(a4, s4);
      return u3.concat(c3);
    }
    function l(t3, e3) {
      if (!t3 || !e3 || t3.charAt(0) != e3.charAt(0)) return 0;
      for (var n2 = 0, r2 = Math.min(t3.length, e3.length), o2 = r2, i3 = 0; n2 < o2; ) t3.substring(i3, o2) == e3.substring(i3, o2) ? (n2 = o2, i3 = n2) : r2 = o2, o2 = Math.floor((r2 - n2) / 2 + n2);
      return o2;
    }
    function a3(t3, e3) {
      if (!t3 || !e3 || t3.charAt(t3.length - 1) != e3.charAt(e3.length - 1)) return 0;
      for (var n2 = 0, r2 = Math.min(t3.length, e3.length), o2 = r2, i3 = 0; n2 < o2; ) t3.substring(t3.length - o2, t3.length - i3) == e3.substring(e3.length - o2, e3.length - i3) ? (n2 = o2, i3 = n2) : r2 = o2, o2 = Math.floor((r2 - n2) / 2 + n2);
      return o2;
    }
    function s3(t3, e3) {
      function n2(t4, e4, n3) {
        for (var r3, o3, i4, s5, u4 = t4.substring(n3, n3 + Math.floor(t4.length / 4)), c4 = -1, f3 = ""; -1 != (c4 = e4.indexOf(u4, c4 + 1)); ) {
          var h5 = l(t4.substring(n3), e4.substring(c4)), p3 = a3(t4.substring(0, n3), e4.substring(0, c4));
          f3.length < p3 + h5 && (f3 = e4.substring(c4 - p3, c4) + e4.substring(c4, c4 + h5), r3 = t4.substring(0, n3 - p3), o3 = t4.substring(n3 + h5), i4 = e4.substring(0, c4 - p3), s5 = e4.substring(c4 + h5));
        }
        return 2 * f3.length >= t4.length ? [r3, o3, i4, s5, f3] : null;
      }
      var r2 = t3.length > e3.length ? t3 : e3, o2 = t3.length > e3.length ? e3 : t3;
      if (r2.length < 4 || 2 * o2.length < r2.length) return null;
      var i3, s4 = n2(r2, o2, Math.ceil(r2.length / 4)), u3 = n2(r2, o2, Math.ceil(r2.length / 2));
      if (!s4 && !u3) return null;
      i3 = u3 ? s4 && s4[4].length > u3[4].length ? s4 : u3 : s4;
      var c3, f2, h4, p2;
      return t3.length > e3.length ? (c3 = i3[0], f2 = i3[1], h4 = i3[2], p2 = i3[3]) : (h4 = i3[0], p2 = i3[1], c3 = i3[2], f2 = i3[3]), [c3, f2, h4, p2, i3[4]];
    }
    function u2(t3) {
      t3.push([v, ""]);
      for (var e3, n2 = 0, r2 = 0, o2 = 0, i3 = "", s4 = ""; n2 < t3.length; ) switch (t3[n2][0]) {
        case y3:
          o2++, s4 += t3[n2][1], n2++;
          break;
        case d3:
          r2++, i3 += t3[n2][1], n2++;
          break;
        case v:
          r2 + o2 > 1 ? (0 !== r2 && 0 !== o2 && (e3 = l(s4, i3), 0 !== e3 && (n2 - r2 - o2 > 0 && t3[n2 - r2 - o2 - 1][0] == v ? t3[n2 - r2 - o2 - 1][1] += s4.substring(0, e3) : (t3.splice(0, 0, [v, s4.substring(0, e3)]), n2++), s4 = s4.substring(e3), i3 = i3.substring(e3)), 0 !== (e3 = a3(s4, i3)) && (t3[n2][1] = s4.substring(s4.length - e3) + t3[n2][1], s4 = s4.substring(0, s4.length - e3), i3 = i3.substring(0, i3.length - e3))), 0 === r2 ? t3.splice(n2 - o2, r2 + o2, [y3, s4]) : 0 === o2 ? t3.splice(n2 - r2, r2 + o2, [d3, i3]) : t3.splice(n2 - r2 - o2, r2 + o2, [d3, i3], [y3, s4]), n2 = n2 - r2 - o2 + (r2 ? 1 : 0) + (o2 ? 1 : 0) + 1) : 0 !== n2 && t3[n2 - 1][0] == v ? (t3[n2 - 1][1] += t3[n2][1], t3.splice(n2, 1)) : n2++, o2 = 0, r2 = 0, i3 = "", s4 = "";
      }
      "" === t3[t3.length - 1][1] && t3.pop();
      var c3 = false;
      for (n2 = 1; n2 < t3.length - 1; ) t3[n2 - 1][0] == v && t3[n2 + 1][0] == v && (t3[n2][1].substring(t3[n2][1].length - t3[n2 - 1][1].length) == t3[n2 - 1][1] ? (t3[n2][1] = t3[n2 - 1][1] + t3[n2][1].substring(0, t3[n2][1].length - t3[n2 - 1][1].length), t3[n2 + 1][1] = t3[n2 - 1][1] + t3[n2 + 1][1], t3.splice(n2 - 1, 1), c3 = true) : t3[n2][1].substring(0, t3[n2 + 1][1].length) == t3[n2 + 1][1] && (t3[n2 - 1][1] += t3[n2 + 1][1], t3[n2][1] = t3[n2][1].substring(t3[n2 + 1][1].length) + t3[n2 + 1][1], t3.splice(n2 + 1, 1), c3 = true)), n2++;
      c3 && u2(t3);
    }
    function c2(t3, e3) {
      if (0 === e3) return [v, t3];
      for (var n2 = 0, r2 = 0; r2 < t3.length; r2++) {
        var o2 = t3[r2];
        if (o2[0] === d3 || o2[0] === v) {
          var i3 = n2 + o2[1].length;
          if (e3 === i3) return [r2 + 1, t3];
          if (e3 < i3) {
            t3 = t3.slice();
            var l2 = e3 - n2, a4 = [o2[0], o2[1].slice(0, l2)], s4 = [o2[0], o2[1].slice(l2)];
            return t3.splice(r2, 1, a4, s4), [r2 + 1, t3];
          }
          n2 = i3;
        }
      }
      throw new Error("cursor_pos is out of bounds!");
    }
    function f(t3, e3) {
      var n2 = c2(t3, e3), r2 = n2[1], o2 = n2[0], i3 = r2[o2], l2 = r2[o2 + 1];
      if (null == i3) return t3;
      if (i3[0] !== v) return t3;
      if (null != l2 && i3[1] + l2[1] === l2[1] + i3[1]) return r2.splice(o2, 2, l2, i3), p(r2, o2, 2);
      if (null != l2 && 0 === l2[1].indexOf(i3[1])) {
        r2.splice(o2, 2, [l2[0], i3[1]], [0, i3[1]]);
        var a4 = l2[1].slice(i3[1].length);
        return a4.length > 0 && r2.splice(o2 + 2, 0, [l2[0], a4]), p(r2, o2, 3);
      }
      return t3;
    }
    function h3(t3) {
      for (var e3 = false, n2 = function(t4) {
        return t4.charCodeAt(0) >= 56320 && t4.charCodeAt(0) <= 57343;
      }, r2 = 2; r2 < t3.length; r2 += 1) t3[r2 - 2][0] === v && (function(t4) {
        return t4.charCodeAt(t4.length - 1) >= 55296 && t4.charCodeAt(t4.length - 1) <= 56319;
      })(t3[r2 - 2][1]) && t3[r2 - 1][0] === d3 && n2(t3[r2 - 1][1]) && t3[r2][0] === y3 && n2(t3[r2][1]) && (e3 = true, t3[r2 - 1][1] = t3[r2 - 2][1].slice(-1) + t3[r2 - 1][1], t3[r2][1] = t3[r2 - 2][1].slice(-1) + t3[r2][1], t3[r2 - 2][1] = t3[r2 - 2][1].slice(0, -1));
      if (!e3) return t3;
      for (var o2 = [], r2 = 0; r2 < t3.length; r2 += 1) t3[r2][1].length > 0 && o2.push(t3[r2]);
      return o2;
    }
    function p(t3, e3, n2) {
      for (var r2 = e3 + n2 - 1; r2 >= 0 && r2 >= e3 - 1; r2--) if (r2 + 1 < t3.length) {
        var o2 = t3[r2], i3 = t3[r2 + 1];
        o2[0] === i3[1] && t3.splice(r2, 2, [o2[0], o2[1] + i3[1]]);
      }
      return t3;
    }
    var d3 = -1, y3 = 1, v = 0, b2 = n;
    b2.INSERT = y3, b2.DELETE = d3, b2.EQUAL = v, t2.exports = b2;
  }, function(t2, e2) {
    function n(t3) {
      var e3 = [];
      for (var n2 in t3) e3.push(n2);
      return e3;
    }
    e2 = t2.exports = "function" == typeof Object.keys ? Object.keys : n, e2.shim = n;
  }, function(t2, e2) {
    function n(t3) {
      return "[object Arguments]" == Object.prototype.toString.call(t3);
    }
    function r(t3) {
      return t3 && "object" == typeof t3 && "number" == typeof t3.length && Object.prototype.hasOwnProperty.call(t3, "callee") && !Object.prototype.propertyIsEnumerable.call(t3, "callee") || false;
    }
    var o = "[object Arguments]" == (function() {
      return Object.prototype.toString.call(arguments);
    })();
    e2 = t2.exports = o ? n : r, e2.supported = n, e2.unsupported = r;
  }, function(t2, e2, n) {
    function r(t3) {
      return t3 && t3.__esModule ? t3 : { default: t3 };
    }
    function o(t3, e3, n2) {
      return e3 in t3 ? Object.defineProperty(t3, e3, { value: n2, enumerable: true, configurable: true, writable: true }) : t3[e3] = n2, t3;
    }
    function i2(t3, e3) {
      if (!(t3 instanceof e3)) throw new TypeError("Cannot call a class as a function");
    }
    function l(t3, e3) {
      return Object.keys(e3).reduce(function(n2, r2) {
        return null == t3[r2] ? n2 : (e3[r2] === t3[r2] ? n2[r2] = e3[r2] : Array.isArray(e3[r2]) ? e3[r2].indexOf(t3[r2]) < 0 && (n2[r2] = e3[r2].concat([t3[r2]])) : n2[r2] = [e3[r2], t3[r2]], n2);
      }, {});
    }
    function a3(t3) {
      return t3.reduce(function(t4, e3) {
        if (1 === e3.insert) {
          var n2 = (0, N.default)(e3.attributes);
          return delete n2.image, t4.insert({ image: e3.attributes.image }, n2);
        }
        if (null == e3.attributes || true !== e3.attributes.list && true !== e3.attributes.bullet || (e3 = (0, N.default)(e3), e3.attributes.list ? e3.attributes.list = "ordered" : (e3.attributes.list = "bullet", delete e3.attributes.bullet)), "string" == typeof e3.insert) {
          var r2 = e3.insert.replace(/\r\n/g, "\n").replace(/\r/g, "\n");
          return t4.insert(r2, e3.attributes);
        }
        return t4.push(e3);
      }, new h3.default());
    }
    Object.defineProperty(e2, "__esModule", { value: true });
    var s3 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t3) {
      return typeof t3;
    } : function(t3) {
      return t3 && "function" == typeof Symbol && t3.constructor === Symbol && t3 !== Symbol.prototype ? "symbol" : typeof t3;
    }, u2 = /* @__PURE__ */ (function() {
      function t3(t4, e3) {
        var n2 = [], r2 = true, o2 = false, i3 = void 0;
        try {
          for (var l2, a4 = t4[Symbol.iterator](); !(r2 = (l2 = a4.next()).done) && (n2.push(l2.value), !e3 || n2.length !== e3); r2 = true) ;
        } catch (t5) {
          o2 = true, i3 = t5;
        } finally {
          try {
            !r2 && a4.return && a4.return();
          } finally {
            if (o2) throw i3;
          }
        }
        return n2;
      }
      return function(e3, n2) {
        if (Array.isArray(e3)) return e3;
        if (Symbol.iterator in Object(e3)) return t3(e3, n2);
        throw new TypeError("Invalid attempt to destructure non-iterable instance");
      };
    })(), c2 = /* @__PURE__ */ (function() {
      function t3(t4, e3) {
        for (var n2 = 0; n2 < e3.length; n2++) {
          var r2 = e3[n2];
          r2.enumerable = r2.enumerable || false, r2.configurable = true, "value" in r2 && (r2.writable = true), Object.defineProperty(t4, r2.key, r2);
        }
      }
      return function(e3, n2, r2) {
        return n2 && t3(e3.prototype, n2), r2 && t3(e3, r2), e3;
      };
    })(), f = n(4), h3 = r(f), p = n(20), d3 = r(p), y3 = n(0), v = r(y3), b2 = n(13), g = r(b2), m3 = n(31), _ = r(m3), O2 = n(3), w2 = r(O2), x2 = n(14), k2 = r(x2), E2 = n(21), N = r(E2), j = n(12), A = r(j), q2 = n(2), T2 = r(q2), P = /^[ -~]*$/, S3 = (function() {
      function t3(e3) {
        i2(this, t3), this.scroll = e3, this.delta = this.getDelta();
      }
      return c2(t3, [{ key: "applyDelta", value: function(t4) {
        var e3 = this, n2 = false;
        this.scroll.update();
        var r2 = this.scroll.length();
        return this.scroll.batchStart(), t4 = a3(t4), t4.reduce(function(t5, o2) {
          var i3 = o2.retain || o2.delete || o2.insert.length || 1, l2 = o2.attributes || {};
          if (null != o2.insert) {
            if ("string" == typeof o2.insert) {
              var a4 = o2.insert;
              a4.endsWith("\n") && n2 && (n2 = false, a4 = a4.slice(0, -1)), t5 >= r2 && !a4.endsWith("\n") && (n2 = true), e3.scroll.insertAt(t5, a4);
              var c3 = e3.scroll.line(t5), f2 = u2(c3, 2), h4 = f2[0], p2 = f2[1], y4 = (0, T2.default)({}, (0, O2.bubbleFormats)(h4));
              if (h4 instanceof w2.default) {
                var b3 = h4.descendant(v.default.Leaf, p2), g2 = u2(b3, 1), m4 = g2[0];
                y4 = (0, T2.default)(y4, (0, O2.bubbleFormats)(m4));
              }
              l2 = d3.default.attributes.diff(y4, l2) || {};
            } else if ("object" === s3(o2.insert)) {
              var _2 = Object.keys(o2.insert)[0];
              if (null == _2) return t5;
              e3.scroll.insertAt(t5, _2, o2.insert[_2]);
            }
            r2 += i3;
          }
          return Object.keys(l2).forEach(function(n3) {
            e3.scroll.formatAt(t5, i3, n3, l2[n3]);
          }), t5 + i3;
        }, 0), t4.reduce(function(t5, n3) {
          return "number" == typeof n3.delete ? (e3.scroll.deleteAt(t5, n3.delete), t5) : t5 + (n3.retain || n3.insert.length || 1);
        }, 0), this.scroll.batchEnd(), this.update(t4);
      } }, { key: "deleteText", value: function(t4, e3) {
        return this.scroll.deleteAt(t4, e3), this.update(new h3.default().retain(t4).delete(e3));
      } }, { key: "formatLine", value: function(t4, e3) {
        var n2 = this, r2 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {};
        return this.scroll.update(), Object.keys(r2).forEach(function(o2) {
          if (null == n2.scroll.whitelist || n2.scroll.whitelist[o2]) {
            var i3 = n2.scroll.lines(t4, Math.max(e3, 1)), l2 = e3;
            i3.forEach(function(e4) {
              var i4 = e4.length();
              if (e4 instanceof g.default) {
                var a4 = t4 - e4.offset(n2.scroll), s4 = e4.newlineIndex(a4 + l2) - a4 + 1;
                e4.formatAt(a4, s4, o2, r2[o2]);
              } else e4.format(o2, r2[o2]);
              l2 -= i4;
            });
          }
        }), this.scroll.optimize(), this.update(new h3.default().retain(t4).retain(e3, (0, N.default)(r2)));
      } }, { key: "formatText", value: function(t4, e3) {
        var n2 = this, r2 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {};
        return Object.keys(r2).forEach(function(o2) {
          n2.scroll.formatAt(t4, e3, o2, r2[o2]);
        }), this.update(new h3.default().retain(t4).retain(e3, (0, N.default)(r2)));
      } }, { key: "getContents", value: function(t4, e3) {
        return this.delta.slice(t4, t4 + e3);
      } }, { key: "getDelta", value: function() {
        return this.scroll.lines().reduce(function(t4, e3) {
          return t4.concat(e3.delta());
        }, new h3.default());
      } }, { key: "getFormat", value: function(t4) {
        var e3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 0, n2 = [], r2 = [];
        0 === e3 ? this.scroll.path(t4).forEach(function(t5) {
          var e4 = u2(t5, 1), o3 = e4[0];
          o3 instanceof w2.default ? n2.push(o3) : o3 instanceof v.default.Leaf && r2.push(o3);
        }) : (n2 = this.scroll.lines(t4, e3), r2 = this.scroll.descendants(v.default.Leaf, t4, e3));
        var o2 = [n2, r2].map(function(t5) {
          if (0 === t5.length) return {};
          for (var e4 = (0, O2.bubbleFormats)(t5.shift()); Object.keys(e4).length > 0; ) {
            var n3 = t5.shift();
            if (null == n3) return e4;
            e4 = l((0, O2.bubbleFormats)(n3), e4);
          }
          return e4;
        });
        return T2.default.apply(T2.default, o2);
      } }, { key: "getText", value: function(t4, e3) {
        return this.getContents(t4, e3).filter(function(t5) {
          return "string" == typeof t5.insert;
        }).map(function(t5) {
          return t5.insert;
        }).join("");
      } }, { key: "insertEmbed", value: function(t4, e3, n2) {
        return this.scroll.insertAt(t4, e3, n2), this.update(new h3.default().retain(t4).insert(o({}, e3, n2)));
      } }, { key: "insertText", value: function(t4, e3) {
        var n2 = this, r2 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {};
        return e3 = e3.replace(/\r\n/g, "\n").replace(/\r/g, "\n"), this.scroll.insertAt(t4, e3), Object.keys(r2).forEach(function(o2) {
          n2.scroll.formatAt(t4, e3.length, o2, r2[o2]);
        }), this.update(new h3.default().retain(t4).insert(e3, (0, N.default)(r2)));
      } }, { key: "isBlank", value: function() {
        if (0 == this.scroll.children.length) return true;
        if (this.scroll.children.length > 1) return false;
        var t4 = this.scroll.children.head;
        return t4.statics.blotName === w2.default.blotName && (!(t4.children.length > 1) && t4.children.head instanceof k2.default);
      } }, { key: "removeFormat", value: function(t4, e3) {
        var n2 = this.getText(t4, e3), r2 = this.scroll.line(t4 + e3), o2 = u2(r2, 2), i3 = o2[0], l2 = o2[1], a4 = 0, s4 = new h3.default();
        null != i3 && (a4 = i3 instanceof g.default ? i3.newlineIndex(l2) - l2 + 1 : i3.length() - l2, s4 = i3.delta().slice(l2, l2 + a4 - 1).insert("\n"));
        var c3 = this.getContents(t4, e3 + a4), f2 = c3.diff(new h3.default().insert(n2).concat(s4)), p2 = new h3.default().retain(t4).concat(f2);
        return this.applyDelta(p2);
      } }, { key: "update", value: function(t4) {
        var e3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : [], n2 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : void 0, r2 = this.delta;
        if (1 === e3.length && "characterData" === e3[0].type && e3[0].target.data.match(P) && v.default.find(e3[0].target)) {
          var o2 = v.default.find(e3[0].target), i3 = (0, O2.bubbleFormats)(o2), l2 = o2.offset(this.scroll), a4 = e3[0].oldValue.replace(_.default.CONTENTS, ""), s4 = new h3.default().insert(a4), u3 = new h3.default().insert(o2.value());
          t4 = new h3.default().retain(l2).concat(s4.diff(u3, n2)).reduce(function(t5, e4) {
            return e4.insert ? t5.insert(e4.insert, i3) : t5.push(e4);
          }, new h3.default()), this.delta = r2.compose(t4);
        } else this.delta = this.getDelta(), t4 && (0, A.default)(r2.compose(t4), this.delta) || (t4 = r2.diff(this.delta, n2));
        return t4;
      } }]), t3;
    })();
    e2.default = S3;
  }, function(t2, e2) {
    function n() {
    }
    function r(t3, e3, n2) {
      this.fn = t3, this.context = e3, this.once = n2 || false;
    }
    function o() {
      this._events = new n(), this._eventsCount = 0;
    }
    var i2 = Object.prototype.hasOwnProperty, l = "~";
    Object.create && (n.prototype = /* @__PURE__ */ Object.create(null), new n().__proto__ || (l = false)), o.prototype.eventNames = function() {
      var t3, e3, n2 = [];
      if (0 === this._eventsCount) return n2;
      for (e3 in t3 = this._events) i2.call(t3, e3) && n2.push(l ? e3.slice(1) : e3);
      return Object.getOwnPropertySymbols ? n2.concat(Object.getOwnPropertySymbols(t3)) : n2;
    }, o.prototype.listeners = function(t3, e3) {
      var n2 = l ? l + t3 : t3, r2 = this._events[n2];
      if (e3) return !!r2;
      if (!r2) return [];
      if (r2.fn) return [r2.fn];
      for (var o2 = 0, i3 = r2.length, a3 = new Array(i3); o2 < i3; o2++) a3[o2] = r2[o2].fn;
      return a3;
    }, o.prototype.emit = function(t3, e3, n2, r2, o2, i3) {
      var a3 = l ? l + t3 : t3;
      if (!this._events[a3]) return false;
      var s3, u2, c2 = this._events[a3], f = arguments.length;
      if (c2.fn) {
        switch (c2.once && this.removeListener(t3, c2.fn, void 0, true), f) {
          case 1:
            return c2.fn.call(c2.context), true;
          case 2:
            return c2.fn.call(c2.context, e3), true;
          case 3:
            return c2.fn.call(c2.context, e3, n2), true;
          case 4:
            return c2.fn.call(c2.context, e3, n2, r2), true;
          case 5:
            return c2.fn.call(c2.context, e3, n2, r2, o2), true;
          case 6:
            return c2.fn.call(c2.context, e3, n2, r2, o2, i3), true;
        }
        for (u2 = 1, s3 = new Array(f - 1); u2 < f; u2++) s3[u2 - 1] = arguments[u2];
        c2.fn.apply(c2.context, s3);
      } else {
        var h3, p = c2.length;
        for (u2 = 0; u2 < p; u2++) switch (c2[u2].once && this.removeListener(t3, c2[u2].fn, void 0, true), f) {
          case 1:
            c2[u2].fn.call(c2[u2].context);
            break;
          case 2:
            c2[u2].fn.call(c2[u2].context, e3);
            break;
          case 3:
            c2[u2].fn.call(c2[u2].context, e3, n2);
            break;
          case 4:
            c2[u2].fn.call(c2[u2].context, e3, n2, r2);
            break;
          default:
            if (!s3) for (h3 = 1, s3 = new Array(f - 1); h3 < f; h3++) s3[h3 - 1] = arguments[h3];
            c2[u2].fn.apply(c2[u2].context, s3);
        }
      }
      return true;
    }, o.prototype.on = function(t3, e3, n2) {
      var o2 = new r(e3, n2 || this), i3 = l ? l + t3 : t3;
      return this._events[i3] ? this._events[i3].fn ? this._events[i3] = [this._events[i3], o2] : this._events[i3].push(o2) : (this._events[i3] = o2, this._eventsCount++), this;
    }, o.prototype.once = function(t3, e3, n2) {
      var o2 = new r(e3, n2 || this, true), i3 = l ? l + t3 : t3;
      return this._events[i3] ? this._events[i3].fn ? this._events[i3] = [this._events[i3], o2] : this._events[i3].push(o2) : (this._events[i3] = o2, this._eventsCount++), this;
    }, o.prototype.removeListener = function(t3, e3, r2, o2) {
      var i3 = l ? l + t3 : t3;
      if (!this._events[i3]) return this;
      if (!e3) return 0 == --this._eventsCount ? this._events = new n() : delete this._events[i3], this;
      var a3 = this._events[i3];
      if (a3.fn) a3.fn !== e3 || o2 && !a3.once || r2 && a3.context !== r2 || (0 == --this._eventsCount ? this._events = new n() : delete this._events[i3]);
      else {
        for (var s3 = 0, u2 = [], c2 = a3.length; s3 < c2; s3++) (a3[s3].fn !== e3 || o2 && !a3[s3].once || r2 && a3[s3].context !== r2) && u2.push(a3[s3]);
        u2.length ? this._events[i3] = 1 === u2.length ? u2[0] : u2 : 0 == --this._eventsCount ? this._events = new n() : delete this._events[i3];
      }
      return this;
    }, o.prototype.removeAllListeners = function(t3) {
      var e3;
      return t3 ? (e3 = l ? l + t3 : t3, this._events[e3] && (0 == --this._eventsCount ? this._events = new n() : delete this._events[e3])) : (this._events = new n(), this._eventsCount = 0), this;
    }, o.prototype.off = o.prototype.removeListener, o.prototype.addListener = o.prototype.on, o.prototype.setMaxListeners = function() {
      return this;
    }, o.prefixed = l, o.EventEmitter = o, void 0 !== t2 && (t2.exports = o);
  }, function(t2, e2, n) {
    function r(t3) {
      return t3 && t3.__esModule ? t3 : { default: t3 };
    }
    function o(t3, e3) {
      if (!(t3 instanceof e3)) throw new TypeError("Cannot call a class as a function");
    }
    function i2(t3, e3) {
      if (!t3) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      return !e3 || "object" != typeof e3 && "function" != typeof e3 ? t3 : e3;
    }
    function l(t3, e3) {
      if ("function" != typeof e3 && null !== e3) throw new TypeError("Super expression must either be null or a function, not " + typeof e3);
      t3.prototype = Object.create(e3 && e3.prototype, { constructor: { value: t3, enumerable: false, writable: true, configurable: true } }), e3 && (Object.setPrototypeOf ? Object.setPrototypeOf(t3, e3) : t3.__proto__ = e3);
    }
    function a3(t3) {
      return t3 instanceof v.default || t3 instanceof y3.BlockEmbed;
    }
    Object.defineProperty(e2, "__esModule", { value: true });
    var s3 = /* @__PURE__ */ (function() {
      function t3(t4, e3) {
        var n2 = [], r2 = true, o2 = false, i3 = void 0;
        try {
          for (var l2, a4 = t4[Symbol.iterator](); !(r2 = (l2 = a4.next()).done) && (n2.push(l2.value), !e3 || n2.length !== e3); r2 = true) ;
        } catch (t5) {
          o2 = true, i3 = t5;
        } finally {
          try {
            !r2 && a4.return && a4.return();
          } finally {
            if (o2) throw i3;
          }
        }
        return n2;
      }
      return function(e3, n2) {
        if (Array.isArray(e3)) return e3;
        if (Symbol.iterator in Object(e3)) return t3(e3, n2);
        throw new TypeError("Invalid attempt to destructure non-iterable instance");
      };
    })(), u2 = /* @__PURE__ */ (function() {
      function t3(t4, e3) {
        for (var n2 = 0; n2 < e3.length; n2++) {
          var r2 = e3[n2];
          r2.enumerable = r2.enumerable || false, r2.configurable = true, "value" in r2 && (r2.writable = true), Object.defineProperty(t4, r2.key, r2);
        }
      }
      return function(e3, n2, r2) {
        return n2 && t3(e3.prototype, n2), r2 && t3(e3, r2), e3;
      };
    })(), c2 = function t3(e3, n2, r2) {
      null === e3 && (e3 = Function.prototype);
      var o2 = Object.getOwnPropertyDescriptor(e3, n2);
      if (void 0 === o2) {
        var i3 = Object.getPrototypeOf(e3);
        return null === i3 ? void 0 : t3(i3, n2, r2);
      }
      if ("value" in o2) return o2.value;
      var l2 = o2.get;
      if (void 0 !== l2) return l2.call(r2);
    }, f = n(0), h3 = r(f), p = n(9), d3 = r(p), y3 = n(3), v = r(y3), b2 = n(14), g = r(b2), m3 = n(13), _ = r(m3), O2 = n(23), w2 = r(O2), x2 = (function(t3) {
      function e3(t4, n2) {
        o(this, e3);
        var r2 = i2(this, (e3.__proto__ || Object.getPrototypeOf(e3)).call(this, t4));
        return r2.emitter = n2.emitter, Array.isArray(n2.whitelist) && (r2.whitelist = n2.whitelist.reduce(function(t5, e4) {
          return t5[e4] = true, t5;
        }, {})), r2.domNode.addEventListener("DOMNodeInserted", function() {
        }), r2.optimize(), r2.enable(), r2;
      }
      return l(e3, t3), u2(e3, [{ key: "batchStart", value: function() {
        this.batch = true;
      } }, { key: "batchEnd", value: function() {
        this.batch = false, this.optimize();
      } }, { key: "deleteAt", value: function(t4, n2) {
        var r2 = this.line(t4), o2 = s3(r2, 2), i3 = o2[0], l2 = o2[1], a4 = this.line(t4 + n2), u3 = s3(a4, 1), f2 = u3[0];
        if (c2(e3.prototype.__proto__ || Object.getPrototypeOf(e3.prototype), "deleteAt", this).call(this, t4, n2), null != f2 && i3 !== f2 && l2 > 0) {
          if (i3 instanceof y3.BlockEmbed || f2 instanceof y3.BlockEmbed) return void this.optimize();
          if (i3 instanceof _.default) {
            var h4 = i3.newlineIndex(i3.length(), true);
            if (h4 > -1 && (i3 = i3.split(h4 + 1)) === f2) return void this.optimize();
          } else if (f2 instanceof _.default) {
            var p2 = f2.newlineIndex(0);
            p2 > -1 && f2.split(p2 + 1);
          }
          var d4 = f2.children.head instanceof g.default ? null : f2.children.head;
          i3.moveChildren(f2, d4), i3.remove();
        }
        this.optimize();
      } }, { key: "enable", value: function() {
        var t4 = !(arguments.length > 0 && void 0 !== arguments[0]) || arguments[0];
        this.domNode.setAttribute("contenteditable", t4);
      } }, { key: "formatAt", value: function(t4, n2, r2, o2) {
        (null == this.whitelist || this.whitelist[r2]) && (c2(e3.prototype.__proto__ || Object.getPrototypeOf(e3.prototype), "formatAt", this).call(this, t4, n2, r2, o2), this.optimize());
      } }, { key: "insertAt", value: function(t4, n2, r2) {
        if (null == r2 || null == this.whitelist || this.whitelist[n2]) {
          if (t4 >= this.length()) if (null == r2 || null == h3.default.query(n2, h3.default.Scope.BLOCK)) {
            var o2 = h3.default.create(this.statics.defaultChild);
            this.appendChild(o2), null == r2 && n2.endsWith("\n") && (n2 = n2.slice(0, -1)), o2.insertAt(0, n2, r2);
          } else {
            var i3 = h3.default.create(n2, r2);
            this.appendChild(i3);
          }
          else c2(e3.prototype.__proto__ || Object.getPrototypeOf(e3.prototype), "insertAt", this).call(this, t4, n2, r2);
          this.optimize();
        }
      } }, { key: "insertBefore", value: function(t4, n2) {
        if (t4.statics.scope === h3.default.Scope.INLINE_BLOT) {
          var r2 = h3.default.create(this.statics.defaultChild);
          r2.appendChild(t4), t4 = r2;
        }
        c2(e3.prototype.__proto__ || Object.getPrototypeOf(e3.prototype), "insertBefore", this).call(this, t4, n2);
      } }, { key: "leaf", value: function(t4) {
        return this.path(t4).pop() || [null, -1];
      } }, { key: "line", value: function(t4) {
        return t4 === this.length() ? this.line(t4 - 1) : this.descendant(a3, t4);
      } }, { key: "lines", value: function() {
        var t4 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0, e4 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : Number.MAX_VALUE;
        return (function t5(e5, n2, r2) {
          var o2 = [], i3 = r2;
          return e5.children.forEachAt(n2, r2, function(e6, n3, r3) {
            a3(e6) ? o2.push(e6) : e6 instanceof h3.default.Container && (o2 = o2.concat(t5(e6, n3, i3))), i3 -= r3;
          }), o2;
        })(this, t4, e4);
      } }, { key: "optimize", value: function() {
        var t4 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : [], n2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
        true !== this.batch && (c2(e3.prototype.__proto__ || Object.getPrototypeOf(e3.prototype), "optimize", this).call(this, t4, n2), t4.length > 0 && this.emitter.emit(d3.default.events.SCROLL_OPTIMIZE, t4, n2));
      } }, { key: "path", value: function(t4) {
        return c2(e3.prototype.__proto__ || Object.getPrototypeOf(e3.prototype), "path", this).call(this, t4).slice(1);
      } }, { key: "update", value: function(t4) {
        if (true !== this.batch) {
          var n2 = d3.default.sources.USER;
          "string" == typeof t4 && (n2 = t4), Array.isArray(t4) || (t4 = this.observer.takeRecords()), t4.length > 0 && this.emitter.emit(d3.default.events.SCROLL_BEFORE_UPDATE, n2, t4), c2(e3.prototype.__proto__ || Object.getPrototypeOf(e3.prototype), "update", this).call(this, t4.concat([])), t4.length > 0 && this.emitter.emit(d3.default.events.SCROLL_UPDATE, n2, t4);
        }
      } }]), e3;
    })(h3.default.Scroll);
    x2.blotName = "scroll", x2.className = "ql-editor", x2.tagName = "DIV", x2.defaultChild = "block", x2.allowedChildren = [v.default, y3.BlockEmbed, w2.default], e2.default = x2;
  }, function(t2, e2, n) {
    function r(t3) {
      return t3 && t3.__esModule ? t3 : { default: t3 };
    }
    function o(t3, e3, n2) {
      return e3 in t3 ? Object.defineProperty(t3, e3, { value: n2, enumerable: true, configurable: true, writable: true }) : t3[e3] = n2, t3;
    }
    function i2(t3, e3) {
      if (!(t3 instanceof e3)) throw new TypeError("Cannot call a class as a function");
    }
    function l(t3, e3) {
      if (!t3) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      return !e3 || "object" != typeof e3 && "function" != typeof e3 ? t3 : e3;
    }
    function a3(t3, e3) {
      if ("function" != typeof e3 && null !== e3) throw new TypeError("Super expression must either be null or a function, not " + typeof e3);
      t3.prototype = Object.create(e3 && e3.prototype, { constructor: { value: t3, enumerable: false, writable: true, configurable: true } }), e3 && (Object.setPrototypeOf ? Object.setPrototypeOf(t3, e3) : t3.__proto__ = e3);
    }
    function s3(t3, e3, n2) {
      return "object" === (void 0 === e3 ? "undefined" : x2(e3)) ? Object.keys(e3).reduce(function(t4, n3) {
        return s3(t4, n3, e3[n3]);
      }, t3) : t3.reduce(function(t4, r2) {
        return r2.attributes && r2.attributes[e3] ? t4.push(r2) : t4.insert(r2.insert, (0, j.default)({}, o({}, e3, n2), r2.attributes));
      }, new q2.default());
    }
    function u2(t3) {
      if (t3.nodeType !== Node.ELEMENT_NODE) return {};
      return t3["__ql-computed-style"] || (t3["__ql-computed-style"] = window.getComputedStyle(t3));
    }
    function c2(t3, e3) {
      for (var n2 = "", r2 = t3.ops.length - 1; r2 >= 0 && n2.length < e3.length; --r2) {
        var o2 = t3.ops[r2];
        if ("string" != typeof o2.insert) break;
        n2 = o2.insert + n2;
      }
      return n2.slice(-1 * e3.length) === e3;
    }
    function f(t3) {
      return 0 !== t3.childNodes.length && ["block", "list-item"].indexOf(u2(t3).display) > -1;
    }
    function h3(t3, e3, n2) {
      return t3.nodeType === t3.TEXT_NODE ? n2.reduce(function(e4, n3) {
        return n3(t3, e4);
      }, new q2.default()) : t3.nodeType === t3.ELEMENT_NODE ? [].reduce.call(t3.childNodes || [], function(r2, o2) {
        var i3 = h3(o2, e3, n2);
        return o2.nodeType === t3.ELEMENT_NODE && (i3 = e3.reduce(function(t4, e4) {
          return e4(o2, t4);
        }, i3), i3 = (o2[W] || []).reduce(function(t4, e4) {
          return e4(o2, t4);
        }, i3)), r2.concat(i3);
      }, new q2.default()) : new q2.default();
    }
    function p(t3, e3, n2) {
      return s3(n2, t3, true);
    }
    function d3(t3, e3) {
      var n2 = P.default.Attributor.Attribute.keys(t3), r2 = P.default.Attributor.Class.keys(t3), o2 = P.default.Attributor.Style.keys(t3), i3 = {};
      return n2.concat(r2).concat(o2).forEach(function(e4) {
        var n3 = P.default.query(e4, P.default.Scope.ATTRIBUTE);
        null != n3 && (i3[n3.attrName] = n3.value(t3), i3[n3.attrName]) || (n3 = Y2[e4], null == n3 || n3.attrName !== e4 && n3.keyName !== e4 || (i3[n3.attrName] = n3.value(t3) || void 0), null == (n3 = X2[e4]) || n3.attrName !== e4 && n3.keyName !== e4 || (n3 = X2[e4], i3[n3.attrName] = n3.value(t3) || void 0));
      }), Object.keys(i3).length > 0 && (e3 = s3(e3, i3)), e3;
    }
    function y3(t3, e3) {
      var n2 = P.default.query(t3);
      if (null == n2) return e3;
      if (n2.prototype instanceof P.default.Embed) {
        var r2 = {}, o2 = n2.value(t3);
        null != o2 && (r2[n2.blotName] = o2, e3 = new q2.default().insert(r2, n2.formats(t3)));
      } else "function" == typeof n2.formats && (e3 = s3(e3, n2.blotName, n2.formats(t3)));
      return e3;
    }
    function v(t3, e3) {
      return c2(e3, "\n") || e3.insert("\n"), e3;
    }
    function b2() {
      return new q2.default();
    }
    function g(t3, e3) {
      var n2 = P.default.query(t3);
      if (null == n2 || "list-item" !== n2.blotName || !c2(e3, "\n")) return e3;
      for (var r2 = -1, o2 = t3.parentNode; !o2.classList.contains("ql-clipboard"); ) "list" === (P.default.query(o2) || {}).blotName && (r2 += 1), o2 = o2.parentNode;
      return r2 <= 0 ? e3 : e3.compose(new q2.default().retain(e3.length() - 1).retain(1, { indent: r2 }));
    }
    function m3(t3, e3) {
      return c2(e3, "\n") || (f(t3) || e3.length() > 0 && t3.nextSibling && f(t3.nextSibling)) && e3.insert("\n"), e3;
    }
    function _(t3, e3) {
      if (f(t3) && null != t3.nextElementSibling && !c2(e3, "\n\n")) {
        var n2 = t3.offsetHeight + parseFloat(u2(t3).marginTop) + parseFloat(u2(t3).marginBottom);
        t3.nextElementSibling.offsetTop > t3.offsetTop + 1.5 * n2 && e3.insert("\n");
      }
      return e3;
    }
    function O2(t3, e3) {
      var n2 = {}, r2 = t3.style || {};
      return r2.fontStyle && "italic" === u2(t3).fontStyle && (n2.italic = true), r2.fontWeight && (u2(t3).fontWeight.startsWith("bold") || parseInt(u2(t3).fontWeight) >= 700) && (n2.bold = true), Object.keys(n2).length > 0 && (e3 = s3(e3, n2)), parseFloat(r2.textIndent || 0) > 0 && (e3 = new q2.default().insert("	").concat(e3)), e3;
    }
    function w2(t3, e3) {
      var n2 = t3.data;
      if ("O:P" === t3.parentNode.tagName) return e3.insert(n2.trim());
      if (0 === n2.trim().length && t3.parentNode.classList.contains("ql-clipboard")) return e3;
      if (!u2(t3.parentNode).whiteSpace.startsWith("pre")) {
        var r2 = function(t4, e4) {
          return e4 = e4.replace(/[^\u00a0]/g, ""), e4.length < 1 && t4 ? " " : e4;
        };
        n2 = n2.replace(/\r\n/g, " ").replace(/\n/g, " "), n2 = n2.replace(/\s\s+/g, r2.bind(r2, true)), (null == t3.previousSibling && f(t3.parentNode) || null != t3.previousSibling && f(t3.previousSibling)) && (n2 = n2.replace(/^\s+/, r2.bind(r2, false))), (null == t3.nextSibling && f(t3.parentNode) || null != t3.nextSibling && f(t3.nextSibling)) && (n2 = n2.replace(/\s+$/, r2.bind(r2, false)));
      }
      return e3.insert(n2);
    }
    Object.defineProperty(e2, "__esModule", { value: true }), e2.matchText = e2.matchSpacing = e2.matchNewline = e2.matchBlot = e2.matchAttributor = e2.default = void 0;
    var x2 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(t3) {
      return typeof t3;
    } : function(t3) {
      return t3 && "function" == typeof Symbol && t3.constructor === Symbol && t3 !== Symbol.prototype ? "symbol" : typeof t3;
    }, k2 = /* @__PURE__ */ (function() {
      function t3(t4, e3) {
        var n2 = [], r2 = true, o2 = false, i3 = void 0;
        try {
          for (var l2, a4 = t4[Symbol.iterator](); !(r2 = (l2 = a4.next()).done) && (n2.push(l2.value), !e3 || n2.length !== e3); r2 = true) ;
        } catch (t5) {
          o2 = true, i3 = t5;
        } finally {
          try {
            !r2 && a4.return && a4.return();
          } finally {
            if (o2) throw i3;
          }
        }
        return n2;
      }
      return function(e3, n2) {
        if (Array.isArray(e3)) return e3;
        if (Symbol.iterator in Object(e3)) return t3(e3, n2);
        throw new TypeError("Invalid attempt to destructure non-iterable instance");
      };
    })(), E2 = /* @__PURE__ */ (function() {
      function t3(t4, e3) {
        for (var n2 = 0; n2 < e3.length; n2++) {
          var r2 = e3[n2];
          r2.enumerable = r2.enumerable || false, r2.configurable = true, "value" in r2 && (r2.writable = true), Object.defineProperty(t4, r2.key, r2);
        }
      }
      return function(e3, n2, r2) {
        return n2 && t3(e3.prototype, n2), r2 && t3(e3, r2), e3;
      };
    })(), N = n(2), j = r(N), A = n(4), q2 = r(A), T2 = n(0), P = r(T2), S3 = n(6), C = r(S3), L2 = n(10), M3 = r(L2), R2 = n(7), I2 = r(R2), B2 = n(34), D2 = n(35), U = n(13), F = r(U), H3 = n(24), K2 = n(36), z2 = n(37), V = n(38), Z = (0, M3.default)("quill:clipboard"), W = "__ql-matcher", G2 = [[Node.TEXT_NODE, w2], [Node.TEXT_NODE, m3], ["br", v], [Node.ELEMENT_NODE, m3], [Node.ELEMENT_NODE, y3], [Node.ELEMENT_NODE, _], [Node.ELEMENT_NODE, d3], [Node.ELEMENT_NODE, O2], ["li", g], ["b", p.bind(p, "bold")], ["i", p.bind(p, "italic")], ["style", b2]], Y2 = [B2.AlignAttribute, K2.DirectionAttribute].reduce(function(t3, e3) {
      return t3[e3.keyName] = e3, t3;
    }, {}), X2 = [B2.AlignStyle, D2.BackgroundStyle, H3.ColorStyle, K2.DirectionStyle, z2.FontStyle, V.SizeStyle].reduce(function(t3, e3) {
      return t3[e3.keyName] = e3, t3;
    }, {}), $ = (function(t3) {
      function e3(t4, n2) {
        i2(this, e3);
        var r2 = l(this, (e3.__proto__ || Object.getPrototypeOf(e3)).call(this, t4, n2));
        return r2.quill.root.addEventListener("paste", r2.onPaste.bind(r2)), r2.container = r2.quill.addContainer("ql-clipboard"), r2.container.setAttribute("contenteditable", true), r2.container.setAttribute("tabindex", -1), r2.matchers = [], G2.concat(r2.options.matchers).forEach(function(t5) {
          var e4 = k2(t5, 2), o2 = e4[0], i3 = e4[1];
          (n2.matchVisual || i3 !== _) && r2.addMatcher(o2, i3);
        }), r2;
      }
      return a3(e3, t3), E2(e3, [{ key: "addMatcher", value: function(t4, e4) {
        this.matchers.push([t4, e4]);
      } }, { key: "convert", value: function(t4) {
        if ("string" == typeof t4) return this.container.innerHTML = t4.replace(/\>\r?\n +\</g, "><"), this.convert();
        var e4 = this.quill.getFormat(this.quill.selection.savedRange.index);
        if (e4[F.default.blotName]) {
          var n2 = this.container.innerText;
          return this.container.innerHTML = "", new q2.default().insert(n2, o({}, F.default.blotName, e4[F.default.blotName]));
        }
        var r2 = this.prepareMatching(), i3 = k2(r2, 2), l2 = i3[0], a4 = i3[1], s4 = h3(this.container, l2, a4);
        return c2(s4, "\n") && null == s4.ops[s4.ops.length - 1].attributes && (s4 = s4.compose(new q2.default().retain(s4.length() - 1).delete(1))), Z.log("convert", this.container.innerHTML, s4), this.container.innerHTML = "", s4;
      } }, { key: "dangerouslyPasteHTML", value: function(t4, e4) {
        var n2 = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : C.default.sources.API;
        if ("string" == typeof t4) this.quill.setContents(this.convert(t4), e4), this.quill.setSelection(0, C.default.sources.SILENT);
        else {
          var r2 = this.convert(e4);
          this.quill.updateContents(new q2.default().retain(t4).concat(r2), n2), this.quill.setSelection(t4 + r2.length(), C.default.sources.SILENT);
        }
      } }, { key: "onPaste", value: function(t4) {
        var e4 = this;
        if (!t4.defaultPrevented && this.quill.isEnabled()) {
          var n2 = this.quill.getSelection(), r2 = new q2.default().retain(n2.index), o2 = this.quill.scrollingContainer.scrollTop;
          this.container.focus(), this.quill.selection.update(C.default.sources.SILENT), setTimeout(function() {
            r2 = r2.concat(e4.convert()).delete(n2.length), e4.quill.updateContents(r2, C.default.sources.USER), e4.quill.setSelection(r2.length() - n2.length, C.default.sources.SILENT), e4.quill.scrollingContainer.scrollTop = o2, e4.quill.focus();
          }, 1);
        }
      } }, { key: "prepareMatching", value: function() {
        var t4 = this, e4 = [], n2 = [];
        return this.matchers.forEach(function(r2) {
          var o2 = k2(r2, 2), i3 = o2[0], l2 = o2[1];
          switch (i3) {
            case Node.TEXT_NODE:
              n2.push(l2);
              break;
            case Node.ELEMENT_NODE:
              e4.push(l2);
              break;
            default:
              [].forEach.call(t4.container.querySelectorAll(i3), function(t5) {
                t5[W] = t5[W] || [], t5[W].push(l2);
              });
          }
        }), [e4, n2];
      } }]), e3;
    })(I2.default);
    $.DEFAULTS = { matchers: [], matchVisual: true }, e2.default = $, e2.matchAttributor = d3, e2.matchBlot = y3, e2.matchNewline = m3, e2.matchSpacing = _, e2.matchText = w2;
  }, function(t2, e2, n) {
    function r(t3) {
      return t3 && t3.__esModule ? t3 : { default: t3 };
    }
    function o(t3, e3) {
      if (!(t3 instanceof e3)) throw new TypeError("Cannot call a class as a function");
    }
    function i2(t3, e3) {
      if (!t3) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      return !e3 || "object" != typeof e3 && "function" != typeof e3 ? t3 : e3;
    }
    function l(t3, e3) {
      if ("function" != typeof e3 && null !== e3) throw new TypeError("Super expression must either be null or a function, not " + typeof e3);
      t3.prototype = Object.create(e3 && e3.prototype, { constructor: { value: t3, enumerable: false, writable: true, configurable: true } }), e3 && (Object.setPrototypeOf ? Object.setPrototypeOf(t3, e3) : t3.__proto__ = e3);
    }
    function a3(t3) {
      var e3 = t3.ops[t3.ops.length - 1];
      return null != e3 && (null != e3.insert ? "string" == typeof e3.insert && e3.insert.endsWith("\n") : null != e3.attributes && Object.keys(e3.attributes).some(function(t4) {
        return null != f.default.query(t4, f.default.Scope.BLOCK);
      }));
    }
    function s3(t3) {
      var e3 = t3.reduce(function(t4, e4) {
        return t4 += e4.delete || 0;
      }, 0), n2 = t3.length() - e3;
      return a3(t3) && (n2 -= 1), n2;
    }
    Object.defineProperty(e2, "__esModule", { value: true }), e2.getLastChangeIndex = e2.default = void 0;
    var u2 = /* @__PURE__ */ (function() {
      function t3(t4, e3) {
        for (var n2 = 0; n2 < e3.length; n2++) {
          var r2 = e3[n2];
          r2.enumerable = r2.enumerable || false, r2.configurable = true, "value" in r2 && (r2.writable = true), Object.defineProperty(t4, r2.key, r2);
        }
      }
      return function(e3, n2, r2) {
        return n2 && t3(e3.prototype, n2), r2 && t3(e3, r2), e3;
      };
    })(), c2 = n(0), f = r(c2), h3 = n(6), p = r(h3), d3 = n(7), y3 = r(d3), v = (function(t3) {
      function e3(t4, n2) {
        o(this, e3);
        var r2 = i2(this, (e3.__proto__ || Object.getPrototypeOf(e3)).call(this, t4, n2));
        return r2.lastRecorded = 0, r2.ignoreChange = false, r2.clear(), r2.quill.on(p.default.events.EDITOR_CHANGE, function(t5, e4, n3, o2) {
          t5 !== p.default.events.TEXT_CHANGE || r2.ignoreChange || (r2.options.userOnly && o2 !== p.default.sources.USER ? r2.transform(e4) : r2.record(e4, n3));
        }), r2.quill.keyboard.addBinding({ key: "Z", shortKey: true }, r2.undo.bind(r2)), r2.quill.keyboard.addBinding({ key: "Z", shortKey: true, shiftKey: true }, r2.redo.bind(r2)), /Win/i.test(navigator.platform) && r2.quill.keyboard.addBinding({ key: "Y", shortKey: true }, r2.redo.bind(r2)), r2;
      }
      return l(e3, t3), u2(e3, [{ key: "change", value: function(t4, e4) {
        if (0 !== this.stack[t4].length) {
          var n2 = this.stack[t4].pop();
          this.stack[e4].push(n2), this.lastRecorded = 0, this.ignoreChange = true, this.quill.updateContents(n2[t4], p.default.sources.USER), this.ignoreChange = false;
          var r2 = s3(n2[t4]);
          this.quill.setSelection(r2);
        }
      } }, { key: "clear", value: function() {
        this.stack = { undo: [], redo: [] };
      } }, { key: "cutoff", value: function() {
        this.lastRecorded = 0;
      } }, { key: "record", value: function(t4, e4) {
        if (0 !== t4.ops.length) {
          this.stack.redo = [];
          var n2 = this.quill.getContents().diff(e4), r2 = Date.now();
          if (this.lastRecorded + this.options.delay > r2 && this.stack.undo.length > 0) {
            var o2 = this.stack.undo.pop();
            n2 = n2.compose(o2.undo), t4 = o2.redo.compose(t4);
          } else this.lastRecorded = r2;
          this.stack.undo.push({ redo: t4, undo: n2 }), this.stack.undo.length > this.options.maxStack && this.stack.undo.shift();
        }
      } }, { key: "redo", value: function() {
        this.change("redo", "undo");
      } }, { key: "transform", value: function(t4) {
        this.stack.undo.forEach(function(e4) {
          e4.undo = t4.transform(e4.undo, true), e4.redo = t4.transform(e4.redo, true);
        }), this.stack.redo.forEach(function(e4) {
          e4.undo = t4.transform(e4.undo, true), e4.redo = t4.transform(e4.redo, true);
        });
      } }, { key: "undo", value: function() {
        this.change("undo", "redo");
      } }]), e3;
    })(y3.default);
    v.DEFAULTS = { delay: 1e3, maxStack: 100, userOnly: false }, e2.default = v, e2.getLastChangeIndex = s3;
  }, function(t2, e2, n) {
    function r(t3, e3) {
      if (!(t3 instanceof e3)) throw new TypeError("Cannot call a class as a function");
    }
    function o(t3, e3) {
      if (!t3) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      return !e3 || "object" != typeof e3 && "function" != typeof e3 ? t3 : e3;
    }
    function i2(t3, e3) {
      if ("function" != typeof e3 && null !== e3) throw new TypeError("Super expression must either be null or a function, not " + typeof e3);
      t3.prototype = Object.create(e3 && e3.prototype, { constructor: { value: t3, enumerable: false, writable: true, configurable: true } }), e3 && (Object.setPrototypeOf ? Object.setPrototypeOf(t3, e3) : t3.__proto__ = e3);
    }
    Object.defineProperty(e2, "__esModule", { value: true }), e2.IndentClass = void 0;
    var l = /* @__PURE__ */ (function() {
      function t3(t4, e3) {
        for (var n2 = 0; n2 < e3.length; n2++) {
          var r2 = e3[n2];
          r2.enumerable = r2.enumerable || false, r2.configurable = true, "value" in r2 && (r2.writable = true), Object.defineProperty(t4, r2.key, r2);
        }
      }
      return function(e3, n2, r2) {
        return n2 && t3(e3.prototype, n2), r2 && t3(e3, r2), e3;
      };
    })(), a3 = function t3(e3, n2, r2) {
      null === e3 && (e3 = Function.prototype);
      var o2 = Object.getOwnPropertyDescriptor(e3, n2);
      if (void 0 === o2) {
        var i3 = Object.getPrototypeOf(e3);
        return null === i3 ? void 0 : t3(i3, n2, r2);
      }
      if ("value" in o2) return o2.value;
      var l2 = o2.get;
      if (void 0 !== l2) return l2.call(r2);
    }, s3 = n(0), u2 = (function(t3) {
      return t3 && t3.__esModule ? t3 : { default: t3 };
    })(s3), c2 = (function(t3) {
      function e3() {
        return r(this, e3), o(this, (e3.__proto__ || Object.getPrototypeOf(e3)).apply(this, arguments));
      }
      return i2(e3, t3), l(e3, [{ key: "add", value: function(t4, n2) {
        if ("+1" === n2 || "-1" === n2) {
          var r2 = this.value(t4) || 0;
          n2 = "+1" === n2 ? r2 + 1 : r2 - 1;
        }
        return 0 === n2 ? (this.remove(t4), true) : a3(e3.prototype.__proto__ || Object.getPrototypeOf(e3.prototype), "add", this).call(this, t4, n2);
      } }, { key: "canAdd", value: function(t4, n2) {
        return a3(e3.prototype.__proto__ || Object.getPrototypeOf(e3.prototype), "canAdd", this).call(this, t4, n2) || a3(e3.prototype.__proto__ || Object.getPrototypeOf(e3.prototype), "canAdd", this).call(this, t4, parseInt(n2));
      } }, { key: "value", value: function(t4) {
        return parseInt(a3(e3.prototype.__proto__ || Object.getPrototypeOf(e3.prototype), "value", this).call(this, t4)) || void 0;
      } }]), e3;
    })(u2.default.Attributor.Class), f = new c2("indent", "ql-indent", { scope: u2.default.Scope.BLOCK, whitelist: [1, 2, 3, 4, 5, 6, 7, 8] });
    e2.IndentClass = f;
  }, function(t2, e2, n) {
    function r(t3, e3) {
      if (!(t3 instanceof e3)) throw new TypeError("Cannot call a class as a function");
    }
    function o(t3, e3) {
      if (!t3) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      return !e3 || "object" != typeof e3 && "function" != typeof e3 ? t3 : e3;
    }
    function i2(t3, e3) {
      if ("function" != typeof e3 && null !== e3) throw new TypeError("Super expression must either be null or a function, not " + typeof e3);
      t3.prototype = Object.create(e3 && e3.prototype, { constructor: { value: t3, enumerable: false, writable: true, configurable: true } }), e3 && (Object.setPrototypeOf ? Object.setPrototypeOf(t3, e3) : t3.__proto__ = e3);
    }
    Object.defineProperty(e2, "__esModule", { value: true });
    var l = n(3), a3 = (function(t3) {
      return t3 && t3.__esModule ? t3 : { default: t3 };
    })(l), s3 = (function(t3) {
      function e3() {
        return r(this, e3), o(this, (e3.__proto__ || Object.getPrototypeOf(e3)).apply(this, arguments));
      }
      return i2(e3, t3), e3;
    })(a3.default);
    s3.blotName = "blockquote", s3.tagName = "blockquote", e2.default = s3;
  }, function(t2, e2, n) {
    function r(t3, e3) {
      if (!(t3 instanceof e3)) throw new TypeError("Cannot call a class as a function");
    }
    function o(t3, e3) {
      if (!t3) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      return !e3 || "object" != typeof e3 && "function" != typeof e3 ? t3 : e3;
    }
    function i2(t3, e3) {
      if ("function" != typeof e3 && null !== e3) throw new TypeError("Super expression must either be null or a function, not " + typeof e3);
      t3.prototype = Object.create(e3 && e3.prototype, { constructor: { value: t3, enumerable: false, writable: true, configurable: true } }), e3 && (Object.setPrototypeOf ? Object.setPrototypeOf(t3, e3) : t3.__proto__ = e3);
    }
    Object.defineProperty(e2, "__esModule", { value: true });
    var l = /* @__PURE__ */ (function() {
      function t3(t4, e3) {
        for (var n2 = 0; n2 < e3.length; n2++) {
          var r2 = e3[n2];
          r2.enumerable = r2.enumerable || false, r2.configurable = true, "value" in r2 && (r2.writable = true), Object.defineProperty(t4, r2.key, r2);
        }
      }
      return function(e3, n2, r2) {
        return n2 && t3(e3.prototype, n2), r2 && t3(e3, r2), e3;
      };
    })(), a3 = n(3), s3 = (function(t3) {
      return t3 && t3.__esModule ? t3 : { default: t3 };
    })(a3), u2 = (function(t3) {
      function e3() {
        return r(this, e3), o(this, (e3.__proto__ || Object.getPrototypeOf(e3)).apply(this, arguments));
      }
      return i2(e3, t3), l(e3, null, [{ key: "formats", value: function(t4) {
        return this.tagName.indexOf(t4.tagName) + 1;
      } }]), e3;
    })(s3.default);
    u2.blotName = "header", u2.tagName = ["H1", "H2", "H3", "H4", "H5", "H6"], e2.default = u2;
  }, function(t2, e2, n) {
    function r(t3) {
      return t3 && t3.__esModule ? t3 : { default: t3 };
    }
    function o(t3, e3, n2) {
      return e3 in t3 ? Object.defineProperty(t3, e3, { value: n2, enumerable: true, configurable: true, writable: true }) : t3[e3] = n2, t3;
    }
    function i2(t3, e3) {
      if (!(t3 instanceof e3)) throw new TypeError("Cannot call a class as a function");
    }
    function l(t3, e3) {
      if (!t3) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      return !e3 || "object" != typeof e3 && "function" != typeof e3 ? t3 : e3;
    }
    function a3(t3, e3) {
      if ("function" != typeof e3 && null !== e3) throw new TypeError("Super expression must either be null or a function, not " + typeof e3);
      t3.prototype = Object.create(e3 && e3.prototype, { constructor: { value: t3, enumerable: false, writable: true, configurable: true } }), e3 && (Object.setPrototypeOf ? Object.setPrototypeOf(t3, e3) : t3.__proto__ = e3);
    }
    Object.defineProperty(e2, "__esModule", { value: true }), e2.default = e2.ListItem = void 0;
    var s3 = /* @__PURE__ */ (function() {
      function t3(t4, e3) {
        for (var n2 = 0; n2 < e3.length; n2++) {
          var r2 = e3[n2];
          r2.enumerable = r2.enumerable || false, r2.configurable = true, "value" in r2 && (r2.writable = true), Object.defineProperty(t4, r2.key, r2);
        }
      }
      return function(e3, n2, r2) {
        return n2 && t3(e3.prototype, n2), r2 && t3(e3, r2), e3;
      };
    })(), u2 = function t3(e3, n2, r2) {
      null === e3 && (e3 = Function.prototype);
      var o2 = Object.getOwnPropertyDescriptor(e3, n2);
      if (void 0 === o2) {
        var i3 = Object.getPrototypeOf(e3);
        return null === i3 ? void 0 : t3(i3, n2, r2);
      }
      if ("value" in o2) return o2.value;
      var l2 = o2.get;
      if (void 0 !== l2) return l2.call(r2);
    }, c2 = n(0), f = r(c2), h3 = n(3), p = r(h3), d3 = n(23), y3 = r(d3), v = (function(t3) {
      function e3() {
        return i2(this, e3), l(this, (e3.__proto__ || Object.getPrototypeOf(e3)).apply(this, arguments));
      }
      return a3(e3, t3), s3(e3, [{ key: "format", value: function(t4, n2) {
        t4 !== b2.blotName || n2 ? u2(e3.prototype.__proto__ || Object.getPrototypeOf(e3.prototype), "format", this).call(this, t4, n2) : this.replaceWith(f.default.create(this.statics.scope));
      } }, { key: "remove", value: function() {
        null == this.prev && null == this.next ? this.parent.remove() : u2(e3.prototype.__proto__ || Object.getPrototypeOf(e3.prototype), "remove", this).call(this);
      } }, { key: "replaceWith", value: function(t4, n2) {
        return this.parent.isolate(this.offset(this.parent), this.length()), t4 === this.parent.statics.blotName ? (this.parent.replaceWith(t4, n2), this) : (this.parent.unwrap(), u2(e3.prototype.__proto__ || Object.getPrototypeOf(e3.prototype), "replaceWith", this).call(this, t4, n2));
      } }], [{ key: "formats", value: function(t4) {
        return t4.tagName === this.tagName ? void 0 : u2(e3.__proto__ || Object.getPrototypeOf(e3), "formats", this).call(this, t4);
      } }]), e3;
    })(p.default);
    v.blotName = "list-item", v.tagName = "LI";
    var b2 = (function(t3) {
      function e3(t4) {
        i2(this, e3);
        var n2 = l(this, (e3.__proto__ || Object.getPrototypeOf(e3)).call(this, t4)), r2 = function(e4) {
          if (e4.target.parentNode === t4) {
            var r3 = n2.statics.formats(t4), o2 = f.default.find(e4.target);
            "checked" === r3 ? o2.format("list", "unchecked") : "unchecked" === r3 && o2.format("list", "checked");
          }
        };
        return t4.addEventListener("touchstart", r2), t4.addEventListener("mousedown", r2), n2;
      }
      return a3(e3, t3), s3(e3, null, [{ key: "create", value: function(t4) {
        var n2 = "ordered" === t4 ? "OL" : "UL", r2 = u2(e3.__proto__ || Object.getPrototypeOf(e3), "create", this).call(this, n2);
        return "checked" !== t4 && "unchecked" !== t4 || r2.setAttribute("data-checked", "checked" === t4), r2;
      } }, { key: "formats", value: function(t4) {
        return "OL" === t4.tagName ? "ordered" : "UL" === t4.tagName ? t4.hasAttribute("data-checked") ? "true" === t4.getAttribute("data-checked") ? "checked" : "unchecked" : "bullet" : void 0;
      } }]), s3(e3, [{ key: "format", value: function(t4, e4) {
        this.children.length > 0 && this.children.tail.format(t4, e4);
      } }, { key: "formats", value: function() {
        return o({}, this.statics.blotName, this.statics.formats(this.domNode));
      } }, { key: "insertBefore", value: function(t4, n2) {
        if (t4 instanceof v) u2(e3.prototype.__proto__ || Object.getPrototypeOf(e3.prototype), "insertBefore", this).call(this, t4, n2);
        else {
          var r2 = null == n2 ? this.length() : n2.offset(this), o2 = this.split(r2);
          o2.parent.insertBefore(t4, o2);
        }
      } }, { key: "optimize", value: function(t4) {
        u2(e3.prototype.__proto__ || Object.getPrototypeOf(e3.prototype), "optimize", this).call(this, t4);
        var n2 = this.next;
        null != n2 && n2.prev === this && n2.statics.blotName === this.statics.blotName && n2.domNode.tagName === this.domNode.tagName && n2.domNode.getAttribute("data-checked") === this.domNode.getAttribute("data-checked") && (n2.moveChildren(this), n2.remove());
      } }, { key: "replace", value: function(t4) {
        if (t4.statics.blotName !== this.statics.blotName) {
          var n2 = f.default.create(this.statics.defaultChild);
          t4.moveChildren(n2), this.appendChild(n2);
        }
        u2(e3.prototype.__proto__ || Object.getPrototypeOf(e3.prototype), "replace", this).call(this, t4);
      } }]), e3;
    })(y3.default);
    b2.blotName = "list", b2.scope = f.default.Scope.BLOCK_BLOT, b2.tagName = ["OL", "UL"], b2.defaultChild = "list-item", b2.allowedChildren = [v], e2.ListItem = v, e2.default = b2;
  }, function(t2, e2, n) {
    function r(t3, e3) {
      if (!(t3 instanceof e3)) throw new TypeError("Cannot call a class as a function");
    }
    function o(t3, e3) {
      if (!t3) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      return !e3 || "object" != typeof e3 && "function" != typeof e3 ? t3 : e3;
    }
    function i2(t3, e3) {
      if ("function" != typeof e3 && null !== e3) throw new TypeError("Super expression must either be null or a function, not " + typeof e3);
      t3.prototype = Object.create(e3 && e3.prototype, { constructor: { value: t3, enumerable: false, writable: true, configurable: true } }), e3 && (Object.setPrototypeOf ? Object.setPrototypeOf(t3, e3) : t3.__proto__ = e3);
    }
    Object.defineProperty(e2, "__esModule", { value: true });
    var l = n(39), a3 = (function(t3) {
      return t3 && t3.__esModule ? t3 : { default: t3 };
    })(l), s3 = (function(t3) {
      function e3() {
        return r(this, e3), o(this, (e3.__proto__ || Object.getPrototypeOf(e3)).apply(this, arguments));
      }
      return i2(e3, t3), e3;
    })(a3.default);
    s3.blotName = "italic", s3.tagName = ["EM", "I"], e2.default = s3;
  }, function(t2, e2, n) {
    function r(t3, e3) {
      if (!(t3 instanceof e3)) throw new TypeError("Cannot call a class as a function");
    }
    function o(t3, e3) {
      if (!t3) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      return !e3 || "object" != typeof e3 && "function" != typeof e3 ? t3 : e3;
    }
    function i2(t3, e3) {
      if ("function" != typeof e3 && null !== e3) throw new TypeError("Super expression must either be null or a function, not " + typeof e3);
      t3.prototype = Object.create(e3 && e3.prototype, { constructor: { value: t3, enumerable: false, writable: true, configurable: true } }), e3 && (Object.setPrototypeOf ? Object.setPrototypeOf(t3, e3) : t3.__proto__ = e3);
    }
    Object.defineProperty(e2, "__esModule", { value: true });
    var l = /* @__PURE__ */ (function() {
      function t3(t4, e3) {
        for (var n2 = 0; n2 < e3.length; n2++) {
          var r2 = e3[n2];
          r2.enumerable = r2.enumerable || false, r2.configurable = true, "value" in r2 && (r2.writable = true), Object.defineProperty(t4, r2.key, r2);
        }
      }
      return function(e3, n2, r2) {
        return n2 && t3(e3.prototype, n2), r2 && t3(e3, r2), e3;
      };
    })(), a3 = function t3(e3, n2, r2) {
      null === e3 && (e3 = Function.prototype);
      var o2 = Object.getOwnPropertyDescriptor(e3, n2);
      if (void 0 === o2) {
        var i3 = Object.getPrototypeOf(e3);
        return null === i3 ? void 0 : t3(i3, n2, r2);
      }
      if ("value" in o2) return o2.value;
      var l2 = o2.get;
      if (void 0 !== l2) return l2.call(r2);
    }, s3 = n(5), u2 = (function(t3) {
      return t3 && t3.__esModule ? t3 : { default: t3 };
    })(s3), c2 = (function(t3) {
      function e3() {
        return r(this, e3), o(this, (e3.__proto__ || Object.getPrototypeOf(e3)).apply(this, arguments));
      }
      return i2(e3, t3), l(e3, null, [{ key: "create", value: function(t4) {
        return "super" === t4 ? document.createElement("sup") : "sub" === t4 ? document.createElement("sub") : a3(e3.__proto__ || Object.getPrototypeOf(e3), "create", this).call(this, t4);
      } }, { key: "formats", value: function(t4) {
        return "SUB" === t4.tagName ? "sub" : "SUP" === t4.tagName ? "super" : void 0;
      } }]), e3;
    })(u2.default);
    c2.blotName = "script", c2.tagName = ["SUB", "SUP"], e2.default = c2;
  }, function(t2, e2, n) {
    function r(t3, e3) {
      if (!(t3 instanceof e3)) throw new TypeError("Cannot call a class as a function");
    }
    function o(t3, e3) {
      if (!t3) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      return !e3 || "object" != typeof e3 && "function" != typeof e3 ? t3 : e3;
    }
    function i2(t3, e3) {
      if ("function" != typeof e3 && null !== e3) throw new TypeError("Super expression must either be null or a function, not " + typeof e3);
      t3.prototype = Object.create(e3 && e3.prototype, { constructor: { value: t3, enumerable: false, writable: true, configurable: true } }), e3 && (Object.setPrototypeOf ? Object.setPrototypeOf(t3, e3) : t3.__proto__ = e3);
    }
    Object.defineProperty(e2, "__esModule", { value: true });
    var l = n(5), a3 = (function(t3) {
      return t3 && t3.__esModule ? t3 : { default: t3 };
    })(l), s3 = (function(t3) {
      function e3() {
        return r(this, e3), o(this, (e3.__proto__ || Object.getPrototypeOf(e3)).apply(this, arguments));
      }
      return i2(e3, t3), e3;
    })(a3.default);
    s3.blotName = "strike", s3.tagName = "S", e2.default = s3;
  }, function(t2, e2, n) {
    function r(t3, e3) {
      if (!(t3 instanceof e3)) throw new TypeError("Cannot call a class as a function");
    }
    function o(t3, e3) {
      if (!t3) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      return !e3 || "object" != typeof e3 && "function" != typeof e3 ? t3 : e3;
    }
    function i2(t3, e3) {
      if ("function" != typeof e3 && null !== e3) throw new TypeError("Super expression must either be null or a function, not " + typeof e3);
      t3.prototype = Object.create(e3 && e3.prototype, { constructor: { value: t3, enumerable: false, writable: true, configurable: true } }), e3 && (Object.setPrototypeOf ? Object.setPrototypeOf(t3, e3) : t3.__proto__ = e3);
    }
    Object.defineProperty(e2, "__esModule", { value: true });
    var l = n(5), a3 = (function(t3) {
      return t3 && t3.__esModule ? t3 : { default: t3 };
    })(l), s3 = (function(t3) {
      function e3() {
        return r(this, e3), o(this, (e3.__proto__ || Object.getPrototypeOf(e3)).apply(this, arguments));
      }
      return i2(e3, t3), e3;
    })(a3.default);
    s3.blotName = "underline", s3.tagName = "U", e2.default = s3;
  }, function(t2, e2, n) {
    function r(t3, e3) {
      if (!(t3 instanceof e3)) throw new TypeError("Cannot call a class as a function");
    }
    function o(t3, e3) {
      if (!t3) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      return !e3 || "object" != typeof e3 && "function" != typeof e3 ? t3 : e3;
    }
    function i2(t3, e3) {
      if ("function" != typeof e3 && null !== e3) throw new TypeError("Super expression must either be null or a function, not " + typeof e3);
      t3.prototype = Object.create(e3 && e3.prototype, { constructor: { value: t3, enumerable: false, writable: true, configurable: true } }), e3 && (Object.setPrototypeOf ? Object.setPrototypeOf(t3, e3) : t3.__proto__ = e3);
    }
    Object.defineProperty(e2, "__esModule", { value: true });
    var l = /* @__PURE__ */ (function() {
      function t3(t4, e3) {
        for (var n2 = 0; n2 < e3.length; n2++) {
          var r2 = e3[n2];
          r2.enumerable = r2.enumerable || false, r2.configurable = true, "value" in r2 && (r2.writable = true), Object.defineProperty(t4, r2.key, r2);
        }
      }
      return function(e3, n2, r2) {
        return n2 && t3(e3.prototype, n2), r2 && t3(e3, r2), e3;
      };
    })(), a3 = function t3(e3, n2, r2) {
      null === e3 && (e3 = Function.prototype);
      var o2 = Object.getOwnPropertyDescriptor(e3, n2);
      if (void 0 === o2) {
        var i3 = Object.getPrototypeOf(e3);
        return null === i3 ? void 0 : t3(i3, n2, r2);
      }
      if ("value" in o2) return o2.value;
      var l2 = o2.get;
      if (void 0 !== l2) return l2.call(r2);
    }, s3 = n(0), u2 = (function(t3) {
      return t3 && t3.__esModule ? t3 : { default: t3 };
    })(s3), c2 = n(15), f = ["alt", "height", "width"], h3 = (function(t3) {
      function e3() {
        return r(this, e3), o(this, (e3.__proto__ || Object.getPrototypeOf(e3)).apply(this, arguments));
      }
      return i2(e3, t3), l(e3, [{ key: "format", value: function(t4, n2) {
        f.indexOf(t4) > -1 ? n2 ? this.domNode.setAttribute(t4, n2) : this.domNode.removeAttribute(t4) : a3(e3.prototype.__proto__ || Object.getPrototypeOf(e3.prototype), "format", this).call(this, t4, n2);
      } }], [{ key: "create", value: function(t4) {
        var n2 = a3(e3.__proto__ || Object.getPrototypeOf(e3), "create", this).call(this, t4);
        return "string" == typeof t4 && n2.setAttribute("src", this.sanitize(t4)), n2;
      } }, { key: "formats", value: function(t4) {
        return f.reduce(function(e4, n2) {
          return t4.hasAttribute(n2) && (e4[n2] = t4.getAttribute(n2)), e4;
        }, {});
      } }, { key: "match", value: function(t4) {
        return /\.(jpe?g|gif|png)$/.test(t4) || /^data:image\/.+;base64/.test(t4);
      } }, { key: "sanitize", value: function(t4) {
        return (0, c2.sanitize)(t4, ["http", "https", "data"]) ? t4 : "//:0";
      } }, { key: "value", value: function(t4) {
        return t4.getAttribute("src");
      } }]), e3;
    })(u2.default.Embed);
    h3.blotName = "image", h3.tagName = "IMG", e2.default = h3;
  }, function(t2, e2, n) {
    function r(t3, e3) {
      if (!(t3 instanceof e3)) throw new TypeError("Cannot call a class as a function");
    }
    function o(t3, e3) {
      if (!t3) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      return !e3 || "object" != typeof e3 && "function" != typeof e3 ? t3 : e3;
    }
    function i2(t3, e3) {
      if ("function" != typeof e3 && null !== e3) throw new TypeError("Super expression must either be null or a function, not " + typeof e3);
      t3.prototype = Object.create(e3 && e3.prototype, { constructor: { value: t3, enumerable: false, writable: true, configurable: true } }), e3 && (Object.setPrototypeOf ? Object.setPrototypeOf(t3, e3) : t3.__proto__ = e3);
    }
    Object.defineProperty(e2, "__esModule", { value: true });
    var l = /* @__PURE__ */ (function() {
      function t3(t4, e3) {
        for (var n2 = 0; n2 < e3.length; n2++) {
          var r2 = e3[n2];
          r2.enumerable = r2.enumerable || false, r2.configurable = true, "value" in r2 && (r2.writable = true), Object.defineProperty(t4, r2.key, r2);
        }
      }
      return function(e3, n2, r2) {
        return n2 && t3(e3.prototype, n2), r2 && t3(e3, r2), e3;
      };
    })(), a3 = function t3(e3, n2, r2) {
      null === e3 && (e3 = Function.prototype);
      var o2 = Object.getOwnPropertyDescriptor(e3, n2);
      if (void 0 === o2) {
        var i3 = Object.getPrototypeOf(e3);
        return null === i3 ? void 0 : t3(i3, n2, r2);
      }
      if ("value" in o2) return o2.value;
      var l2 = o2.get;
      if (void 0 !== l2) return l2.call(r2);
    }, s3 = n(3), u2 = n(15), c2 = (function(t3) {
      return t3 && t3.__esModule ? t3 : { default: t3 };
    })(u2), f = ["height", "width"], h3 = (function(t3) {
      function e3() {
        return r(this, e3), o(this, (e3.__proto__ || Object.getPrototypeOf(e3)).apply(this, arguments));
      }
      return i2(e3, t3), l(e3, [{ key: "format", value: function(t4, n2) {
        f.indexOf(t4) > -1 ? n2 ? this.domNode.setAttribute(t4, n2) : this.domNode.removeAttribute(t4) : a3(e3.prototype.__proto__ || Object.getPrototypeOf(e3.prototype), "format", this).call(this, t4, n2);
      } }], [{ key: "create", value: function(t4) {
        var n2 = a3(e3.__proto__ || Object.getPrototypeOf(e3), "create", this).call(this, t4);
        return n2.setAttribute("frameborder", "0"), n2.setAttribute("allowfullscreen", true), n2.setAttribute("src", this.sanitize(t4)), n2;
      } }, { key: "formats", value: function(t4) {
        return f.reduce(function(e4, n2) {
          return t4.hasAttribute(n2) && (e4[n2] = t4.getAttribute(n2)), e4;
        }, {});
      } }, { key: "sanitize", value: function(t4) {
        return c2.default.sanitize(t4);
      } }, { key: "value", value: function(t4) {
        return t4.getAttribute("src");
      } }]), e3;
    })(s3.BlockEmbed);
    h3.blotName = "video", h3.className = "ql-video", h3.tagName = "IFRAME", e2.default = h3;
  }, function(t2, e2, n) {
    function r(t3) {
      return t3 && t3.__esModule ? t3 : { default: t3 };
    }
    function o(t3, e3) {
      if (!(t3 instanceof e3)) throw new TypeError("Cannot call a class as a function");
    }
    function i2(t3, e3) {
      if (!t3) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      return !e3 || "object" != typeof e3 && "function" != typeof e3 ? t3 : e3;
    }
    function l(t3, e3) {
      if ("function" != typeof e3 && null !== e3) throw new TypeError("Super expression must either be null or a function, not " + typeof e3);
      t3.prototype = Object.create(e3 && e3.prototype, { constructor: { value: t3, enumerable: false, writable: true, configurable: true } }), e3 && (Object.setPrototypeOf ? Object.setPrototypeOf(t3, e3) : t3.__proto__ = e3);
    }
    Object.defineProperty(e2, "__esModule", { value: true }), e2.default = e2.FormulaBlot = void 0;
    var a3 = /* @__PURE__ */ (function() {
      function t3(t4, e3) {
        for (var n2 = 0; n2 < e3.length; n2++) {
          var r2 = e3[n2];
          r2.enumerable = r2.enumerable || false, r2.configurable = true, "value" in r2 && (r2.writable = true), Object.defineProperty(t4, r2.key, r2);
        }
      }
      return function(e3, n2, r2) {
        return n2 && t3(e3.prototype, n2), r2 && t3(e3, r2), e3;
      };
    })(), s3 = function t3(e3, n2, r2) {
      null === e3 && (e3 = Function.prototype);
      var o2 = Object.getOwnPropertyDescriptor(e3, n2);
      if (void 0 === o2) {
        var i3 = Object.getPrototypeOf(e3);
        return null === i3 ? void 0 : t3(i3, n2, r2);
      }
      if ("value" in o2) return o2.value;
      var l2 = o2.get;
      if (void 0 !== l2) return l2.call(r2);
    }, u2 = n(33), c2 = r(u2), f = n(6), h3 = r(f), p = n(7), d3 = r(p), y3 = (function(t3) {
      function e3() {
        return o(this, e3), i2(this, (e3.__proto__ || Object.getPrototypeOf(e3)).apply(this, arguments));
      }
      return l(e3, t3), a3(e3, null, [{ key: "create", value: function(t4) {
        var n2 = s3(e3.__proto__ || Object.getPrototypeOf(e3), "create", this).call(this, t4);
        return "string" == typeof t4 && (window.katex.render(t4, n2, { throwOnError: false, errorColor: "#f00" }), n2.setAttribute("data-value", t4)), n2;
      } }, { key: "value", value: function(t4) {
        return t4.getAttribute("data-value");
      } }]), e3;
    })(c2.default);
    y3.blotName = "formula", y3.className = "ql-formula", y3.tagName = "SPAN";
    var v = (function(t3) {
      function e3() {
        o(this, e3);
        var t4 = i2(this, (e3.__proto__ || Object.getPrototypeOf(e3)).call(this));
        if (null == window.katex) throw new Error("Formula module requires KaTeX.");
        return t4;
      }
      return l(e3, t3), a3(e3, null, [{ key: "register", value: function() {
        h3.default.register(y3, true);
      } }]), e3;
    })(d3.default);
    e2.FormulaBlot = y3, e2.default = v;
  }, function(t2, e2, n) {
    function r(t3) {
      return t3 && t3.__esModule ? t3 : { default: t3 };
    }
    function o(t3, e3) {
      if (!(t3 instanceof e3)) throw new TypeError("Cannot call a class as a function");
    }
    function i2(t3, e3) {
      if (!t3) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      return !e3 || "object" != typeof e3 && "function" != typeof e3 ? t3 : e3;
    }
    function l(t3, e3) {
      if ("function" != typeof e3 && null !== e3) throw new TypeError("Super expression must either be null or a function, not " + typeof e3);
      t3.prototype = Object.create(e3 && e3.prototype, { constructor: { value: t3, enumerable: false, writable: true, configurable: true } }), e3 && (Object.setPrototypeOf ? Object.setPrototypeOf(t3, e3) : t3.__proto__ = e3);
    }
    Object.defineProperty(e2, "__esModule", { value: true }), e2.default = e2.CodeToken = e2.CodeBlock = void 0;
    var a3 = /* @__PURE__ */ (function() {
      function t3(t4, e3) {
        for (var n2 = 0; n2 < e3.length; n2++) {
          var r2 = e3[n2];
          r2.enumerable = r2.enumerable || false, r2.configurable = true, "value" in r2 && (r2.writable = true), Object.defineProperty(t4, r2.key, r2);
        }
      }
      return function(e3, n2, r2) {
        return n2 && t3(e3.prototype, n2), r2 && t3(e3, r2), e3;
      };
    })(), s3 = function t3(e3, n2, r2) {
      null === e3 && (e3 = Function.prototype);
      var o2 = Object.getOwnPropertyDescriptor(e3, n2);
      if (void 0 === o2) {
        var i3 = Object.getPrototypeOf(e3);
        return null === i3 ? void 0 : t3(i3, n2, r2);
      }
      if ("value" in o2) return o2.value;
      var l2 = o2.get;
      if (void 0 !== l2) return l2.call(r2);
    }, u2 = n(0), c2 = r(u2), f = n(6), h3 = r(f), p = n(7), d3 = r(p), y3 = n(13), v = r(y3), b2 = (function(t3) {
      function e3() {
        return o(this, e3), i2(this, (e3.__proto__ || Object.getPrototypeOf(e3)).apply(this, arguments));
      }
      return l(e3, t3), a3(e3, [{ key: "replaceWith", value: function(t4) {
        this.domNode.textContent = this.domNode.textContent, this.attach(), s3(e3.prototype.__proto__ || Object.getPrototypeOf(e3.prototype), "replaceWith", this).call(this, t4);
      } }, { key: "highlight", value: function(t4) {
        var e4 = this.domNode.textContent;
        this.cachedText !== e4 && ((e4.trim().length > 0 || null == this.cachedText) && (this.domNode.innerHTML = t4(e4), this.domNode.normalize(), this.attach()), this.cachedText = e4);
      } }]), e3;
    })(v.default);
    b2.className = "ql-syntax";
    var g = new c2.default.Attributor.Class("token", "hljs", { scope: c2.default.Scope.INLINE }), m3 = (function(t3) {
      function e3(t4, n2) {
        o(this, e3);
        var r2 = i2(this, (e3.__proto__ || Object.getPrototypeOf(e3)).call(this, t4, n2));
        if ("function" != typeof r2.options.highlight) throw new Error("Syntax module requires highlight.js. Please include the library on the page before Quill.");
        var l2 = null;
        return r2.quill.on(h3.default.events.SCROLL_OPTIMIZE, function() {
          clearTimeout(l2), l2 = setTimeout(function() {
            r2.highlight(), l2 = null;
          }, r2.options.interval);
        }), r2.highlight(), r2;
      }
      return l(e3, t3), a3(e3, null, [{ key: "register", value: function() {
        h3.default.register(g, true), h3.default.register(b2, true);
      } }]), a3(e3, [{ key: "highlight", value: function() {
        var t4 = this;
        if (!this.quill.selection.composing) {
          this.quill.update(h3.default.sources.USER);
          var e4 = this.quill.getSelection();
          this.quill.scroll.descendants(b2).forEach(function(e5) {
            e5.highlight(t4.options.highlight);
          }), this.quill.update(h3.default.sources.SILENT), null != e4 && this.quill.setSelection(e4, h3.default.sources.SILENT);
        }
      } }]), e3;
    })(d3.default);
    m3.DEFAULTS = { highlight: (function() {
      return null == window.hljs ? null : function(t3) {
        return window.hljs.highlightAuto(t3).value;
      };
    })(), interval: 1e3 }, e2.CodeBlock = b2, e2.CodeToken = g, e2.default = m3;
  }, function(t2, e2, n) {
    function r(t3) {
      return t3 && t3.__esModule ? t3 : { default: t3 };
    }
    function o(t3, e3, n2) {
      return e3 in t3 ? Object.defineProperty(t3, e3, { value: n2, enumerable: true, configurable: true, writable: true }) : t3[e3] = n2, t3;
    }
    function i2(t3, e3) {
      if (!(t3 instanceof e3)) throw new TypeError("Cannot call a class as a function");
    }
    function l(t3, e3) {
      if (!t3) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      return !e3 || "object" != typeof e3 && "function" != typeof e3 ? t3 : e3;
    }
    function a3(t3, e3) {
      if ("function" != typeof e3 && null !== e3) throw new TypeError("Super expression must either be null or a function, not " + typeof e3);
      t3.prototype = Object.create(e3 && e3.prototype, { constructor: { value: t3, enumerable: false, writable: true, configurable: true } }), e3 && (Object.setPrototypeOf ? Object.setPrototypeOf(t3, e3) : t3.__proto__ = e3);
    }
    function s3(t3, e3, n2) {
      var r2 = document.createElement("button");
      r2.setAttribute("type", "button"), r2.classList.add("ql-" + e3), null != n2 && (r2.value = n2), t3.appendChild(r2);
    }
    function u2(t3, e3) {
      Array.isArray(e3[0]) || (e3 = [e3]), e3.forEach(function(e4) {
        var n2 = document.createElement("span");
        n2.classList.add("ql-formats"), e4.forEach(function(t4) {
          if ("string" == typeof t4) s3(n2, t4);
          else {
            var e5 = Object.keys(t4)[0], r2 = t4[e5];
            Array.isArray(r2) ? c2(n2, e5, r2) : s3(n2, e5, r2);
          }
        }), t3.appendChild(n2);
      });
    }
    function c2(t3, e3, n2) {
      var r2 = document.createElement("select");
      r2.classList.add("ql-" + e3), n2.forEach(function(t4) {
        var e4 = document.createElement("option");
        false !== t4 ? e4.setAttribute("value", t4) : e4.setAttribute("selected", "selected"), r2.appendChild(e4);
      }), t3.appendChild(r2);
    }
    Object.defineProperty(e2, "__esModule", { value: true }), e2.addControls = e2.default = void 0;
    var f = /* @__PURE__ */ (function() {
      function t3(t4, e3) {
        var n2 = [], r2 = true, o2 = false, i3 = void 0;
        try {
          for (var l2, a4 = t4[Symbol.iterator](); !(r2 = (l2 = a4.next()).done) && (n2.push(l2.value), !e3 || n2.length !== e3); r2 = true) ;
        } catch (t5) {
          o2 = true, i3 = t5;
        } finally {
          try {
            !r2 && a4.return && a4.return();
          } finally {
            if (o2) throw i3;
          }
        }
        return n2;
      }
      return function(e3, n2) {
        if (Array.isArray(e3)) return e3;
        if (Symbol.iterator in Object(e3)) return t3(e3, n2);
        throw new TypeError("Invalid attempt to destructure non-iterable instance");
      };
    })(), h3 = /* @__PURE__ */ (function() {
      function t3(t4, e3) {
        for (var n2 = 0; n2 < e3.length; n2++) {
          var r2 = e3[n2];
          r2.enumerable = r2.enumerable || false, r2.configurable = true, "value" in r2 && (r2.writable = true), Object.defineProperty(t4, r2.key, r2);
        }
      }
      return function(e3, n2, r2) {
        return n2 && t3(e3.prototype, n2), r2 && t3(e3, r2), e3;
      };
    })(), p = n(4), d3 = r(p), y3 = n(0), v = r(y3), b2 = n(6), g = r(b2), m3 = n(10), _ = r(m3), O2 = n(7), w2 = r(O2), x2 = (0, _.default)("quill:toolbar"), k2 = (function(t3) {
      function e3(t4, n2) {
        i2(this, e3);
        var r2 = l(this, (e3.__proto__ || Object.getPrototypeOf(e3)).call(this, t4, n2));
        if (Array.isArray(r2.options.container)) {
          var o2 = document.createElement("div");
          u2(o2, r2.options.container), t4.container.parentNode.insertBefore(o2, t4.container), r2.container = o2;
        } else "string" == typeof r2.options.container ? r2.container = document.querySelector(r2.options.container) : r2.container = r2.options.container;
        if (!(r2.container instanceof HTMLElement)) {
          var a4;
          return a4 = x2.error("Container required for toolbar", r2.options), l(r2, a4);
        }
        return r2.container.classList.add("ql-toolbar"), r2.controls = [], r2.handlers = {}, Object.keys(r2.options.handlers).forEach(function(t5) {
          r2.addHandler(t5, r2.options.handlers[t5]);
        }), [].forEach.call(r2.container.querySelectorAll("button, select"), function(t5) {
          r2.attach(t5);
        }), r2.quill.on(g.default.events.EDITOR_CHANGE, function(t5, e4) {
          t5 === g.default.events.SELECTION_CHANGE && r2.update(e4);
        }), r2.quill.on(g.default.events.SCROLL_OPTIMIZE, function() {
          var t5 = r2.quill.selection.getRange(), e4 = f(t5, 1), n3 = e4[0];
          r2.update(n3);
        }), r2;
      }
      return a3(e3, t3), h3(e3, [{ key: "addHandler", value: function(t4, e4) {
        this.handlers[t4] = e4;
      } }, { key: "attach", value: function(t4) {
        var e4 = this, n2 = [].find.call(t4.classList, function(t5) {
          return 0 === t5.indexOf("ql-");
        });
        if (n2) {
          if (n2 = n2.slice("ql-".length), "BUTTON" === t4.tagName && t4.setAttribute("type", "button"), null == this.handlers[n2]) {
            if (null != this.quill.scroll.whitelist && null == this.quill.scroll.whitelist[n2]) return void x2.warn("ignoring attaching to disabled format", n2, t4);
            if (null == v.default.query(n2)) return void x2.warn("ignoring attaching to nonexistent format", n2, t4);
          }
          var r2 = "SELECT" === t4.tagName ? "change" : "click";
          t4.addEventListener(r2, function(r3) {
            var i3 = void 0;
            if ("SELECT" === t4.tagName) {
              if (t4.selectedIndex < 0) return;
              var l2 = t4.options[t4.selectedIndex];
              i3 = !l2.hasAttribute("selected") && (l2.value || false);
            } else i3 = !t4.classList.contains("ql-active") && (t4.value || !t4.hasAttribute("value")), r3.preventDefault();
            e4.quill.focus();
            var a4 = e4.quill.selection.getRange(), s4 = f(a4, 1), u3 = s4[0];
            if (null != e4.handlers[n2]) e4.handlers[n2].call(e4, i3);
            else if (v.default.query(n2).prototype instanceof v.default.Embed) {
              if (!(i3 = prompt("Enter " + n2))) return;
              e4.quill.updateContents(new d3.default().retain(u3.index).delete(u3.length).insert(o({}, n2, i3)), g.default.sources.USER);
            } else e4.quill.format(n2, i3, g.default.sources.USER);
            e4.update(u3);
          }), this.controls.push([n2, t4]);
        }
      } }, { key: "update", value: function(t4) {
        var e4 = null == t4 ? {} : this.quill.getFormat(t4);
        this.controls.forEach(function(n2) {
          var r2 = f(n2, 2), o2 = r2[0], i3 = r2[1];
          if ("SELECT" === i3.tagName) {
            var l2 = void 0;
            if (null == t4) l2 = null;
            else if (null == e4[o2]) l2 = i3.querySelector("option[selected]");
            else if (!Array.isArray(e4[o2])) {
              var a4 = e4[o2];
              "string" == typeof a4 && (a4 = a4.replace(/\"/g, '\\"')), l2 = i3.querySelector('option[value="' + a4 + '"]');
            }
            null == l2 ? (i3.value = "", i3.selectedIndex = -1) : l2.selected = true;
          } else if (null == t4) i3.classList.remove("ql-active");
          else if (i3.hasAttribute("value")) {
            var s4 = e4[o2] === i3.getAttribute("value") || null != e4[o2] && e4[o2].toString() === i3.getAttribute("value") || null == e4[o2] && !i3.getAttribute("value");
            i3.classList.toggle("ql-active", s4);
          } else i3.classList.toggle("ql-active", null != e4[o2]);
        });
      } }]), e3;
    })(w2.default);
    k2.DEFAULTS = {}, k2.DEFAULTS = { container: null, handlers: { clean: function() {
      var t3 = this, e3 = this.quill.getSelection();
      if (null != e3) if (0 == e3.length) {
        var n2 = this.quill.getFormat();
        Object.keys(n2).forEach(function(e4) {
          null != v.default.query(e4, v.default.Scope.INLINE) && t3.quill.format(e4, false);
        });
      } else this.quill.removeFormat(e3, g.default.sources.USER);
    }, direction: function(t3) {
      var e3 = this.quill.getFormat().align;
      "rtl" === t3 && null == e3 ? this.quill.format("align", "right", g.default.sources.USER) : t3 || "right" !== e3 || this.quill.format("align", false, g.default.sources.USER), this.quill.format("direction", t3, g.default.sources.USER);
    }, indent: function(t3) {
      var e3 = this.quill.getSelection(), n2 = this.quill.getFormat(e3), r2 = parseInt(n2.indent || 0);
      if ("+1" === t3 || "-1" === t3) {
        var o2 = "+1" === t3 ? 1 : -1;
        "rtl" === n2.direction && (o2 *= -1), this.quill.format("indent", r2 + o2, g.default.sources.USER);
      }
    }, link: function(t3) {
      true === t3 && (t3 = prompt("Enter link URL:")), this.quill.format("link", t3, g.default.sources.USER);
    }, list: function(t3) {
      var e3 = this.quill.getSelection(), n2 = this.quill.getFormat(e3);
      "check" === t3 ? "checked" === n2.list || "unchecked" === n2.list ? this.quill.format("list", false, g.default.sources.USER) : this.quill.format("list", "unchecked", g.default.sources.USER) : this.quill.format("list", t3, g.default.sources.USER);
    } } }, e2.default = k2, e2.addControls = u2;
  }, function(t2, e2) {
    t2.exports = '<svg viewbox="0 0 18 18"> <line class=ql-stroke x1=3 x2=15 y1=9 y2=9></line> <line class=ql-stroke x1=3 x2=13 y1=14 y2=14></line> <line class=ql-stroke x1=3 x2=9 y1=4 y2=4></line> </svg>';
  }, function(t2, e2) {
    t2.exports = '<svg viewbox="0 0 18 18"> <line class=ql-stroke x1=15 x2=3 y1=9 y2=9></line> <line class=ql-stroke x1=14 x2=4 y1=14 y2=14></line> <line class=ql-stroke x1=12 x2=6 y1=4 y2=4></line> </svg>';
  }, function(t2, e2) {
    t2.exports = '<svg viewbox="0 0 18 18"> <line class=ql-stroke x1=15 x2=3 y1=9 y2=9></line> <line class=ql-stroke x1=15 x2=5 y1=14 y2=14></line> <line class=ql-stroke x1=15 x2=9 y1=4 y2=4></line> </svg>';
  }, function(t2, e2) {
    t2.exports = '<svg viewbox="0 0 18 18"> <line class=ql-stroke x1=15 x2=3 y1=9 y2=9></line> <line class=ql-stroke x1=15 x2=3 y1=14 y2=14></line> <line class=ql-stroke x1=15 x2=3 y1=4 y2=4></line> </svg>';
  }, function(t2, e2) {
    t2.exports = '<svg viewbox="0 0 18 18"> <g class="ql-fill ql-color-label"> <polygon points="6 6.868 6 6 5 6 5 7 5.942 7 6 6.868"></polygon> <rect height=1 width=1 x=4 y=4></rect> <polygon points="6.817 5 6 5 6 6 6.38 6 6.817 5"></polygon> <rect height=1 width=1 x=2 y=6></rect> <rect height=1 width=1 x=3 y=5></rect> <rect height=1 width=1 x=4 y=7></rect> <polygon points="4 11.439 4 11 3 11 3 12 3.755 12 4 11.439"></polygon> <rect height=1 width=1 x=2 y=12></rect> <rect height=1 width=1 x=2 y=9></rect> <rect height=1 width=1 x=2 y=15></rect> <polygon points="4.63 10 4 10 4 11 4.192 11 4.63 10"></polygon> <rect height=1 width=1 x=3 y=8></rect> <path d=M10.832,4.2L11,4.582V4H10.708A1.948,1.948,0,0,1,10.832,4.2Z></path> <path d=M7,4.582L7.168,4.2A1.929,1.929,0,0,1,7.292,4H7V4.582Z></path> <path d=M8,13H7.683l-0.351.8a1.933,1.933,0,0,1-.124.2H8V13Z></path> <rect height=1 width=1 x=12 y=2></rect> <rect height=1 width=1 x=11 y=3></rect> <path d=M9,3H8V3.282A1.985,1.985,0,0,1,9,3Z></path> <rect height=1 width=1 x=2 y=3></rect> <rect height=1 width=1 x=6 y=2></rect> <rect height=1 width=1 x=3 y=2></rect> <rect height=1 width=1 x=5 y=3></rect> <rect height=1 width=1 x=9 y=2></rect> <rect height=1 width=1 x=15 y=14></rect> <polygon points="13.447 10.174 13.469 10.225 13.472 10.232 13.808 11 14 11 14 10 13.37 10 13.447 10.174"></polygon> <rect height=1 width=1 x=13 y=7></rect> <rect height=1 width=1 x=15 y=5></rect> <rect height=1 width=1 x=14 y=6></rect> <rect height=1 width=1 x=15 y=8></rect> <rect height=1 width=1 x=14 y=9></rect> <path d=M3.775,14H3v1H4V14.314A1.97,1.97,0,0,1,3.775,14Z></path> <rect height=1 width=1 x=14 y=3></rect> <polygon points="12 6.868 12 6 11.62 6 12 6.868"></polygon> <rect height=1 width=1 x=15 y=2></rect> <rect height=1 width=1 x=12 y=5></rect> <rect height=1 width=1 x=13 y=4></rect> <polygon points="12.933 9 13 9 13 8 12.495 8 12.933 9"></polygon> <rect height=1 width=1 x=9 y=14></rect> <rect height=1 width=1 x=8 y=15></rect> <path d=M6,14.926V15H7V14.316A1.993,1.993,0,0,1,6,14.926Z></path> <rect height=1 width=1 x=5 y=15></rect> <path d=M10.668,13.8L10.317,13H10v1h0.792A1.947,1.947,0,0,1,10.668,13.8Z></path> <rect height=1 width=1 x=11 y=15></rect> <path d=M14.332,12.2a1.99,1.99,0,0,1,.166.8H15V12H14.245Z></path> <rect height=1 width=1 x=14 y=15></rect> <rect height=1 width=1 x=15 y=11></rect> </g> <polyline class=ql-stroke points="5.5 13 9 5 12.5 13"></polyline> <line class=ql-stroke x1=11.63 x2=6.38 y1=11 y2=11></line> </svg>';
  }, function(t2, e2) {
    t2.exports = '<svg viewbox="0 0 18 18"> <rect class="ql-fill ql-stroke" height=3 width=3 x=4 y=5></rect> <rect class="ql-fill ql-stroke" height=3 width=3 x=11 y=5></rect> <path class="ql-even ql-fill ql-stroke" d=M7,8c0,4.031-3,5-3,5></path> <path class="ql-even ql-fill ql-stroke" d=M14,8c0,4.031-3,5-3,5></path> </svg>';
  }, function(t2, e2) {
    t2.exports = '<svg viewbox="0 0 18 18"> <path class=ql-stroke d=M5,4H9.5A2.5,2.5,0,0,1,12,6.5v0A2.5,2.5,0,0,1,9.5,9H5A0,0,0,0,1,5,9V4A0,0,0,0,1,5,4Z></path> <path class=ql-stroke d=M5,9h5.5A2.5,2.5,0,0,1,13,11.5v0A2.5,2.5,0,0,1,10.5,14H5a0,0,0,0,1,0,0V9A0,0,0,0,1,5,9Z></path> </svg>';
  }, function(t2, e2) {
    t2.exports = '<svg class="" viewbox="0 0 18 18"> <line class=ql-stroke x1=5 x2=13 y1=3 y2=3></line> <line class=ql-stroke x1=6 x2=9.35 y1=12 y2=3></line> <line class=ql-stroke x1=11 x2=15 y1=11 y2=15></line> <line class=ql-stroke x1=15 x2=11 y1=11 y2=15></line> <rect class=ql-fill height=1 rx=0.5 ry=0.5 width=7 x=2 y=14></rect> </svg>';
  }, function(t2, e2) {
    t2.exports = '<svg viewbox="0 0 18 18"> <line class="ql-color-label ql-stroke ql-transparent" x1=3 x2=15 y1=15 y2=15></line> <polyline class=ql-stroke points="5.5 11 9 3 12.5 11"></polyline> <line class=ql-stroke x1=11.63 x2=6.38 y1=9 y2=9></line> </svg>';
  }, function(t2, e2) {
    t2.exports = '<svg viewbox="0 0 18 18"> <polygon class="ql-stroke ql-fill" points="3 11 5 9 3 7 3 11"></polygon> <line class="ql-stroke ql-fill" x1=15 x2=11 y1=4 y2=4></line> <path class=ql-fill d=M11,3a3,3,0,0,0,0,6h1V3H11Z></path> <rect class=ql-fill height=11 width=1 x=11 y=4></rect> <rect class=ql-fill height=11 width=1 x=13 y=4></rect> </svg>';
  }, function(t2, e2) {
    t2.exports = '<svg viewbox="0 0 18 18"> <polygon class="ql-stroke ql-fill" points="15 12 13 10 15 8 15 12"></polygon> <line class="ql-stroke ql-fill" x1=9 x2=5 y1=4 y2=4></line> <path class=ql-fill d=M5,3A3,3,0,0,0,5,9H6V3H5Z></path> <rect class=ql-fill height=11 width=1 x=5 y=4></rect> <rect class=ql-fill height=11 width=1 x=7 y=4></rect> </svg>';
  }, function(t2, e2) {
    t2.exports = '<svg viewbox="0 0 18 18"> <path class=ql-fill d=M14,16H4a1,1,0,0,1,0-2H14A1,1,0,0,1,14,16Z /> <path class=ql-fill d=M14,4H4A1,1,0,0,1,4,2H14A1,1,0,0,1,14,4Z /> <rect class=ql-fill x=3 y=6 width=12 height=6 rx=1 ry=1 /> </svg>';
  }, function(t2, e2) {
    t2.exports = '<svg viewbox="0 0 18 18"> <path class=ql-fill d=M13,16H5a1,1,0,0,1,0-2h8A1,1,0,0,1,13,16Z /> <path class=ql-fill d=M13,4H5A1,1,0,0,1,5,2h8A1,1,0,0,1,13,4Z /> <rect class=ql-fill x=2 y=6 width=14 height=6 rx=1 ry=1 /> </svg>';
  }, function(t2, e2) {
    t2.exports = '<svg viewbox="0 0 18 18"> <path class=ql-fill d=M15,8H13a1,1,0,0,1,0-2h2A1,1,0,0,1,15,8Z /> <path class=ql-fill d=M15,12H13a1,1,0,0,1,0-2h2A1,1,0,0,1,15,12Z /> <path class=ql-fill d=M15,16H5a1,1,0,0,1,0-2H15A1,1,0,0,1,15,16Z /> <path class=ql-fill d=M15,4H5A1,1,0,0,1,5,2H15A1,1,0,0,1,15,4Z /> <rect class=ql-fill x=2 y=6 width=8 height=6 rx=1 ry=1 /> </svg>';
  }, function(t2, e2) {
    t2.exports = '<svg viewbox="0 0 18 18"> <path class=ql-fill d=M5,8H3A1,1,0,0,1,3,6H5A1,1,0,0,1,5,8Z /> <path class=ql-fill d=M5,12H3a1,1,0,0,1,0-2H5A1,1,0,0,1,5,12Z /> <path class=ql-fill d=M13,16H3a1,1,0,0,1,0-2H13A1,1,0,0,1,13,16Z /> <path class=ql-fill d=M13,4H3A1,1,0,0,1,3,2H13A1,1,0,0,1,13,4Z /> <rect class=ql-fill x=8 y=6 width=8 height=6 rx=1 ry=1 transform="translate(24 18) rotate(-180)"/> </svg>';
  }, function(t2, e2) {
    t2.exports = '<svg viewbox="0 0 18 18"> <path class=ql-fill d=M11.759,2.482a2.561,2.561,0,0,0-3.53.607A7.656,7.656,0,0,0,6.8,6.2C6.109,9.188,5.275,14.677,4.15,14.927a1.545,1.545,0,0,0-1.3-.933A0.922,0.922,0,0,0,2,15.036S1.954,16,4.119,16s3.091-2.691,3.7-5.553c0.177-.826.36-1.726,0.554-2.6L8.775,6.2c0.381-1.421.807-2.521,1.306-2.676a1.014,1.014,0,0,0,1.02.56A0.966,0.966,0,0,0,11.759,2.482Z></path> <rect class=ql-fill height=1.6 rx=0.8 ry=0.8 width=5 x=5.15 y=6.2></rect> <path class=ql-fill d=M13.663,12.027a1.662,1.662,0,0,1,.266-0.276q0.193,0.069.456,0.138a2.1,2.1,0,0,0,.535.069,1.075,1.075,0,0,0,.767-0.3,1.044,1.044,0,0,0,.314-0.8,0.84,0.84,0,0,0-.238-0.619,0.8,0.8,0,0,0-.594-0.239,1.154,1.154,0,0,0-.781.3,4.607,4.607,0,0,0-.781,1q-0.091.15-.218,0.346l-0.246.38c-0.068-.288-0.137-0.582-0.212-0.885-0.459-1.847-2.494-.984-2.941-0.8-0.482.2-.353,0.647-0.094,0.529a0.869,0.869,0,0,1,1.281.585c0.217,0.751.377,1.436,0.527,2.038a5.688,5.688,0,0,1-.362.467,2.69,2.69,0,0,1-.264.271q-0.221-.08-0.471-0.147a2.029,2.029,0,0,0-.522-0.066,1.079,1.079,0,0,0-.768.3A1.058,1.058,0,0,0,9,15.131a0.82,0.82,0,0,0,.832.852,1.134,1.134,0,0,0,.787-0.3,5.11,5.11,0,0,0,.776-0.993q0.141-.219.215-0.34c0.046-.076.122-0.194,0.223-0.346a2.786,2.786,0,0,0,.918,1.726,2.582,2.582,0,0,0,2.376-.185c0.317-.181.212-0.565,0-0.494A0.807,0.807,0,0,1,14.176,15a5.159,5.159,0,0,1-.913-2.446l0,0Q13.487,12.24,13.663,12.027Z></path> </svg>';
  }, function(t2, e2) {
    t2.exports = '<svg viewBox="0 0 18 18"> <path class=ql-fill d=M10,4V14a1,1,0,0,1-2,0V10H3v4a1,1,0,0,1-2,0V4A1,1,0,0,1,3,4V8H8V4a1,1,0,0,1,2,0Zm6.06787,9.209H14.98975V7.59863a.54085.54085,0,0,0-.605-.60547h-.62744a1.01119,1.01119,0,0,0-.748.29688L11.645,8.56641a.5435.5435,0,0,0-.022.8584l.28613.30762a.53861.53861,0,0,0,.84717.0332l.09912-.08789a1.2137,1.2137,0,0,0,.2417-.35254h.02246s-.01123.30859-.01123.60547V13.209H12.041a.54085.54085,0,0,0-.605.60547v.43945a.54085.54085,0,0,0,.605.60547h4.02686a.54085.54085,0,0,0,.605-.60547v-.43945A.54085.54085,0,0,0,16.06787,13.209Z /> </svg>';
  }, function(t2, e2) {
    t2.exports = '<svg viewBox="0 0 18 18"> <path class=ql-fill d=M16.73975,13.81445v.43945a.54085.54085,0,0,1-.605.60547H11.855a.58392.58392,0,0,1-.64893-.60547V14.0127c0-2.90527,3.39941-3.42187,3.39941-4.55469a.77675.77675,0,0,0-.84717-.78125,1.17684,1.17684,0,0,0-.83594.38477c-.2749.26367-.561.374-.85791.13184l-.4292-.34082c-.30811-.24219-.38525-.51758-.1543-.81445a2.97155,2.97155,0,0,1,2.45361-1.17676,2.45393,2.45393,0,0,1,2.68408,2.40918c0,2.45312-3.1792,2.92676-3.27832,3.93848h2.79443A.54085.54085,0,0,1,16.73975,13.81445ZM9,3A.99974.99974,0,0,0,8,4V8H3V4A1,1,0,0,0,1,4V14a1,1,0,0,0,2,0V10H8v4a1,1,0,0,0,2,0V4A.99974.99974,0,0,0,9,3Z /> </svg>';
  }, function(t2, e2) {
    t2.exports = '<svg viewbox="0 0 18 18"> <line class=ql-stroke x1=7 x2=13 y1=4 y2=4></line> <line class=ql-stroke x1=5 x2=11 y1=14 y2=14></line> <line class=ql-stroke x1=8 x2=10 y1=14 y2=4></line> </svg>';
  }, function(t2, e2) {
    t2.exports = '<svg viewbox="0 0 18 18"> <rect class=ql-stroke height=10 width=12 x=3 y=4></rect> <circle class=ql-fill cx=6 cy=7 r=1></circle> <polyline class="ql-even ql-fill" points="5 12 5 11 7 9 8 10 11 7 13 9 13 12 5 12"></polyline> </svg>';
  }, function(t2, e2) {
    t2.exports = '<svg viewbox="0 0 18 18"> <line class=ql-stroke x1=3 x2=15 y1=14 y2=14></line> <line class=ql-stroke x1=3 x2=15 y1=4 y2=4></line> <line class=ql-stroke x1=9 x2=15 y1=9 y2=9></line> <polyline class="ql-fill ql-stroke" points="3 7 3 11 5 9 3 7"></polyline> </svg>';
  }, function(t2, e2) {
    t2.exports = '<svg viewbox="0 0 18 18"> <line class=ql-stroke x1=3 x2=15 y1=14 y2=14></line> <line class=ql-stroke x1=3 x2=15 y1=4 y2=4></line> <line class=ql-stroke x1=9 x2=15 y1=9 y2=9></line> <polyline class=ql-stroke points="5 7 5 11 3 9 5 7"></polyline> </svg>';
  }, function(t2, e2) {
    t2.exports = '<svg viewbox="0 0 18 18"> <line class=ql-stroke x1=7 x2=11 y1=7 y2=11></line> <path class="ql-even ql-stroke" d=M8.9,4.577a3.476,3.476,0,0,1,.36,4.679A3.476,3.476,0,0,1,4.577,8.9C3.185,7.5,2.035,6.4,4.217,4.217S7.5,3.185,8.9,4.577Z></path> <path class="ql-even ql-stroke" d=M13.423,9.1a3.476,3.476,0,0,0-4.679-.36,3.476,3.476,0,0,0,.36,4.679c1.392,1.392,2.5,2.542,4.679.36S14.815,10.5,13.423,9.1Z></path> </svg>';
  }, function(t2, e2) {
    t2.exports = '<svg viewbox="0 0 18 18"> <line class=ql-stroke x1=7 x2=15 y1=4 y2=4></line> <line class=ql-stroke x1=7 x2=15 y1=9 y2=9></line> <line class=ql-stroke x1=7 x2=15 y1=14 y2=14></line> <line class="ql-stroke ql-thin" x1=2.5 x2=4.5 y1=5.5 y2=5.5></line> <path class=ql-fill d=M3.5,6A0.5,0.5,0,0,1,3,5.5V3.085l-0.276.138A0.5,0.5,0,0,1,2.053,3c-0.124-.247-0.023-0.324.224-0.447l1-.5A0.5,0.5,0,0,1,4,2.5v3A0.5,0.5,0,0,1,3.5,6Z></path> <path class="ql-stroke ql-thin" d=M4.5,10.5h-2c0-.234,1.85-1.076,1.85-2.234A0.959,0.959,0,0,0,2.5,8.156></path> <path class="ql-stroke ql-thin" d=M2.5,14.846a0.959,0.959,0,0,0,1.85-.109A0.7,0.7,0,0,0,3.75,14a0.688,0.688,0,0,0,.6-0.736,0.959,0.959,0,0,0-1.85-.109></path> </svg>';
  }, function(t2, e2) {
    t2.exports = '<svg viewbox="0 0 18 18"> <line class=ql-stroke x1=6 x2=15 y1=4 y2=4></line> <line class=ql-stroke x1=6 x2=15 y1=9 y2=9></line> <line class=ql-stroke x1=6 x2=15 y1=14 y2=14></line> <line class=ql-stroke x1=3 x2=3 y1=4 y2=4></line> <line class=ql-stroke x1=3 x2=3 y1=9 y2=9></line> <line class=ql-stroke x1=3 x2=3 y1=14 y2=14></line> </svg>';
  }, function(t2, e2) {
    t2.exports = '<svg class="" viewbox="0 0 18 18"> <line class=ql-stroke x1=9 x2=15 y1=4 y2=4></line> <polyline class=ql-stroke points="3 4 4 5 6 3"></polyline> <line class=ql-stroke x1=9 x2=15 y1=14 y2=14></line> <polyline class=ql-stroke points="3 14 4 15 6 13"></polyline> <line class=ql-stroke x1=9 x2=15 y1=9 y2=9></line> <polyline class=ql-stroke points="3 9 4 10 6 8"></polyline> </svg>';
  }, function(t2, e2) {
    t2.exports = '<svg viewbox="0 0 18 18"> <path class=ql-fill d=M15.5,15H13.861a3.858,3.858,0,0,0,1.914-2.975,1.8,1.8,0,0,0-1.6-1.751A1.921,1.921,0,0,0,12.021,11.7a0.50013,0.50013,0,1,0,.957.291h0a0.914,0.914,0,0,1,1.053-.725,0.81,0.81,0,0,1,.744.762c0,1.076-1.16971,1.86982-1.93971,2.43082A1.45639,1.45639,0,0,0,12,15.5a0.5,0.5,0,0,0,.5.5h3A0.5,0.5,0,0,0,15.5,15Z /> <path class=ql-fill d=M9.65,5.241a1,1,0,0,0-1.409.108L6,7.964,3.759,5.349A1,1,0,0,0,2.192,6.59178Q2.21541,6.6213,2.241,6.649L4.684,9.5,2.241,12.35A1,1,0,0,0,3.71,13.70722q0.02557-.02768.049-0.05722L6,11.036,8.241,13.65a1,1,0,1,0,1.567-1.24277Q9.78459,12.3777,9.759,12.35L7.316,9.5,9.759,6.651A1,1,0,0,0,9.65,5.241Z /> </svg>';
  }, function(t2, e2) {
    t2.exports = '<svg viewbox="0 0 18 18"> <path class=ql-fill d=M15.5,7H13.861a4.015,4.015,0,0,0,1.914-2.975,1.8,1.8,0,0,0-1.6-1.751A1.922,1.922,0,0,0,12.021,3.7a0.5,0.5,0,1,0,.957.291,0.917,0.917,0,0,1,1.053-.725,0.81,0.81,0,0,1,.744.762c0,1.077-1.164,1.925-1.934,2.486A1.423,1.423,0,0,0,12,7.5a0.5,0.5,0,0,0,.5.5h3A0.5,0.5,0,0,0,15.5,7Z /> <path class=ql-fill d=M9.651,5.241a1,1,0,0,0-1.41.108L6,7.964,3.759,5.349a1,1,0,1,0-1.519,1.3L4.683,9.5,2.241,12.35a1,1,0,1,0,1.519,1.3L6,11.036,8.241,13.65a1,1,0,0,0,1.519-1.3L7.317,9.5,9.759,6.651A1,1,0,0,0,9.651,5.241Z /> </svg>';
  }, function(t2, e2) {
    t2.exports = '<svg viewbox="0 0 18 18"> <line class="ql-stroke ql-thin" x1=15.5 x2=2.5 y1=8.5 y2=9.5></line> <path class=ql-fill d=M9.007,8C6.542,7.791,6,7.519,6,6.5,6,5.792,7.283,5,9,5c1.571,0,2.765.679,2.969,1.309a1,1,0,0,0,1.9-.617C13.356,4.106,11.354,3,9,3,6.2,3,4,4.538,4,6.5a3.2,3.2,0,0,0,.5,1.843Z></path> <path class=ql-fill d=M8.984,10C11.457,10.208,12,10.479,12,11.5c0,0.708-1.283,1.5-3,1.5-1.571,0-2.765-.679-2.969-1.309a1,1,0,1,0-1.9.617C4.644,13.894,6.646,15,9,15c2.8,0,5-1.538,5-3.5a3.2,3.2,0,0,0-.5-1.843Z></path> </svg>';
  }, function(t2, e2) {
    t2.exports = '<svg viewbox="0 0 18 18"> <path class=ql-stroke d=M5,3V9a4.012,4.012,0,0,0,4,4H9a4.012,4.012,0,0,0,4-4V3></path> <rect class=ql-fill height=1 rx=0.5 ry=0.5 width=12 x=3 y=15></rect> </svg>';
  }, function(t2, e2) {
    t2.exports = '<svg viewbox="0 0 18 18"> <rect class=ql-stroke height=12 width=12 x=3 y=3></rect> <rect class=ql-fill height=12 width=1 x=5 y=3></rect> <rect class=ql-fill height=12 width=1 x=12 y=3></rect> <rect class=ql-fill height=2 width=8 x=5 y=8></rect> <rect class=ql-fill height=1 width=3 x=3 y=5></rect> <rect class=ql-fill height=1 width=3 x=3 y=7></rect> <rect class=ql-fill height=1 width=3 x=3 y=10></rect> <rect class=ql-fill height=1 width=3 x=3 y=12></rect> <rect class=ql-fill height=1 width=3 x=12 y=5></rect> <rect class=ql-fill height=1 width=3 x=12 y=7></rect> <rect class=ql-fill height=1 width=3 x=12 y=10></rect> <rect class=ql-fill height=1 width=3 x=12 y=12></rect> </svg>';
  }, function(t2, e2) {
    t2.exports = '<svg viewbox="0 0 18 18"> <polygon class=ql-stroke points="7 11 9 13 11 11 7 11"></polygon> <polygon class=ql-stroke points="7 7 9 5 11 7 7 7"></polygon> </svg>';
  }, function(t2, e2, n) {
    function r(t3) {
      return t3 && t3.__esModule ? t3 : { default: t3 };
    }
    function o(t3, e3) {
      if (!(t3 instanceof e3)) throw new TypeError("Cannot call a class as a function");
    }
    function i2(t3, e3) {
      if (!t3) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      return !e3 || "object" != typeof e3 && "function" != typeof e3 ? t3 : e3;
    }
    function l(t3, e3) {
      if ("function" != typeof e3 && null !== e3) throw new TypeError("Super expression must either be null or a function, not " + typeof e3);
      t3.prototype = Object.create(e3 && e3.prototype, { constructor: { value: t3, enumerable: false, writable: true, configurable: true } }), e3 && (Object.setPrototypeOf ? Object.setPrototypeOf(t3, e3) : t3.__proto__ = e3);
    }
    Object.defineProperty(e2, "__esModule", { value: true }), e2.default = e2.BubbleTooltip = void 0;
    var a3 = function t3(e3, n2, r2) {
      null === e3 && (e3 = Function.prototype);
      var o2 = Object.getOwnPropertyDescriptor(e3, n2);
      if (void 0 === o2) {
        var i3 = Object.getPrototypeOf(e3);
        return null === i3 ? void 0 : t3(i3, n2, r2);
      }
      if ("value" in o2) return o2.value;
      var l2 = o2.get;
      if (void 0 !== l2) return l2.call(r2);
    }, s3 = /* @__PURE__ */ (function() {
      function t3(t4, e3) {
        for (var n2 = 0; n2 < e3.length; n2++) {
          var r2 = e3[n2];
          r2.enumerable = r2.enumerable || false, r2.configurable = true, "value" in r2 && (r2.writable = true), Object.defineProperty(t4, r2.key, r2);
        }
      }
      return function(e3, n2, r2) {
        return n2 && t3(e3.prototype, n2), r2 && t3(e3, r2), e3;
      };
    })(), u2 = n(2), c2 = r(u2), f = n(9), h3 = r(f), p = n(44), d3 = r(p), y3 = n(22), v = n(26), b2 = r(v), g = [["bold", "italic", "link"], [{ header: 1 }, { header: 2 }, "blockquote"]], m3 = (function(t3) {
      function e3(t4, n2) {
        o(this, e3), null != n2.modules.toolbar && null == n2.modules.toolbar.container && (n2.modules.toolbar.container = g);
        var r2 = i2(this, (e3.__proto__ || Object.getPrototypeOf(e3)).call(this, t4, n2));
        return r2.quill.container.classList.add("ql-bubble"), r2;
      }
      return l(e3, t3), s3(e3, [{ key: "extendToolbar", value: function(t4) {
        this.tooltip = new _(this.quill, this.options.bounds), this.tooltip.root.appendChild(t4.container), this.buildButtons([].slice.call(t4.container.querySelectorAll("button")), b2.default), this.buildPickers([].slice.call(t4.container.querySelectorAll("select")), b2.default);
      } }]), e3;
    })(d3.default);
    m3.DEFAULTS = (0, c2.default)(true, {}, d3.default.DEFAULTS, { modules: { toolbar: { handlers: { link: function(t3) {
      t3 ? this.quill.theme.tooltip.edit() : this.quill.format("link", false);
    } } } } });
    var _ = (function(t3) {
      function e3(t4, n2) {
        o(this, e3);
        var r2 = i2(this, (e3.__proto__ || Object.getPrototypeOf(e3)).call(this, t4, n2));
        return r2.quill.on(h3.default.events.EDITOR_CHANGE, function(t5, e4, n3, o2) {
          if (t5 === h3.default.events.SELECTION_CHANGE) if (null != e4 && e4.length > 0 && o2 === h3.default.sources.USER) {
            r2.show(), r2.root.style.left = "0px", r2.root.style.width = "", r2.root.style.width = r2.root.offsetWidth + "px";
            var i3 = r2.quill.getLines(e4.index, e4.length);
            if (1 === i3.length) r2.position(r2.quill.getBounds(e4));
            else {
              var l2 = i3[i3.length - 1], a4 = r2.quill.getIndex(l2), s4 = Math.min(l2.length() - 1, e4.index + e4.length - a4), u3 = r2.quill.getBounds(new y3.Range(a4, s4));
              r2.position(u3);
            }
          } else document.activeElement !== r2.textbox && r2.quill.hasFocus() && r2.hide();
        }), r2;
      }
      return l(e3, t3), s3(e3, [{ key: "listen", value: function() {
        var t4 = this;
        a3(e3.prototype.__proto__ || Object.getPrototypeOf(e3.prototype), "listen", this).call(this), this.root.querySelector(".ql-close").addEventListener("click", function() {
          t4.root.classList.remove("ql-editing");
        }), this.quill.on(h3.default.events.SCROLL_OPTIMIZE, function() {
          setTimeout(function() {
            if (!t4.root.classList.contains("ql-hidden")) {
              var e4 = t4.quill.getSelection();
              null != e4 && t4.position(t4.quill.getBounds(e4));
            }
          }, 1);
        });
      } }, { key: "cancel", value: function() {
        this.show();
      } }, { key: "position", value: function(t4) {
        var n2 = a3(e3.prototype.__proto__ || Object.getPrototypeOf(e3.prototype), "position", this).call(this, t4), r2 = this.root.querySelector(".ql-tooltip-arrow");
        if (r2.style.marginLeft = "", 0 === n2) return n2;
        r2.style.marginLeft = -1 * n2 - r2.offsetWidth / 2 + "px";
      } }]), e3;
    })(p.BaseTooltip);
    _.TEMPLATE = ['<span class="ql-tooltip-arrow"></span>', '<div class="ql-tooltip-editor">', '<input type="text" data-formula="e=mc^2" data-link="https://quilljs.com" data-video="Embed URL">', '<a class="ql-close"></a>', "</div>"].join(""), e2.BubbleTooltip = _, e2.default = m3;
  }, function(t2, e2, n) {
    function r(t3) {
      return t3 && t3.__esModule ? t3 : { default: t3 };
    }
    function o(t3, e3) {
      if (!(t3 instanceof e3)) throw new TypeError("Cannot call a class as a function");
    }
    function i2(t3, e3) {
      if (!t3) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      return !e3 || "object" != typeof e3 && "function" != typeof e3 ? t3 : e3;
    }
    function l(t3, e3) {
      if ("function" != typeof e3 && null !== e3) throw new TypeError("Super expression must either be null or a function, not " + typeof e3);
      t3.prototype = Object.create(e3 && e3.prototype, { constructor: { value: t3, enumerable: false, writable: true, configurable: true } }), e3 && (Object.setPrototypeOf ? Object.setPrototypeOf(t3, e3) : t3.__proto__ = e3);
    }
    Object.defineProperty(e2, "__esModule", { value: true });
    var a3 = /* @__PURE__ */ (function() {
      function t3(t4, e3) {
        var n2 = [], r2 = true, o2 = false, i3 = void 0;
        try {
          for (var l2, a4 = t4[Symbol.iterator](); !(r2 = (l2 = a4.next()).done) && (n2.push(l2.value), !e3 || n2.length !== e3); r2 = true) ;
        } catch (t5) {
          o2 = true, i3 = t5;
        } finally {
          try {
            !r2 && a4.return && a4.return();
          } finally {
            if (o2) throw i3;
          }
        }
        return n2;
      }
      return function(e3, n2) {
        if (Array.isArray(e3)) return e3;
        if (Symbol.iterator in Object(e3)) return t3(e3, n2);
        throw new TypeError("Invalid attempt to destructure non-iterable instance");
      };
    })(), s3 = function t3(e3, n2, r2) {
      null === e3 && (e3 = Function.prototype);
      var o2 = Object.getOwnPropertyDescriptor(e3, n2);
      if (void 0 === o2) {
        var i3 = Object.getPrototypeOf(e3);
        return null === i3 ? void 0 : t3(i3, n2, r2);
      }
      if ("value" in o2) return o2.value;
      var l2 = o2.get;
      if (void 0 !== l2) return l2.call(r2);
    }, u2 = /* @__PURE__ */ (function() {
      function t3(t4, e3) {
        for (var n2 = 0; n2 < e3.length; n2++) {
          var r2 = e3[n2];
          r2.enumerable = r2.enumerable || false, r2.configurable = true, "value" in r2 && (r2.writable = true), Object.defineProperty(t4, r2.key, r2);
        }
      }
      return function(e3, n2, r2) {
        return n2 && t3(e3.prototype, n2), r2 && t3(e3, r2), e3;
      };
    })(), c2 = n(2), f = r(c2), h3 = n(9), p = r(h3), d3 = n(44), y3 = r(d3), v = n(15), b2 = r(v), g = n(22), m3 = n(26), _ = r(m3), O2 = [[{ header: ["1", "2", "3", false] }], ["bold", "italic", "underline", "link"], [{ list: "ordered" }, { list: "bullet" }], ["clean"]], w2 = (function(t3) {
      function e3(t4, n2) {
        o(this, e3), null != n2.modules.toolbar && null == n2.modules.toolbar.container && (n2.modules.toolbar.container = O2);
        var r2 = i2(this, (e3.__proto__ || Object.getPrototypeOf(e3)).call(this, t4, n2));
        return r2.quill.container.classList.add("ql-snow"), r2;
      }
      return l(e3, t3), u2(e3, [{ key: "extendToolbar", value: function(t4) {
        t4.container.classList.add("ql-snow"), this.buildButtons([].slice.call(t4.container.querySelectorAll("button")), _.default), this.buildPickers([].slice.call(t4.container.querySelectorAll("select")), _.default), this.tooltip = new x2(this.quill, this.options.bounds), t4.container.querySelector(".ql-link") && this.quill.keyboard.addBinding({ key: "K", shortKey: true }, function(e4, n2) {
          t4.handlers.link.call(t4, !n2.format.link);
        });
      } }]), e3;
    })(y3.default);
    w2.DEFAULTS = (0, f.default)(true, {}, y3.default.DEFAULTS, { modules: { toolbar: { handlers: { link: function(t3) {
      if (t3) {
        var e3 = this.quill.getSelection();
        if (null == e3 || 0 == e3.length) return;
        var n2 = this.quill.getText(e3);
        /^\S+@\S+\.\S+$/.test(n2) && 0 !== n2.indexOf("mailto:") && (n2 = "mailto:" + n2);
        this.quill.theme.tooltip.edit("link", n2);
      } else this.quill.format("link", false);
    } } } } });
    var x2 = (function(t3) {
      function e3(t4, n2) {
        o(this, e3);
        var r2 = i2(this, (e3.__proto__ || Object.getPrototypeOf(e3)).call(this, t4, n2));
        return r2.preview = r2.root.querySelector("a.ql-preview"), r2;
      }
      return l(e3, t3), u2(e3, [{ key: "listen", value: function() {
        var t4 = this;
        s3(e3.prototype.__proto__ || Object.getPrototypeOf(e3.prototype), "listen", this).call(this), this.root.querySelector("a.ql-action").addEventListener("click", function(e4) {
          t4.root.classList.contains("ql-editing") ? t4.save() : t4.edit("link", t4.preview.textContent), e4.preventDefault();
        }), this.root.querySelector("a.ql-remove").addEventListener("click", function(e4) {
          if (null != t4.linkRange) {
            var n2 = t4.linkRange;
            t4.restoreFocus(), t4.quill.formatText(n2, "link", false, p.default.sources.USER), delete t4.linkRange;
          }
          e4.preventDefault(), t4.hide();
        }), this.quill.on(p.default.events.SELECTION_CHANGE, function(e4, n2, r2) {
          if (null != e4) {
            if (0 === e4.length && r2 === p.default.sources.USER) {
              var o2 = t4.quill.scroll.descendant(b2.default, e4.index), i3 = a3(o2, 2), l2 = i3[0], s4 = i3[1];
              if (null != l2) {
                t4.linkRange = new g.Range(e4.index - s4, l2.length());
                var u3 = b2.default.formats(l2.domNode);
                return t4.preview.textContent = u3, t4.preview.setAttribute("href", u3), t4.show(), void t4.position(t4.quill.getBounds(t4.linkRange));
              }
            } else delete t4.linkRange;
            t4.hide();
          }
        });
      } }, { key: "show", value: function() {
        s3(e3.prototype.__proto__ || Object.getPrototypeOf(e3.prototype), "show", this).call(this), this.root.removeAttribute("data-mode");
      } }]), e3;
    })(d3.BaseTooltip);
    x2.TEMPLATE = ['<a class="ql-preview" rel="noopener noreferrer" target="_blank" href="about:blank"></a>', '<input type="text" data-formula="e=mc^2" data-link="https://quilljs.com" data-video="Embed URL">', '<a class="ql-action"></a>', '<a class="ql-remove"></a>'].join(""), e2.default = w2;
  }]).default;
});
const jmixRichTextEditorStyles = css`
    :host {
        display: flex;
        box-sizing: content-box;

        min-height: calc(var(--lumo-size-m) * 8);
        --_focus-ring-color: var(--vaadin-focus-ring-color, var(--lumo-primary-color-50pct));
        --_focus-ring-width: var(--vaadin-focus-ring-width, 2px);

        font-family: var(--lumo-font-family);
        font-size: var(--lumo-font-size-m);
        line-height: var(--lumo-line-height-m);
        -webkit-text-size-adjust: 100%;
        -webkit-font-smoothing: antialiased;
        -moz-osx-font-smoothing: grayscale;
        
        padding: var(--lumo-space-xs) 0;
    }

    :host([hidden]) {
        display: none !important;
    }

    :host([disabled]) {
        pointer-events: none;
        opacity: 0.5;
        -webkit-user-select: none;
        -moz-user-select: none;
        user-select: none;
    }

    :host(:not([has-label])) [part='label'] {
        display: none;
    }

    :host([disabled]) [part='label'] {
        color: var(--lumo-disabled-text-color);
        -webkit-text-fill-color: var(--lumo-disabled-text-color);
    }

    .jmix-rich-text-editor-wrapper {
        display: flex;
        flex-direction: column;
        min-height: 100%;
        max-height: 100%;
        flex: auto;
    }

    [part="editor"] {
        display: flex;
        flex-direction: column;
        flex: auto;
        height: 100%;
        overflow-y: auto;
    }

    :host(:not([theme~='no-border'])) [part="editor"] {
        border: 1px solid var(--lumo-contrast-20pct);
        border-radius: var(--lumo-border-radius-m);
    }
    
    /**
     * Label styles
     * 
     * Can be replaced with packages/vaadin-lumo-styles/mixins/required-field.js import
     * after other required-field functionality is added 
     */

    [part='label'] {
        align-self: flex-start;
        color: var(--vaadin-input-field-label-color, var(--lumo-secondary-text-color));
        font-weight: var(--vaadin-input-field-label-font-weight, 500);
        font-size: var(--vaadin-input-field-label-font-size, var(--lumo-font-size-s));
        margin-left: calc(var(--lumo-border-radius-m) / 4);
        transition: color 0.2s;
        line-height: 1;
        padding-right: 1em;
        padding-bottom: 0.5em;
        /* As a workaround for diacritics being cut off, add a top padding and a
        negative margin to compensate */
        padding-top: 0.25em;
        margin-top: -0.25em;
        overflow: hidden;
        white-space: nowrap;
        text-overflow: ellipsis;
        position: relative;
        max-width: 100%;
        box-sizing: border-box;
    }

    :host([focused]:not([readonly])) [part='label'] {
        color: var(--vaadin-input-field-focused-label-color, var(--lumo-primary-text-color));
    }

    :host(:hover:not([readonly]):not([focused])) [part='label'] {
        color: var(--vaadin-input-field-hovered-label-color, var(--lumo-body-text-color));
    }

    /* Touch device adjustment */
    @media (pointer: coarse) {
        :host(:hover:not([readonly]):not([focused])) [part='label'] {
            color: var(--vaadin-input-field-label-color, var(--lumo-secondary-text-color));
        }
    }

    :host([has-label]) {
        padding-top: var(--lumo-space-m);
    }

    /* RTL specific styles */

    :host([dir='rtl']) [part='label'] {
        margin-left: 0;
        margin-right: calc(var(--lumo-border-radius-m) / 4);
    }

    :host([dir='rtl']) [part='label'] {
        padding-left: 1em;
        padding-right: 0;
    }
`;
const Quill = window.Quill;
const Inline = Quill.import("blots/inline");
class CustomColor extends Inline {
  constructor(domNode, value) {
    super(domNode, value);
    domNode.style.color = domNode.color;
    const span = this.replaceWith(new Inline(Inline.create()));
    span.children.forEach((child) => {
      if (child.attributes) child.attributes.copy(span);
      if (child.unwrap) child.unwrap();
    });
    this.remove();
    return span;
  }
}
CustomColor.blotName = "customColor";
CustomColor.tagName = "FONT";
Quill.register(CustomColor, true);
const SOURCE = {
  API: "api",
  USER: "user",
  SILENT: "silent"
};
const STATE = {
  DEFAULT: 0,
  CLICKED: 1
};
const HANDLERS = [
  "bold",
  "italic",
  "underline",
  "strike",
  "header",
  /* 1, 2, 3 */
  "script",
  /* sub, super */
  "list",
  /* ordered, bullet */
  "align",
  /* default, center, justify */
  "blockquote",
  "code-block"
];
registerStyles$1("jmix-rich-text-editor", [jmixRichTextEditorStyles, helper], { moduleId: "jmix-rich-text-editor-styles" });
class RichTextEditor extends ElementMixin(FocusMixin(LabelMixin(ThemableMixin(PolymerElement)))) {
  static get is() {
    return "jmix-rich-text-editor";
  }
  static get template() {
    return html`
            <div class="jmix-rich-text-editor-wrapper">
                <div part="label">
                    <slot name="label"></slot>
                    <span part="required-indicator" aria-hidden="true"></span>
                </div>

                <div part="editor">
                    <slot name="editor"></slot>
                </div>

                <div part="helper-text">
                    <slot name="helper"></slot>
                </div>

                <div part="error-message">
                    <slot name="error-message"></slot>
                </div>
            </div>
        `;
  }
  /** @private */
  _layout() {
    const container = document.createElement("div");
    container.className = "jmix-rich-text-editor-container";
    container.innerHTML = `
                <div class="jmix-rich-text-editor-toolbar">
                    <span class="toolbar-group toolbar-group-emphasis">
                        <!-- Bold -->
                        <button class="toolbar-button toolbar-button-bold ql-bold"
                                i18n="bold">
                        </button>
    
                        <!-- Italic -->
                        <button class="toolbar-button toolbar-button-italic ql-italic"
                                i18n="italic">
                        </button>
    
                        <!-- Underline -->
                        <button class="toolbar-button toolbar-button-underline ql-underline"
                                i18n="underline">
                        </button>
    
                        <!-- Strike -->
                        <button class="toolbar-button toolbar-button-strike ql-strike"
                                i18n="strike">
                        </button>
                    </span>
                    
                    <span class="toolbar-group toolbar-group-heading">
                        <!-- Header 1 -->
                        <button class="toolbar-button toolbar-button-h1 ql-header" value="1" 
                                i18n="h1">
                        </button>
                        
                        <!-- Header 2 -->
                        <button class="toolbar-button toolbar-button-h2 ql-header" value="2"
                                i18n="h2">
                        </button>
                        
                        <!-- Header 3 -->
                        <button class="toolbar-button toolbar-button-h3 ql-header" value="3"
                                i18n="h3">
                        </button>
                    </span>
                    
                    <span class="toolbar-group toolbar-group-glyph-transformation">
                        <!-- Subscript -->
                        <button class="toolbar-button toolbar-button-subscript ql-script" value="sub"
                                i18n="subscript">
                        </button>
                        
                        <!-- Superscript -->
                        <button class="toolbar-button toolbar-button-superscript ql-script" value="super"
                                i18n="superscript">
                        </button>
                    </span>
                    
                    <span class="toolbar-group toolbar-group-list">
                        <!-- Ordered list -->
                        <button class="toolbar-button toolbar-button-list-ordered ql-list" value="ordered"
                                i18n="listOrdered">
                        </button>
                        
                        <!-- Unordered list -->
                        <button class="toolbar-button toolbar-button-list-bullet ql-list" value="bullet"
                                i18n="listBullet">
                        </button>
                    </span>
                    
                    <span class="toolbar-group toolbar-group-alignment">
                        <!-- Align start (left for ltr and right for rtl) -->
                        <button class="toolbar-button toolbar-button-align-start ql-align" value="" 
                                i18n="alignStart">
                        </button>
                        
                        <!-- Align center -->
                        <button class="toolbar-button toolbar-button-align-center ql-align" value="center"
                                i18n="alignCenter">
                        </button>
                        
                        <!-- Align end (right for ltr and left for rtl) -->
                        <button class="toolbar-button toolbar-button-align-end ql-align" value="right"
                                i18n="alignEnd">
                        </button>
                        
                        <!-- Align justify -->
                        <button class="toolbar-button toolbar-button-align-justify ql-align" value="justify"
                                i18n="alignJustify">
                        </button>
                    </span>
                    
                    <span class="toolbar-group toolbar-group-rich-text">
                        <!-- Image -->
                        <button class="toolbar-button toolbar-button-image"
                                i18n="image">
                        </button>
                        
                        <!-- Link -->
                        <button class="toolbar-button toolbar-button-link ql-link"
                                i18n="link">
                        </button>
                    </span>
                    
                    <span class="toolbar-group toolbar-group-block">
                        <!-- Blockquote -->
                        <button class="toolbar-button toolbar-button-blockquote ql-blockquote"
                                i18n="blockquote">
                        </button>
                        
                        <!-- Code block -->
                        <button class="toolbar-button toolbar-button-code-block ql-code-block"
                                i18n="codeBlock">
                        </button>
                    </span>
                    
                    <span class="toolbar-group toolbar-group-format">
                        <!-- Clean -->
                        <button class="toolbar-button toolbar-button-clean ql-clean"
                                i18n="clean">
                        </button>
                    </span>
                    
                    <input type="file"
                        class="jmix-rich-text-editor-file-input"
                        accept="image/png, image/gif, image/jpeg, image/bmp, image/x-icon"/>
                </div>
                
                <div class="jmix-rich-text-editor-content"></div>
        `;
    return container;
  }
  static get properties() {
    return {
      /**
       * Value is a list of the operations which describe change to the document.
       * Each of those operations describe the change at the current index.
       * They can be an `insert`, `delete` or `retain`. The format is as follows:
       *
       * ```js
       *  [
       *    { insert: 'Hello World' },
       *    { insert: '!', attributes: { bold: true }}
       *  ]
       * ```
       *
       * See also https://github.com/quilljs/delta for detailed documentation.
       * @type {string}
       */
      value: {
        type: String,
        notify: true,
        value: "",
        sync: true
      },
      /**
       * HTML representation of the rich text editor content.
       */
      htmlValue: {
        type: String,
        notify: true,
        readOnly: true
      },
      /**
       * When true, the user can not modify, nor copy the editor content.
       * @type {boolean}
       */
      disabled: {
        type: Boolean,
        value: false,
        reflectToAttribute: true
      },
      /**
       * When true, the user can not modify the editor content, but can copy it.
       * @type {boolean}
       */
      readonly: {
        type: Boolean,
        value: false,
        reflectToAttribute: true
      },
      /**
       * String used for the helper text.
       * @attr {string} helper-text
       */
      helperText: {
        type: String,
        observer: "_helperTextChanged"
      },
      /**
       * An object used to localize this component. The properties are used
       * e.g. as the tooltips for the editor toolbar buttons.
       *
       * @default {English/US}
       */
      i18n: {
        type: Object,
        value: () => {
          return {
            bold: "bold",
            italic: "italic",
            underline: "underline",
            strike: "strike",
            h1: "h1",
            h2: "h2",
            h3: "h3",
            subscript: "subscript",
            superscript: "superscript",
            listOrdered: "list ordered",
            listBullet: "list bullet",
            alignStart: "align start",
            alignCenter: "align center",
            alignEnd: "align end",
            alignJustify: "align justify",
            image: "image",
            link: "link",
            blockquote: "blockquote",
            codeBlock: "code block",
            clean: "clean"
          };
        }
      },
      /** @private */
      _editor: {
        type: Object,
        sync: true
      },
      /**
       * Stores old value
       * @private
       */
      __oldValue: String,
      /** @private */
      __lastCommittedChange: {
        type: String,
        value: ""
      }
    };
  }
  static get observers() {
    return [
      "_valueChanged(value, _editor)",
      "_disabledChanged(disabled, readonly, _editor)"
    ];
  }
  /** @protected */
  async connectedCallback() {
    super.connectedCallback();
    if (!this.$ && this.updateComplete) {
      await this.updateComplete;
    }
    this.__flushPendingHtmlValue();
  }
  /** @private */
  __flushPendingHtmlValue() {
    if (this.__pendingHtmlValue) {
      this.setHtmlValueInternal(this.__pendingHtmlValue);
    }
  }
  constructor() {
    super();
    this._helperController = new HelperController(this);
    this._helperController.addEventListener("slot-content-changed", (event) => {
      const { hasContent, node } = event.detail;
      this.toggleAttribute("has-helper", hasContent);
    });
  }
  /** @protected */
  ready() {
    super.ready();
    const layout = this._layout();
    layout.setAttribute("slot", "editor");
    this.appendChild(layout);
    const editor = this.querySelector(".jmix-rich-text-editor-content");
    const toolbar = this.querySelector(".jmix-rich-text-editor-toolbar");
    const toolbarConfig = this._prepareToolbar(toolbar);
    this._editor = new Quill(editor, {
      modules: {
        toolbar: toolbarConfig
      }
    });
    const qlEditor = editor.querySelector(".ql-editor");
    qlEditor.setAttribute("role", "textbox");
    qlEditor.setAttribute("aria-multiline", "true");
    this._editor.on("text-change", () => {
      const timeout = 200;
      this.__debounceSetValue = Debouncer$1.debounce(this.__debounceSetValue, timeOut$1.after(timeout), () => {
        this.value = JSON.stringify(this._editor.getContents().ops);
      });
    });
    qlEditor.addEventListener("focusout", () => {
      if (this._toolbarState !== STATE.DEFAULT) {
        this._cleanToolbarState();
      } else {
        this.__emitChangeEvent();
      }
    });
    qlEditor.addEventListener("focus", () => {
      if (this._toolbarState !== STATE.CLICKED) {
        this._cleanToolbarState();
      }
    });
    this.applyLocalization();
  }
  /** @private */
  _prepareToolbar(toolbar) {
    const imageBtn = toolbar.querySelector(".toolbar-button-image");
    imageBtn.onclick = () => {
      this._onImageClick();
    };
    imageBtn.ontouchend = (event) => {
      this._onImageTouchEnd(event);
    };
    const fileInput = toolbar.querySelector(".jmix-rich-text-editor-file-input");
    fileInput.onchange = (event) => {
      this._uploadImage(event);
    };
    const clean = Quill.imports["modules/toolbar"].DEFAULTS.handlers.clean;
    const self2 = this;
    const toolbarConfig = {
      container: toolbar,
      handlers: {
        clean() {
          self2._markToolbarClicked();
          clean.call(this);
        }
      }
    };
    HANDLERS.forEach((handler) => {
      toolbarConfig.handlers[handler] = (value) => {
        self2._markToolbarClicked();
        self2._editor.format(handler, value, SOURCE.USER);
      };
    });
    return toolbarConfig;
  }
  /**
   * Sets content represented by HTML snippet into the editor.
   * The snippet is interpreted by [Quill's Clipboard matchers](https://quilljs.com/docs/modules/clipboard/#matchers),
   * which may not produce the exactly input HTML.
   *
   * **NOTE:** Improper handling of HTML can lead to cross site scripting (XSS) and failure to sanitize
   * properly is both notoriously error-prone and a leading cause of web vulnerabilities.
   * This method is aptly named to ensure the developer has taken the necessary precautions.
   * @param {string} htmlValue
   */
  setHtmlValueInternal(htmlValue2) {
    if (!this._editor) {
      this.__pendingHtmlValue = htmlValue2;
      this.value = "";
      return;
    }
    const whitespaceCharacters = {
      "	": "__RICH_TEXT_EDITOR_TAB",
      "  ": "__RICH_TEXT_EDITOR_DOUBLE_SPACE"
    };
    Object.entries(whitespaceCharacters).forEach(([character, replacement]) => {
      htmlValue2 = htmlValue2.replaceAll(/>[^<]*</gu, (match2) => match2.replaceAll(character, replacement));
    });
    const deltaFromHtml = this._editor.clipboard.convert(htmlValue2);
    Object.entries(whitespaceCharacters).forEach(([character, replacement]) => {
      deltaFromHtml.ops.forEach((op) => {
        if (typeof op.insert === "string") {
          op.insert = op.insert.replaceAll(replacement, character);
        }
      });
    });
    this._editor.setContents(deltaFromHtml, SOURCE.API);
  }
  /** @private */
  _valueChanged(value, editor) {
    if (value && this.__pendingHtmlValue) {
      this.__pendingHtmlValue = void 0;
    }
    if (editor === void 0) {
      return;
    }
    if (value == null || value === '[{"insert":"\\n"}]') {
      this.value = "";
      return;
    }
    if (value === "") {
      this._clear();
      return;
    }
    let parsedValue;
    try {
      parsedValue = JSON.parse(value);
      if (Array.isArray(parsedValue)) {
        this.__oldValue = value;
      } else {
        throw new Error(`expected JSON string with array of objects, got: ${value}`);
      }
    } catch (err) {
      this.value = this.__oldValue;
      console.error("Invalid value set to rich-text-editor:", err);
      return;
    }
    const delta = new Quill.imports.delta(parsedValue);
    if (JSON.stringify(editor.getContents()) !== JSON.stringify(delta)) {
      editor.setContents(delta, SOURCE.SILENT);
    }
    this.__updateHtmlValue();
    if (this._toolbarState === STATE.CLICKED) {
      this._cleanToolbarState();
      this.__emitChangeEvent();
    } else if (!this._editor.hasFocus()) {
      this.__lastCommittedChange = this.value;
    }
  }
  /** @private */
  _disabledChanged(disabled, readonly, editor) {
    if (disabled === void 0 || readonly === void 0 || editor === void 0) {
      return;
    }
    if (disabled || readonly) {
      editor.enable(false);
      if (disabled) {
        this._toggleToolbarDisabled(true);
      }
    } else {
      editor.enable();
      if (this.__oldDisabled) {
        this._toggleToolbarDisabled(false);
      }
    }
    this.__oldDisabled = disabled;
  }
  /**
   * @param {string} helperText
   * @private
   */
  _helperTextChanged(helperText) {
    this._helperController.setHelperText(helperText);
  }
  applyLocalization() {
    const buttons = this._toolbarButtons;
    buttons.forEach((btn) => {
      const i18nKey = btn.getAttribute("i18n");
      const value = this.i18n[i18nKey];
      if (value) {
        btn.setAttribute("title", value);
      } else {
        btn.removeAttribute("title");
      }
    });
  }
  /** @private */
  _toggleToolbarDisabled(disable) {
    const buttons = this._toolbarButtons;
    if (disable) {
      buttons.forEach((btn) => btn.setAttribute("disabled", "true"));
    } else {
      buttons.forEach((btn) => btn.removeAttribute("disabled"));
    }
  }
  /** @private */
  get _toolbarButtons() {
    return this.querySelectorAll(".jmix-rich-text-editor-toolbar button");
  }
  /** @private */
  __emitChangeEvent() {
    let lastCommittedChange = this.__lastCommittedChange;
    if (this.__debounceSetValue && this.__debounceSetValue.isActive()) {
      lastCommittedChange = this.value;
      this.__debounceSetValue.flush();
    }
    if (lastCommittedChange !== this.value) {
      this.dispatchEvent(new CustomEvent("change", { bubbles: true, cancelable: false }));
      this.__lastCommittedChange = this.value;
    }
  }
  /** @private */
  _clear() {
    this._editor.deleteText(0, this._editor.getLength(), SOURCE.SILENT);
    this.__updateHtmlValue();
  }
  /** @private */
  __updateHtmlValue() {
    const editor = this._editor.container.querySelector(".ql-editor");
    let content = editor.innerHTML;
    content = content.replace(/\s*ql-(?!align)[\w-]*\s*/gu, "");
    content = content.replace(/<\/?span[^>]*>/gu, "");
    [this.__dir === "rtl" ? "left" : "right", "center", "justify"].forEach((align) => {
      content = content.replace(
        new RegExp(` class=[\\\\]?"\\s?ql-align-${align}[\\\\]?"`, "gu"),
        ` style="text-align: ${align}"`
      );
    });
    content = content.replace(/ class=""/gu, "");
    this._setHtmlValue(content);
  }
  /** @private */
  _onImageTouchEnd(event) {
    event.preventDefault();
    this._onImageClick();
  }
  /** @private */
  _onImageClick() {
    const fileInput = this.querySelector(".jmix-rich-text-editor-file-input");
    fileInput.value = "";
    fileInput.click();
  }
  /** @private */
  _uploadImage(e2) {
    const fileInput = e2.target;
    if (fileInput.files != null && fileInput.files[0] != null) {
      const reader = new FileReader();
      reader.onload = (e3) => {
        const image = e3.target.result;
        const range = this._editor.getSelection(true);
        this._editor.updateContents(
          new Quill.imports.delta().retain(range.index).delete(range.length).insert({ image }),
          SOURCE.USER
        );
        this._markToolbarClicked();
        this._editor.setSelection(range.index + 1, SOURCE.SILENT);
        fileInput.value = "";
      };
      reader.readAsDataURL(fileInput.files[0]);
    }
  }
  /** @private */
  _markToolbarClicked() {
    this._toolbarState = STATE.CLICKED;
  }
  /** @private */
  _cleanToolbarState() {
    this._toolbarState = STATE.DEFAULT;
  }
}
defineCustomElement(RichTextEditor);
const tabsheet = css`
  :host {
    font-size: var(--lumo-font-size-m);
    line-height: var(--lumo-line-height-m);
    font-family: var(--lumo-font-family);
  }

  :host([theme~='bordered']) {
    border: 1px solid var(--lumo-contrast-20pct);
    border-radius: var(--lumo-border-radius-l);
  }

  [part='tabs-container'] {
    box-shadow: inset 0 -1px 0 0 var(--lumo-contrast-10pct);
    padding: var(--lumo-space-xs) var(--lumo-space-s);
    gap: var(--lumo-space-s);
  }

  ::slotted([slot='tabs']) {
    box-shadow: initial;
    margin: calc(var(--lumo-space-xs) * -1) calc(var(--lumo-space-s) * -1);
  }

  [part='content'] {
    padding: var(--lumo-space-s) var(--lumo-space-m);
    border-bottom-left-radius: inherit;
    border-bottom-right-radius: inherit;
  }

  :host([loading]) [part='content'] {
    display: flex;
    align-items: center;
    justify-content: center;
  }

  :host([theme~='no-padding']) [part='content'] {
    padding: 0;
  }
`;
registerStyles$1("jmix-tabsheet", [tabsheet, loader], {
  moduleId: "lumo-tabsheet-styles"
});
/**
 * @license
 * Copyright (c) 2022 Vaadin Ltd.
 * This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
 */
class JmixTabSheet extends TabSheetMixin(ThemableMixin(ElementMixin(ControllerMixin(PolymerElement)))) {
  static get template() {
    return html`
            <style>
                :host([hidden]) {
                    display: none !important;
                }

                :host {
                    display: flex;
                    flex-direction: column;
                }

                [part='tabs-container'] {
                    position: relative;
                    display: flex;
                    align-items: center;
                }

                ::slotted([slot='tabs']) {
                    flex: 1;
                    align-self: stretch;
                    min-width: 8em;
                }

                [part='content'] {
                    position: relative;
                    flex: 1;
                    box-sizing: border-box;
                }
            </style>

            <div part="tabs-container">
                <slot name="prefix"></slot>
                <slot name="tabs"></slot>
                <slot name="suffix"></slot>
            </div>

            <vaadin-tabsheet-scroller part="content">
                <div part="loader"></div>
                <slot id="panel-slot"></slot>
            </vaadin-tabsheet-scroller>
        `;
  }
  static get is() {
    return "jmix-tabsheet";
  }
}
defineCustomElement(JmixTabSheet);
const jmixTwinColumnStyles = css`
    .jmix-twin-column-container {
        display: flex;
        flex-direction: column;
        width: 100%;
        height: 100%;
    }

    .jmix-twin-column-input-container {
        height: 100%;
        overflow-y: auto;
        overflow-x: auto;
        display: grid;
        grid-template-columns: 1fr 0fr 1fr;
        grid-template-rows: 0fr 1fr;
    }

    :host([has-width]) .jmix-twin-column-input-container {
        width: 100%;
    }

    ::slotted([slot="items-label"]) {
        grid-row: 1;
        grid-column: 1;
    }

    ::slotted([slot="selected-items-label"]) {
        grid-row: 1;
        grid-column: 3;
    }

    ::slotted([slot="items"]) {
        grid-row: 2;
        grid-column: 1;
        overflow-y: auto;
    }

    ::slotted([slot="actions"]) {
        grid-row: 2;
        grid-column: 2;
    }

    ::slotted([slot="selected-items"]) {
        grid-row: 2;
        grid-column: 3;
        overflow-y: auto;
    }

    :host(:not([has-label])) [part='label'] {
        display: none;
    }

    :host(:not([has-width])) ::slotted([slot="items"]),
    :host(:not([has-width])) ::slotted([slot="selected-items"]) {
        min-width: var(--jmix-twin-column-column-min-width, 15em);
        width: var(--jmix-twin-column-column-width, 15em);
        max-width: var(--jmix-twin-column-column-max-width, 15em);
    }

    :host(:not([has-height])) ::slotted([slot="items"]),
    :host(:not([has-height])) ::slotted([slot="selected-items"]) {
        min-height: var(--jmix-twin-column-column-min-height, 20em);
        height: var(--jmix-twin-column-column-height, 20em);
        max-height: var(--jmix-twin-column-column-max-height, 20em);
    }

    :host(:not([has-width])) ::slotted([slot="items-label"]),
    :host(:not([has-width])) ::slotted([slot="selected-items-label"]) {
        min-width: var(--jmix-twin-column-column-min-width, 15em);
        width: var(--jmix-twin-column-column-width, 15em);
        max-width: var(--jmix-twin-column-column-max-width, 15em);
    }

    :host(:not([has-height])) ::slotted([slot="actions"]) {
        min-height: var(--jmix-twin-column-column-min-height, 20em);
        height: var(--jmix-twin-column-column-height, 20em);
        max-height: var(--jmix-twin-column-column-max-height, 20em);
    }
`;
registerStyles$1("jmix-twin-column", [inputFieldShared$1, jmixTwinColumnStyles], { moduleId: "jmix-twin-column-styles" });
class JmixTwinColumn extends InputFieldMixin(ThemableMixin(ElementMixin(PolymerElement))) {
  static get is() {
    return "jmix-twin-column";
  }
  static get template() {
    return html`
        <vaadin-vertical-layout class="jmix-twin-column-container">
            <div part="label" on-click="focus">
              <slot name="label"></slot>
              <span part="required-indicator" aria-hidden="true"></span>
            </div>

            <div class="jmix-twin-column-input-container">
                <slot name="items-label"></slot>
                <slot name="selected-items-label"></slot>
                <slot name="items"></slot>
                <slot name="actions"></slot>
                <slot name="selected-items"></slot>
            </div>

            <div part="helper-text">
              <slot name="helper"></slot>
            </div>

            <div part="error-message">
              <slot name="error-message"></slot>
            </div>
        </vaadin-vertical-layout>

        <slot name="tooltip"></slot>
        `;
  }
  /** @protected */
  ready() {
    super.ready();
    let components = [
      this.getElementsByClassName("jmix-twin-column-actions-panel")[0],
      this.getElementsByClassName("jmix-twin-column-items-column")[0],
      this.getElementsByClassName("jmix-twin-column-selected-items-column")[0]
    ];
    (function(twinColumn) {
      for (let component of components) {
        component.addEventListener("focusin", () => {
          twinColumn._setFocused(true);
        });
        component.addEventListener("focusout", () => {
          twinColumn._setFocused(false);
        });
      }
    })(this);
  }
}
defineCustomElement(JmixTwinColumn);
const uploadField$1 = css`
  :host(:hover:not([readonly]):not([focused])) [part='input-field']::after {
    opacity: 0;
  }
  
  ::slotted(:not([slot$='fix'])) {
    padding: 0;
    --_lumo-text-field-overflow-mask-image: 0;
    -webkit-mask-image: 0;
    mask-image: 0;
  }
`;
registerStyles$1("jmix-upload-field", [inputFieldShared$1, uploadField$1], {
  moduleId: "lumo-jmix-upload-field-styles"
});
const uploadField = css`
  :host::before {
    display: inline-flex;
  }
  
  /*
   * Use "auto" width instead of default 12em, because upload field
   * with visible file name is not fit in.
   */
  [class$='container'] {
    width: var(--jmix-upload-field-default-width, var(--vaadin-field-default-width, auto));
  }
  
  [part='input-field'] {
      --vaadin-input-field-hover-highlight-opacity: 0;
  }
`;
registerStyles$1("jmix-upload-field", [inputFieldShared, uploadField], {
  moduleId: "jmix-upload-field-styles"
});
class JmixUploadField extends SlotStylesMixin(DelegateFocusMixin(InputConstraintsMixin(FieldMixin(ThemableMixin(
  ElementMixin(PolymerElement)
))))) {
  static get is() {
    return "jmix-upload-field";
  }
  static get template() {
    return html`
            <style>
                vaadin-input-container {
                    background-color: transparent;
                    padding: 0;
                    cursor: auto;
                }

                vaadin-input-container:after {
                    border: 0;
                }
            </style>

            <div class="upload-field-container">
                <div part="label">
                    <slot name="label"></slot>
                    <span part="required-indicator" aria-hidden="true" on-click="focus"></span>
                </div>

                <vaadin-input-container
                        part="input-field"
                        readonly="[[readonly]]"
                        disabled="[[disabled]]"
                        invalid="[[invalid]]"
                        theme$="[[_theme]]">
                    <slot name="input"></slot>
                </vaadin-input-container>

                <div part="helper-text">
                    <slot name="helper"></slot>
                </div>

                <div part="error-message">
                    <slot name="error-message"></slot>
                </div>
            </div>
            
            <slot name="tooltip"></slot>
        `;
  }
  static get properties() {
    return {};
  }
  /** @protected */
  get slotStyles() {
    return [];
  }
  /** @protected */
  ready() {
    super.ready();
    this._tooltipController = new TooltipController(this);
    this._tooltipController.setPosition("top");
    this._tooltipController.setAriaTarget(this.inputElement);
    this.addController(this._tooltipController);
  }
}
defineCustomElement(JmixUploadField);
const valuePicker$1 = css`
  [part="action-part"] ::slotted(*) {
    gap: var(--lumo-space-xs);
  }
  
  :host([has-actions]) [part="input-field"] {
    padding-right: var(--lumo-space-xs);
  }
`;
registerStyles$1("jmix-value-picker", [inputFieldShared$1, valuePicker$1], {
  moduleId: "lumo-value-picker-styles"
});
const valuePicker = css`
  :host::before {
    display: inline-flex;
  }
`;
registerStyles$1("jmix-value-picker", [inputFieldShared, valuePicker], {
  moduleId: "jmix-value-picker-styles"
});
class JmixValuePicker extends InputFieldMixin(ThemableMixin(ElementMixin(PolymerElement))) {
  static get is() {
    return "jmix-value-picker";
  }
  static get template() {
    return html`
            <style>
                [part="action-part"] ::slotted(*) {
                    display: flex;
                }

                :host([readonly]) [part="action-part"] {
                    display: none;
                }
            </style>

            <div class="value-picker-container">
                <div part="label">
                    <slot name="label"></slot>
                    <span part="required-indicator" aria-hidden="true" on-click="focus"></span>
                </div>

                <vaadin-input-container
                        part="input-field"
                        readonly="[[readonly]]"
                        disabled="[[disabled]]"
                        invalid="[[invalid]]"
                        theme$="[[_theme]]"
                >
                    <slot name="prefix" slot="prefix"></slot>
                    <slot name="input"></slot>
                    <slot name="suffix" slot="suffix"></slot>
                    <div id="pickerAction" part="action-part" slot="suffix">
                        <slot name="actions"></slot>
                    </div>
                </vaadin-input-container>

                <div part="helper-text">
                    <slot name="helper"></slot>
                </div>

                <div part="error-message">
                    <slot name="error-message"></slot>
                </div>
            </div>

            <slot name="tooltip"></slot>
        `;
  }
  static get properties() {
    return {
      allowCustomValue: {
        type: Boolean,
        value: false
      }
    };
  }
  constructor() {
    super();
    this._setType("text");
  }
  /** @protected */
  get clearElement() {
    return null;
  }
  /** @protected */
  ready() {
    super.ready();
    this.addController(
      new InputController(this, (input) => {
        this._setInputElement(input);
        this._setFocusElement(input);
        this.stateTarget = input;
        this.ariaTarget = input;
      })
    );
    this.addController(new LabelledInputController(this.inputElement, this._labelController));
    this._tooltipController = new TooltipController(this);
    this._tooltipController.setPosition("top");
    this._tooltipController.setAriaTarget(this.inputElement);
    this.addController(this._tooltipController);
  }
  _onInput(event) {
    if (!this.allowCustomValue) {
      this.inputElement.value = this.value || "";
    }
    super._onInput(event);
  }
  checkValidity() {
    return !this.invalid && super.checkValidity();
  }
}
defineCustomElement(JmixValuePicker);
class JmixTimer extends ElementMixin(PolymerElement) {
  static get is() {
    return "jmix-timer";
  }
  static get template() {
    return html`
            <style>
                :host {
                    display: none;
                }
            </style>
        `;
  }
  static get properties() {
    return {
      repeating: {
        type: Boolean,
        value: false
      },
      delay: {
        type: Number,
        value: 0
      },
      autostart: {
        type: Boolean,
        value: false
      }
    };
  }
  start() {
    if (!this.running) {
      this.runTimer();
      this.running = true;
    }
  }
  runTimer() {
    this.intervalId = setTimeout(this.onTimerTick.bind(this), this.delay);
  }
  onTimerTick() {
    this.dispatchEvent(new CustomEvent("jmix-timer-tick"));
    if (this.repeating) {
      this.runTimer();
    } else {
      this.intervalId = null;
      this.running = false;
    }
  }
  stop() {
    this.stopInternal(true);
  }
  stopInternal(userOriginated) {
    if (this.running) {
      clearInterval(this.intervalId);
      this.intervalId = null;
      this.running = false;
      if (userOriginated) {
        this.dispatchEvent(new CustomEvent("jmix-timer-stop"));
      }
    }
  }
  disconnectedCallback() {
    super.disconnectedCallback();
    this.stopInternal(false);
  }
  connectedCallback() {
    super.connectedCallback();
    if (this.autostart) {
      this.start();
    }
  }
}
defineCustomElement(JmixTimer);
const uploadButton = css`
  :host(:not([nodrop])) {
    border: 0;
    overflow: initial;
    padding: 0;
    transition: background-color 0.6s;
  }
  [part='drop-label'] {
    display: none;
  }

  ::slotted(vaadin-button) {
    margin: 0;
  }
  
  ::slotted(vaadin-button[theme~="full-width"]) {
    width: 100%;
  }
`;
registerStyles$1("jmix-upload-button", uploadButton, {
  moduleId: "lumo-jmix-upload-button-styles"
});
class JmixUploadButton extends Upload {
  static get is() {
    return "jmix-upload-button";
  }
  static get properties() {
    return {
      file: Object,
      jmixI18n: {
        type: Object,
        value: function() {
          return {
            uploadDialog: {
              title: "Uploading",
              cancel: "Cancel"
            }
          };
        },
        notify: true
      }
    };
  }
  ready() {
    super.ready();
    this.$.dropLabelContainer.hidden = true;
    this.addEventListener("upload-progress", this._onUploadProgressEvent.bind(this));
    this.addEventListener("upload-success", this._onUploadSuccessEvent.bind(this));
    this.addEventListener("upload-error", this._onUploadFailedEvent.bind(this));
    this.addEventListener("file-abort", this._closeUploadDialogOnEvent.bind(this));
    this.addEventListener("file-reject", this._closeUploadDialogOnEvent.bind(this));
    this.addEventListener("upload-start", this._openUploadDialogOnEvent.bind(this));
    this._initUploadDialog();
  }
  static get observers() {
    return [
      "_onJmixI18nChanged(jmixI18n)"
    ];
  }
  /**
   * @private
   * @override
   */
  _renderFileList() {
    if (this._fileList) {
      this._fileList.hidden = true;
    }
  }
  _onUploadSuccessEvent(event) {
    this.files = [];
    this._closeUploadDialogOnEvent(event);
  }
  _onUploadFailedEvent(event) {
    this.files = [];
    this._closeUploadDialogOnEvent(event);
    this.dispatchEvent(new CustomEvent("jmix-upload-internal-error", { detail: { file: this.file, xhr: this.file.xhr } }));
  }
  _openUploadDialogOnEvent(event) {
    this._setUploadDialogOpened(true);
  }
  _closeUploadDialogOnEvent(event) {
    this._setUploadDialogOpened(false);
  }
  _initUploadDialog() {
    const uploadDialog = document.createElement("vaadin-dialog");
    uploadDialog.id = "jmixUploadDialog";
    uploadDialog.headerTitle = this.jmixI18n.uploadDialog.title;
    uploadDialog.noCloseOnOutsideClick = true;
    uploadDialog.noCloseOnEsc = true;
    uploadDialog.className = "jmix-upload-dialog";
    uploadDialog.renderer = this._uploadDialogRenderer();
    this.appendChild(uploadDialog);
  }
  _uploadDialogRenderer() {
    const uploadContext = this;
    return function(root2, dialog) {
      if (root2.children && root2.children.length > 0) {
        const fileWrapper = root2.children[0].children.fileWrapper;
        uploadContext._updateUploadFileElement(uploadContext.file, fileWrapper, uploadContext.jmixI18n);
        const uploadFileElements = root2.getElementsByTagName("vaadin-upload-file");
        if (uploadFileElements.length === 0) {
          return;
        }
        const uploadFile2 = uploadFileElements[0];
        const uploadFileButtons = uploadFile2.shadowRoot.querySelectorAll("button");
        if (uploadFileButtons.length > 0) {
          for (const btn of uploadFileButtons) {
            btn.hidden = true;
          }
        }
      } else {
        const dialogContent = document.createElement("div");
        dialogContent.className = "jmix-upload-dialog-content";
        const fileWrapper = document.createElement("div");
        fileWrapper.id = "fileWrapper";
        uploadContext._updateUploadFileElement(uploadContext.file, fileWrapper, uploadContext.jmixI18n);
        const cancelBtn = uploadContext._createUploadDialogCancelButton();
        dialogContent.appendChild(fileWrapper);
        dialogContent.appendChild(cancelBtn);
        root2.appendChild(dialogContent);
      }
    };
  }
  _updateUploadFileElement(file, content, i18n) {
    if (!file) {
      return;
    }
    return render(html$1`
            <vaadin-upload-file
                    .file="${file}"
                    .complete="${file.complete}"
                    .errorMessage="${file.error}"
                    .fileName="${file.name}"
                    .held="${file.held}"
                    .indeterminate="${file.indeterminate}"
                    .progress="${file.progress}"
                    .status="${file.status}"
                    .uploading="${file.uploading}"
                    .i18n="${i18n}"
            ></vaadin-upload-file>
        `, content);
  }
  _createUploadDialogCancelButton() {
    const cancelBtn = document.createElement("vaadin-button");
    cancelBtn.className = "jmix-upload-dialog-cancel-button";
    cancelBtn.innerText = this.jmixI18n.uploadDialog.cancel;
    cancelBtn.addEventListener("click", this._onUploadDialogCancelButtonClick.bind(this));
    return cancelBtn;
  }
  _onUploadDialogCancelButtonClick(event) {
    this.dispatchEvent(new CustomEvent("file-abort", { detail: { file: this.file, xhr: this.file.xhr } }));
  }
  _onJmixI18nChanged(jmixI18n) {
    const dialog = this._getUploadDialog();
    if (dialog) {
      dialog.headerTitle = jmixI18n.uploadDialog.title;
    }
  }
  _onUploadProgressEvent(e2) {
    this.file = e2.detail.file;
    const dialog = this._getUploadDialog();
    if (dialog) {
      dialog.requestContentUpdate();
    }
  }
  _setUploadDialogOpened(opened) {
    const dialog = this._getUploadDialog();
    if (dialog) {
      dialog.opened = opened;
    }
  }
  _getUploadDialog() {
    const dialogs = this.getElementsByTagName("vaadin-dialog");
    if (dialogs.length <= 0) {
      return;
    }
    const dialog = Array.from(dialogs).filter((dialog2) => {
      return dialog2.id === "jmixUploadDialog";
    });
    return dialog.length > 0 ? dialog[0] : null;
  }
}
defineCustomElement(JmixUploadButton);
const pickerButton = css`
  :host {
    /* Sizing */
    --lumo-button-size: var(--lumo-size-s);
    min-width: var(--lumo-button-size);
    height: var(--lumo-button-size);
    box-sizing: border-box;
    
    /* Style */
    font-family: var(--lumo-font-family);
    font-size: var(--lumo-font-size-m);
    font-weight: 500;
    color: var(--_lumo-button-color, var(--lumo-primary-text-color));
    background-color: var(--_lumo-button-background-color, var(--lumo-contrast-5pct));
    border-radius: var(--lumo-border-radius-m);
    cursor: var(--lumo-clickable-cursor);
    -webkit-tap-highlight-color: transparent;
    -webkit-font-smoothing: antialiased;
    -moz-osx-font-smoothing: grayscale;
  }
  
  /* Set only for the internal parts so we dont affect the host vertical alignment */
  [part='icon'] {
    line-height: var(--lumo-line-height-xs);
  }
  
  /* For interaction states */
  :host::before,
  :host::after {
    content: '';
    /* We rely on the host always being relative */
    position: absolute;
    z-index: 1;
    top: 0;
    right: 0;
    bottom: 0;
    left: 0;
    background-color: currentColor;
    border-radius: inherit;
    opacity: 0;
    transition: opacity 0.2s;
    pointer-events: none;
  }
  
  /* Hover */
  
  @media (any-hover: hover) {
    :host(:hover)::before {
      opacity: 0.02;
    }
  }
  
  /* Active */
  
  :host::after {
    transition: opacity 1.4s, transform 0.1s;
    filter: blur(8px);
  }
  
  :host([active])::before {
    opacity: 0.05;
    transition-duration: 0s;
  }
  
  :host([active])::after {
    opacity: 0.1;
    transition-duration: 0s, 0s;
    transform: scale(0);
  }
  
  /* Keyboard focus */
  
  :host([focus-ring]) {
    box-shadow: 0 0 0 2px var(--lumo-primary-color-50pct);
  }
  
  /* Disabled state. Keep selectors after other color variants. */
  
  :host([disabled]) {
    pointer-events: none;
    color: var(--lumo-disabled-text-color);
  }
  
  /* Icons */
  
  [part] ::slotted(vaadin-icon),
  [part] ::slotted(iron-icon) {
    display: inline-block;
    width: var(--lumo-icon-size-m);
    height: var(--lumo-icon-size-m);
  }
  
  /* Vaadin icons are based on a 16x16 grid (unlike Lumo and Material icons with 24x24), so they look too big by default */
  [part] ::slotted(vaadin-icon[icon^='vaadin:']),
  [part] ::slotted(iron-icon[icon^='vaadin:']) {
    padding: 0.25em;
    box-sizing: border-box !important;
  }
`;
registerStyles$1("jmix-value-picker-button", pickerButton, {
  moduleId: "lumo-value-picker-button-styles"
});
registerStyles$1("jmix-value-picker-button", [], {
  moduleId: "jmix-value-picker-button-styles"
});
class JmixValuePickerButton extends ActiveMixin(TabindexMixin(FocusMixin(ElementMixin(ThemableMixin(PolymerElement))))) {
  static get is() {
    return "jmix-value-picker-button";
  }
  static get template() {
    return html`
            <style>
                :host {
                    display: inline-block;
                    position: relative;
                    outline: none;
                    white-space: nowrap;
                    -webkit-user-select: none;
                    -moz-user-select: none;
                    user-select: none;
                }

                :host([hidden]) {
                    display: none !important;
                }
                
                /* Aligns the button with form fields when placed on the same line.
                Note, to make it work, the form fields should have the same "::before" pseudo-element. */
                .value-picker-button-container::before {
                    content: '\\2003';
                    display: inline-block;
                    width: 0;
                }
                
                .value-picker-button-container {
                    display: inline-flex;
                    align-items: center;
                    justify-content: center;
                    text-align: center;
                    width: 100%;
                    height: 100%;
                    min-height: inherit;
                    text-shadow: inherit;
                    background: transparent;
                    padding: 0;
                    border: none;
                    box-shadow: none;
                }

                [part='icon'] {
                    flex: none;
                }
            </style>

            <div class="value-picker-button-container">
                <span part="icon">
                    <slot name="icon"></slot>
                </span>
            </div>
        `;
  }
  static get properties() {
    return {
      /**
       * Indicates whether the element can be focused and where it participates in sequential keyboard navigation.
       *
       * @override
       * @protected
       */
      tabindex: {
        value: 0
      }
    };
  }
  /** @protected */
  ready() {
    super.ready();
    if (!this.hasAttribute("role")) {
      this.setAttribute("role", "button");
    }
  }
  /**
   * By default, `Space` is the only possible activation key for a focusable HTML element.
   * Nonetheless, the button is an exception as it can be also activated by pressing `Enter`.
   * See the "Keyboard Support" section in https://www.w3.org/TR/wai-aria-practices/examples/button/button.html.
   *
   * @protected
   * @override
   */
  get _activeKeys() {
    return ["Enter", " "];
  }
  /**
   * Since the button component is designed on the base of the `[role=button]` attribute,
   * and doesn't have a native <button> inside, in order to be fully accessible from the keyboard,
   * it should manually fire the `click` event once an activation key is pressed,
   * as it follows from the WAI-ARIA specifications:
   * https://www.w3.org/TR/wai-aria-practices-1.1/#button
   *
   * According to the UI Events specifications,
   * the `click` event should be fired exactly on `keydown`:
   * https://www.w3.org/TR/uievents/#event-type-keydown
   *
   * @param {KeyboardEvent} event
   * @protected
   * @override
   */
  _onKeyDown(event) {
    super._onKeyDown(event);
    if (this._activeKeys.includes(event.key)) {
      event.preventDefault();
      this.click();
    }
  }
}
defineCustomElement(JmixValuePickerButton);
const loadOnDemand = (key) => {
  return Promise.resolve(0);
};
window.Vaadin = window.Vaadin || {};
window.Vaadin.Flow = window.Vaadin.Flow || {};
window.Vaadin.Flow.loadOnDemand = loadOnDemand;
window.Vaadin.Flow.resetFocus = () => {
  let ae = document.activeElement;
  while (ae && ae.shadowRoot) ae = ae.shadowRoot.activeElement;
  return !ae || ae.blur() || ae.focus() || true;
};
const generatedFlowImports = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null
}, Symbol.toStringTag, { value: "Module" }));
export {
  generatedFlowImports as a,
  commonjsGlobal as c,
  getDefaultExportFromCjs as g
};
